package math2html

import (
	πg "github.com/pygolin/runtime"
	_ "github.com/pygolin/stdlib/pkg/codecs"
	_ "github.com/pygolin/stdlib/pkg/datetime"
	_ "github.com/pygolin/stdlib/pkg/gettext"
	_ "github.com/pygolin/stdlib/pkg/gzip"
	_ "github.com/pygolin/stdlib/pkg/io"
	_ "github.com/pygolin/stdlib/pkg/os"
	_ "github.com/pygolin/stdlib/pkg/os/path"
	_ "github.com/pygolin/stdlib/pkg/sys"
	_ "github.com/pygolin/stdlib/pkg/unicodedata"
	_ "github.com/pygolin/stdlib/pkg/urllib"
	_ "github.com/pygolin/stdlib/pkg/urllib/parse"
)

var Code *πg.Code

func init() {
	Code = πg.NewCode("<module>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
		var πR *πg.Object
		_ = πR
		var πE *πg.BaseException
		_ = πE
		ß := πg.InternStr("")
		ß0 := πg.InternStr("0")
		ß0xd835 := πg.InternStr("0xd835")
		ß1 := πg.InternStr("1")
		ßA := πg.InternStr("A")
		ßABCDEFGHIJKLMNOPQRSTUVWXYZ := πg.InternStr("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
		ßAlign := πg.InternStr("Align")
		ßAlphaCommand := πg.InternStr("AlphaCommand")
		ßAppendix := πg.InternStr("Appendix")
		ßBarredText := πg.InternStr("BarredText")
		ßBeginCommand := πg.InternStr("BeginCommand")
		ßBibStylesConfig := πg.InternStr("BibStylesConfig")
		ßBibTeXConfig := πg.InternStr("BibTeXConfig")
		ßBigBracket := πg.InternStr("BigBracket")
		ßBigSymbol := πg.InternStr("BigSymbol")
		ßBlackBox := πg.InternStr("BlackBox")
		ßBoldText := πg.InternStr("BoldText")
		ßBoundedDummy := πg.InternStr("BoundedDummy")
		ßBoundedParser := πg.InternStr("BoundedParser")
		ßBracket := πg.InternStr("Bracket")
		ßBracketCommand := πg.InternStr("BracketCommand")
		ßBracketProcessor := πg.InternStr("BracketProcessor")
		ßBranchOptions := πg.InternStr("BranchOptions")
		ßC := πg.InternStr("C")
		ßCD := πg.InternStr("CD")
		ßCM := πg.InternStr("CM")
		ßChapter := πg.InternStr("Chapter")
		ßChapteredGenerator := πg.InternStr("ChapteredGenerator")
		ßCloner := πg.InternStr("Cloner")
		ßColorText := πg.InternStr("ColorText")
		ßCombiningFunction := πg.InternStr("CombiningFunction")
		ßCommandBit := πg.InternStr("CommandBit")
		ßCommandLineParser := πg.InternStr("CommandLineParser")
		ßComment := πg.InternStr("Comment")
		ßConstant := πg.InternStr("Constant")
		ßContainer := πg.InternStr("Container")
		ßContainerConfig := πg.InternStr("ContainerConfig")
		ßContainerExtractor := πg.InternStr("ContainerExtractor")
		ßContainerOutput := πg.InternStr("ContainerOutput")
		ßContainerSize := πg.InternStr("ContainerSize")
		ßContentsOutput := πg.InternStr("ContentsOutput")
		ßD := πg.InternStr("D")
		ßDecoratingFunction := πg.InternStr("DecoratingFunction")
		ßDependentCounter := πg.InternStr("DependentCounter")
		ßDocumentParameters := πg.InternStr("DocumentParameters")
		ßEmphaticText := πg.InternStr("EmphaticText")
		ßEmptyCommand := πg.InternStr("EmptyCommand")
		ßEmptyOutput := πg.InternStr("EmptyOutput")
		ßEndingList := πg.InternStr("EndingList")
		ßEquationEnvironment := πg.InternStr("EquationEnvironment")
		ßError := πg.InternStr("Error")
		ßEscapeConfig := πg.InternStr("EscapeConfig")
		ßExcludingParser := πg.InternStr("ExcludingParser")
		ßFalse := πg.InternStr("False")
		ßFilePosition := πg.InternStr("FilePosition")
		ßFilteredOutput := πg.InternStr("FilteredOutput")
		ßFixedOutput := πg.InternStr("FixedOutput")
		ßFlexURL := πg.InternStr("FlexURL")
		ßFontFunction := πg.InternStr("FontFunction")
		ßFormula := πg.InternStr("Formula")
		ßFormulaArray := πg.InternStr("FormulaArray")
		ßFormulaBit := πg.InternStr("FormulaBit")
		ßFormulaCases := πg.InternStr("FormulaCases")
		ßFormulaCell := πg.InternStr("FormulaCell")
		ßFormulaCommand := πg.InternStr("FormulaCommand")
		ßFormulaConfig := πg.InternStr("FormulaConfig")
		ßFormulaConstant := πg.InternStr("FormulaConstant")
		ßFormulaEquation := πg.InternStr("FormulaEquation")
		ßFormulaFactory := πg.InternStr("FormulaFactory")
		ßFormulaMacro := πg.InternStr("FormulaMacro")
		ßFormulaMatrix := πg.InternStr("FormulaMatrix")
		ßFormulaNumber := πg.InternStr("FormulaNumber")
		ßFormulaParser := πg.InternStr("FormulaParser")
		ßFormulaProcessor := πg.InternStr("FormulaProcessor")
		ßFormulaRow := πg.InternStr("FormulaRow")
		ßFormulaSymbol := πg.InternStr("FormulaSymbol")
		ßGeneralConfig := πg.InternStr("GeneralConfig")
		ßGlobable := πg.InternStr("Globable")
		ßHeaderConfig := πg.InternStr("HeaderConfig")
		ßHeaderParser := πg.InternStr("HeaderParser")
		ßHfill := πg.InternStr("Hfill")
		ßHybridFunction := πg.InternStr("HybridFunction")
		ßHybridSize := πg.InternStr("HybridSize")
		ßI := πg.InternStr("I")
		ßIOBase := πg.InternStr("IOBase")
		ßIOError := πg.InternStr("IOError")
		ßIV := πg.InternStr("IV")
		ßIX := πg.InternStr("IX")
		ßImageConfig := πg.InternStr("ImageConfig")
		ßInset := πg.InternStr("Inset")
		ßInsetLength := πg.InternStr("InsetLength")
		ßInsetParser := πg.InternStr("InsetParser")
		ßL := πg.InternStr("L")
		ßLabel := πg.InternStr("Label")
		ßLabelFunction := πg.InternStr("LabelFunction")
		ßLangLine := πg.InternStr("LangLine")
		ßLatexCommand := πg.InternStr("LatexCommand")
		ßLayout := πg.InternStr("Layout")
		ßLayoutConfig := πg.InternStr("LayoutConfig")
		ßLimitCommand := πg.InternStr("LimitCommand")
		ßLimitPreviousCommand := πg.InternStr("LimitPreviousCommand")
		ßLimitsProcessor := πg.InternStr("LimitsProcessor")
		ßLineReader := πg.InternStr("LineReader")
		ßLineWriter := πg.InternStr("LineWriter")
		ßLink := πg.InternStr("Link")
		ßLinkOutput := πg.InternStr("LinkOutput")
		ßLoneCommand := πg.InternStr("LoneCommand")
		ßLstParser := πg.InternStr("LstParser")
		ßLyXFormat := πg.InternStr("LyXFormat")
		ßLyXLine := πg.InternStr("LyXLine")
		ßM := πg.InternStr("M")
		ßMacroDefinition := πg.InternStr("MacroDefinition")
		ßMacroFunction := πg.InternStr("MacroFunction")
		ßMacroParameter := πg.InternStr("MacroParameter")
		ßMacroParser := πg.InternStr("MacroParser")
		ßMathsProcessor := πg.InternStr("MathsProcessor")
		ßMultiRowFormula := πg.InternStr("MultiRowFormula")
		ßNewPage := πg.InternStr("NewPage")
		ßNewfangleConfig := πg.InternStr("NewfangleConfig")
		ßNewline := πg.InternStr("Newline")
		ßNone := πg.InternStr("None")
		ßNumberCounter := πg.InternStr("NumberCounter")
		ßNumberGenerator := πg.InternStr("NumberGenerator")
		ßNumberingConfig := πg.InternStr("NumberingConfig")
		ßOneParamFunction := πg.InternStr("OneParamFunction")
		ßOops := πg.InternStr("Oops")
		ßOptions := πg.InternStr("Options")
		ßParameterDefinition := πg.InternStr("ParameterDefinition")
		ßParameterFunction := πg.InternStr("ParameterFunction")
		ßParser := πg.InternStr("Parser")
		ßParsing := πg.InternStr("Parsing")
		ßPosition := πg.InternStr("Position")
		ßPositionEnding := πg.InternStr("PositionEnding")
		ßPostprocessor := πg.InternStr("Postprocessor")
		ßPreambleParser := πg.InternStr("PreambleParser")
		ßQuoteContainer := πg.InternStr("QuoteContainer")
		ßRawText := πg.InternStr("RawText")
		ßReference := πg.InternStr("Reference")
		ßSeparator := πg.InternStr("Separator")
		ßShapedText := πg.InternStr("ShapedText")
		ßSizeText := πg.InternStr("SizeText")
		ßSpace := πg.InternStr("Space")
		ßSpacedCommand := πg.InternStr("SpacedCommand")
		ßSquareBracket := πg.InternStr("SquareBracket")
		ßStageDict := πg.InternStr("StageDict")
		ßStartAppendix := πg.InternStr("StartAppendix")
		ßStreamReaderWriter := πg.InternStr("StreamReaderWriter")
		ßStrikeOut := πg.InternStr("StrikeOut")
		ßStringContainer := πg.InternStr("StringContainer")
		ßStringOutput := πg.InternStr("StringOutput")
		ßStringParser := πg.InternStr("StringParser")
		ßStyleConfig := πg.InternStr("StyleConfig")
		ßSymbolFunction := πg.InternStr("SymbolFunction")
		ßTOCConfig := πg.InternStr("TOCConfig")
		ßTagConfig := πg.InternStr("TagConfig")
		ßTaggedBit := πg.InternStr("TaggedBit")
		ßTaggedOutput := πg.InternStr("TaggedOutput")
		ßTaggedText := πg.InternStr("TaggedText")
		ßTextFamily := πg.InternStr("TextFamily")
		ßTextFunction := πg.InternStr("TextFunction")
		ßTextParser := πg.InternStr("TextParser")
		ßTextPosition := πg.InternStr("TextPosition")
		ßTodayCommand := πg.InternStr("TodayCommand")
		ßTrace := πg.InternStr("Trace")
		ßTranslationConfig := πg.InternStr("TranslationConfig")
		ßTranslator := πg.InternStr("Translator")
		ßTrue := πg.InternStr("True")
		ßURL := πg.InternStr("URL")
		ßUnicodeDecodeError := πg.InternStr("UnicodeDecodeError")
		ßV := πg.InternStr("V")
		ßVersalitasText := πg.InternStr("VersalitasText")
		ßVerticalSpace := πg.InternStr("VerticalSpace")
		ßWhiteSpace := πg.InternStr("WhiteSpace")
		ßWholeFormula := πg.InternStr("WholeFormula")
		ßX := πg.InternStr("X")
		ßXC := πg.InternStr("XC")
		ßXL := πg.InternStr("XL")
		ß_ := πg.InternStr("_")
		ß__class__ := πg.InternStr("__class__")
		ß__doc__ := πg.InternStr("__doc__")
		ß__init__ := πg.InternStr("__init__")
		ß__main__ := πg.InternStr("__main__")
		ß__metaclass__ := πg.InternStr("__metaclass__")
		ß__module__ := πg.InternStr("__module__")
		ß__name__ := πg.InternStr("__name__")
		ß__new__ := πg.InternStr("__new__")
		ß__next__ := πg.InternStr("__next__")
		ß__str__ := πg.InternStr("__str__")
		ß__unicode__ := πg.InternStr("__unicode__")
		ßa := πg.InternStr("a")
		ßabbrvnat := πg.InternStr("abbrvnat")
		ßadd := πg.InternStr("add")
		ßaddempty := πg.InternStr("addempty")
		ßaddfilter := πg.InternStr("addfilter")
		ßaddrow := πg.InternStr("addrow")
		ßaddstyle := πg.InternStr("addstyle")
		ßaddsymbol := πg.InternStr("addsymbol")
		ßalignfoot := πg.InternStr("alignfoot")
		ßalignment := πg.InternStr("alignment")
		ßalignments := πg.InternStr("alignments")
		ßallowed := πg.InternStr("allowed")
		ßalpha := πg.InternStr("alpha")
		ßalphacommands := πg.InternStr("alphacommands")
		ßanchor := πg.InternStr("anchor")
		ßappend := πg.InternStr("append")
		ßappendix := πg.InternStr("appendix")
		ßargv := πg.InternStr("argv")
		ßarray := πg.InternStr("array")
		ßauthordate2 := πg.InternStr("authordate2")
		ßauto := πg.InternStr("auto")
		ßb := πg.InternStr("b")
		ßbarred := πg.InternStr("barred")
		ßbasename := πg.InternStr("basename")
		ßbasestring := πg.InternStr("basestring")
		ßbegin := πg.InternStr("begin")
		ßbeginafter := πg.InternStr("beginafter")
		ßbeginbefore := πg.InternStr("beginbefore")
		ßbeginpreamble := πg.InternStr("beginpreamble")
		ßbibliography := πg.InternStr("bibliography")
		ßbigbrackets := πg.InternStr("bigbrackets")
		ßbigsymbols := πg.InternStr("bigsymbols")
		ßblock := πg.InternStr("block")
		ßbool := πg.InternStr("bool")
		ßbracket := πg.InternStr("bracket")
		ßbracketcommands := πg.InternStr("bracketcommands")
		ßbranch := πg.InternStr("branch")
		ßbranches := πg.InternStr("branches")
		ßbreaklines := πg.InternStr("breaklines")
		ßc := πg.InternStr("c")
		ßcases := πg.InternStr("cases")
		ßcellseparator := πg.InternStr("cellseparator")
		ßchangeline := πg.InternStr("changeline")
		ßchaptered := πg.InternStr("chaptered")
		ßcharacters := πg.InternStr("characters")
		ßchars := πg.InternStr("chars")
		ßcheckbytemark := πg.InternStr("checkbytemark")
		ßcheckcommand := πg.InternStr("checkcommand")
		ßcheckdirection := πg.InternStr("checkdirection")
		ßcheckfor := πg.InternStr("checkfor")
		ßcheckforlower := πg.InternStr("checkforlower")
		ßcheckimage := πg.InternStr("checkimage")
		ßcheckin := πg.InternStr("checkin")
		ßcheckleft := πg.InternStr("checkleft")
		ßchecklimits := πg.InternStr("checklimits")
		ßcheckpending := πg.InternStr("checkpending")
		ßcheckright := πg.InternStr("checkright")
		ßcheckscript := πg.InternStr("checkscript")
		ßcheckskip := πg.InternStr("checkskip")
		ßchecktag := πg.InternStr("checktag")
		ßcheckvalidheight := πg.InternStr("checkvalidheight")
		ßclassic := πg.InternStr("classic")
		ßclassmethod := πg.InternStr("classmethod")
		ßclearskipped := πg.InternStr("clearskipped")
		ßclone := πg.InternStr("clone")
		ßcloned := πg.InternStr("cloned")
		ßclose := πg.InternStr("close")
		ßcodecs := πg.InternStr("codecs")
		ßcolor := πg.InternStr("color")
		ßcombiningfunctions := πg.InternStr("combiningfunctions")
		ßcommand := πg.InternStr("command")
		ßcommandmap := πg.InternStr("commandmap")
		ßcommands := πg.InternStr("commands")
		ßcomment := πg.InternStr("comment")
		ßcomplete := πg.InternStr("complete")
		ßcompletemacro := πg.InternStr("completemacro")
		ßcomplex := πg.InternStr("complex")
		ßcomputedestination := πg.InternStr("computedestination")
		ßcomputehybridsize := πg.InternStr("computehybridsize")
		ßcomputesize := πg.InternStr("computesize")
		ßconfigsizes := πg.InternStr("configsizes")
		ßconstant := πg.InternStr("constant")
		ßconstants := πg.InternStr("constants")
		ßcontents := πg.InternStr("contents")
		ßconverter := πg.InternStr("converter")
		ßconverters := πg.InternStr("converters")
		ßcopy := πg.InternStr("copy")
		ßcopyimages := πg.InternStr("copyimages")
		ßcopyright := πg.InternStr("copyright")
		ßcounters := πg.InternStr("counters")
		ßcreate := πg.InternStr("create")
		ßcreatecell := πg.InternStr("createcell")
		ßcreatecontainer := πg.InternStr("createcontainer")
		ßcreatedependent := πg.InternStr("createdependent")
		ßcropboxformats := πg.InternStr("cropboxformats")
		ßcss := πg.InternStr("css")
		ßcurrent := πg.InternStr("current")
		ßcurrentline := πg.InternStr("currentline")
		ßdate := πg.InternStr("date")
		ßdatetime := πg.InternStr("datetime")
		ßdeasterisk := πg.InternStr("deasterisk")
		ßdebug := πg.InternStr("debug")
		ßdebugmode := πg.InternStr("debugmode")
		ßdecode := πg.InternStr("decode")
		ßdecoratedcommand := πg.InternStr("decoratedcommand")
		ßdecoratingfunctions := πg.InternStr("decoratingfunctions")
		ßdefault := πg.InternStr("default")
		ßdefaults := πg.InternStr("defaults")
		ßdefaulttags := πg.InternStr("defaulttags")
		ßdefining := πg.InternStr("defining")
		ßdefinition := πg.InternStr("definition")
		ßdepleted := πg.InternStr("depleted")
		ßdestdirectory := πg.InternStr("destdirectory")
		ßdestination := πg.InternStr("destination")
		ßdetect := πg.InternStr("detect")
		ßdetecttype := πg.InternStr("detecttype")
		ßdict := πg.InternStr("dict")
		ßdir := πg.InternStr("dir")
		ßdirection := πg.InternStr("direction")
		ßdirectory := πg.InternStr("directory")
		ßdisplaymode := πg.InternStr("displaymode")
		ßelyxer := πg.InternStr("elyxer")
		ßembedcss := πg.InternStr("embedcss")
		ßempty := πg.InternStr("empty")
		ßemptycommand := πg.InternStr("emptycommand")
		ßen := πg.InternStr("en")
		ßencode := πg.InternStr("encode")
		ßend := πg.InternStr("end")
		ßendafter := πg.InternStr("endafter")
		ßendbefore := πg.InternStr("endbefore")
		ßendbranch := πg.InternStr("endbranch")
		ßendfoot := πg.InternStr("endfoot")
		ßending := πg.InternStr("ending")
		ßendinglist := πg.InternStr("endinglist")
		ßendings := πg.InternStr("endings")
		ßendpreamble := πg.InternStr("endpreamble")
		ßendswith := πg.InternStr("endswith")
		ßentities := πg.InternStr("entities")
		ßenumerate := πg.InternStr("enumerate")
		ßenvironments := πg.InternStr("environments")
		ßeqnumber := πg.InternStr("eqnumber")
		ßequation := πg.InternStr("equation")
		ßerror := πg.InternStr("error")
		ßescape := πg.InternStr("escape")
		ßescapeall := πg.InternStr("escapeall")
		ßescapeentities := πg.InternStr("escapeentities")
		ßeval := πg.InternStr("eval")
		ßexit := πg.InternStr("exit")
		ßextract := πg.InternStr("extract")
		ßextractcommand := πg.InternStr("extractcommand")
		ßextracted := πg.InternStr("extracted")
		ßextractlstset := πg.InternStr("extractlstset")
		ßextractnumber := πg.InternStr("extractnumber")
		ßextractplain := πg.InternStr("extractplain")
		ßextracttext := πg.InternStr("extracttext")
		ßextracttitle := πg.InternStr("extracttitle")
		ßf := πg.InternStr("f")
		ßfactory := πg.InternStr("factory")
		ßfamily := πg.InternStr("family")
		ßfatal := πg.InternStr("fatal")
		ßfavicon := πg.InternStr("favicon")
		ßfile := πg.InternStr("file")
		ßfilename := πg.InternStr("filename")
		ßfilter := πg.InternStr("filter")
		ßfilters := πg.InternStr("filters")
		ßfind := πg.InternStr("find")
		ßfindbit := πg.InternStr("findbit")
		ßfindending := πg.InternStr("findending")
		ßfindmax := πg.InternStr("findmax")
		ßfindpartkey := πg.InternStr("findpartkey")
		ßfindright := πg.InternStr("findright")
		ßfindtranslation := πg.InternStr("findtranslation")
		ßfinished := πg.InternStr("finished")
		ßfirst := πg.InternStr("first")
		ßflex := πg.InternStr("flex")
		ßfont := πg.InternStr("font")
		ßfontfunctions := πg.InternStr("fontfunctions")
		ßfoot := πg.InternStr("foot")
		ßfootnotes := πg.InternStr("footnotes")
		ßforceformat := πg.InternStr("forceformat")
		ßformatcontents := πg.InternStr("formatcontents")
		ßformats := πg.InternStr("formats")
		ßformatted := πg.InternStr("formatted")
		ßgenerate := πg.InternStr("generate")
		ßgenerator := πg.InternStr("generator")
		ßgetattr := πg.InternStr("getattr")
		ßgetcell := πg.InternStr("getcell")
		ßgetcontents := πg.InternStr("getcontents")
		ßgetcounter := πg.InternStr("getcounter")
		ßgetdependentcounter := πg.InternStr("getdependentcounter")
		ßgethtml := πg.InternStr("gethtml")
		ßgetlength := πg.InternStr("getlength")
		ßgetletter := πg.InternStr("getletter")
		ßgetlevel := πg.InternStr("getlevel")
		ßgetlimit := πg.InternStr("getlimit")
		ßgetlinenumber := πg.InternStr("getlinenumber")
		ßgetliteralvalue := πg.InternStr("getliteralvalue")
		ßgetmessage := πg.InternStr("getmessage")
		ßgetnext := πg.InternStr("getnext")
		ßgetparam := πg.InternStr("getparam")
		ßgetparameter := πg.InternStr("getparameter")
		ßgetparameterlist := πg.InternStr("getparameterlist")
		ßgetparttype := πg.InternStr("getparttype")
		ßgetpiece := πg.InternStr("getpiece")
		ßgetpiece1 := πg.InternStr("getpiece1")
		ßgetpiece3 := πg.InternStr("getpiece3")
		ßgetpiece4 := πg.InternStr("getpiece4")
		ßgetpieces := πg.InternStr("getpieces")
		ßgetroman := πg.InternStr("getroman")
		ßgetscript := πg.InternStr("getscript")
		ßgetsequence := πg.InternStr("getsequence")
		ßgetsinglebracket := πg.InternStr("getsinglebracket")
		ßgetsize := πg.InternStr("getsize")
		ßgetstage := πg.InternStr("getstage")
		ßgetsymbol := πg.InternStr("getsymbol")
		ßgettext := πg.InternStr("gettext")
		ßgetuntranslated := πg.InternStr("getuntranslated")
		ßgetvalue := πg.InternStr("getvalue")
		ßglob := πg.InternStr("glob")
		ßglobalparams := πg.InternStr("globalparams")
		ßglobalpha := πg.InternStr("globalpha")
		ßglobexcluding := πg.InternStr("globexcluding")
		ßglobidentifier := πg.InternStr("globidentifier")
		ßglobincluding := πg.InternStr("globincluding")
		ßglobnumber := πg.InternStr("globnumber")
		ßglobvalue := πg.InternStr("globvalue")
		ßgooglecharts := πg.InternStr("googlecharts")
		ßgroup := πg.InternStr("group")
		ßgroupable := πg.InternStr("groupable")
		ßgrouped := πg.InternStr("grouped")
		ßhardversion := πg.InternStr("hardversion")
		ßhasattr := πg.InternStr("hasattr")
		ßhasemptyoutput := πg.InternStr("hasemptyoutput")
		ßheader := πg.InternStr("header")
		ßheight := πg.InternStr("height")
		ßheight_special := πg.InternStr("height_special")
		ßhelp := πg.InternStr("help")
		ßhex := πg.InternStr("hex")
		ßhoverfoot := πg.InternStr("hoverfoot")
		ßhspaces := πg.InternStr("hspaces")
		ßhtml := πg.InternStr("html")
		ßhybridfunctions := πg.InternStr("hybridfunctions")
		ßhybridsizes := πg.InternStr("hybridsizes")
		ßi := πg.InternStr("i")
		ßidentifier := πg.InternStr("identifier")
		ßieeetr := πg.InternStr("ieeetr")
		ßignoredtexts := πg.InternStr("ignoredtexts")
		ßimageformat := πg.InternStr("imageformat")
		ßimagemagick := πg.InternStr("imagemagick")
		ßindentstandard := πg.InternStr("indentstandard")
		ßindex := πg.InternStr("index")
		ßinit := πg.InternStr("init")
		ßinline := πg.InternStr("inline")
		ßinner := πg.InternStr("inner")
		ßinnerformula := πg.InternStr("innerformula")
		ßinnerliteral := πg.InternStr("innerliteral")
		ßinnertext := πg.InternStr("innertext")
		ßinsert := πg.InternStr("insert")
		ßinstance := πg.InternStr("instance")
		ßinstances := πg.InternStr("instances")
		ßinstantiate := πg.InternStr("instantiate")
		ßint := πg.InternStr("int")
		ßio := πg.InternStr("io")
		ßisalnum := πg.InternStr("isalnum")
		ßisalpha := πg.InternStr("isalpha")
		ßisdigit := πg.InternStr("isdigit")
		ßisempty := πg.InternStr("isempty")
		ßisending := πg.InternStr("isending")
		ßisidentifier := πg.InternStr("isidentifier")
		ßisinordered := πg.InternStr("isinordered")
		ßisinstance := πg.InternStr("isinstance")
		ßisnumbered := πg.InternStr("isnumbered")
		ßiso885915 := πg.InternStr("iso885915")
		ßisout := πg.InternStr("isout")
		ßisroman := πg.InternStr("isroman")
		ßisselected := πg.InternStr("isselected")
		ßisspace := πg.InternStr("isspace")
		ßisunique := πg.InternStr("isunique")
		ßisunordered := πg.InternStr("isunordered")
		ßisvalue := πg.InternStr("isvalue")
		ßitalicize := πg.InternStr("italicize")
		ßiteraterows := πg.InternStr("iteraterows")
		ßjoin := πg.InternStr("join")
		ßjsmath := πg.InternStr("jsmath")
		ßkey := πg.InternStr("key")
		ßkeys := πg.InternStr("keys")
		ßl := πg.InternStr("l")
		ßlabel := πg.InternStr("label")
		ßlabelfunctions := πg.InternStr("labelfunctions")
		ßlangcodes := πg.InternStr("langcodes")
		ßlanguage := πg.InternStr("language")
		ßlanguages := πg.InternStr("languages")
		ßlast := πg.InternStr("last")
		ßlastlayout := πg.InternStr("lastlayout")
		ßlastline := πg.InternStr("lastline")
		ßlastnumbered := πg.InternStr("lastnumbered")
		ßlayouts := πg.InternStr("layouts")
		ßleavepending := πg.InternStr("leavepending")
		ßleft := πg.InternStr("left")
		ßlen := πg.InternStr("len")
		ßlength := πg.InternStr("length")
		ßletterfoot := πg.InternStr("letterfoot")
		ßletters := πg.InternStr("letters")
		ßlimit := πg.InternStr("limit")
		ßlimitcommands := πg.InternStr("limitcommands")
		ßlimitsahead := πg.InternStr("limitsahead")
		ßlinenumber := πg.InternStr("linenumber")
		ßlist := πg.InternStr("list")
		ßlistitems := πg.InternStr("listitems")
		ßliteral := πg.InternStr("literal")
		ßliteralvalue := πg.InternStr("literalvalue")
		ßlocateprocess := πg.InternStr("locateprocess")
		ßlocation := πg.InternStr("location")
		ßlower := πg.InternStr("lower")
		ßlowmem := πg.InternStr("lowmem")
		ßlstparams := πg.InternStr("lstparams")
		ßlstset := πg.InternStr("lstset")
		ßlyxformat := πg.InternStr("lyxformat")
		ßmacros := πg.InternStr("macros")
		ßmain := πg.InternStr("main")
		ßmarginfoot := πg.InternStr("marginfoot")
		ßmaster := πg.InternStr("master")
		ßmath2html := πg.InternStr("math2html")
		ßmathjax := πg.InternStr("mathjax")
		ßmatrix := πg.InternStr("matrix")
		ßmax := πg.InternStr("max")
		ßmaxdepth := πg.InternStr("maxdepth")
		ßmaxheight := πg.InternStr("maxheight")
		ßmaxwidth := πg.InternStr("maxwidth")
		ßmemory := πg.InternStr("memory")
		ßmessage := πg.InternStr("message")
		ßmisccommands := πg.InternStr("misccommands")
		ßmode := πg.InternStr("mode")
		ßmodified := πg.InternStr("modified")
		ßmodifylimits := πg.InternStr("modifylimits")
		ßmodifyscripts := πg.InternStr("modifyscripts")
		ßmustread := πg.InternStr("mustread")
		ßname := πg.InternStr("name")
		ßnames := πg.InternStr("names")
		ßnewcommand := πg.InternStr("newcommand")
		ßnext := πg.InternStr("next")
		ßnextending := πg.InternStr("nextending")
		ßnextline := πg.InternStr("nextline")
		ßnobib := πg.InternStr("nobib")
		ßnoconvert := πg.InternStr("noconvert")
		ßnocopy := πg.InternStr("nocopy")
		ßnofooter := πg.InternStr("nofooter")
		ßnone := πg.InternStr("none")
		ßnonunicode := πg.InternStr("nonunicode")
		ßnotes := πg.InternStr("notes")
		ßnotoclabels := πg.InternStr("notoclabels")
		ßnumber := πg.InternStr("number")
		ßnumbered := πg.InternStr("numbered")
		ßnumberfoot := πg.InternStr("numberfoot")
		ßobject := πg.InternStr("object")
		ßonefunctions := πg.InternStr("onefunctions")
		ßopen := πg.InternStr("open")
		ßoptional := πg.InternStr("optional")
		ßoptions := πg.InternStr("options")
		ßord := πg.InternStr("ord")
		ßordered := πg.InternStr("ordered")
		ßorderedlayouts := πg.InternStr("orderedlayouts")
		ßoriginal := πg.InternStr("original")
		ßos := πg.InternStr("os")
		ßoutput := πg.InternStr("output")
		ßoutputchanges := πg.InternStr("outputchanges")
		ßpage := πg.InternStr("page")
		ßparambrackets := πg.InternStr("parambrackets")
		ßparamdefs := πg.InternStr("paramdefs")
		ßparameter := πg.InternStr("parameter")
		ßparameternumber := πg.InternStr("parameternumber")
		ßparameters := πg.InternStr("parameters")
		ßparams := πg.InternStr("params")
		ßparent := πg.InternStr("parent")
		ßparse := πg.InternStr("parse")
		ßparsealignments := πg.InternStr("parsealignments")
		ßparseany := πg.InternStr("parseany")
		ßparsebit := πg.InternStr("parsebit")
		ßparseblockto := πg.InternStr("parseblockto")
		ßparsebranch := πg.InternStr("parsebranch")
		ßparsecommandtype := πg.InternStr("parsecommandtype")
		ßparsecomplete := πg.InternStr("parsecomplete")
		ßparsecontainer := πg.InternStr("parsecontainer")
		ßparsed := πg.InternStr("parsed")
		ßparsedollar := πg.InternStr("parsedollar")
		ßparsedollarblock := πg.InternStr("parsedollarblock")
		ßparsedollarinline := πg.InternStr("parsedollarinline")
		ßparseending := πg.InternStr("parseending")
		ßparsefootnotes := πg.InternStr("parsefootnotes")
		ßparseformula := πg.InternStr("parseformula")
		ßparseheader := πg.InternStr("parseheader")
		ßparseinlineto := πg.InternStr("parseinlineto")
		ßparseline := πg.InternStr("parseline")
		ßparseliteral := πg.InternStr("parseliteral")
		ßparselstparams := πg.InternStr("parselstparams")
		ßparselstset := πg.InternStr("parselstset")
		ßparsemacroparameter := πg.InternStr("parsemacroparameter")
		ßparsemandatory := πg.InternStr("parsemandatory")
		ßparsemultiliner := πg.InternStr("parsemultiliner")
		ßparsenewcommand := πg.InternStr("parsenewcommand")
		ßparsenumbers := πg.InternStr("parsenumbers")
		ßparseoptional := πg.InternStr("parseoptional")
		ßparseoptions := πg.InternStr("parseoptions")
		ßparseparameter := πg.InternStr("parseparameter")
		ßparseparameters := πg.InternStr("parseparameters")
		ßparsepreambleline := πg.InternStr("parsepreambleline")
		ßparser := πg.InternStr("parser")
		ßparserows := πg.InternStr("parserows")
		ßparsesingleliner := πg.InternStr("parsesingleliner")
		ßparsesingleparameter := πg.InternStr("parsesingleparameter")
		ßparsesquare := πg.InternStr("parsesquare")
		ßparsesquareliteral := πg.InternStr("parsesquareliteral")
		ßparsetext := πg.InternStr("parsetext")
		ßparsetype := πg.InternStr("parsetype")
		ßparseupgreek := πg.InternStr("parseupgreek")
		ßparseupto := πg.InternStr("parseupto")
		ßparsewithcommand := πg.InternStr("parsewithcommand")
		ßparsexml := πg.InternStr("parsexml")
		ßpartkey := πg.InternStr("partkey")
		ßpath := πg.InternStr("path")
		ßpdftitle := πg.InternStr("pdftitle")
		ßpickpending := πg.InternStr("pickpending")
		ßpiece := πg.InternStr("piece")
		ßpieces := πg.InternStr("pieces")
		ßplain := πg.InternStr("plain")
		ßpop := πg.InternStr("pop")
		ßpopending := πg.InternStr("popending")
		ßpos := πg.InternStr("pos")
		ßpostcurrent := πg.InternStr("postcurrent")
		ßpostprocess := πg.InternStr("postprocess")
		ßpostprocessor := πg.InternStr("postprocessor")
		ßpostrecursive := πg.InternStr("postrecursive")
		ßpreamble := πg.InternStr("preamble")
		ßprefix := πg.InternStr("prefix")
		ßpreref := πg.InternStr("preref")
		ßprocess := πg.InternStr("process")
		ßprocesscontents := πg.InternStr("processcontents")
		ßprocessedclass := πg.InternStr("processedclass")
		ßprocessinsides := πg.InternStr("processinsides")
		ßprocessleft := πg.InternStr("processleft")
		ßprocessoptions := πg.InternStr("processoptions")
		ßprocessors := πg.InternStr("processors")
		ßprocessparameter := πg.InternStr("processparameter")
		ßpushending := πg.InternStr("pushending")
		ßpx := πg.InternStr("px")
		ßquiet := πg.InternStr("quiet")
		ßquietmode := πg.InternStr("quietmode")
		ßquote_plus := πg.InternStr("quote_plus")
		ßquotes := πg.InternStr("quotes")
		ßrU := πg.InternStr("rU")
		ßrange := πg.InternStr("range")
		ßraw := πg.InternStr("raw")
		ßrb := πg.InternStr("rb")
		ßread := πg.InternStr("read")
		ßreadequalskey := πg.InternStr("readequalskey")
		ßreader := πg.InternStr("reader")
		ßreadline := πg.InternStr("readline")
		ßreadoption := πg.InternStr("readoption")
		ßreadparameters := πg.InternStr("readparameters")
		ßreadparams := πg.InternStr("readparams")
		ßreadquoted := πg.InternStr("readquoted")
		ßreadtag := πg.InternStr("readtag")
		ßrecursivesearch := πg.InternStr("recursivesearch")
		ßref := πg.InternStr("ref")
		ßreference := πg.InternStr("reference")
		ßreferenceformats := πg.InternStr("referenceformats")
		ßreferences := πg.InternStr("references")
		ßremove := πg.InternStr("remove")
		ßremovepercentwidth := πg.InternStr("removepercentwidth")
		ßreplace := πg.InternStr("replace")
		ßreplaced := πg.InternStr("replaced")
		ßreplacespecial := πg.InternStr("replacespecial")
		ßreset := πg.InternStr("reset")
		ßresize := πg.InternStr("resize")
		ßreversed := πg.InternStr("reversed")
		ßright := πg.InternStr("right")
		ßroman := πg.InternStr("roman")
		ßromanlayouts := πg.InternStr("romanlayouts")
		ßromannumerals := πg.InternStr("romannumerals")
		ßrows := πg.InternStr("rows")
		ßrowseparator := πg.InternStr("rowseparator")
		ßrstrip := πg.InternStr("rstrip")
		ßsafeclone := πg.InternStr("safeclone")
		ßscale := πg.InternStr("scale")
		ßscalevalue := πg.InternStr("scalevalue")
		ßscript := πg.InternStr("script")
		ßsearchall := πg.InternStr("searchall")
		ßsearchprocess := πg.InternStr("searchprocess")
		ßsearchremove := πg.InternStr("searchremove")
		ßselected := πg.InternStr("selected")
		ßselfclosing := πg.InternStr("selfclosing")
		ßselfcomplete := πg.InternStr("selfcomplete")
		ßsequence := πg.InternStr("sequence")
		ßset := πg.InternStr("set")
		ßsetalignment := πg.InternStr("setalignment")
		ßsetalignments := πg.InternStr("setalignments")
		ßsetattr := πg.InternStr("setattr")
		ßsetbreaklines := πg.InternStr("setbreaklines")
		ßsetcommand := πg.InternStr("setcommand")
		ßsetend := πg.InternStr("setend")
		ßsetfactory := πg.InternStr("setfactory")
		ßsetmaster := πg.InternStr("setmaster")
		ßsetmax := πg.InternStr("setmax")
		ßsetmode := πg.InternStr("setmode")
		ßsetmutualdestination := πg.InternStr("setmutualdestination")
		ßsetparameter := πg.InternStr("setparameter")
		ßsetstart := πg.InternStr("setstart")
		ßsettag := πg.InternStr("settag")
		ßsetvalue := πg.InternStr("setvalue")
		ßshaped := πg.InternStr("shaped")
		ßshow := πg.InternStr("show")
		ßshowhardversion := πg.InternStr("showhardversion")
		ßshowlines := πg.InternStr("showlines")
		ßshowlinesmode := πg.InternStr("showlinesmode")
		ßshowlyxformat := πg.InternStr("showlyxformat")
		ßshowoptions := πg.InternStr("showoptions")
		ßshowversion := πg.InternStr("showversion")
		ßshowversiondate := πg.InternStr("showversiondate")
		ßsimple := πg.InternStr("simple")
		ßsimplemath := πg.InternStr("simplemath")
		ßsimplified := πg.InternStr("simplified")
		ßsimplifyifpossible := πg.InternStr("simplifyifpossible")
		ßsize := πg.InternStr("size")
		ßskip := πg.InternStr("skip")
		ßskipany := πg.InternStr("skipany")
		ßskipcurrent := πg.InternStr("skipcurrent")
		ßskiporiginal := πg.InternStr("skiporiginal")
		ßskippedtypes := πg.InternStr("skippedtypes")
		ßskipspace := πg.InternStr("skipspace")
		ßsmalllimit := πg.InternStr("smalllimit")
		ßsorted := πg.InternStr("sorted")
		ßspacedcommands := πg.InternStr("spacedcommands")
		ßspan := πg.InternStr("span")
		ßsplit := πg.InternStr("split")
		ßsplitpart := πg.InternStr("splitpart")
		ßsquarebracket := πg.InternStr("squarebracket")
		ßstack := πg.InternStr("stack")
		ßstagedict := πg.InternStr("stagedict")
		ßstages := πg.InternStr("stages")
		ßstart := πg.InternStr("start")
		ßstartappendix := πg.InternStr("startappendix")
		ßstartcommand := πg.InternStr("startcommand")
		ßstartendings := πg.InternStr("startendings")
		ßstartinglevel := πg.InternStr("startinglevel")
		ßstarts := πg.InternStr("starts")
		ßstartswith := πg.InternStr("startswith")
		ßstderr := πg.InternStr("stderr")
		ßstdout := πg.InternStr("stdout")
		ßstr := πg.InternStr("str")
		ßstrftime := πg.InternStr("strftime")
		ßstrike := πg.InternStr("strike")
		ßstring := πg.InternStr("string")
		ßstrip := πg.InternStr("strip")
		ßstyleparameter := πg.InternStr("styleparameter")
		ßstyles := πg.InternStr("styles")
		ßsupfoot := πg.InternStr("supfoot")
		ßsymbol := πg.InternStr("symbol")
		ßsymbolfoot := πg.InternStr("symbolfoot")
		ßsymbolfunctions := πg.InternStr("symbolfunctions")
		ßsymbols := πg.InternStr("symbols")
		ßsys := πg.InternStr("sys")
		ßtable := πg.InternStr("table")
		ßtag := πg.InternStr("tag")
		ßtarget := πg.InternStr("target")
		ßtemplate := πg.InternStr("template")
		ßtext := πg.InternStr("text")
		ßtextfunctions := πg.InternStr("textfunctions")
		ßtitle := πg.InternStr("title")
		ßtitlecontents := πg.InternStr("titlecontents")
		ßtoc := πg.InternStr("toc")
		ßtocdepth := πg.InternStr("tocdepth")
		ßtocentry := πg.InternStr("tocentry")
		ßtocfor := πg.InternStr("tocfor")
		ßtoctarget := πg.InternStr("toctarget")
		ßtoday := πg.InternStr("today")
		ßtotalheight := πg.InternStr("totalheight")
		ßtranslate := πg.InternStr("translate")
		ßtranslated := πg.InternStr("translated")
		ßtranslation := πg.InternStr("translation")
		ßtraverse := πg.InternStr("traverse")
		ßtraversewhole := πg.InternStr("traversewhole")
		ßtree := πg.InternStr("tree")
		ßtype := πg.InternStr("type")
		ßtypes := πg.InternStr("types")
		ßugettext := πg.InternStr("ugettext")
		ßunicode := πg.InternStr("unicode")
		ßunicodedata := πg.InternStr("unicodedata")
		ßunknown := πg.InternStr("unknown")
		ßunmodified := πg.InternStr("unmodified")
		ßunnumbered := πg.InternStr("unnumbered")
		ßupdate := πg.InternStr("update")
		ßupper := πg.InternStr("upper")
		ßurl := πg.InternStr("url")
		ßurls := πg.InternStr("urls")
		ßusage := πg.InternStr("usage")
		ßvalign := πg.InternStr("valign")
		ßvalue := πg.InternStr("value")
		ßvalues := πg.InternStr("values")
		ßvancouver := πg.InternStr("vancouver")
		ßversion := πg.InternStr("version")
		ßversion_info := πg.InternStr("version_info")
		ßversiondate := πg.InternStr("versiondate")
		ßvspaces := πg.InternStr("vspaces")
		ßw := πg.InternStr("w")
		ßwidth := πg.InternStr("width")
		ßwrite := πg.InternStr("write")
		ßwritebracket := πg.InternStr("writebracket")
		ßwritefunction := πg.InternStr("writefunction")
		ßwriteline := πg.InternStr("writeline")
		ßwriteparam := πg.InternStr("writeparam")
		ßwriteparams := πg.InternStr("writeparams")
		ßwritepos := πg.InternStr("writepos")
		ßwritestring := πg.InternStr("writestring")
		var πTemp001 *πg.Object
		_ = πTemp001
		var πTemp002 []*πg.Object
		_ = πTemp002
		var πTemp003 *πg.Object
		_ = πTemp003
		var πTemp004 *πg.Object
		_ = πTemp004
		var πTemp005 bool
		_ = πTemp005
		var πTemp006 *πg.Dict
		_ = πTemp006
		var πTemp007 *πg.Object
		_ = πTemp007
		var πTemp008 []πg.Param
		_ = πTemp008
		for ; πF.State() >= 0; πF.PopCheckpoint() {
			switch πF.State() {
			case 0:
			default:
				panic("unexpected function state")
			}
			// line 23: import codecs
			πF.SetLineno(23)
			if πTemp002, πE = πg.ImportModule(πF, "codecs"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßcodecs.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 24: import datetime
			πF.SetLineno(24)
			if πTemp002, πE = πg.ImportModule(πF, "datetime"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßdatetime.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 25: import gettext
			πF.SetLineno(25)
			if πTemp002, πE = πg.ImportModule(πF, "gettext"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßgettext.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 26: import io
			πF.SetLineno(26)
			if πTemp002, πE = πg.ImportModule(πF, "io"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßio.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 27: import os.path
			πF.SetLineno(27)
			if πTemp002, πE = πg.ImportModule(πF, "os.path"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßos.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 28: import sys
			πF.SetLineno(28)
			if πTemp002, πE = πg.ImportModule(πF, "sys"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßsys.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 29: import unicodedata
			πF.SetLineno(29)
			if πTemp002, πE = πg.ImportModule(πF, "unicodedata"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßunicodedata.ToObject(), πTemp001); πE != nil {
				continue
			}
			if πTemp003, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
				continue
			}
			if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßversion_info, nil); πE != nil {
				continue
			}
			πTemp003 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
			if πTemp001, πE = πg.GE(πF, πTemp004, πTemp003); πE != nil {
				continue
			}
			if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
				continue
			}
			if πTemp005 {
				goto Label1
			}
			goto Label2
			// line 31: if sys.version_info >= (3, 0):
			πF.SetLineno(31)
		Label1:
			// line 32: from urllib.parse import quote_plus
			πF.SetLineno(32)
			if πTemp002, πE = πg.ImportModule(πF, "urllib.parse"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßquote_plus); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßquote_plus.ToObject(), πTemp003); πE != nil {
				continue
			}
			goto Label3
		Label2:
			// line 34: from urllib import quote_plus
			πF.SetLineno(34)
			if πTemp002, πE = πg.ImportModule(πF, "urllib"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßquote_plus); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßquote_plus.ToObject(), πTemp003); πE != nil {
				continue
			}
			goto Label3
		Label3:
			if πTemp003, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
				continue
			}
			if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßversion_info, nil); πE != nil {
				continue
			}
			πTemp003 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
			if πTemp001, πE = πg.GE(πF, πTemp004, πTemp003); πE != nil {
				continue
			}
			if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
				continue
			}
			if πTemp005 {
				goto Label4
			}
			goto Label5
			// line 37: if sys.version_info >= (3, 0):
			πF.SetLineno(37)
		Label4:
			// line 38: unicode = str  #noqa
			πF.SetLineno(38)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßunicode.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 39: basestring = str  # noqa
			πF.SetLineno(39)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßbasestring.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 40: file = io.IOBase  # noqa
			πF.SetLineno(40)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßio); πE != nil {
				continue
			}
			if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßIOBase, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßfile.ToObject(), πTemp003); πE != nil {
				continue
			}
			goto Label5
		Label5:
			// line 43: class Trace(object):
			πF.SetLineno(43)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Trace", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 []*πg.Object
				_ = πTemp009
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 44: "A tracing class"
					πF.SetLineno(44)
					// line 44: "A tracing class"
					πF.SetLineno(44)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A tracing class").ToObject()); πE != nil {
						continue
					}
					// line 46: debugmode = False
					πF.SetLineno(46)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßdebugmode.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 47: quietmode = False
					πF.SetLineno(47)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßquietmode.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 48: showlinesmode = False
					πF.SetLineno(48)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßshowlinesmode.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 50: prefix = None
					πF.SetLineno(50)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßprefix.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 52: def debug(cls, message):
					πF.SetLineno(52)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "cls", Def: nil}
					πTemp002[1] = πg.Param{Name: "message", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("debug", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µcls *πg.Object = πArgs[0]
						_ = µcls
						var µmessage *πg.Object = πArgs[1]
						_ = µmessage
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 53: "Show a debug message"
							πF.SetLineno(53)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßdebugmode, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßquietmode, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 54: if not Trace.debugmode or Trace.quietmode:
							πF.SetLineno(54)
						Label2:
							// line 55: return
							πF.SetLineno(55)
							πR = πg.None
							continue
							goto Label3
						Label3:
							// line 56: Trace.show(message, sys.stdout)
							πF.SetLineno(56)
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp007[0] = µmessage
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßstdout, nil); πE != nil {
								continue
							}
							πTemp007[1] = πTemp003
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßshow, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdebug.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 53: "Show a debug message"
					πF.SetLineno(53)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Show a debug message").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßdebug); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 58: def message(cls, message):
					πF.SetLineno(58)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "cls", Def: nil}
					πTemp002[1] = πg.Param{Name: "message", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("message", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µcls *πg.Object = πArgs[0]
						_ = µcls
						var µmessage *πg.Object = πArgs[1]
						_ = µmessage
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 59: "Show a trace message"
							πF.SetLineno(59)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßquietmode, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 60: if Trace.quietmode:
							πF.SetLineno(60)
						Label1:
							// line 61: return
							πF.SetLineno(61)
							πR = πg.None
							continue
							goto Label2
						Label2:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßprefix, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label3
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßshowlinesmode, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
						Label3:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 62: if Trace.prefix and Trace.showlinesmode:
							πF.SetLineno(62)
						Label4:
							// line 63: message = Trace.prefix + message
							πF.SetLineno(63)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßprefix, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, µmessage); πE != nil {
								continue
							}
							µmessage = πTemp001
							goto Label5
						Label5:
							// line 64: Trace.show(message, sys.stdout)
							πF.SetLineno(64)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp005[0] = µmessage
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßstdout, nil); πE != nil {
								continue
							}
							πTemp005[1] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßshow, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßmessage.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 59: "Show a trace message"
					πF.SetLineno(59)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Show a trace message").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßmessage); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 66: def error(cls, message):
					πF.SetLineno(66)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "cls", Def: nil}
					πTemp002[1] = πg.Param{Name: "message", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("error", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µcls *πg.Object = πArgs[0]
						_ = µcls
						var µmessage *πg.Object = πArgs[1]
						_ = µmessage
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 67: "Show an error message"
							πF.SetLineno(67)
							// line 68: message = '* ' + message
							πF.SetLineno(68)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("* ").ToObject(), µmessage); πE != nil {
								continue
							}
							µmessage = πTemp001
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßprefix, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßshowlinesmode, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 69: if Trace.prefix and Trace.showlinesmode:
							πF.SetLineno(69)
						Label2:
							// line 70: message = Trace.prefix + message
							πF.SetLineno(70)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßprefix, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, µmessage); πE != nil {
								continue
							}
							µmessage = πTemp001
							goto Label3
						Label3:
							// line 71: Trace.show(message, sys.stderr)
							πF.SetLineno(71)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp005[0] = µmessage
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßstderr, nil); πE != nil {
								continue
							}
							πTemp005[1] = πTemp003
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßshow, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßerror.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 67: "Show an error message"
					πF.SetLineno(67)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Show an error message").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßerror); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 73: def fatal(cls, message):
					πF.SetLineno(73)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "cls", Def: nil}
					πTemp002[1] = πg.Param{Name: "message", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("fatal", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µcls *πg.Object = πArgs[0]
						_ = µcls
						var µmessage *πg.Object = πArgs[1]
						_ = µmessage
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 74: "Show an error message and terminate"
							πF.SetLineno(74)
							// line 75: Trace.error('FATAL: ' + message)
							πF.SetLineno(75)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("FATAL: ").ToObject(), µmessage); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 76: exit(-1)
							πF.SetLineno(76)
							πTemp001 = πF.MakeArgs(1)
							if πTemp002, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßexit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfatal.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 74: "Show an error message and terminate"
					πF.SetLineno(74)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Show an error message and terminate").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßfatal); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 78: def show(cls, message, channel):
					πF.SetLineno(78)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "cls", Def: nil}
					πTemp002[1] = πg.Param{Name: "message", Def: nil}
					πTemp002[2] = πg.Param{Name: "channel", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("show", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µcls *πg.Object = πArgs[0]
						_ = µcls
						var µmessage *πg.Object = πArgs[1]
						_ = µmessage
						var µchannel *πg.Object = πArgs[2]
						_ = µchannel
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 79: "Show a message out of a channel"
							πF.SetLineno(79)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßversion_info, nil); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
							if πTemp001, πE = πg.LT(πF, πTemp003, πTemp002); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 80: if sys.version_info < (3, 0):
							πF.SetLineno(80)
						Label1:
							// line 81: message = message.encode('utf-8')
							πF.SetLineno(81)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = πg.NewStr("utf-8").ToObject()
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmessage, ßencode, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µmessage = πTemp002
							goto Label2
						Label2:
							// line 82: channel.write(message + '\n')
							πF.SetLineno(82)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µmessage, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πE = πg.CheckLocal(πF, µchannel, "channel"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µchannel, ßwrite, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßshow.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 79: "Show a message out of a channel"
					πF.SetLineno(79)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Show a message out of a channel").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßshow); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 84: debug = classmethod(debug)
					πF.SetLineno(84)
					πTemp009 = πF.MakeArgs(1)
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßdebug); πE != nil {
						continue
					}
					πTemp009[0] = πTemp007
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßclassmethod); πE != nil {
						continue
					}
					if πTemp008, πE = πTemp007.Call(πF, πTemp009, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp009)
					if πE = πClass.SetItem(πF, ßdebug.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 85: message = classmethod(message)
					πF.SetLineno(85)
					πTemp009 = πF.MakeArgs(1)
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßmessage); πE != nil {
						continue
					}
					πTemp009[0] = πTemp007
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßclassmethod); πE != nil {
						continue
					}
					if πTemp008, πE = πTemp007.Call(πF, πTemp009, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp009)
					if πE = πClass.SetItem(πF, ßmessage.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 86: error = classmethod(error)
					πF.SetLineno(86)
					πTemp009 = πF.MakeArgs(1)
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßerror); πE != nil {
						continue
					}
					πTemp009[0] = πTemp007
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßclassmethod); πE != nil {
						continue
					}
					if πTemp008, πE = πTemp007.Call(πF, πTemp009, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp009)
					if πE = πClass.SetItem(πF, ßerror.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 87: fatal = classmethod(fatal)
					πF.SetLineno(87)
					πTemp009 = πF.MakeArgs(1)
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßfatal); πE != nil {
						continue
					}
					πTemp009[0] = πTemp007
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßclassmethod); πE != nil {
						continue
					}
					if πTemp008, πE = πTemp007.Call(πF, πTemp009, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp009)
					if πE = πClass.SetItem(πF, ßfatal.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 88: show = classmethod(show)
					πF.SetLineno(88)
					πTemp009 = πF.MakeArgs(1)
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßshow); πE != nil {
						continue
					}
					πTemp009[0] = πTemp007
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßclassmethod); πE != nil {
						continue
					}
					if πTemp008, πE = πTemp007.Call(πF, πTemp009, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp009)
					if πE = πClass.SetItem(πF, ßshow.ToObject(), πTemp008); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Trace").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTrace.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 91: class BibStylesConfig(object):
			πF.SetLineno(91)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BibStylesConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 92: "Configuration class from elyxer.config file"
					πF.SetLineno(92)
					// line 92: "Configuration class from elyxer.config file"
					πF.SetLineno(92)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 94: abbrvnat = {
					πF.SetLineno(94)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@article").ToObject(), πg.NewUnicode("$authors. $title. <i>$journal</i>,{ {$volume:}$pages,} $month $year.{ doi: $doi.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cite").ToObject(), πg.NewUnicode("$surname($year)").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("default").ToObject(), πg.NewUnicode("$authors. <i>$title</i>. $publisher, $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßabbrvnat.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 100: alpha = {
					πF.SetLineno(100)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@article").ToObject(), πg.NewUnicode("$authors. $title.{ <i>$journal</i>{, {$volume}{($number)}}{: $pages}{, $year}.}{ <a href=\"$url\">$url</a>.}{ <a href=\"$filename\">$filename</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cite").ToObject(), πg.NewUnicode("$Sur$YY").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("default").ToObject(), πg.NewUnicode("$authors. $title.{ <i>$journal</i>,} $year.{ <a href=\"$url\">$url</a>.}{ <a href=\"$filename\">$filename</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßalpha.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 106: authordate2 = {
					πF.SetLineno(106)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@article").ToObject(), πg.NewUnicode("$authors. $year. $title. <i>$journal</i>, <b>$volume</b>($number), $pages.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@book").ToObject(), πg.NewUnicode("$authors. $year. <i>$title</i>. $publisher.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cite").ToObject(), πg.NewUnicode("$surname, $year").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("default").ToObject(), πg.NewUnicode("$authors. $year. <i>$title</i>. $publisher.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßauthordate2.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 113: default = {
					πF.SetLineno(113)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@article").ToObject(), πg.NewUnicode("$authors: \xe2\x80\x9c$title\xe2\x80\x9d, <i>$journal</i>,{ pp. $pages,} $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@book").ToObject(), πg.NewUnicode("{$authors: }<i>$title</i>{ ($editor, ed.)}.{{ $publisher,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@booklet").ToObject(), πg.NewUnicode("$authors: <i>$title</i>.{{ $publisher,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@conference").ToObject(), πg.NewUnicode("$authors: \xe2\x80\x9c$title\xe2\x80\x9d, <i>$journal</i>,{ pp. $pages,} $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@inbook").ToObject(), πg.NewUnicode("$authors: <i>$title</i>.{{ $publisher,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@incollection").ToObject(), πg.NewUnicode("$authors: <i>$title</i>{ in <i>$booktitle</i>{ ($editor, ed.)}}.{{ $publisher,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@inproceedings").ToObject(), πg.NewUnicode("$authors: \xe2\x80\x9c$title\xe2\x80\x9d, <i>$booktitle</i>,{ pp. $pages,} $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@manual").ToObject(), πg.NewUnicode("$authors: <i>$title</i>.{{ $publisher,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@mastersthesis").ToObject(), πg.NewUnicode("$authors: <i>$title</i>.{{ $publisher,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@misc").ToObject(), πg.NewUnicode("$authors: <i>$title</i>.{{ $publisher,}{ $howpublished,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@phdthesis").ToObject(), πg.NewUnicode("$authors: <i>$title</i>.{{ $publisher,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@proceedings").ToObject(), πg.NewUnicode("$authors: \xe2\x80\x9c$title\xe2\x80\x9d, <i>$journal</i>,{ pp. $pages,} $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@techreport").ToObject(), πg.NewUnicode("$authors: <i>$title</i>, $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@unpublished").ToObject(), πg.NewUnicode("$authors: \xe2\x80\x9c$title\xe2\x80\x9d, <i>$journal</i>, $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cite").ToObject(), πg.NewUnicode("$index").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("default").ToObject(), πg.NewUnicode("$authors: <i>$title</i>.{{ $publisher,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßdefault.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 132: defaulttags = {
					πF.SetLineno(132)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("YY").ToObject(), πg.NewUnicode("??").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("authors").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("surname").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßdefaulttags.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 136: ieeetr = {
					πF.SetLineno(136)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@article").ToObject(), πg.NewUnicode("$authors, \xe2\x80\x9c$title\xe2\x80\x9d, <i>$journal</i>, vol. $volume, no. $number, pp. $pages, $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@book").ToObject(), πg.NewUnicode("$authors, <i>$title</i>. $publisher, $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cite").ToObject(), πg.NewUnicode("$index").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("default").ToObject(), πg.NewUnicode("$authors, \xe2\x80\x9c$title\xe2\x80\x9d. $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßieeetr.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 143: plain = {
					πF.SetLineno(143)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@article").ToObject(), πg.NewUnicode("$authors. $title.{ <i>$journal</i>{, {$volume}{($number)}}{:$pages}{, $year}.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@book").ToObject(), πg.NewUnicode("$authors. <i>$title</i>. $publisher,{ $month} $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@incollection").ToObject(), πg.NewUnicode("$authors. $title.{ In <i>$booktitle</i> {($editor, ed.)}.} $publisher,{ $month} $year.{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@inproceedings").ToObject(), πg.NewUnicode("$authors. $title. { <i>$booktitle</i>{, {$volume}{($number)}}{:$pages}{, $year}.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cite").ToObject(), πg.NewUnicode("$index").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("default").ToObject(), πg.NewUnicode("{$authors. }$title.{{ $publisher,} $year.}{ URL <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßplain.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 152: vancouver = {
					πF.SetLineno(152)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@article").ToObject(), πg.NewUnicode("$authors. $title. <i>$journal</i>, $year{;{<b>$volume</b>}{($number)}{:$pages}}.{ URL: <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@book").ToObject(), πg.NewUnicode("$authors. $title. {$publisher, }$year.{ URL: <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cite").ToObject(), πg.NewUnicode("$index").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("default").ToObject(), πg.NewUnicode("$authors. $title; {$publisher, }$year.{ $howpublished.}{ URL: <a href=\"$url\">$url</a>.}{ $note.}").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßvancouver.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BibStylesConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBibStylesConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 159: class BibTeXConfig(object):
			πF.SetLineno(159)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BibTeXConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 160: "Configuration class from elyxer.config file"
					πF.SetLineno(160)
					// line 160: "Configuration class from elyxer.config file"
					πF.SetLineno(160)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 162: replaced = {
					πF.SetLineno(162)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("--").ToObject(), πg.NewUnicode("\xe2\x80\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("..").ToObject(), πg.NewUnicode(".").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßreplaced.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BibTeXConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBibTeXConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 166: class ContainerConfig(object):
			πF.SetLineno(166)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ContainerConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 167: "Configuration class from elyxer.config file"
					πF.SetLineno(167)
					// line 167: "Configuration class from elyxer.config file"
					πF.SetLineno(167)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 169: endings = {
					πF.SetLineno(169)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Align").ToObject(), πg.NewUnicode("\\end_layout").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("BarredText").ToObject(), πg.NewUnicode("\\bar").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("BoldText").ToObject(), πg.NewUnicode("\\series").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Cell").ToObject(), πg.NewUnicode("</cell").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ChangeDeleted").ToObject(), πg.NewUnicode("\\change_unchanged").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ChangeInserted").ToObject(), πg.NewUnicode("\\change_unchanged").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ColorText").ToObject(), πg.NewUnicode("\\color").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("EmphaticText").ToObject(), πg.NewUnicode("\\emph").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Hfill").ToObject(), πg.NewUnicode("\\hfill").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Inset").ToObject(), πg.NewUnicode("\\end_inset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Layout").ToObject(), πg.NewUnicode("\\end_layout").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("LyXFooter").ToObject(), πg.NewUnicode("\\end_document").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("LyXHeader").ToObject(), πg.NewUnicode("\\end_header").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Row").ToObject(), πg.NewUnicode("</row").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ShapedText").ToObject(), πg.NewUnicode("\\shape").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("SizeText").ToObject(), πg.NewUnicode("\\size").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("StrikeOut").ToObject(), πg.NewUnicode("\\strikeout").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("TextFamily").ToObject(), πg.NewUnicode("\\family").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("VersalitasText").ToObject(), πg.NewUnicode("\\noun").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßendings.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 181: extracttext = {
					πF.SetLineno(181)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("StringContainer").ToObject()
					πTemp003[1] = πg.NewUnicode("Constant").ToObject()
					πTemp003[2] = πg.NewUnicode("FormulaConstant").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("allowed").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 1)
					πTemp003[0] = πg.NewUnicode("").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cloned").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 27)
					πTemp003[0] = πg.NewUnicode("PlainLayout").ToObject()
					πTemp003[1] = πg.NewUnicode("TaggedText").ToObject()
					πTemp003[2] = πg.NewUnicode("Align").ToObject()
					πTemp003[3] = πg.NewUnicode("Caption").ToObject()
					πTemp003[4] = πg.NewUnicode("TextFamily").ToObject()
					πTemp003[5] = πg.NewUnicode("EmphaticText").ToObject()
					πTemp003[6] = πg.NewUnicode("VersalitasText").ToObject()
					πTemp003[7] = πg.NewUnicode("BarredText").ToObject()
					πTemp003[8] = πg.NewUnicode("SizeText").ToObject()
					πTemp003[9] = πg.NewUnicode("ColorText").ToObject()
					πTemp003[10] = πg.NewUnicode("LangLine").ToObject()
					πTemp003[11] = πg.NewUnicode("Formula").ToObject()
					πTemp003[12] = πg.NewUnicode("Bracket").ToObject()
					πTemp003[13] = πg.NewUnicode("RawText").ToObject()
					πTemp003[14] = πg.NewUnicode("BibTag").ToObject()
					πTemp003[15] = πg.NewUnicode("FormulaNumber").ToObject()
					πTemp003[16] = πg.NewUnicode("AlphaCommand").ToObject()
					πTemp003[17] = πg.NewUnicode("EmptyCommand").ToObject()
					πTemp003[18] = πg.NewUnicode("OneParamFunction").ToObject()
					πTemp003[19] = πg.NewUnicode("SymbolFunction").ToObject()
					πTemp003[20] = πg.NewUnicode("TextFunction").ToObject()
					πTemp003[21] = πg.NewUnicode("FontFunction").ToObject()
					πTemp003[22] = πg.NewUnicode("CombiningFunction").ToObject()
					πTemp003[23] = πg.NewUnicode("DecoratingFunction").ToObject()
					πTemp003[24] = πg.NewUnicode("FormulaSymbol").ToObject()
					πTemp003[25] = πg.NewUnicode("BracketCommand").ToObject()
					πTemp003[26] = πg.NewUnicode("TeXCode").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("extracted").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßextracttext.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 187: startendings = {
					πF.SetLineno(187)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_deeper").ToObject(), πg.NewUnicode("\\end_deeper").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset").ToObject(), πg.NewUnicode("\\end_inset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout").ToObject(), πg.NewUnicode("\\end_layout").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßstartendings.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 192: starts = {
					πF.SetLineno(192)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("").ToObject(), πg.NewUnicode("StringContainer").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("#LyX").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("</lyxtabular").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("<cell").ToObject(), πg.NewUnicode("Cell").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("<column").ToObject(), πg.NewUnicode("Column").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("<row").ToObject(), πg.NewUnicode("Row").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\align").ToObject(), πg.NewUnicode("Align").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bar").ToObject(), πg.NewUnicode("BarredText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bar default").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bar no").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_body").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_deeper").ToObject(), πg.NewUnicode("DeeperList").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_document").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_header").ToObject(), πg.NewUnicode("LyXHeader").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Argument").ToObject(), πg.NewUnicode("ShortTitle").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Box").ToObject(), πg.NewUnicode("BoxInset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Branch").ToObject(), πg.NewUnicode("Branch").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Caption").ToObject(), πg.NewUnicode("Caption").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset bibitem").ToObject(), πg.NewUnicode("BiblioEntry").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset bibtex").ToObject(), πg.NewUnicode("BibTeX").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset citation").ToObject(), πg.NewUnicode("BiblioCitation").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset href").ToObject(), πg.NewUnicode("URL").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset include").ToObject(), πg.NewUnicode("IncludeInset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset index_print").ToObject(), πg.NewUnicode("PrintIndex").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset label").ToObject(), πg.NewUnicode("Label").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset line").ToObject(), πg.NewUnicode("LineInset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset nomencl_print").ToObject(), πg.NewUnicode("PrintNomenclature").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset nomenclature").ToObject(), πg.NewUnicode("NomenclatureEntry").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset ref").ToObject(), πg.NewUnicode("Reference").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset CommandInset toc").ToObject(), πg.NewUnicode("TableOfContents").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset ERT").ToObject(), πg.NewUnicode("ERT").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Flex").ToObject(), πg.NewUnicode("FlexInset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Flex Chunkref").ToObject(), πg.NewUnicode("NewfangledChunkRef").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Flex Marginnote").ToObject(), πg.NewUnicode("SideNote").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Flex Sidenote").ToObject(), πg.NewUnicode("SideNote").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Flex URL").ToObject(), πg.NewUnicode("FlexURL").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Float").ToObject(), πg.NewUnicode("Float").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset FloatList").ToObject(), πg.NewUnicode("ListOf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Foot").ToObject(), πg.NewUnicode("Footnote").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Formula").ToObject(), πg.NewUnicode("Formula").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset FormulaMacro").ToObject(), πg.NewUnicode("FormulaMacro").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Graphics").ToObject(), πg.NewUnicode("Image").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Index").ToObject(), πg.NewUnicode("IndexReference").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Info").ToObject(), πg.NewUnicode("InfoInset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand bibitem").ToObject(), πg.NewUnicode("BiblioEntry").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand bibtex").ToObject(), πg.NewUnicode("BibTeX").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand cite").ToObject(), πg.NewUnicode("BiblioCitation").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand citealt").ToObject(), πg.NewUnicode("BiblioCitation").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand citep").ToObject(), πg.NewUnicode("BiblioCitation").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand citet").ToObject(), πg.NewUnicode("BiblioCitation").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand htmlurl").ToObject(), πg.NewUnicode("URL").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand index").ToObject(), πg.NewUnicode("IndexReference").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand label").ToObject(), πg.NewUnicode("Label").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand nomenclature").ToObject(), πg.NewUnicode("NomenclatureEntry").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand prettyref").ToObject(), πg.NewUnicode("Reference").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand printindex").ToObject(), πg.NewUnicode("PrintIndex").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand printnomenclature").ToObject(), πg.NewUnicode("PrintNomenclature").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand ref").ToObject(), πg.NewUnicode("Reference").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand tableofcontents").ToObject(), πg.NewUnicode("TableOfContents").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand url").ToObject(), πg.NewUnicode("URL").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset LatexCommand vref").ToObject(), πg.NewUnicode("Reference").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Marginal").ToObject(), πg.NewUnicode("SideNote").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Newline").ToObject(), πg.NewUnicode("NewlineInset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Newpage").ToObject(), πg.NewUnicode("NewPageInset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Note").ToObject(), πg.NewUnicode("Note").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset OptArg").ToObject(), πg.NewUnicode("ShortTitle").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Phantom").ToObject(), πg.NewUnicode("PhantomText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Quotes").ToObject(), πg.NewUnicode("QuoteContainer").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Tabular").ToObject(), πg.NewUnicode("Table").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Text").ToObject(), πg.NewUnicode("InsetText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset VSpace").ToObject(), πg.NewUnicode("VerticalSpace").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset Wrap").ToObject(), πg.NewUnicode("Wrap").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset listings").ToObject(), πg.NewUnicode("Listing").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset script").ToObject(), πg.NewUnicode("ScriptInset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_inset space").ToObject(), πg.NewUnicode("Space").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout").ToObject(), πg.NewUnicode("Layout").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Abstract").ToObject(), πg.NewUnicode("Abstract").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Author").ToObject(), πg.NewUnicode("Author").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Bibliography").ToObject(), πg.NewUnicode("Bibliography").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Chunk").ToObject(), πg.NewUnicode("NewfangledChunk").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Description").ToObject(), πg.NewUnicode("Description").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Enumerate").ToObject(), πg.NewUnicode("ListItem").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Itemize").ToObject(), πg.NewUnicode("ListItem").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout List").ToObject(), πg.NewUnicode("List").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout LyX-Code").ToObject(), πg.NewUnicode("LyXCode").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Plain").ToObject(), πg.NewUnicode("PlainLayout").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Standard").ToObject(), πg.NewUnicode("StandardLayout").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_layout Title").ToObject(), πg.NewUnicode("Title").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin_preamble").ToObject(), πg.NewUnicode("LyXPreamble").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\change_deleted").ToObject(), πg.NewUnicode("ChangeDeleted").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\change_inserted").ToObject(), πg.NewUnicode("ChangeInserted").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\change_unchanged").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\color").ToObject(), πg.NewUnicode("ColorText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\color inherit").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\color none").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\emph default").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\emph off").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\emph on").ToObject(), πg.NewUnicode("EmphaticText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\emph toggle").ToObject(), πg.NewUnicode("EmphaticText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\end_body").ToObject(), πg.NewUnicode("LyXFooter").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\family").ToObject(), πg.NewUnicode("TextFamily").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\family default").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\family roman").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hfill").ToObject(), πg.NewUnicode("Hfill").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\labelwidthstring").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lang").ToObject(), πg.NewUnicode("LangLine").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\length").ToObject(), πg.NewUnicode("InsetLength").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lyxformat").ToObject(), πg.NewUnicode("LyXFormat").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lyxline").ToObject(), πg.NewUnicode("LyXLine").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\newline").ToObject(), πg.NewUnicode("Newline").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\newpage").ToObject(), πg.NewUnicode("NewPage").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\noindent").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\noun default").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\noun off").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\noun on").ToObject(), πg.NewUnicode("VersalitasText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\paragraph_spacing").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\series bold").ToObject(), πg.NewUnicode("BoldText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\series default").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\series medium").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\shape").ToObject(), πg.NewUnicode("ShapedText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\shape default").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\shape up").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\size").ToObject(), πg.NewUnicode("SizeText").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\size normal").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\start_of_appendix").ToObject(), πg.NewUnicode("StartAppendix").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\strikeout default").ToObject(), πg.NewUnicode("BlackBox").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\strikeout on").ToObject(), πg.NewUnicode("StrikeOut").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßstarts.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 285: string = {
					πF.SetLineno(285)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("startcommand").ToObject(), πg.NewUnicode("\\").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßstring.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 289: table = {
					πF.SetLineno(289)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 2)
					πTemp003[0] = πg.NewUnicode("<lyxtabular").ToObject()
					πTemp003[1] = πg.NewUnicode("<features").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("headers").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßtable.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ContainerConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßContainerConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 293: class EscapeConfig(object):
			πF.SetLineno(293)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("EscapeConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 294: "Configuration class from elyxer.config file"
					πF.SetLineno(294)
					// line 294: "Configuration class from elyxer.config file"
					πF.SetLineno(294)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 296: chars = {
					πF.SetLineno(296)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\n").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(" -- ").ToObject(), πg.NewUnicode(" \xe2\x80\x94 ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(" --- ").ToObject(), πg.NewUnicode(" \xe2\x80\x94 ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("'").ToObject(), πg.NewUnicode("\xe2\x80\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("`").ToObject(), πg.NewUnicode("\xe2\x80\x98").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßchars.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 300: commands = {
					πF.SetLineno(300)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\InsetSpace \\space{}").ToObject(), πg.NewUnicode("\xc2\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\InsetSpace \\thinspace{}").ToObject(), πg.NewUnicode("\xe2\x80\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\InsetSpace ~").ToObject(), πg.NewUnicode("\xc2\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\SpecialChar \\-").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\SpecialChar \\@.").ToObject(), πg.NewUnicode(".").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\SpecialChar \\ldots{}").ToObject(), πg.NewUnicode("\xe2\x80\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\SpecialChar \\menuseparator").ToObject(), πg.NewUnicode("\xc2\xa0\xe2\x96\xb7\xc2\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\SpecialChar \\nobreakdash-").ToObject(), πg.NewUnicode("-").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\SpecialChar \\slash{}").ToObject(), πg.NewUnicode("/").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\SpecialChar \\textcompwordmark{}").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\backslash").ToObject(), πg.NewUnicode("\\").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßcommands.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 309: entities = {
					πF.SetLineno(309)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("&").ToObject(), πg.NewUnicode("&amp;").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("<").ToObject(), πg.NewUnicode("&lt;").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(">").ToObject(), πg.NewUnicode("&gt;").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßentities.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 313: html = {
					πF.SetLineno(313)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("/>").ToObject(), πg.NewUnicode(">").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßhtml.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 317: iso885915 = {
					πF.SetLineno(317)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\xc2\xa0").ToObject(), πg.NewUnicode("&nbsp;").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\xe2\x80\x83").ToObject(), πg.NewUnicode("&emsp;").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\xe2\x81\x9f").ToObject(), πg.NewUnicode("&#8197;").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßiso885915.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 321: nonunicode = {
					πF.SetLineno(321)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\xe2\x81\x9f").ToObject(), πg.NewUnicode("\xe2\x80\x85").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßnonunicode.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("EscapeConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßEscapeConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 325: class FormulaConfig(object):
			πF.SetLineno(325)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 326: "Configuration class from elyxer.config file"
					πF.SetLineno(326)
					// line 326: "Configuration class from elyxer.config file"
					πF.SetLineno(326)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 328: alphacommands = {
					πF.SetLineno(328)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\AA").ToObject(), πg.NewUnicode("\xc3\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\AE").ToObject(), πg.NewUnicode("\xc3\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\AmS").ToObject(), πg.NewUnicode("<span class=\"versalitas\">AmS</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Angstroem").ToObject(), πg.NewUnicode("\xe2\x84\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\DH").ToObject(), πg.NewUnicode("\xc3\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Koppa").ToObject(), πg.NewUnicode("\xcf\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\L").ToObject(), πg.NewUnicode("\xc5\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Micro").ToObject(), πg.NewUnicode("\xc2\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\O").ToObject(), πg.NewUnicode("\xc3\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\OE").ToObject(), πg.NewUnicode("\xc5\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Sampi").ToObject(), πg.NewUnicode("\xcf\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Stigma").ToObject(), πg.NewUnicode("\xcf\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\TH").ToObject(), πg.NewUnicode("\xc3\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\aa").ToObject(), πg.NewUnicode("\xc3\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ae").ToObject(), πg.NewUnicode("\xc3\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\alpha").ToObject(), πg.NewUnicode("\xce\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\beta").ToObject(), πg.NewUnicode("\xce\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\delta").ToObject(), πg.NewUnicode("\xce\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dh").ToObject(), πg.NewUnicode("\xc3\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\digamma").ToObject(), πg.NewUnicode("\xcf\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\epsilon").ToObject(), πg.NewUnicode("\xcf\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\eta").ToObject(), πg.NewUnicode("\xce\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\eth").ToObject(), πg.NewUnicode("\xc3\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gamma").ToObject(), πg.NewUnicode("\xce\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\i").ToObject(), πg.NewUnicode("\xc4\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\imath").ToObject(), πg.NewUnicode("\xc4\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\iota").ToObject(), πg.NewUnicode("\xce\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\j").ToObject(), πg.NewUnicode("\xc8\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\jmath").ToObject(), πg.NewUnicode("\xc8\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\kappa").ToObject(), πg.NewUnicode("\xce\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\koppa").ToObject(), πg.NewUnicode("\xcf\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\l").ToObject(), πg.NewUnicode("\xc5\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lambda").ToObject(), πg.NewUnicode("\xce\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mu").ToObject(), πg.NewUnicode("\xce\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nu").ToObject(), πg.NewUnicode("\xce\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\o").ToObject(), πg.NewUnicode("\xc3\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\oe").ToObject(), πg.NewUnicode("\xc5\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\omega").ToObject(), πg.NewUnicode("\xcf\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\phi").ToObject(), πg.NewUnicode("\xcf\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pi").ToObject(), πg.NewUnicode("\xcf\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\psi").ToObject(), πg.NewUnicode("\xcf\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rho").ToObject(), πg.NewUnicode("\xcf\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sampi").ToObject(), πg.NewUnicode("\xcf\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sigma").ToObject(), πg.NewUnicode("\xcf\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ss").ToObject(), πg.NewUnicode("\xc3\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\stigma").ToObject(), πg.NewUnicode("\xcf\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\tau").ToObject(), πg.NewUnicode("\xcf\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\tcohm").ToObject(), πg.NewUnicode("\xe2\x84\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textcrh").ToObject(), πg.NewUnicode("\xc4\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\th").ToObject(), πg.NewUnicode("\xc3\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\theta").ToObject(), πg.NewUnicode("\xce\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\upsilon").ToObject(), πg.NewUnicode("\xcf\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varDelta").ToObject(), πg.NewUnicode("\xe2\x88\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varGamma").ToObject(), πg.NewUnicode("\xce\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varLambda").ToObject(), πg.NewUnicode("\xce\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varOmega").ToObject(), πg.NewUnicode("\xce\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varPhi").ToObject(), πg.NewUnicode("\xce\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varPi").ToObject(), πg.NewUnicode("\xce\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varPsi").ToObject(), πg.NewUnicode("\xce\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varSigma").ToObject(), πg.NewUnicode("\xce\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varTheta").ToObject(), πg.NewUnicode("\xce\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varUpsilon").ToObject(), πg.NewUnicode("\xce\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varXi").ToObject(), πg.NewUnicode("\xce\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varbeta").ToObject(), πg.NewUnicode("\xcf\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varepsilon").ToObject(), πg.NewUnicode("\xce\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varkappa").ToObject(), πg.NewUnicode("\xcf\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varphi").ToObject(), πg.NewUnicode("\xcf\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varpi").ToObject(), πg.NewUnicode("\xcf\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varrho").ToObject(), πg.NewUnicode("\xcf\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varsigma").ToObject(), πg.NewUnicode("\xcf\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vartheta").ToObject(), πg.NewUnicode("\xcf\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\xi").ToObject(), πg.NewUnicode("\xce\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\zeta").ToObject(), πg.NewUnicode("\xce\xb6").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßalphacommands.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 351: array = {
					πF.SetLineno(351)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("begin").ToObject(), πg.NewUnicode("\\begin").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cellseparator").ToObject(), πg.NewUnicode("&").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("end").ToObject(), πg.NewUnicode("\\end").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("rowseparator").ToObject(), πg.NewUnicode("\\\\").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßarray.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 356: bigbrackets = {
					πF.SetLineno(356)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("\xe2\x8e\x9b").ToObject()
					πTemp003[1] = πg.NewUnicode("\xe2\x8e\x9c").ToObject()
					πTemp003[2] = πg.NewUnicode("\xe2\x8e\x9d").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("(").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("\xe2\x8e\x9e").ToObject()
					πTemp003[1] = πg.NewUnicode("\xe2\x8e\x9f").ToObject()
					πTemp003[2] = πg.NewUnicode("\xe2\x8e\xa0").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(")").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("\xe2\x8e\xa1").ToObject()
					πTemp003[1] = πg.NewUnicode("\xe2\x8e\xa2").ToObject()
					πTemp003[2] = πg.NewUnicode("\xe2\x8e\xa3").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("[").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("\xe2\x8e\xa4").ToObject()
					πTemp003[1] = πg.NewUnicode("\xe2\x8e\xa5").ToObject()
					πTemp003[2] = πg.NewUnicode("\xe2\x8e\xa6").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("]").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 4)
					πTemp003[0] = πg.NewUnicode("\xe2\x8e\xa7").ToObject()
					πTemp003[1] = πg.NewUnicode("\xe2\x8e\xaa").ToObject()
					πTemp003[2] = πg.NewUnicode("\xe2\x8e\xa8").ToObject()
					πTemp003[3] = πg.NewUnicode("\xe2\x8e\xa9").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("{").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 1)
					πTemp003[0] = πg.NewUnicode("|").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("|").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 4)
					πTemp003[0] = πg.NewUnicode("\xe2\x8e\xab").ToObject()
					πTemp003[1] = πg.NewUnicode("\xe2\x8e\xaa").ToObject()
					πTemp003[2] = πg.NewUnicode("\xe2\x8e\xac").ToObject()
					πTemp003[3] = πg.NewUnicode("\xe2\x8e\xad").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("}").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 1)
					πTemp003[0] = πg.NewUnicode("\xe2\x88\xa5").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\xe2\x88\xa5").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßbigbrackets.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 362: bigsymbols = {
					πF.SetLineno(362)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 2)
					πTemp003[0] = πg.NewUnicode("\xe2\x8e\xb2").ToObject()
					πTemp003[1] = πg.NewUnicode("\xe2\x8e\xb3").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\xe2\x88\x91").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 2)
					πTemp003[0] = πg.NewUnicode("\xe2\x8c\xa0").ToObject()
					πTemp003[1] = πg.NewUnicode("\xe2\x8c\xa1").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\xe2\x88\xab").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßbigsymbols.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 366: bracketcommands = {
					πF.SetLineno(366)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\left").ToObject(), πg.NewUnicode("span class=\"symbol\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\left.").ToObject(), πg.NewUnicode("<span class=\"leftdot\"></span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\middle").ToObject(), πg.NewUnicode("span class=\"symbol\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\right").ToObject(), πg.NewUnicode("span class=\"symbol\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\right.").ToObject(), πg.NewUnicode("<span class=\"rightdot\"></span>").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßbracketcommands.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 373: combiningfunctions = {
					πF.SetLineno(373)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\\"").ToObject(), πg.NewUnicode("\xcc\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\'").ToObject(), πg.NewUnicode("\xcc\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\^").ToObject(), πg.NewUnicode("\xcc\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\`").ToObject(), πg.NewUnicode("\xcc\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\acute").ToObject(), πg.NewUnicode("\xcc\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bar").ToObject(), πg.NewUnicode("\xcc\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\breve").ToObject(), πg.NewUnicode("\xcc\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\c").ToObject(), πg.NewUnicode("\xcc\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\check").ToObject(), πg.NewUnicode("\xcc\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dddot").ToObject(), πg.NewUnicode("\xe2\x83\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ddot").ToObject(), πg.NewUnicode("\xcc\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dot").ToObject(), πg.NewUnicode("\xcc\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\grave").ToObject(), πg.NewUnicode("\xcc\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hat").ToObject(), πg.NewUnicode("\xcc\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathring").ToObject(), πg.NewUnicode("\xcc\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\overleftarrow").ToObject(), πg.NewUnicode("\xe2\x83\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\overrightarrow").ToObject(), πg.NewUnicode("\xe2\x83\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\r").ToObject(), πg.NewUnicode("\xcc\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\s").ToObject(), πg.NewUnicode("\xcc\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textcircled").ToObject(), πg.NewUnicode("\xe2\x83\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textsubring").ToObject(), πg.NewUnicode("\xcc\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\tilde").ToObject(), πg.NewUnicode("\xcc\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\v").ToObject(), πg.NewUnicode("\xcc\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vec").ToObject(), πg.NewUnicode("\xe2\x83\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\~").ToObject(), πg.NewUnicode("\xcc\x83").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßcombiningfunctions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 383: commands = {
					πF.SetLineno(383)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ ").ToObject(), πg.NewUnicode("\xc2\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\!").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\#").ToObject(), πg.NewUnicode("#").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\$").ToObject(), πg.NewUnicode("$").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\%").ToObject(), πg.NewUnicode("%").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\&").ToObject(), πg.NewUnicode("&").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\,").ToObject(), πg.NewUnicode(" ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\:").ToObject(), πg.NewUnicode("\xe2\x81\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\;").ToObject(), πg.NewUnicode("\xe2\x80\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\AC").ToObject(), πg.NewUnicode("\xe2\x88\xbf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\APLcomment").ToObject(), πg.NewUnicode("\xe2\x8d\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\APLdownarrowbox").ToObject(), πg.NewUnicode("\xe2\x8d\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\APLinput").ToObject(), πg.NewUnicode("\xe2\x8d\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\APLinv").ToObject(), πg.NewUnicode("\xe2\x8c\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\APLleftarrowbox").ToObject(), πg.NewUnicode("\xe2\x8d\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\APLlog").ToObject(), πg.NewUnicode("\xe2\x8d\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\APLrightarrowbox").ToObject(), πg.NewUnicode("\xe2\x8d\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\APLuparrowbox").ToObject(), πg.NewUnicode("\xe2\x8d\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Box").ToObject(), πg.NewUnicode("\xe2\x96\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Bumpeq").ToObject(), πg.NewUnicode("\xe2\x89\x8e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\CIRCLE").ToObject(), πg.NewUnicode("\xe2\x97\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Cap").ToObject(), πg.NewUnicode("\xe2\x8b\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\CapitalDifferentialD").ToObject(), πg.NewUnicode("\xe2\x85\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\CheckedBox").ToObject(), πg.NewUnicode("\xe2\x98\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Circle").ToObject(), πg.NewUnicode("\xe2\x97\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Coloneqq").ToObject(), πg.NewUnicode("\xe2\xa9\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ComplexI").ToObject(), πg.NewUnicode("\xe2\x85\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ComplexJ").ToObject(), πg.NewUnicode("\xe2\x85\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Corresponds").ToObject(), πg.NewUnicode("\xe2\x89\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Cup").ToObject(), πg.NewUnicode("\xe2\x8b\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Delta").ToObject(), πg.NewUnicode("\xce\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Diamond").ToObject(), πg.NewUnicode("\xe2\x97\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Diamondblack").ToObject(), πg.NewUnicode("\xe2\x97\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Diamonddot").ToObject(), πg.NewUnicode("\xe2\x9f\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\DifferentialD").ToObject(), πg.NewUnicode("\xe2\x85\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Downarrow").ToObject(), πg.NewUnicode("\xe2\x87\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\EUR").ToObject(), πg.NewUnicode("\xe2\x82\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Euler").ToObject(), πg.NewUnicode("\xe2\x84\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ExponetialE").ToObject(), πg.NewUnicode("\xe2\x85\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Finv").ToObject(), πg.NewUnicode("\xe2\x84\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Game").ToObject(), πg.NewUnicode("\xe2\x85\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Gamma").ToObject(), πg.NewUnicode("\xce\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Im").ToObject(), πg.NewUnicode("\xe2\x84\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Join").ToObject(), πg.NewUnicode("\xe2\xa8\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LEFTCIRCLE").ToObject(), πg.NewUnicode("\xe2\x97\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LEFTcircle").ToObject(), πg.NewUnicode("\xe2\x97\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LHD").ToObject(), πg.NewUnicode("\xe2\x97\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Lambda").ToObject(), πg.NewUnicode("\xce\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Lbag").ToObject(), πg.NewUnicode("\xe2\x9f\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Leftarrow").ToObject(), πg.NewUnicode("\xe2\x87\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Lleftarrow").ToObject(), πg.NewUnicode("\xe2\x87\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Longleftarrow").ToObject(), πg.NewUnicode("\xe2\x9f\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Longleftrightarrow").ToObject(), πg.NewUnicode("\xe2\x9f\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Longrightarrow").ToObject(), πg.NewUnicode("\xe2\x9f\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Lparen").ToObject(), πg.NewUnicode("\xe2\xa6\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Lsh").ToObject(), πg.NewUnicode("\xe2\x86\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Mapsfrom").ToObject(), πg.NewUnicode("\xe2\x87\x90|").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Mapsto").ToObject(), πg.NewUnicode("|\xe2\x87\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Omega").ToObject(), πg.NewUnicode("\xce\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\P").ToObject(), πg.NewUnicode("\xc2\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Phi").ToObject(), πg.NewUnicode("\xce\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Pi").ToObject(), πg.NewUnicode("\xce\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Pr").ToObject(), πg.NewUnicode("Pr").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Psi").ToObject(), πg.NewUnicode("\xce\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Qoppa").ToObject(), πg.NewUnicode("\xcf\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RHD").ToObject(), πg.NewUnicode("\xe2\x96\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RIGHTCIRCLE").ToObject(), πg.NewUnicode("\xe2\x97\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RIGHTcircle").ToObject(), πg.NewUnicode("\xe2\x97\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Rbag").ToObject(), πg.NewUnicode("\xe2\x9f\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Re").ToObject(), πg.NewUnicode("\xe2\x84\x9c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Rparen").ToObject(), πg.NewUnicode("\xe2\xa6\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Rrightarrow").ToObject(), πg.NewUnicode("\xe2\x87\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Rsh").ToObject(), πg.NewUnicode("\xe2\x86\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\S").ToObject(), πg.NewUnicode("\xc2\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Sigma").ToObject(), πg.NewUnicode("\xce\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Square").ToObject(), πg.NewUnicode("\xe2\x98\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Subset").ToObject(), πg.NewUnicode("\xe2\x8b\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Sun").ToObject(), πg.NewUnicode("\xe2\x98\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Supset").ToObject(), πg.NewUnicode("\xe2\x8b\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Theta").ToObject(), πg.NewUnicode("\xce\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Uparrow").ToObject(), πg.NewUnicode("\xe2\x87\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Updownarrow").ToObject(), πg.NewUnicode("\xe2\x87\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Upsilon").ToObject(), πg.NewUnicode("\xce\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Vdash").ToObject(), πg.NewUnicode("\xe2\x8a\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Vert").ToObject(), πg.NewUnicode("\xe2\x88\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Vvdash").ToObject(), πg.NewUnicode("\xe2\x8a\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\XBox").ToObject(), πg.NewUnicode("\xe2\x98\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Xi").ToObject(), πg.NewUnicode("\xce\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Yup").ToObject(), πg.NewUnicode("\xe2\x85\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\\\").ToObject(), πg.NewUnicode("<br/>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\_").ToObject(), πg.NewUnicode("_").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\aleph").ToObject(), πg.NewUnicode("\xe2\x84\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\amalg").ToObject(), πg.NewUnicode("\xe2\x88\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\anchor").ToObject(), πg.NewUnicode("\xe2\x9a\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\angle").ToObject(), πg.NewUnicode("\xe2\x88\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\aquarius").ToObject(), πg.NewUnicode("\xe2\x99\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\arccos").ToObject(), πg.NewUnicode("arccos").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\arcsin").ToObject(), πg.NewUnicode("arcsin").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\arctan").ToObject(), πg.NewUnicode("arctan").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\arg").ToObject(), πg.NewUnicode("arg").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\aries").ToObject(), πg.NewUnicode("\xe2\x99\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\arrowbullet").ToObject(), πg.NewUnicode("\xe2\x9e\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ast").ToObject(), πg.NewUnicode("\xe2\x88\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\asymp").ToObject(), πg.NewUnicode("\xe2\x89\x8d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\backepsilon").ToObject(), πg.NewUnicode("\xe2\x88\x8d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\backprime").ToObject(), πg.NewUnicode("\xe2\x80\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\backsimeq").ToObject(), πg.NewUnicode("\xe2\x8b\x8d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\backslash").ToObject(), πg.NewUnicode("\\").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ballotx").ToObject(), πg.NewUnicode("\xe2\x9c\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\barwedge").ToObject(), πg.NewUnicode("\xe2\x8a\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\because").ToObject(), πg.NewUnicode("\xe2\x88\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\beth").ToObject(), πg.NewUnicode("\xe2\x84\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\between").ToObject(), πg.NewUnicode("\xe2\x89\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigcap").ToObject(), πg.NewUnicode("\xe2\x88\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigcirc").ToObject(), πg.NewUnicode("\xe2\x97\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigcup").ToObject(), πg.NewUnicode("\xe2\x88\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigodot").ToObject(), πg.NewUnicode("\xe2\x8a\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigoplus").ToObject(), πg.NewUnicode("\xe2\x8a\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigotimes").ToObject(), πg.NewUnicode("\xe2\x8a\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigsqcup").ToObject(), πg.NewUnicode("\xe2\x8a\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigstar").ToObject(), πg.NewUnicode("\xe2\x98\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigtriangledown").ToObject(), πg.NewUnicode("\xe2\x96\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigtriangleup").ToObject(), πg.NewUnicode("\xe2\x96\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\biguplus").ToObject(), πg.NewUnicode("\xe2\x8a\x8e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigvee").ToObject(), πg.NewUnicode("\xe2\x88\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigwedge").ToObject(), πg.NewUnicode("\xe2\x88\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\biohazard").ToObject(), πg.NewUnicode("\xe2\x98\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\blacklozenge").ToObject(), πg.NewUnicode("\xe2\xa7\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\blacksmiley").ToObject(), πg.NewUnicode("\xe2\x98\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\blacksquare").ToObject(), πg.NewUnicode("\xe2\x96\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\blacktriangle").ToObject(), πg.NewUnicode("\xe2\x96\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\blacktriangledown").ToObject(), πg.NewUnicode("\xe2\x96\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\blacktriangleleft").ToObject(), πg.NewUnicode("\xe2\x97\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\blacktriangleright").ToObject(), πg.NewUnicode("\xe2\x96\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\blacktriangleup").ToObject(), πg.NewUnicode("\xe2\x96\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bot").ToObject(), πg.NewUnicode("\xe2\x8a\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bowtie").ToObject(), πg.NewUnicode("\xe2\x8b\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\box").ToObject(), πg.NewUnicode("\xe2\x96\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxast").ToObject(), πg.NewUnicode("\xe2\xa7\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxbar").ToObject(), πg.NewUnicode("\xe2\x97\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxbox").ToObject(), πg.NewUnicode("\xe2\xa7\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxbslash").ToObject(), πg.NewUnicode("\xe2\xa7\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxcircle").ToObject(), πg.NewUnicode("\xe2\xa7\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxdot").ToObject(), πg.NewUnicode("\xe2\x8a\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxminus").ToObject(), πg.NewUnicode("\xe2\x8a\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxplus").ToObject(), πg.NewUnicode("\xe2\x8a\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxslash").ToObject(), πg.NewUnicode("\xe2\xa7\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxtimes").ToObject(), πg.NewUnicode("\xe2\x8a\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bullet").ToObject(), πg.NewUnicode("\xe2\x80\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bumpeq").ToObject(), πg.NewUnicode("\xe2\x89\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cancer").ToObject(), πg.NewUnicode("\xe2\x99\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cap").ToObject(), πg.NewUnicode("\xe2\x88\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\capricornus").ToObject(), πg.NewUnicode("\xe2\x99\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cat").ToObject(), πg.NewUnicode("\xe2\x81\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cdot").ToObject(), πg.NewUnicode("\xe2\x8b\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cdots").ToObject(), πg.NewUnicode("\xe2\x8b\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cent").ToObject(), πg.NewUnicode("\xc2\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\centerdot").ToObject(), πg.NewUnicode("\xe2\x88\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\checkmark").ToObject(), πg.NewUnicode("\xe2\x9c\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\chi").ToObject(), πg.NewUnicode("\xcf\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circ").ToObject(), πg.NewUnicode("\xe2\x88\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circeq").ToObject(), πg.NewUnicode("\xe2\x89\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circlearrowleft").ToObject(), πg.NewUnicode("\xe2\x86\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circlearrowright").ToObject(), πg.NewUnicode("\xe2\x86\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circledR").ToObject(), πg.NewUnicode("\xc2\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circledast").ToObject(), πg.NewUnicode("\xe2\x8a\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circledbslash").ToObject(), πg.NewUnicode("\xe2\xa6\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circledcirc").ToObject(), πg.NewUnicode("\xe2\x8a\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circleddash").ToObject(), πg.NewUnicode("\xe2\x8a\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circledgtr").ToObject(), πg.NewUnicode("\xe2\xa7\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\circledless").ToObject(), πg.NewUnicode("\xe2\xa7\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\clubsuit").ToObject(), πg.NewUnicode("\xe2\x99\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\colon").ToObject(), πg.NewUnicode(": ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\coloneqq").ToObject(), πg.NewUnicode("\xe2\x89\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\complement").ToObject(), πg.NewUnicode("\xe2\x88\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cong").ToObject(), πg.NewUnicode("\xe2\x89\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\coprod").ToObject(), πg.NewUnicode("\xe2\x88\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\copyright").ToObject(), πg.NewUnicode("\xc2\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cos").ToObject(), πg.NewUnicode("cos").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cosh").ToObject(), πg.NewUnicode("cosh").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cot").ToObject(), πg.NewUnicode("cot").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\coth").ToObject(), πg.NewUnicode("coth").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\csc").ToObject(), πg.NewUnicode("csc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cup").ToObject(), πg.NewUnicode("\xe2\x88\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\curlyvee").ToObject(), πg.NewUnicode("\xe2\x8b\x8e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\curlywedge").ToObject(), πg.NewUnicode("\xe2\x8b\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\curvearrowleft").ToObject(), πg.NewUnicode("\xe2\x86\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\curvearrowright").ToObject(), πg.NewUnicode("\xe2\x86\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dag").ToObject(), πg.NewUnicode("\xe2\x80\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dagger").ToObject(), πg.NewUnicode("\xe2\x80\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\daleth").ToObject(), πg.NewUnicode("\xe2\x84\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dashleftarrow").ToObject(), πg.NewUnicode("\xe2\x87\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dashv").ToObject(), πg.NewUnicode("\xe2\x8a\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ddag").ToObject(), πg.NewUnicode("\xe2\x80\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ddagger").ToObject(), πg.NewUnicode("\xe2\x80\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ddots").ToObject(), πg.NewUnicode("\xe2\x8b\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\deg").ToObject(), πg.NewUnicode("deg").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\det").ToObject(), πg.NewUnicode("det").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\diagdown").ToObject(), πg.NewUnicode("\xe2\x95\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\diagup").ToObject(), πg.NewUnicode("\xe2\x95\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\diameter").ToObject(), πg.NewUnicode("\xe2\x8c\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\diamond").ToObject(), πg.NewUnicode("\xe2\x97\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\diamondsuit").ToObject(), πg.NewUnicode("\xe2\x99\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dim").ToObject(), πg.NewUnicode("dim").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\div").ToObject(), πg.NewUnicode("\xc3\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\divideontimes").ToObject(), πg.NewUnicode("\xe2\x8b\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dotdiv").ToObject(), πg.NewUnicode("\xe2\x88\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\doteq").ToObject(), πg.NewUnicode("\xe2\x89\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\doteqdot").ToObject(), πg.NewUnicode("\xe2\x89\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dotplus").ToObject(), πg.NewUnicode("\xe2\x88\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dots").ToObject(), πg.NewUnicode("\xe2\x80\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\doublebarwedge").ToObject(), πg.NewUnicode("\xe2\x8c\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\downarrow").ToObject(), πg.NewUnicode("\xe2\x86\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\downdownarrows").ToObject(), πg.NewUnicode("\xe2\x87\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\downharpoonleft").ToObject(), πg.NewUnicode("\xe2\x87\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\downharpoonright").ToObject(), πg.NewUnicode("\xe2\x87\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dsub").ToObject(), πg.NewUnicode("\xe2\xa9\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\earth").ToObject(), πg.NewUnicode("\xe2\x99\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\eighthnote").ToObject(), πg.NewUnicode("\xe2\x99\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ell").ToObject(), πg.NewUnicode("\xe2\x84\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\emptyset").ToObject(), πg.NewUnicode("\xe2\x88\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\eqcirc").ToObject(), πg.NewUnicode("\xe2\x89\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\eqcolon").ToObject(), πg.NewUnicode("\xe2\x89\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\eqsim").ToObject(), πg.NewUnicode("\xe2\x89\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\euro").ToObject(), πg.NewUnicode("\xe2\x82\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\exists").ToObject(), πg.NewUnicode("\xe2\x88\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\exp").ToObject(), πg.NewUnicode("exp").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fallingdotseq").ToObject(), πg.NewUnicode("\xe2\x89\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fcmp").ToObject(), πg.NewUnicode("\xe2\xa8\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\female").ToObject(), πg.NewUnicode("\xe2\x99\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\flat").ToObject(), πg.NewUnicode("\xe2\x99\xad").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\forall").ToObject(), πg.NewUnicode("\xe2\x88\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fourth").ToObject(), πg.NewUnicode("\xe2\x81\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\frown").ToObject(), πg.NewUnicode("\xe2\x8c\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\frownie").ToObject(), πg.NewUnicode("\xe2\x98\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gcd").ToObject(), πg.NewUnicode("gcd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gemini").ToObject(), πg.NewUnicode("\xe2\x99\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\geq)").ToObject(), πg.NewUnicode("\xe2\x89\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\geqq").ToObject(), πg.NewUnicode("\xe2\x89\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\geqslant").ToObject(), πg.NewUnicode("\xe2\x89\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gets").ToObject(), πg.NewUnicode("\xe2\x86\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gg").ToObject(), πg.NewUnicode("\xe2\x89\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ggg").ToObject(), πg.NewUnicode("\xe2\x8b\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gimel").ToObject(), πg.NewUnicode("\xe2\x84\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gneqq").ToObject(), πg.NewUnicode("\xe2\x89\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gnsim").ToObject(), πg.NewUnicode("\xe2\x8b\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gtrdot").ToObject(), πg.NewUnicode("\xe2\x8b\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gtreqless").ToObject(), πg.NewUnicode("\xe2\x8b\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gtreqqless").ToObject(), πg.NewUnicode("\xe2\xaa\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gtrless").ToObject(), πg.NewUnicode("\xe2\x89\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gtrsim").ToObject(), πg.NewUnicode("\xe2\x89\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\guillemotleft").ToObject(), πg.NewUnicode("\xc2\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\guillemotright").ToObject(), πg.NewUnicode("\xc2\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hbar").ToObject(), πg.NewUnicode("\xe2\x84\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\heartsuit").ToObject(), πg.NewUnicode("\xe2\x99\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hfill").ToObject(), πg.NewUnicode("<span class=\"hfill\"> </span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hom").ToObject(), πg.NewUnicode("hom").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hookleftarrow").ToObject(), πg.NewUnicode("\xe2\x86\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hookrightarrow").ToObject(), πg.NewUnicode("\xe2\x86\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hslash").ToObject(), πg.NewUnicode("\xe2\x84\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\idotsint").ToObject(), πg.NewUnicode("<span class=\"bigsymbol\">\xe2\x88\xab\xe2\x8b\xaf\xe2\x88\xab</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\iiint").ToObject(), πg.NewUnicode("<span class=\"bigsymbol\">\xe2\x88\xad</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\iint").ToObject(), πg.NewUnicode("<span class=\"bigsymbol\">\xe2\x88\xac</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\imath").ToObject(), πg.NewUnicode("\xc4\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\inf").ToObject(), πg.NewUnicode("inf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\infty").ToObject(), πg.NewUnicode("\xe2\x88\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\intercal").ToObject(), πg.NewUnicode("\xe2\x8a\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\interleave").ToObject(), πg.NewUnicode("\xe2\xab\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\invamp").ToObject(), πg.NewUnicode("\xe2\x85\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\invneg").ToObject(), πg.NewUnicode("\xe2\x8c\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\jmath").ToObject(), πg.NewUnicode("\xc8\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\jupiter").ToObject(), πg.NewUnicode("\xe2\x99\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ker").ToObject(), πg.NewUnicode("ker").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\land").ToObject(), πg.NewUnicode("\xe2\x88\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\landupint").ToObject(), πg.NewUnicode("<span class=\"bigsymbol\">\xe2\x88\xb1</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lang").ToObject(), πg.NewUnicode("\xe2\x9f\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\langle").ToObject(), πg.NewUnicode("\xe2\x9f\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lblot").ToObject(), πg.NewUnicode("\xe2\xa6\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lbrace").ToObject(), πg.NewUnicode("{").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lbrace)").ToObject(), πg.NewUnicode("{").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lbrack").ToObject(), πg.NewUnicode("[").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lceil").ToObject(), πg.NewUnicode("\xe2\x8c\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ldots").ToObject(), πg.NewUnicode("\xe2\x80\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leadsto").ToObject(), πg.NewUnicode("\xe2\x87\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftarrow)").ToObject(), πg.NewUnicode("\xe2\x86\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftarrowtail").ToObject(), πg.NewUnicode("\xe2\x86\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftarrowtobar").ToObject(), πg.NewUnicode("\xe2\x87\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftharpoondown").ToObject(), πg.NewUnicode("\xe2\x86\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftharpoonup").ToObject(), πg.NewUnicode("\xe2\x86\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftleftarrows").ToObject(), πg.NewUnicode("\xe2\x87\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftleftharpoons").ToObject(), πg.NewUnicode("\xe2\xa5\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftmoon").ToObject(), πg.NewUnicode("\xe2\x98\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftrightarrow").ToObject(), πg.NewUnicode("\xe2\x86\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftrightarrows").ToObject(), πg.NewUnicode("\xe2\x87\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftrightharpoons").ToObject(), πg.NewUnicode("\xe2\x87\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftthreetimes").ToObject(), πg.NewUnicode("\xe2\x8b\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leo").ToObject(), πg.NewUnicode("\xe2\x99\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leq)").ToObject(), πg.NewUnicode("\xe2\x89\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leqq").ToObject(), πg.NewUnicode("\xe2\x89\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leqslant").ToObject(), πg.NewUnicode("\xe2\x89\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lessdot").ToObject(), πg.NewUnicode("\xe2\x8b\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lesseqgtr").ToObject(), πg.NewUnicode("\xe2\x8b\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lesseqqgtr").ToObject(), πg.NewUnicode("\xe2\xaa\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lessgtr").ToObject(), πg.NewUnicode("\xe2\x89\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lesssim").ToObject(), πg.NewUnicode("\xe2\x89\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lfloor").ToObject(), πg.NewUnicode("\xe2\x8c\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lg").ToObject(), πg.NewUnicode("lg").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lgroup").ToObject(), πg.NewUnicode("\xe2\x9f\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lhd").ToObject(), πg.NewUnicode("\xe2\x8a\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\libra").ToObject(), πg.NewUnicode("\xe2\x99\x8e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lightning").ToObject(), πg.NewUnicode("\xe2\x86\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\limg").ToObject(), πg.NewUnicode("\xe2\xa6\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\liminf").ToObject(), πg.NewUnicode("liminf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\limsup").ToObject(), πg.NewUnicode("limsup").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ll").ToObject(), πg.NewUnicode("\xe2\x89\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\llbracket").ToObject(), πg.NewUnicode("\xe2\x9f\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\llcorner").ToObject(), πg.NewUnicode("\xe2\x8c\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lll").ToObject(), πg.NewUnicode("\xe2\x8b\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ln").ToObject(), πg.NewUnicode("ln").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lneqq").ToObject(), πg.NewUnicode("\xe2\x89\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lnot").ToObject(), πg.NewUnicode("\xc2\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lnsim").ToObject(), πg.NewUnicode("\xe2\x8b\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\log").ToObject(), πg.NewUnicode("log").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\longleftarrow").ToObject(), πg.NewUnicode("\xe2\x9f\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\longleftrightarrow").ToObject(), πg.NewUnicode("\xe2\x9f\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\longmapsto").ToObject(), πg.NewUnicode("\xe2\x9f\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\longrightarrow").ToObject(), πg.NewUnicode("\xe2\x9f\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\looparrowleft").ToObject(), πg.NewUnicode("\xe2\x86\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\looparrowright").ToObject(), πg.NewUnicode("\xe2\x86\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lor").ToObject(), πg.NewUnicode("\xe2\x88\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lozenge").ToObject(), πg.NewUnicode("\xe2\x97\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lrcorner").ToObject(), πg.NewUnicode("\xe2\x8c\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ltimes").ToObject(), πg.NewUnicode("\xe2\x8b\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lyxlock").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\male").ToObject(), πg.NewUnicode("\xe2\x99\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\maltese").ToObject(), πg.NewUnicode("\xe2\x9c\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mapsfrom").ToObject(), πg.NewUnicode("\xe2\x86\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mapsto").ToObject(), πg.NewUnicode("\xe2\x86\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcircumflex").ToObject(), πg.NewUnicode("^").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\max").ToObject(), πg.NewUnicode("max").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\measuredangle").ToObject(), πg.NewUnicode("\xe2\x88\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\medbullet").ToObject(), πg.NewUnicode("\xe2\x9a\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\medcirc").ToObject(), πg.NewUnicode("\xe2\x9a\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mercury").ToObject(), πg.NewUnicode("\xe2\x98\xbf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mho").ToObject(), πg.NewUnicode("\xe2\x84\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mid").ToObject(), πg.NewUnicode("\xe2\x88\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\min").ToObject(), πg.NewUnicode("min").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\models").ToObject(), πg.NewUnicode("\xe2\x8a\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mp").ToObject(), πg.NewUnicode("\xe2\x88\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\multimap").ToObject(), πg.NewUnicode("\xe2\x8a\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nLeftarrow").ToObject(), πg.NewUnicode("\xe2\x87\x8d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nLeftrightarrow").ToObject(), πg.NewUnicode("\xe2\x87\x8e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nRightarrow").ToObject(), πg.NewUnicode("\xe2\x87\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nVDash").ToObject(), πg.NewUnicode("\xe2\x8a\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nabla").ToObject(), πg.NewUnicode("\xe2\x88\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\napprox").ToObject(), πg.NewUnicode("\xe2\x89\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\natural").ToObject(), πg.NewUnicode("\xe2\x99\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ncong").ToObject(), πg.NewUnicode("\xe2\x89\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nearrow").ToObject(), πg.NewUnicode("\xe2\x86\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\neg").ToObject(), πg.NewUnicode("\xc2\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\neg)").ToObject(), πg.NewUnicode("\xc2\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\neptune").ToObject(), πg.NewUnicode("\xe2\x99\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nequiv").ToObject(), πg.NewUnicode("\xe2\x89\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\newline").ToObject(), πg.NewUnicode("<br/>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nexists").ToObject(), πg.NewUnicode("\xe2\x88\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ngeqslant").ToObject(), πg.NewUnicode("\xe2\x89\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ngtr").ToObject(), πg.NewUnicode("\xe2\x89\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ngtrless").ToObject(), πg.NewUnicode("\xe2\x89\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ni").ToObject(), πg.NewUnicode("\xe2\x88\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ni)").ToObject(), πg.NewUnicode("\xe2\x88\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nleftarrow").ToObject(), πg.NewUnicode("\xe2\x86\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nleftrightarrow").ToObject(), πg.NewUnicode("\xe2\x86\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nleqslant").ToObject(), πg.NewUnicode("\xe2\x89\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nless").ToObject(), πg.NewUnicode("\xe2\x89\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nlessgtr").ToObject(), πg.NewUnicode("\xe2\x89\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nmid").ToObject(), πg.NewUnicode("\xe2\x88\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nolimits").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nonumber").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\not").ToObject(), πg.NewUnicode("\xc2\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\not<").ToObject(), πg.NewUnicode("\xe2\x89\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\not=").ToObject(), πg.NewUnicode("\xe2\x89\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\not>").ToObject(), πg.NewUnicode("\xe2\x89\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\notbackslash").ToObject(), πg.NewUnicode("\xe2\x8d\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\notin").ToObject(), πg.NewUnicode("\xe2\x88\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\notni").ToObject(), πg.NewUnicode("\xe2\x88\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\notslash").ToObject(), πg.NewUnicode("\xe2\x8c\xbf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nparallel").ToObject(), πg.NewUnicode("\xe2\x88\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nprec").ToObject(), πg.NewUnicode("\xe2\x8a\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nrightarrow").ToObject(), πg.NewUnicode("\xe2\x86\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsim").ToObject(), πg.NewUnicode("\xe2\x89\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsimeq").ToObject(), πg.NewUnicode("\xe2\x89\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsqsubset").ToObject(), πg.NewUnicode("\xe2\x8a\x8f\xcc\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsubseteq").ToObject(), πg.NewUnicode("\xe2\x8a\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsucc").ToObject(), πg.NewUnicode("\xe2\x8a\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsucccurlyeq").ToObject(), πg.NewUnicode("\xe2\x8b\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsupset").ToObject(), πg.NewUnicode("\xe2\x8a\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsupseteq").ToObject(), πg.NewUnicode("\xe2\x8a\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ntriangleleft").ToObject(), πg.NewUnicode("\xe2\x8b\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ntrianglelefteq").ToObject(), πg.NewUnicode("\xe2\x8b\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ntriangleright").ToObject(), πg.NewUnicode("\xe2\x8b\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ntrianglerighteq").ToObject(), πg.NewUnicode("\xe2\x8b\xad").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nvDash").ToObject(), πg.NewUnicode("\xe2\x8a\xad").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nvdash").ToObject(), πg.NewUnicode("\xe2\x8a\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nwarrow").ToObject(), πg.NewUnicode("\xe2\x86\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\odot").ToObject(), πg.NewUnicode("\xe2\x8a\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\officialeuro").ToObject(), πg.NewUnicode("\xe2\x82\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\oiiint").ToObject(), πg.NewUnicode("<span class=\"bigsymbol\">\xe2\x88\xb0</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\oiint").ToObject(), πg.NewUnicode("<span class=\"bigsymbol\">\xe2\x88\xaf</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\oint").ToObject(), πg.NewUnicode("<span class=\"bigsymbol\">\xe2\x88\xae</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ointclockwise").ToObject(), πg.NewUnicode("<span class=\"bigsymbol\">\xe2\x88\xb2</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ointctrclockwise").ToObject(), πg.NewUnicode("<span class=\"bigsymbol\">\xe2\x88\xb3</span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ominus").ToObject(), πg.NewUnicode("\xe2\x8a\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\oplus").ToObject(), πg.NewUnicode("\xe2\x8a\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\oslash").ToObject(), πg.NewUnicode("\xe2\x8a\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\otimes").ToObject(), πg.NewUnicode("\xe2\x8a\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\owns").ToObject(), πg.NewUnicode("\xe2\x88\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\parallel").ToObject(), πg.NewUnicode("\xe2\x88\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\partial").ToObject(), πg.NewUnicode("\xe2\x88\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pencil").ToObject(), πg.NewUnicode("\xe2\x9c\x8e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\perp").ToObject(), πg.NewUnicode("\xe2\x8a\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pisces").ToObject(), πg.NewUnicode("\xe2\x99\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pitchfork").ToObject(), πg.NewUnicode("\xe2\x8b\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pluto").ToObject(), πg.NewUnicode("\xe2\x99\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pm").ToObject(), πg.NewUnicode("\xc2\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pointer").ToObject(), πg.NewUnicode("\xe2\x9e\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pointright").ToObject(), πg.NewUnicode("\xe2\x98\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pounds").ToObject(), πg.NewUnicode("\xc2\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\prec").ToObject(), πg.NewUnicode("\xe2\x89\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\preccurlyeq").ToObject(), πg.NewUnicode("\xe2\x89\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\preceq").ToObject(), πg.NewUnicode("\xe2\x89\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\precsim").ToObject(), πg.NewUnicode("\xe2\x89\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\prime").ToObject(), πg.NewUnicode("\xe2\x80\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\prompto").ToObject(), πg.NewUnicode("\xe2\x88\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\qoppa").ToObject(), πg.NewUnicode("\xcf\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\qquad").ToObject(), πg.NewUnicode("  ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\quad").ToObject(), πg.NewUnicode(" ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\quarternote").ToObject(), πg.NewUnicode("\xe2\x99\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\radiation").ToObject(), πg.NewUnicode("\xe2\x98\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rang").ToObject(), πg.NewUnicode("\xe2\x9f\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rangle").ToObject(), πg.NewUnicode("\xe2\x9f\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rblot").ToObject(), πg.NewUnicode("\xe2\xa6\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rbrace").ToObject(), πg.NewUnicode("}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rbrace)").ToObject(), πg.NewUnicode("}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rbrack").ToObject(), πg.NewUnicode("]").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rceil").ToObject(), πg.NewUnicode("\xe2\x8c\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\recycle").ToObject(), πg.NewUnicode("\xe2\x99\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rfloor").ToObject(), πg.NewUnicode("\xe2\x8c\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rgroup").ToObject(), πg.NewUnicode("\xe2\x9f\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rhd").ToObject(), πg.NewUnicode("\xe2\x8a\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightangle").ToObject(), πg.NewUnicode("\xe2\x88\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightarrow)").ToObject(), πg.NewUnicode("\xe2\x86\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightarrowtail").ToObject(), πg.NewUnicode("\xe2\x86\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightarrowtobar").ToObject(), πg.NewUnicode("\xe2\x87\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightharpoondown").ToObject(), πg.NewUnicode("\xe2\x87\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightharpoonup").ToObject(), πg.NewUnicode("\xe2\x87\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightharpooondown").ToObject(), πg.NewUnicode("\xe2\x87\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightharpooonup").ToObject(), πg.NewUnicode("\xe2\x87\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightleftarrows").ToObject(), πg.NewUnicode("\xe2\x87\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightleftharpoons").ToObject(), πg.NewUnicode("\xe2\x87\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightmoon").ToObject(), πg.NewUnicode("\xe2\x98\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightrightarrows").ToObject(), πg.NewUnicode("\xe2\x87\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightrightharpoons").ToObject(), πg.NewUnicode("\xe2\xa5\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightthreetimes").ToObject(), πg.NewUnicode("\xe2\x8b\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rimg").ToObject(), πg.NewUnicode("\xe2\xa6\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\risingdotseq").ToObject(), πg.NewUnicode("\xe2\x89\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rrbracket").ToObject(), πg.NewUnicode("\xe2\x9f\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rsub").ToObject(), πg.NewUnicode("\xe2\xa9\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rtimes").ToObject(), πg.NewUnicode("\xe2\x8b\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sagittarius").ToObject(), πg.NewUnicode("\xe2\x99\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\saturn").ToObject(), πg.NewUnicode("\xe2\x99\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\scorpio").ToObject(), πg.NewUnicode("\xe2\x99\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\searrow").ToObject(), πg.NewUnicode("\xe2\x86\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sec").ToObject(), πg.NewUnicode("sec").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\second").ToObject(), πg.NewUnicode("\xe2\x80\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\setminus").ToObject(), πg.NewUnicode("\xe2\x88\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sharp").ToObject(), πg.NewUnicode("\xe2\x99\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\simeq").ToObject(), πg.NewUnicode("\xe2\x89\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sin").ToObject(), πg.NewUnicode("sin").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sinh").ToObject(), πg.NewUnicode("sinh").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sixteenthnote").ToObject(), πg.NewUnicode("\xe2\x99\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\skull").ToObject(), πg.NewUnicode("\xe2\x98\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\slash").ToObject(), πg.NewUnicode("\xe2\x88\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\smallsetminus").ToObject(), πg.NewUnicode("\xe2\x88\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\smalltriangledown").ToObject(), πg.NewUnicode("\xe2\x96\xbf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\smalltriangleleft").ToObject(), πg.NewUnicode("\xe2\x97\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\smalltriangleright").ToObject(), πg.NewUnicode("\xe2\x96\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\smalltriangleup").ToObject(), πg.NewUnicode("\xe2\x96\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\smile").ToObject(), πg.NewUnicode("\xe2\x8c\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\smiley").ToObject(), πg.NewUnicode("\xe2\x98\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\spadesuit").ToObject(), πg.NewUnicode("\xe2\x99\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\spddot").ToObject(), πg.NewUnicode("\xc2\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sphat").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sphericalangle").ToObject(), πg.NewUnicode("\xe2\x88\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\spot").ToObject(), πg.NewUnicode("\xe2\xa6\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sptilde").ToObject(), πg.NewUnicode("~").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sqcap").ToObject(), πg.NewUnicode("\xe2\x8a\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sqcup").ToObject(), πg.NewUnicode("\xe2\x8a\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sqsubset").ToObject(), πg.NewUnicode("\xe2\x8a\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sqsubseteq").ToObject(), πg.NewUnicode("\xe2\x8a\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sqsupset").ToObject(), πg.NewUnicode("\xe2\x8a\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sqsupseteq").ToObject(), πg.NewUnicode("\xe2\x8a\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\square").ToObject(), πg.NewUnicode("\xe2\x96\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sslash").ToObject(), πg.NewUnicode("\xe2\xab\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\star").ToObject(), πg.NewUnicode("\xe2\x8b\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\steaming").ToObject(), πg.NewUnicode("\xe2\x98\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\subseteqq").ToObject(), πg.NewUnicode("\xe2\xab\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\subsetneqq").ToObject(), πg.NewUnicode("\xe2\xab\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\succ").ToObject(), πg.NewUnicode("\xe2\x89\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\succcurlyeq").ToObject(), πg.NewUnicode("\xe2\x89\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\succeq").ToObject(), πg.NewUnicode("\xe2\x89\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\succnsim").ToObject(), πg.NewUnicode("\xe2\x8b\xa9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\succsim").ToObject(), πg.NewUnicode("\xe2\x89\xbf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sun").ToObject(), πg.NewUnicode("\xe2\x98\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sup").ToObject(), πg.NewUnicode("sup").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\supseteqq").ToObject(), πg.NewUnicode("\xe2\xab\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\supsetneqq").ToObject(), πg.NewUnicode("\xe2\xab\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\surd").ToObject(), πg.NewUnicode("\xe2\x88\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\swarrow").ToObject(), πg.NewUnicode("\xe2\x86\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\swords").ToObject(), πg.NewUnicode("\xe2\x9a\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\talloblong").ToObject(), πg.NewUnicode("\xe2\xab\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\tan").ToObject(), πg.NewUnicode("tan").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\tanh").ToObject(), πg.NewUnicode("tanh").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\taurus").ToObject(), πg.NewUnicode("\xe2\x99\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textasciicircum").ToObject(), πg.NewUnicode("^").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textasciitilde").ToObject(), πg.NewUnicode("~").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textbackslash").ToObject(), πg.NewUnicode("\\").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textcopyright").ToObject(), πg.NewUnicode("\xc2\xa9'").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textdegree").ToObject(), πg.NewUnicode("\xc2\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textellipsis").ToObject(), πg.NewUnicode("\xe2\x80\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textemdash").ToObject(), πg.NewUnicode("\xe2\x80\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textendash").ToObject(), πg.NewUnicode("\xe2\x80\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\texteuro").ToObject(), πg.NewUnicode("\xe2\x82\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textgreater").ToObject(), πg.NewUnicode(">").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textless").ToObject(), πg.NewUnicode("<").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textordfeminine").ToObject(), πg.NewUnicode("\xc2\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textordmasculine").ToObject(), πg.NewUnicode("\xc2\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textquotedblleft").ToObject(), πg.NewUnicode("\xe2\x80\x9c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textquotedblright").ToObject(), πg.NewUnicode("\xe2\x80\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textquoteright").ToObject(), πg.NewUnicode("\xe2\x80\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textregistered").ToObject(), πg.NewUnicode("\xc2\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textrightarrow").ToObject(), πg.NewUnicode("\xe2\x86\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textsection").ToObject(), πg.NewUnicode("\xc2\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\texttrademark").ToObject(), πg.NewUnicode("\xe2\x84\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\texttwosuperior").ToObject(), πg.NewUnicode("\xc2\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textvisiblespace").ToObject(), πg.NewUnicode(" ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\therefore").ToObject(), πg.NewUnicode("\xe2\x88\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\third").ToObject(), πg.NewUnicode("\xe2\x80\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\top").ToObject(), πg.NewUnicode("\xe2\x8a\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\triangle").ToObject(), πg.NewUnicode("\xe2\x96\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\triangleleft").ToObject(), πg.NewUnicode("\xe2\x8a\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\trianglelefteq").ToObject(), πg.NewUnicode("\xe2\x8a\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\triangleq").ToObject(), πg.NewUnicode("\xe2\x89\x9c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\triangleright").ToObject(), πg.NewUnicode("\xe2\x96\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\trianglerighteq").ToObject(), πg.NewUnicode("\xe2\x8a\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\twoheadleftarrow").ToObject(), πg.NewUnicode("\xe2\x86\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\twoheadrightarrow").ToObject(), πg.NewUnicode("\xe2\x86\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\twonotes").ToObject(), πg.NewUnicode("\xe2\x99\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\udot").ToObject(), πg.NewUnicode("\xe2\x8a\x8d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ulcorner").ToObject(), πg.NewUnicode("\xe2\x8c\x9c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\unlhd").ToObject(), πg.NewUnicode("\xe2\x8a\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\unrhd").ToObject(), πg.NewUnicode("\xe2\x8a\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\unrhl").ToObject(), πg.NewUnicode("\xe2\x8a\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\uparrow").ToObject(), πg.NewUnicode("\xe2\x86\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\updownarrow").ToObject(), πg.NewUnicode("\xe2\x86\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\upharpoonleft").ToObject(), πg.NewUnicode("\xe2\x86\xbf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\upharpoonright").ToObject(), πg.NewUnicode("\xe2\x86\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\uplus").ToObject(), πg.NewUnicode("\xe2\x8a\x8e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\upuparrows").ToObject(), πg.NewUnicode("\xe2\x87\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\uranus").ToObject(), πg.NewUnicode("\xe2\x99\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\urcorner").ToObject(), πg.NewUnicode("\xe2\x8c\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vDash").ToObject(), πg.NewUnicode("\xe2\x8a\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varclubsuit").ToObject(), πg.NewUnicode("\xe2\x99\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vardiamondsuit").ToObject(), πg.NewUnicode("\xe2\x99\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varheartsuit").ToObject(), πg.NewUnicode("\xe2\x99\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varnothing").ToObject(), πg.NewUnicode("\xe2\x88\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varspadesuit").ToObject(), πg.NewUnicode("\xe2\x99\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vdash").ToObject(), πg.NewUnicode("\xe2\x8a\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vdots").ToObject(), πg.NewUnicode("\xe2\x8b\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vee").ToObject(), πg.NewUnicode("\xe2\x88\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vee)").ToObject(), πg.NewUnicode("\xe2\x88\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\veebar").ToObject(), πg.NewUnicode("\xe2\x8a\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vert").ToObject(), πg.NewUnicode("\xe2\x88\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\virgo").ToObject(), πg.NewUnicode("\xe2\x99\x8d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\warning").ToObject(), πg.NewUnicode("\xe2\x9a\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\wasylozenge").ToObject(), πg.NewUnicode("\xe2\x8c\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\wedge").ToObject(), πg.NewUnicode("\xe2\x88\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\wedge)").ToObject(), πg.NewUnicode("\xe2\x88\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\wp").ToObject(), πg.NewUnicode("\xe2\x84\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\wr").ToObject(), πg.NewUnicode("\xe2\x89\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\yen").ToObject(), πg.NewUnicode("\xc2\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\yinyang").ToObject(), πg.NewUnicode("\xe2\x98\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\{").ToObject(), πg.NewUnicode("{").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\|").ToObject(), πg.NewUnicode("\xe2\x88\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\}").ToObject(), πg.NewUnicode("}").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßcommands.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 574: decoratedcommand = {
					πF.SetLineno(574)
					πTemp001 = πg.NewDict()
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßdecoratedcommand.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 577: decoratingfunctions = {
					πF.SetLineno(577)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\overleftarrow").ToObject(), πg.NewUnicode("\xe2\x9f\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\overrightarrow").ToObject(), πg.NewUnicode("\xe2\x9f\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\widehat").ToObject(), πg.NewUnicode("^").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßdecoratingfunctions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 581: endings = {
					πF.SetLineno(581)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("bracket").ToObject(), πg.NewUnicode("}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("complex").ToObject(), πg.NewUnicode("\\]").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("endafter").ToObject(), πg.NewUnicode("}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("endbefore").ToObject(), πg.NewUnicode("\\end{").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("squarebracket").ToObject(), πg.NewUnicode("]").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßendings.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 586: environments = {
					πF.SetLineno(586)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 2)
					πTemp003[0] = πg.NewUnicode("r").ToObject()
					πTemp003[1] = πg.NewUnicode("l").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("align").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("r").ToObject()
					πTemp003[1] = πg.NewUnicode("c").ToObject()
					πTemp003[2] = πg.NewUnicode("l").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("eqnarray").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 2)
					πTemp003[0] = πg.NewUnicode("l").ToObject()
					πTemp003[1] = πg.NewUnicode("l").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("gathered").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßenvironments.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 591: fontfunctions = {
					πF.SetLineno(591)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boldsymbol").ToObject(), πg.NewUnicode("b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb").ToObject(), πg.NewUnicode("span class=\"blackboard\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{A}").ToObject(), πg.NewUnicode("\xf0\x9d\x94\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{B}").ToObject(), πg.NewUnicode("\xf0\x9d\x94\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{C}").ToObject(), πg.NewUnicode("\xe2\x84\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{D}").ToObject(), πg.NewUnicode("\xf0\x9d\x94\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{E}").ToObject(), πg.NewUnicode("\xf0\x9d\x94\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{F}").ToObject(), πg.NewUnicode("\xf0\x9d\x94\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{G}").ToObject(), πg.NewUnicode("\xf0\x9d\x94\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{H}").ToObject(), πg.NewUnicode("\xe2\x84\x8d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{J}").ToObject(), πg.NewUnicode("\xf0\x9d\x95\x81").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{K}").ToObject(), πg.NewUnicode("\xf0\x9d\x95\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{L}").ToObject(), πg.NewUnicode("\xf0\x9d\x95\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{N}").ToObject(), πg.NewUnicode("\xe2\x84\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{O}").ToObject(), πg.NewUnicode("\xf0\x9d\x95\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{P}").ToObject(), πg.NewUnicode("\xe2\x84\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{Q}").ToObject(), πg.NewUnicode("\xe2\x84\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{R}").ToObject(), πg.NewUnicode("\xe2\x84\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{S}").ToObject(), πg.NewUnicode("\xf0\x9d\x95\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{T}").ToObject(), πg.NewUnicode("\xf0\x9d\x95\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{W}").ToObject(), πg.NewUnicode("\xf0\x9d\x95\x8e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbb{Z}").ToObject(), πg.NewUnicode("\xe2\x84\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathbf").ToObject(), πg.NewUnicode("b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcal").ToObject(), πg.NewUnicode("span class=\"scriptfont\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcal{B}").ToObject(), πg.NewUnicode("\xe2\x84\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcal{E}").ToObject(), πg.NewUnicode("\xe2\x84\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcal{F}").ToObject(), πg.NewUnicode("\xe2\x84\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcal{H}").ToObject(), πg.NewUnicode("\xe2\x84\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcal{I}").ToObject(), πg.NewUnicode("\xe2\x84\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcal{L}").ToObject(), πg.NewUnicode("\xe2\x84\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcal{M}").ToObject(), πg.NewUnicode("\xe2\x84\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathcal{R}").ToObject(), πg.NewUnicode("\xe2\x84\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathfrak").ToObject(), πg.NewUnicode("span class=\"fraktur\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathfrak{C}").ToObject(), πg.NewUnicode("\xe2\x84\xad").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathfrak{F}").ToObject(), πg.NewUnicode("\xf0\x9d\x94\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathfrak{H}").ToObject(), πg.NewUnicode("\xe2\x84\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathfrak{I}").ToObject(), πg.NewUnicode("\xe2\x84\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathfrak{R}").ToObject(), πg.NewUnicode("\xe2\x84\x9c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathfrak{Z}").ToObject(), πg.NewUnicode("\xe2\x84\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathit").ToObject(), πg.NewUnicode("i").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathring{A}").ToObject(), πg.NewUnicode("\xc3\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathring{U}").ToObject(), πg.NewUnicode("\xc5\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathring{a}").ToObject(), πg.NewUnicode("\xc3\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathring{u}").ToObject(), πg.NewUnicode("\xc5\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathring{w}").ToObject(), πg.NewUnicode("\xe1\xba\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathring{y}").ToObject(), πg.NewUnicode("\xe1\xba\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathrm").ToObject(), πg.NewUnicode("span class=\"mathrm\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathscr").ToObject(), πg.NewUnicode("span class=\"scriptfont\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathscr{B}").ToObject(), πg.NewUnicode("\xe2\x84\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathscr{E}").ToObject(), πg.NewUnicode("\xe2\x84\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathscr{F}").ToObject(), πg.NewUnicode("\xe2\x84\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathscr{H}").ToObject(), πg.NewUnicode("\xe2\x84\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathscr{I}").ToObject(), πg.NewUnicode("\xe2\x84\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathscr{L}").ToObject(), πg.NewUnicode("\xe2\x84\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathscr{M}").ToObject(), πg.NewUnicode("\xe2\x84\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathscr{R}").ToObject(), πg.NewUnicode("\xe2\x84\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathsf").ToObject(), πg.NewUnicode("span class=\"mathsf\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mathtt").ToObject(), πg.NewUnicode("tt").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßfontfunctions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 616: hybridfunctions = {
					πF.SetLineno(616)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}{$q!}{$r!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\addcontentsline").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}{$q!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\addtocontents").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\backmatter").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 5)
					πTemp003[0] = πg.NewUnicode("{$1}{$2}").ToObject()
					πTemp003[1] = πg.NewUnicode("f2{(}f0{f1{$1}f1{$2}}f2{)}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"binom\"").ToObject()
					πTemp003[3] = πg.NewUnicode("span class=\"binomstack\"").ToObject()
					πTemp003[4] = πg.NewUnicode("span class=\"bigsymbol\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\binom").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"boxed\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\boxed").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 6)
					πTemp003[0] = πg.NewUnicode("[$p!]{$1}{$2}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{f3{(}f1{$1}f3{)/(}f2{$2}f3{)}}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"fullfraction\"").ToObject()
					πTemp003[3] = πg.NewUnicode("span class=\"numerator align-$p\"").ToObject()
					πTemp003[4] = πg.NewUnicode("span class=\"denominator\"").ToObject()
					πTemp003[5] = πg.NewUnicode("span class=\"ignored\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cfrac").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span style=\"color: $p;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\color").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"colorbox\" style=\"background: $p;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\colorbox").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 5)
					πTemp003[0] = πg.NewUnicode("{$1}{$2}").ToObject()
					πTemp003[1] = πg.NewUnicode("(f0{f1{f2{$1}}f1{f2{\xe2\x80\x85}}f1{f2{$2}}})").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"binomial\"").ToObject()
					πTemp003[3] = πg.NewUnicode("span class=\"binomrow\"").ToObject()
					πTemp003[4] = πg.NewUnicode("span class=\"binomcell\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dbinom").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 6)
					πTemp003[0] = πg.NewUnicode("{$1}{$2}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{f3{(}f1{$1}f3{)/(}f2{$2}f3{)}}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"fullfraction\"").ToObject()
					πTemp003[3] = πg.NewUnicode("span class=\"numerator\"").ToObject()
					πTemp003[4] = πg.NewUnicode("span class=\"denominator\"").ToObject()
					πTemp003[5] = πg.NewUnicode("span class=\"ignored\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dfrac").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"displaystyle\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\displaystyle").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("[$p!]{$q!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fancyfoot").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("[$p!]{$q!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fancyhead").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"fbox\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fbox").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fboxrule").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fboxsep").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}{$q!}{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"boxed\" style=\"border-color: $p; background: $q;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fcolorbox").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 6)
					πTemp003[0] = πg.NewUnicode("{$1}{$2}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{f3{(}f1{$1}f3{)/(}f2{$2}f3{)}}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"fraction\"").ToObject()
					πTemp003[3] = πg.NewUnicode("span class=\"numerator\"").ToObject()
					πTemp003[4] = πg.NewUnicode("span class=\"denominator\"").ToObject()
					πTemp003[5] = πg.NewUnicode("span class=\"ignored\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\frac").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("[$p!][$q!]{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"framebox align-$q\" style=\"width: $p;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\framebox").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\frontmatter").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("[$o]{$u!}{$t!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$t}").ToObject()
					πTemp003[2] = πg.NewUnicode("a href=\"$u\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\href").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{ }").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"hspace\" style=\"width: $p;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hspace").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{ }").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"leftroot\" style=\"width: $p;px\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftroot").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mainmatter").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}{$q!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\markboth").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\markright").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 6)
					πTemp003[0] = πg.NewUnicode("{$1}{$2}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{f1{$1}\xe2\x81\x84f2{$2}}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"fraction\"").ToObject()
					πTemp003[3] = πg.NewUnicode("sup class=\"numerator\"").ToObject()
					πTemp003[4] = πg.NewUnicode("sub class=\"denominator\"").ToObject()
					πTemp003[5] = πg.NewUnicode("span class=\"ignored\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nicefrac").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("[$p!]{$w!}{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{1}").ToObject()
					πTemp003[2] = πg.NewUnicode("div class=\"Boxed\" style=\"width: $w;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\parbox").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1.font}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"raisebox\" style=\"vertical-align: $p;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\raisebox").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 2)
					πTemp003[0] = πg.NewUnicode("{$1!}{$2!}{$3!}").ToObject()
					πTemp003[1] = πg.NewUnicode("").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\renewenvironment").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("[$v!]{$w!}{$h!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0/").ToObject()
					πTemp003[2] = πg.NewUnicode("hr class=\"line\" style=\"width: $w; height: $h;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rule").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"scriptscriptstyle\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\scriptscriptstyle").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"scriptstyle\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\scriptstyle").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 7)
					πTemp003[0] = πg.NewUnicode("[$0]{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{f1{$0}f2{\xe2\x88\x9a}f4{(}f3{$1}f4{)}}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"sqrt\"").ToObject()
					πTemp003[3] = πg.NewUnicode("sup class=\"root\"").ToObject()
					πTemp003[4] = πg.NewUnicode("span class=\"radical\"").ToObject()
					πTemp003[5] = πg.NewUnicode("span class=\"root\"").ToObject()
					πTemp003[6] = πg.NewUnicode("span class=\"ignored\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sqrt").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 5)
					πTemp003[0] = πg.NewUnicode("{$1}{$2}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{f1{$1}f2{$2}}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"stackrel\"").ToObject()
					πTemp003[3] = πg.NewUnicode("span class=\"upstackrel\"").ToObject()
					πTemp003[4] = πg.NewUnicode("span class=\"downstackrel\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\stackrel").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 5)
					πTemp003[0] = πg.NewUnicode("{$1}{$2}").ToObject()
					πTemp003[1] = πg.NewUnicode("(f0{f1{f2{$1}}f1{f2{\xe2\x80\x85}}f1{f2{$2}}})").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"binomial\"").ToObject()
					πTemp003[3] = πg.NewUnicode("span class=\"binomrow\"").ToObject()
					πTemp003[4] = πg.NewUnicode("span class=\"binomcell\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\tbinom").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span style=\"color: $p;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textcolor").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$1}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"textstyle\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textstyle").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{}").ToObject()
					πTemp003[2] = πg.NewUnicode("ignored").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\thispagestyle").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("[$0]{$1}").ToObject()
					πTemp003[1] = πg.NewUnicode("$0f0{$1.font}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"unit\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\unit").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 5)
					πTemp003[0] = πg.NewUnicode("[$0]{$1}{$2}").ToObject()
					πTemp003[1] = πg.NewUnicode("$0f0{f1{$1.font}\xe2\x81\x84f2{$2.font}}").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"fraction\"").ToObject()
					πTemp003[3] = πg.NewUnicode("sup class=\"unit\"").ToObject()
					πTemp003[4] = πg.NewUnicode("sub class=\"unit\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\unitfrac").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{ }").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"uproot\" style=\"width: $p;px\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\uproot").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$u!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{$u}").ToObject()
					πTemp003[2] = πg.NewUnicode("a href=\"$u\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\url").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 3)
					πTemp003[0] = πg.NewUnicode("{$p!}").ToObject()
					πTemp003[1] = πg.NewUnicode("f0{ }").ToObject()
					πTemp003[2] = πg.NewUnicode("span class=\"vspace\" style=\"height: $p;\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vspace").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßhybridfunctions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 663: hybridsizes = {
					πF.SetLineno(663)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\binom").ToObject(), πg.NewUnicode("$1+$2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\cfrac").ToObject(), πg.NewUnicode("$1+$2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dbinom").ToObject(), πg.NewUnicode("$1+$2+1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dfrac").ToObject(), πg.NewUnicode("$1+$2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\frac").ToObject(), πg.NewUnicode("$1+$2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\tbinom").ToObject(), πg.NewUnicode("$1+$2+1").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßhybridsizes.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 668: labelfunctions = {
					πF.SetLineno(668)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\label").ToObject(), πg.NewUnicode("a name=\"#\"").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßlabelfunctions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 672: limitcommands = {
					πF.SetLineno(672)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\biginterleave").ToObject(), πg.NewUnicode("\xe2\xab\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigsqcap").ToObject(), πg.NewUnicode("\xe2\xa8\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\fint").ToObject(), πg.NewUnicode("\xe2\xa8\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\iiiint").ToObject(), πg.NewUnicode("\xe2\xa8\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\int").ToObject(), πg.NewUnicode("\xe2\x88\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\intop").ToObject(), πg.NewUnicode("\xe2\x88\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lim").ToObject(), πg.NewUnicode("lim").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\prod").ToObject(), πg.NewUnicode("\xe2\x88\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\smallint").ToObject(), πg.NewUnicode("\xe2\x88\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sqint").ToObject(), πg.NewUnicode("\xe2\xa8\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sum").ToObject(), πg.NewUnicode("\xe2\x88\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varointclockwise").ToObject(), πg.NewUnicode("\xe2\x88\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\varprod").ToObject(), πg.NewUnicode("\xe2\xa8\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\zcmp").ToObject(), πg.NewUnicode("\xe2\xa8\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\zhide").ToObject(), πg.NewUnicode("\xe2\xa7\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\zpipe").ToObject(), πg.NewUnicode("\xe2\xa8\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\zproject").ToObject(), πg.NewUnicode("\xe2\xa8\xa1").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßlimitcommands.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 680: misccommands = {
					πF.SetLineno(680)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\limits").ToObject(), πg.NewUnicode("LimitPreviousCommand").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\newcommand").ToObject(), πg.NewUnicode("MacroDefinition").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\renewcommand").ToObject(), πg.NewUnicode("MacroDefinition").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\setcounter").ToObject(), πg.NewUnicode("SetCounterFunction").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\tag").ToObject(), πg.NewUnicode("FormulaTag").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\tag*").ToObject(), πg.NewUnicode("FormulaTag").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\today").ToObject(), πg.NewUnicode("TodayCommand").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßmisccommands.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 687: modified = {
					πF.SetLineno(687)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\n").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(" ").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("$").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("&").ToObject(), πg.NewUnicode("\t").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("'").ToObject(), πg.NewUnicode("\xe2\x80\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("+").ToObject(), πg.NewUnicode("\xe2\x81\x9f+\xe2\x81\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(",").ToObject(), πg.NewUnicode(",\xe2\x81\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("-").ToObject(), πg.NewUnicode("\xe2\x81\x9f\xe2\x88\x92\xe2\x81\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("/").ToObject(), πg.NewUnicode("\xe2\x81\x9f\xe2\x81\x84\xe2\x81\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(":").ToObject(), πg.NewUnicode(" : ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("<").ToObject(), πg.NewUnicode("\xe2\x81\x9f&lt;\xe2\x81\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("=").ToObject(), πg.NewUnicode("\xe2\x81\x9f=\xe2\x81\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(">").ToObject(), πg.NewUnicode("\xe2\x81\x9f&gt;\xe2\x81\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("@").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("~").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßmodified.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 693: onefunctions = {
					πF.SetLineno(693)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Big").ToObject(), πg.NewUnicode("span class=\"bigsymbol\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Bigg").ToObject(), πg.NewUnicode("span class=\"hugesymbol\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bar").ToObject(), πg.NewUnicode("span class=\"bar\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\begin{array}").ToObject(), πg.NewUnicode("span class=\"arraydef\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\big").ToObject(), πg.NewUnicode("span class=\"symbol\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigg").ToObject(), πg.NewUnicode("span class=\"largesymbol\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigl").ToObject(), πg.NewUnicode("span class=\"bigsymbol\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bigr").ToObject(), πg.NewUnicode("span class=\"bigsymbol\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\centering").ToObject(), πg.NewUnicode("span class=\"align-center\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ensuremath").ToObject(), πg.NewUnicode("span class=\"ensuremath\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hphantom").ToObject(), πg.NewUnicode("span class=\"phantom\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\noindent").ToObject(), πg.NewUnicode("span class=\"noindent\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\overbrace").ToObject(), πg.NewUnicode("span class=\"overbrace\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\overline").ToObject(), πg.NewUnicode("span class=\"overline\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\phantom").ToObject(), πg.NewUnicode("span class=\"phantom\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\underbrace").ToObject(), πg.NewUnicode("span class=\"underbrace\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\underline").ToObject(), πg.NewUnicode("u").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vphantom").ToObject(), πg.NewUnicode("span class=\"phantom\"").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßonefunctions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 709: spacedcommands = {
					πF.SetLineno(709)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Bot").ToObject(), πg.NewUnicode("\xe2\xab\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Doteq").ToObject(), πg.NewUnicode("\xe2\x89\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\DownArrowBar").ToObject(), πg.NewUnicode("\xe2\xa4\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\DownLeftTeeVector").ToObject(), πg.NewUnicode("\xe2\xa5\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\DownLeftVectorBar").ToObject(), πg.NewUnicode("\xe2\xa5\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\DownRightTeeVector").ToObject(), πg.NewUnicode("\xe2\xa5\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\DownRightVectorBar").ToObject(), πg.NewUnicode("\xe2\xa5\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Equal").ToObject(), πg.NewUnicode("\xe2\xa9\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LeftArrowBar").ToObject(), πg.NewUnicode("\xe2\x87\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LeftDownTeeVector").ToObject(), πg.NewUnicode("\xe2\xa5\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LeftDownVectorBar").ToObject(), πg.NewUnicode("\xe2\xa5\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LeftTeeVector").ToObject(), πg.NewUnicode("\xe2\xa5\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LeftTriangleBar").ToObject(), πg.NewUnicode("\xe2\xa7\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LeftUpTeeVector").ToObject(), πg.NewUnicode("\xe2\xa5\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LeftUpVectorBar").ToObject(), πg.NewUnicode("\xe2\xa5\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\LeftVectorBar").ToObject(), πg.NewUnicode("\xe2\xa5\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Leftrightarrow").ToObject(), πg.NewUnicode("\xe2\x87\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Longmapsfrom").ToObject(), πg.NewUnicode("\xe2\x9f\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Longmapsto").ToObject(), πg.NewUnicode("\xe2\x9f\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\MapsDown").ToObject(), πg.NewUnicode("\xe2\x86\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\MapsUp").ToObject(), πg.NewUnicode("\xe2\x86\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Nearrow").ToObject(), πg.NewUnicode("\xe2\x87\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\NestedGreaterGreater").ToObject(), πg.NewUnicode("\xe2\xaa\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\NestedLessLess").ToObject(), πg.NewUnicode("\xe2\xaa\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\NotGreaterLess").ToObject(), πg.NewUnicode("\xe2\x89\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\NotGreaterTilde").ToObject(), πg.NewUnicode("\xe2\x89\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\NotLessTilde").ToObject(), πg.NewUnicode("\xe2\x89\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Nwarrow").ToObject(), πg.NewUnicode("\xe2\x87\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Proportion").ToObject(), πg.NewUnicode("\xe2\x88\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RightArrowBar").ToObject(), πg.NewUnicode("\xe2\x87\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RightDownTeeVector").ToObject(), πg.NewUnicode("\xe2\xa5\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RightDownVectorBar").ToObject(), πg.NewUnicode("\xe2\xa5\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RightTeeVector").ToObject(), πg.NewUnicode("\xe2\xa5\x9b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RightTriangleBar").ToObject(), πg.NewUnicode("\xe2\xa7\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RightUpTeeVector").ToObject(), πg.NewUnicode("\xe2\xa5\x9c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RightUpVectorBar").ToObject(), πg.NewUnicode("\xe2\xa5\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\RightVectorBar").ToObject(), πg.NewUnicode("\xe2\xa5\x93").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Rightarrow").ToObject(), πg.NewUnicode("\xe2\x87\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Same").ToObject(), πg.NewUnicode("\xe2\xa9\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Searrow").ToObject(), πg.NewUnicode("\xe2\x87\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Swarrow").ToObject(), πg.NewUnicode("\xe2\x87\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\Top").ToObject(), πg.NewUnicode("\xe2\xab\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\UpArrowBar").ToObject(), πg.NewUnicode("\xe2\xa4\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\VDash").ToObject(), πg.NewUnicode("\xe2\x8a\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\approx").ToObject(), πg.NewUnicode("\xe2\x89\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\approxeq").ToObject(), πg.NewUnicode("\xe2\x89\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\backsim").ToObject(), πg.NewUnicode("\xe2\x88\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\barin").ToObject(), πg.NewUnicode("\xe2\x8b\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\barleftharpoon").ToObject(), πg.NewUnicode("\xe2\xa5\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\barrightharpoon").ToObject(), πg.NewUnicode("\xe2\xa5\xad").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\bij").ToObject(), πg.NewUnicode("\xe2\xa4\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\coloneq").ToObject(), πg.NewUnicode("\xe2\x89\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\corresponds").ToObject(), πg.NewUnicode("\xe2\x89\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\curlyeqprec").ToObject(), πg.NewUnicode("\xe2\x8b\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\curlyeqsucc").ToObject(), πg.NewUnicode("\xe2\x8b\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dashrightarrow").ToObject(), πg.NewUnicode("\xe2\x87\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\dlsh").ToObject(), πg.NewUnicode("\xe2\x86\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\downdownharpoons").ToObject(), πg.NewUnicode("\xe2\xa5\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\downuparrows").ToObject(), πg.NewUnicode("\xe2\x87\xb5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\downupharpoons").ToObject(), πg.NewUnicode("\xe2\xa5\xaf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\drsh").ToObject(), πg.NewUnicode("\xe2\x86\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\eqslantgtr").ToObject(), πg.NewUnicode("\xe2\xaa\x96").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\eqslantless").ToObject(), πg.NewUnicode("\xe2\xaa\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\equiv").ToObject(), πg.NewUnicode("\xe2\x89\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ffun").ToObject(), πg.NewUnicode("\xe2\x87\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\finj").ToObject(), πg.NewUnicode("\xe2\xa4\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ge").ToObject(), πg.NewUnicode("\xe2\x89\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\geq").ToObject(), πg.NewUnicode("\xe2\x89\xa5").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ggcurly").ToObject(), πg.NewUnicode("\xe2\xaa\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gnapprox").ToObject(), πg.NewUnicode("\xe2\xaa\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gneq").ToObject(), πg.NewUnicode("\xe2\xaa\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\gtrapprox").ToObject(), πg.NewUnicode("\xe2\xaa\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hash").ToObject(), πg.NewUnicode("\xe2\x8b\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\iddots").ToObject(), πg.NewUnicode("\xe2\x8b\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\implies").ToObject(), πg.NewUnicode("\xe2\x81\x9f\xe2\x87\x92\xe2\x81\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\in").ToObject(), πg.NewUnicode("\xe2\x88\x88").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\le").ToObject(), πg.NewUnicode("\xe2\x89\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftarrow").ToObject(), πg.NewUnicode("\xe2\x86\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftarrowtriangle").ToObject(), πg.NewUnicode("\xe2\x87\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftbarharpoon").ToObject(), πg.NewUnicode("\xe2\xa5\xaa").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftrightarrowtriangle").ToObject(), πg.NewUnicode("\xe2\x87\xbf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftrightharpoon").ToObject(), πg.NewUnicode("\xe2\xa5\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftrightharpoondown").ToObject(), πg.NewUnicode("\xe2\xa5\x90").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftrightharpoonup").ToObject(), πg.NewUnicode("\xe2\xa5\x8e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftrightsquigarrow").ToObject(), πg.NewUnicode("\xe2\x86\xad").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftslice").ToObject(), πg.NewUnicode("\xe2\xaa\xa6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftsquigarrow").ToObject(), πg.NewUnicode("\xe2\x87\x9c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leftupdownharpoon").ToObject(), πg.NewUnicode("\xe2\xa5\x91").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\leq").ToObject(), πg.NewUnicode("\xe2\x89\xa4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lessapprox").ToObject(), πg.NewUnicode("\xe2\xaa\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\llcurly").ToObject(), πg.NewUnicode("\xe2\xaa\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lnapprox").ToObject(), πg.NewUnicode("\xe2\xaa\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\lneq").ToObject(), πg.NewUnicode("\xe2\xaa\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\longmapsfrom").ToObject(), πg.NewUnicode("\xe2\x9f\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\multimapboth").ToObject(), πg.NewUnicode("\xe2\xa7\x9f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\multimapdotbothA").ToObject(), πg.NewUnicode("\xe2\x8a\xb6").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\multimapdotbothB").ToObject(), πg.NewUnicode("\xe2\x8a\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\multimapinv").ToObject(), πg.NewUnicode("\xe2\x9f\x9c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nVdash").ToObject(), πg.NewUnicode("\xe2\x8a\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ne").ToObject(), πg.NewUnicode("\xe2\x89\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\neq").ToObject(), πg.NewUnicode("\xe2\x89\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\ngeq").ToObject(), πg.NewUnicode("\xe2\x89\xb1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nleq").ToObject(), πg.NewUnicode("\xe2\x89\xb0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nni").ToObject(), πg.NewUnicode("\xe2\x88\x8c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\not\\in").ToObject(), πg.NewUnicode("\xe2\x88\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\notasymp").ToObject(), πg.NewUnicode("\xe2\x89\xad").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\npreceq").ToObject(), πg.NewUnicode("\xe2\x8b\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsqsubseteq").ToObject(), πg.NewUnicode("\xe2\x8b\xa2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsqsupseteq").ToObject(), πg.NewUnicode("\xe2\x8b\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsubset").ToObject(), πg.NewUnicode("\xe2\x8a\x84").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\nsucceq").ToObject(), πg.NewUnicode("\xe2\x8b\xa1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pfun").ToObject(), πg.NewUnicode("\xe2\x87\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\pinj").ToObject(), πg.NewUnicode("\xe2\xa4\x94").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\precapprox").ToObject(), πg.NewUnicode("\xe2\xaa\xb7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\preceqq").ToObject(), πg.NewUnicode("\xe2\xaa\xb3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\precnapprox").ToObject(), πg.NewUnicode("\xe2\xaa\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\precnsim").ToObject(), πg.NewUnicode("\xe2\x8b\xa8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\propto").ToObject(), πg.NewUnicode("\xe2\x88\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\psur").ToObject(), πg.NewUnicode("\xe2\xa4\x80").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightarrow").ToObject(), πg.NewUnicode("\xe2\x86\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightarrowtriangle").ToObject(), πg.NewUnicode("\xe2\x87\xbe").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightbarharpoon").ToObject(), πg.NewUnicode("\xe2\xa5\xac").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightleftharpoon").ToObject(), πg.NewUnicode("\xe2\xa5\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightslice").ToObject(), πg.NewUnicode("\xe2\xaa\xa7").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightsquigarrow").ToObject(), πg.NewUnicode("\xe2\x87\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\rightupdownharpoon").ToObject(), πg.NewUnicode("\xe2\xa5\x8f").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\sim").ToObject(), πg.NewUnicode("~").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\strictfi").ToObject(), πg.NewUnicode("\xe2\xa5\xbc").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\strictif").ToObject(), πg.NewUnicode("\xe2\xa5\xbd").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\subset").ToObject(), πg.NewUnicode("\xe2\x8a\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\subseteq").ToObject(), πg.NewUnicode("\xe2\x8a\x86").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\subsetneq").ToObject(), πg.NewUnicode("\xe2\x8a\x8a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\succapprox").ToObject(), πg.NewUnicode("\xe2\xaa\xb8").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\succeqq").ToObject(), πg.NewUnicode("\xe2\xaa\xb4").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\succnapprox").ToObject(), πg.NewUnicode("\xe2\xaa\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\supset").ToObject(), πg.NewUnicode("\xe2\x8a\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\supseteq").ToObject(), πg.NewUnicode("\xe2\x8a\x87").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\supsetneq").ToObject(), πg.NewUnicode("\xe2\x8a\x8b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\times").ToObject(), πg.NewUnicode("\xc3\x97").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\to").ToObject(), πg.NewUnicode("\xe2\x86\x92").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\updownarrows").ToObject(), πg.NewUnicode("\xe2\x87\x85").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\updownharpoons").ToObject(), πg.NewUnicode("\xe2\xa5\xae").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\upupharpoons").ToObject(), πg.NewUnicode("\xe2\xa5\xa3").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vartriangleleft").ToObject(), πg.NewUnicode("\xe2\x8a\xb2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\vartriangleright").ToObject(), πg.NewUnicode("\xe2\x8a\xb3").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßspacedcommands.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 764: starts = {
					πF.SetLineno(764)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("beginafter").ToObject(), πg.NewUnicode("}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("beginbefore").ToObject(), πg.NewUnicode("\\begin{").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("bracket").ToObject(), πg.NewUnicode("{").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("command").ToObject(), πg.NewUnicode("\\").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("comment").ToObject(), πg.NewUnicode("%").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("complex").ToObject(), πg.NewUnicode("\\[").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("simple").ToObject(), πg.NewUnicode("$").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("squarebracket").ToObject(), πg.NewUnicode("[").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("unnumbered").ToObject(), πg.NewUnicode("*").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßstarts.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 770: symbolfunctions = {
					πF.SetLineno(770)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("^").ToObject(), πg.NewUnicode("sup").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("_").ToObject(), πg.NewUnicode("sub").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßsymbolfunctions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 774: textfunctions = {
					πF.SetLineno(774)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\mbox").ToObject(), πg.NewUnicode("span class=\"mbox\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\text").ToObject(), πg.NewUnicode("span class=\"text\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textbf").ToObject(), πg.NewUnicode("b").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textipa").ToObject(), πg.NewUnicode("span class=\"textipa\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textit").ToObject(), πg.NewUnicode("i").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textnormal").ToObject(), πg.NewUnicode("span class=\"textnormal\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textrm").ToObject(), πg.NewUnicode("span class=\"textrm\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textsc").ToObject(), πg.NewUnicode("span class=\"versalitas\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textsf").ToObject(), πg.NewUnicode("span class=\"textsf\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textsl").ToObject(), πg.NewUnicode("i").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\texttt").ToObject(), πg.NewUnicode("tt").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\textup").ToObject(), πg.NewUnicode("span class=\"normal\"").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßtextfunctions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 784: unmodified = {
					πF.SetLineno(784)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 13)
					πTemp003[0] = πg.NewUnicode(".").ToObject()
					πTemp003[1] = πg.NewUnicode("*").ToObject()
					πTemp003[2] = πg.NewUnicode("\xe2\x82\xac").ToObject()
					πTemp003[3] = πg.NewUnicode("(").ToObject()
					πTemp003[4] = πg.NewUnicode(")").ToObject()
					πTemp003[5] = πg.NewUnicode("[").ToObject()
					πTemp003[6] = πg.NewUnicode("]").ToObject()
					πTemp003[7] = πg.NewUnicode("\xc2\xb7").ToObject()
					πTemp003[8] = πg.NewUnicode("!").ToObject()
					πTemp003[9] = πg.NewUnicode(";").ToObject()
					πTemp003[10] = πg.NewUnicode("|").ToObject()
					πTemp003[11] = πg.NewUnicode("\xc2\xa7").ToObject()
					πTemp003[12] = πg.NewUnicode("\"").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("characters").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßunmodified.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 788: urls = {
					πF.SetLineno(788)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("googlecharts").ToObject(), πg.NewUnicode("http://chart.googleapis.com/chart?cht=tx&chl=").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßurls.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 792: class GeneralConfig(object):
			πF.SetLineno(792)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("GeneralConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 793: "Configuration class from elyxer.config file"
					πF.SetLineno(793)
					// line 793: "Configuration class from elyxer.config file"
					πF.SetLineno(793)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 795: version = {
					πF.SetLineno(795)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("date").ToObject(), πg.NewUnicode("2015-02-26").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("lyxformat").ToObject(), πg.NewUnicode("413").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("number").ToObject(), πg.NewUnicode("1.2.5").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßversion.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("GeneralConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßGeneralConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 799: class HeaderConfig(object):
			πF.SetLineno(799)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("HeaderConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 800: "Configuration class from elyxer.config file"
					πF.SetLineno(800)
					// line 800: "Configuration class from elyxer.config file"
					πF.SetLineno(800)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 802: parameters = {
					πF.SetLineno(802)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("beginpreamble").ToObject(), πg.NewUnicode("\\begin_preamble").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("branch").ToObject(), πg.NewUnicode("\\branch").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("documentclass").ToObject(), πg.NewUnicode("\\textclass").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("endbranch").ToObject(), πg.NewUnicode("\\end_branch").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("endpreamble").ToObject(), πg.NewUnicode("\\end_preamble").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("language").ToObject(), πg.NewUnicode("\\language").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("lstset").ToObject(), πg.NewUnicode("\\lstset").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("outputchanges").ToObject(), πg.NewUnicode("\\output_changes").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("paragraphseparation").ToObject(), πg.NewUnicode("\\paragraph_separation").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("pdftitle").ToObject(), πg.NewUnicode("\\pdf_title").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("secnumdepth").ToObject(), πg.NewUnicode("\\secnumdepth").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("tocdepth").ToObject(), πg.NewUnicode("\\tocdepth").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßparameters.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 812: styles = {
					πF.SetLineno(812)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 48)
					πTemp003[0] = πg.NewUnicode("article").ToObject()
					πTemp003[1] = πg.NewUnicode("aastex").ToObject()
					πTemp003[2] = πg.NewUnicode("aapaper").ToObject()
					πTemp003[3] = πg.NewUnicode("acmsiggraph").ToObject()
					πTemp003[4] = πg.NewUnicode("sigplanconf").ToObject()
					πTemp003[5] = πg.NewUnicode("achemso").ToObject()
					πTemp003[6] = πg.NewUnicode("amsart").ToObject()
					πTemp003[7] = πg.NewUnicode("apa").ToObject()
					πTemp003[8] = πg.NewUnicode("arab-article").ToObject()
					πTemp003[9] = πg.NewUnicode("armenian-article").ToObject()
					πTemp003[10] = πg.NewUnicode("article-beamer").ToObject()
					πTemp003[11] = πg.NewUnicode("chess").ToObject()
					πTemp003[12] = πg.NewUnicode("dtk").ToObject()
					πTemp003[13] = πg.NewUnicode("elsarticle").ToObject()
					πTemp003[14] = πg.NewUnicode("heb-article").ToObject()
					πTemp003[15] = πg.NewUnicode("IEEEtran").ToObject()
					πTemp003[16] = πg.NewUnicode("iopart").ToObject()
					πTemp003[17] = πg.NewUnicode("kluwer").ToObject()
					πTemp003[18] = πg.NewUnicode("scrarticle-beamer").ToObject()
					πTemp003[19] = πg.NewUnicode("scrartcl").ToObject()
					πTemp003[20] = πg.NewUnicode("extarticle").ToObject()
					πTemp003[21] = πg.NewUnicode("paper").ToObject()
					πTemp003[22] = πg.NewUnicode("mwart").ToObject()
					πTemp003[23] = πg.NewUnicode("revtex4").ToObject()
					πTemp003[24] = πg.NewUnicode("spie").ToObject()
					πTemp003[25] = πg.NewUnicode("svglobal3").ToObject()
					πTemp003[26] = πg.NewUnicode("ltugboat").ToObject()
					πTemp003[27] = πg.NewUnicode("agu-dtd").ToObject()
					πTemp003[28] = πg.NewUnicode("jgrga").ToObject()
					πTemp003[29] = πg.NewUnicode("agums").ToObject()
					πTemp003[30] = πg.NewUnicode("entcs").ToObject()
					πTemp003[31] = πg.NewUnicode("egs").ToObject()
					πTemp003[32] = πg.NewUnicode("ijmpc").ToObject()
					πTemp003[33] = πg.NewUnicode("ijmpd").ToObject()
					πTemp003[34] = πg.NewUnicode("singlecol-new").ToObject()
					πTemp003[35] = πg.NewUnicode("doublecol-new").ToObject()
					πTemp003[36] = πg.NewUnicode("isprs").ToObject()
					πTemp003[37] = πg.NewUnicode("tarticle").ToObject()
					πTemp003[38] = πg.NewUnicode("jsarticle").ToObject()
					πTemp003[39] = πg.NewUnicode("jarticle").ToObject()
					πTemp003[40] = πg.NewUnicode("jss").ToObject()
					πTemp003[41] = πg.NewUnicode("literate-article").ToObject()
					πTemp003[42] = πg.NewUnicode("siamltex").ToObject()
					πTemp003[43] = πg.NewUnicode("cl2emult").ToObject()
					πTemp003[44] = πg.NewUnicode("llncs").ToObject()
					πTemp003[45] = πg.NewUnicode("svglobal").ToObject()
					πTemp003[46] = πg.NewUnicode("svjog").ToObject()
					πTemp003[47] = πg.NewUnicode("svprobth").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("article").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 18)
					πTemp003[0] = πg.NewUnicode("book").ToObject()
					πTemp003[1] = πg.NewUnicode("amsbook").ToObject()
					πTemp003[2] = πg.NewUnicode("scrbook").ToObject()
					πTemp003[3] = πg.NewUnicode("extbook").ToObject()
					πTemp003[4] = πg.NewUnicode("tufte-book").ToObject()
					πTemp003[5] = πg.NewUnicode("report").ToObject()
					πTemp003[6] = πg.NewUnicode("extreport").ToObject()
					πTemp003[7] = πg.NewUnicode("scrreprt").ToObject()
					πTemp003[8] = πg.NewUnicode("memoir").ToObject()
					πTemp003[9] = πg.NewUnicode("tbook").ToObject()
					πTemp003[10] = πg.NewUnicode("jsbook").ToObject()
					πTemp003[11] = πg.NewUnicode("jbook").ToObject()
					πTemp003[12] = πg.NewUnicode("mwbk").ToObject()
					πTemp003[13] = πg.NewUnicode("svmono").ToObject()
					πTemp003[14] = πg.NewUnicode("svmult").ToObject()
					πTemp003[15] = πg.NewUnicode("treport").ToObject()
					πTemp003[16] = πg.NewUnicode("jreport").ToObject()
					πTemp003[17] = πg.NewUnicode("mwrep").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("book").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßstyles.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("HeaderConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßHeaderConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 817: class ImageConfig(object):
			πF.SetLineno(817)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ImageConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 818: "Configuration class from elyxer.config file"
					πF.SetLineno(818)
					// line 818: "Configuration class from elyxer.config file"
					πF.SetLineno(818)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 820: converters = {
					πF.SetLineno(820)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("imagemagick").ToObject(), πg.NewUnicode("convert[ -density $scale][ -define $format:use-cropbox=true] \"$input\" \"$output\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("inkscape").ToObject(), πg.NewUnicode("inkscape \"$input\" --export-png=\"$output\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("lyx").ToObject(), πg.NewUnicode("lyx -C \"$input\" \"$output\"").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßconverters.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 826: cropboxformats = {
					πF.SetLineno(826)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(".eps").ToObject(), πg.NewUnicode("ps").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(".pdf").ToObject(), πg.NewUnicode("pdf").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode(".ps").ToObject(), πg.NewUnicode("ps").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßcropboxformats.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 830: formats = {
					πF.SetLineno(830)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("default").ToObject(), πg.NewUnicode(".png").ToObject()); πE != nil {
						continue
					}
					πTemp003 = make([]*πg.Object, 2)
					πTemp003[0] = πg.NewUnicode(".svg").ToObject()
					πTemp003[1] = πg.NewUnicode(".eps").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("vector").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßformats.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ImageConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßImageConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 834: class LayoutConfig(object):
			πF.SetLineno(834)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LayoutConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 835: "Configuration class from elyxer.config file"
					πF.SetLineno(835)
					// line 835: "Configuration class from elyxer.config file"
					πF.SetLineno(835)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 837: groupable = {
					πF.SetLineno(837)
					πTemp001 = πg.NewDict()
					πTemp002 = make([]*πg.Object, 12)
					πTemp002[0] = πg.NewUnicode("StringContainer").ToObject()
					πTemp002[1] = πg.NewUnicode("Constant").ToObject()
					πTemp002[2] = πg.NewUnicode("TaggedText").ToObject()
					πTemp002[3] = πg.NewUnicode("Align").ToObject()
					πTemp002[4] = πg.NewUnicode("TextFamily").ToObject()
					πTemp002[5] = πg.NewUnicode("EmphaticText").ToObject()
					πTemp002[6] = πg.NewUnicode("VersalitasText").ToObject()
					πTemp002[7] = πg.NewUnicode("BarredText").ToObject()
					πTemp002[8] = πg.NewUnicode("SizeText").ToObject()
					πTemp002[9] = πg.NewUnicode("ColorText").ToObject()
					πTemp002[10] = πg.NewUnicode("LangLine").ToObject()
					πTemp002[11] = πg.NewUnicode("Formula").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("allowed").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp003 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßgroupable.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LayoutConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLayoutConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 841: class NewfangleConfig(object):
			πF.SetLineno(841)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("NewfangleConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 842: "Configuration class from elyxer.config file"
					πF.SetLineno(842)
					// line 842: "Configuration class from elyxer.config file"
					πF.SetLineno(842)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 844: constants = {
					πF.SetLineno(844)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("chunkref").ToObject(), πg.NewUnicode("chunkref{").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("endcommand").ToObject(), πg.NewUnicode("}").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("endmark").ToObject(), πg.NewUnicode("&gt;").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("startcommand").ToObject(), πg.NewUnicode("\\").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("startmark").ToObject(), πg.NewUnicode("=&lt;").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßconstants.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("NewfangleConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßNewfangleConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 849: class NumberingConfig(object):
			πF.SetLineno(849)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("NumberingConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 850: "Configuration class from elyxer.config file"
					πF.SetLineno(850)
					// line 850: "Configuration class from elyxer.config file"
					πF.SetLineno(850)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 852: layouts = {
					πF.SetLineno(852)
					πTemp001 = πg.NewDict()
					πTemp002 = make([]*πg.Object, 5)
					πTemp002[0] = πg.NewUnicode("Chapter").ToObject()
					πTemp002[1] = πg.NewUnicode("Section").ToObject()
					πTemp002[2] = πg.NewUnicode("Subsection").ToObject()
					πTemp002[3] = πg.NewUnicode("Subsubsection").ToObject()
					πTemp002[4] = πg.NewUnicode("Paragraph").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ordered").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp002 = make([]*πg.Object, 2)
					πTemp002[0] = πg.NewUnicode("Part").ToObject()
					πTemp002[1] = πg.NewUnicode("Book").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("roman").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp003 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßlayouts.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 857: sequence = {
					πF.SetLineno(857)
					πTemp001 = πg.NewDict()
					πTemp002 = make([]*πg.Object, 10)
					πTemp002[0] = πg.NewUnicode("*").ToObject()
					πTemp002[1] = πg.NewUnicode("**").ToObject()
					πTemp002[2] = πg.NewUnicode("\xe2\x80\xa0").ToObject()
					πTemp002[3] = πg.NewUnicode("\xe2\x80\xa1").ToObject()
					πTemp002[4] = πg.NewUnicode("\xc2\xa7").ToObject()
					πTemp002[5] = πg.NewUnicode("\xc2\xa7\xc2\xa7").ToObject()
					πTemp002[6] = πg.NewUnicode("\xc2\xb6").ToObject()
					πTemp002[7] = πg.NewUnicode("\xc2\xb6\xc2\xb6").ToObject()
					πTemp002[8] = πg.NewUnicode("#").ToObject()
					πTemp002[9] = πg.NewUnicode("##").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("symbols").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp003 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßsequence.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("NumberingConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßNumberingConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 861: class StyleConfig(object):
			πF.SetLineno(861)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("StyleConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 862: "Configuration class from elyxer.config file"
					πF.SetLineno(862)
					// line 862: "Configuration class from elyxer.config file"
					πF.SetLineno(862)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 864: hspaces = {
					πF.SetLineno(864)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\enskip{}").ToObject(), πg.NewUnicode("\xe2\x80\x82").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hfill{}").ToObject(), πg.NewUnicode("<span class=\"hfill\"> </span>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hspace*{\\fill}").ToObject(), πg.NewUnicode("\xe2\x80\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hspace*{}").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\hspace{}").ToObject(), πg.NewUnicode("\xe2\x80\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\negthinspace{}").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\qquad{}").ToObject(), πg.NewUnicode("\xe2\x80\x83\xe2\x80\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\quad{}").ToObject(), πg.NewUnicode("\xe2\x80\x83").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\space{}").ToObject(), πg.NewUnicode("\xc2\xa0").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("\\thinspace{}").ToObject(), πg.NewUnicode("\xe2\x80\x89").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("~").ToObject(), πg.NewUnicode("\xc2\xa0").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßhspaces.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 871: quotes = {
					πF.SetLineno(871)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ald").ToObject(), πg.NewUnicode("\xc2\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("als").ToObject(), πg.NewUnicode("\xe2\x80\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ard").ToObject(), πg.NewUnicode("\xc2\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ars").ToObject(), πg.NewUnicode("\xe2\x80\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("eld").ToObject(), πg.NewUnicode("&ldquo;").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("els").ToObject(), πg.NewUnicode("&lsquo;").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("erd").ToObject(), πg.NewUnicode("&rdquo;").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ers").ToObject(), πg.NewUnicode("&rsquo;").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("fld").ToObject(), πg.NewUnicode("\xc2\xab").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("fls").ToObject(), πg.NewUnicode("\xe2\x80\xb9").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("frd").ToObject(), πg.NewUnicode("\xc2\xbb").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("frs").ToObject(), πg.NewUnicode("\xe2\x80\xba").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("gld").ToObject(), πg.NewUnicode("\xe2\x80\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("gls").ToObject(), πg.NewUnicode("\xe2\x80\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("grd").ToObject(), πg.NewUnicode("\xe2\x80\x9c").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("grs").ToObject(), πg.NewUnicode("\xe2\x80\x98").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("pld").ToObject(), πg.NewUnicode("\xe2\x80\x9e").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("pls").ToObject(), πg.NewUnicode("\xe2\x80\x9a").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("prd").ToObject(), πg.NewUnicode("\xe2\x80\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("prs").ToObject(), πg.NewUnicode("\xe2\x80\x99").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("sld").ToObject(), πg.NewUnicode("\xe2\x80\x9d").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("srd").ToObject(), πg.NewUnicode("\xe2\x80\x9d").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßquotes.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 879: referenceformats = {
					πF.SetLineno(879)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("eqref").ToObject(), πg.NewUnicode("(@\xe2\x86\x95)").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("formatted").ToObject(), πg.NewUnicode("\xc2\xb6\xe2\x86\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("nameref").ToObject(), πg.NewUnicode("$\xe2\x86\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("pageref").ToObject(), πg.NewUnicode("#\xe2\x86\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ref").ToObject(), πg.NewUnicode("@\xe2\x86\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("vpageref").ToObject(), πg.NewUnicode("on-page#\xe2\x86\x95").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("vref").ToObject(), πg.NewUnicode("@on-page#\xe2\x86\x95").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßreferenceformats.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 884: size = {
					πF.SetLineno(884)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 6)
					πTemp003[0] = πg.NewUnicode("col").ToObject()
					πTemp003[1] = πg.NewUnicode("text").ToObject()
					πTemp003[2] = πg.NewUnicode("line").ToObject()
					πTemp003[3] = πg.NewUnicode("page").ToObject()
					πTemp003[4] = πg.NewUnicode("theight").ToObject()
					πTemp003[5] = πg.NewUnicode("pheight").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ignoredtexts").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßsize.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 888: vspaces = {
					πF.SetLineno(888)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("bigskip").ToObject(), πg.NewUnicode("<div class=\"bigskip\"> </div>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("defskip").ToObject(), πg.NewUnicode("<div class=\"defskip\"> </div>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("medskip").ToObject(), πg.NewUnicode("<div class=\"medskip\"> </div>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("smallskip").ToObject(), πg.NewUnicode("<div class=\"smallskip\"> </div>").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("vfill").ToObject(), πg.NewUnicode("<div class=\"vfill\"> </div>").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßvspaces.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("StyleConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStyleConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 896: class TOCConfig(object):
			πF.SetLineno(896)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TOCConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 897: "Configuration class from elyxer.config file"
					πF.SetLineno(897)
					// line 897: "Configuration class from elyxer.config file"
					πF.SetLineno(897)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 899: extractplain = {
					πF.SetLineno(899)
					πTemp001 = πg.NewDict()
					πTemp002 = make([]*πg.Object, 12)
					πTemp002[0] = πg.NewUnicode("StringContainer").ToObject()
					πTemp002[1] = πg.NewUnicode("Constant").ToObject()
					πTemp002[2] = πg.NewUnicode("TaggedText").ToObject()
					πTemp002[3] = πg.NewUnicode("Align").ToObject()
					πTemp002[4] = πg.NewUnicode("TextFamily").ToObject()
					πTemp002[5] = πg.NewUnicode("EmphaticText").ToObject()
					πTemp002[6] = πg.NewUnicode("VersalitasText").ToObject()
					πTemp002[7] = πg.NewUnicode("BarredText").ToObject()
					πTemp002[8] = πg.NewUnicode("SizeText").ToObject()
					πTemp002[9] = πg.NewUnicode("ColorText").ToObject()
					πTemp002[10] = πg.NewUnicode("LangLine").ToObject()
					πTemp002[11] = πg.NewUnicode("Formula").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("allowed").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp002 = make([]*πg.Object, 1)
					πTemp002[0] = πg.NewUnicode("").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cloned").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp002 = make([]*πg.Object, 1)
					πTemp002[0] = πg.NewUnicode("").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("extracted").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp003 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßextractplain.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 904: extracttitle = {
					πF.SetLineno(904)
					πTemp001 = πg.NewDict()
					πTemp002 = make([]*πg.Object, 3)
					πTemp002[0] = πg.NewUnicode("StringContainer").ToObject()
					πTemp002[1] = πg.NewUnicode("Constant").ToObject()
					πTemp002[2] = πg.NewUnicode("Space").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("allowed").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp002 = make([]*πg.Object, 8)
					πTemp002[0] = πg.NewUnicode("TextFamily").ToObject()
					πTemp002[1] = πg.NewUnicode("EmphaticText").ToObject()
					πTemp002[2] = πg.NewUnicode("VersalitasText").ToObject()
					πTemp002[3] = πg.NewUnicode("BarredText").ToObject()
					πTemp002[4] = πg.NewUnicode("SizeText").ToObject()
					πTemp002[5] = πg.NewUnicode("ColorText").ToObject()
					πTemp002[6] = πg.NewUnicode("LangLine").ToObject()
					πTemp002[7] = πg.NewUnicode("Formula").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("cloned").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp002 = make([]*πg.Object, 6)
					πTemp002[0] = πg.NewUnicode("PlainLayout").ToObject()
					πTemp002[1] = πg.NewUnicode("TaggedText").ToObject()
					πTemp002[2] = πg.NewUnicode("Align").ToObject()
					πTemp002[3] = πg.NewUnicode("Caption").ToObject()
					πTemp002[4] = πg.NewUnicode("StandardLayout").ToObject()
					πTemp002[5] = πg.NewUnicode("FlexInset").ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("extracted").ToObject(), πTemp003); πE != nil {
						continue
					}
					πTemp003 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßextracttitle.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TOCConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTOCConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 910: class TagConfig(object):
			πF.SetLineno(910)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TagConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 911: "Configuration class from elyxer.config file"
					πF.SetLineno(911)
					// line 911: "Configuration class from elyxer.config file"
					πF.SetLineno(911)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 913: barred = {
					πF.SetLineno(913)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("under").ToObject(), πg.NewUnicode("u").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßbarred.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 917: family = {
					πF.SetLineno(917)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("sans").ToObject(), πg.NewUnicode("span class=\"sans\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("typewriter").ToObject(), πg.NewUnicode("tt").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßfamily.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 921: flex = {
					πF.SetLineno(921)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("CharStyle:Code").ToObject(), πg.NewUnicode("span class=\"code\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("CharStyle:MenuItem").ToObject(), πg.NewUnicode("span class=\"menuitem\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Code").ToObject(), πg.NewUnicode("span class=\"code\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("MenuItem").ToObject(), πg.NewUnicode("span class=\"menuitem\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Noun").ToObject(), πg.NewUnicode("span class=\"noun\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Strong").ToObject(), πg.NewUnicode("span class=\"strong\"").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßflex.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 928: group = {
					πF.SetLineno(928)
					πTemp001 = πg.NewDict()
					πTemp003 = make([]*πg.Object, 2)
					πTemp003[0] = πg.NewUnicode("Quotation").ToObject()
					πTemp003[1] = πg.NewUnicode("Quote").ToObject()
					πTemp002 = πg.NewList(πTemp003...).ToObject()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("layouts").ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßgroup.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 932: layouts = {
					πF.SetLineno(932)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Center").ToObject(), πg.NewUnicode("div").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Chapter").ToObject(), πg.NewUnicode("h?").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Date").ToObject(), πg.NewUnicode("h2").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Paragraph").ToObject(), πg.NewUnicode("div").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Part").ToObject(), πg.NewUnicode("h1").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Quotation").ToObject(), πg.NewUnicode("blockquote").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Quote").ToObject(), πg.NewUnicode("blockquote").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Section").ToObject(), πg.NewUnicode("h?").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Subsection").ToObject(), πg.NewUnicode("h?").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Subsubsection").ToObject(), πg.NewUnicode("h?").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßlayouts.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 938: listitems = {
					πF.SetLineno(938)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Enumerate").ToObject(), πg.NewUnicode("ol").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Itemize").ToObject(), πg.NewUnicode("ul").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßlistitems.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 942: notes = {
					πF.SetLineno(942)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Comment").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Greyedout").ToObject(), πg.NewUnicode("span class=\"greyedout\"").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Note").ToObject(), πg.NewUnicode("").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßnotes.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 946: script = {
					πF.SetLineno(946)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("subscript").ToObject(), πg.NewUnicode("sub").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("superscript").ToObject(), πg.NewUnicode("sup").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßscript.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 950: shaped = {
					πF.SetLineno(950)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("italic").ToObject(), πg.NewUnicode("i").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("slanted").ToObject(), πg.NewUnicode("i").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("smallcaps").ToObject(), πg.NewUnicode("span class=\"versalitas\"").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßshaped.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TagConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTagConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 954: class TranslationConfig(object):
			πF.SetLineno(954)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TranslationConfig", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 955: "Configuration class from elyxer.config file"
					πF.SetLineno(955)
					// line 955: "Configuration class from elyxer.config file"
					πF.SetLineno(955)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Configuration class from elyxer.config file").ToObject()); πE != nil {
						continue
					}
					// line 957: constants = {
					πF.SetLineno(957)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Appendix").ToObject(), πg.NewUnicode("Appendix").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Book").ToObject(), πg.NewUnicode("Book").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Chapter").ToObject(), πg.NewUnicode("Chapter").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Paragraph").ToObject(), πg.NewUnicode("Paragraph").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Part").ToObject(), πg.NewUnicode("Part").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Section").ToObject(), πg.NewUnicode("Section").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Subsection").ToObject(), πg.NewUnicode("Subsection").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("Subsubsection").ToObject(), πg.NewUnicode("Subsubsection").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("abstract").ToObject(), πg.NewUnicode("Abstract").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("bibliography").ToObject(), πg.NewUnicode("Bibliography").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("figure").ToObject(), πg.NewUnicode("figure").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("float-algorithm").ToObject(), πg.NewUnicode("Algorithm ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("float-figure").ToObject(), πg.NewUnicode("Figure ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("float-listing").ToObject(), πg.NewUnicode("Listing ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("float-table").ToObject(), πg.NewUnicode("Table ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("float-tableau").ToObject(), πg.NewUnicode("Tableau ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("footnotes").ToObject(), πg.NewUnicode("Footnotes").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("generated-by").ToObject(), πg.NewUnicode("Document generated by ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("generated-on").ToObject(), πg.NewUnicode(" on ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("index").ToObject(), πg.NewUnicode("Index").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("jsmath-enable").ToObject(), πg.NewUnicode("Please enable JavaScript on your browser.").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("jsmath-requires").ToObject(), πg.NewUnicode(" requires JavaScript to correctly process the mathematics on this page. ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("jsmath-warning").ToObject(), πg.NewUnicode("Warning: ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("list-algorithm").ToObject(), πg.NewUnicode("List of Algorithms").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("list-figure").ToObject(), πg.NewUnicode("List of Figures").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("list-table").ToObject(), πg.NewUnicode("List of Tables").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("list-tableau").ToObject(), πg.NewUnicode("List of Tableaux").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("main-page").ToObject(), πg.NewUnicode("Main page").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("next").ToObject(), πg.NewUnicode("Next").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("nomenclature").ToObject(), πg.NewUnicode("Nomenclature").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("on-page").ToObject(), πg.NewUnicode(" on page ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("prev").ToObject(), πg.NewUnicode("Prev").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("references").ToObject(), πg.NewUnicode("References").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("toc").ToObject(), πg.NewUnicode("Table of Contents").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("toc-for").ToObject(), πg.NewUnicode("Contents for ").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("up").ToObject(), πg.NewUnicode("Up").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßconstants.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 977: languages = {
					πF.SetLineno(977)
					πTemp001 = πg.NewDict()
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("american").ToObject(), πg.NewUnicode("en").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("british").ToObject(), πg.NewUnicode("en").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("deutsch").ToObject(), πg.NewUnicode("de").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("dutch").ToObject(), πg.NewUnicode("nl").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("english").ToObject(), πg.NewUnicode("en").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("french").ToObject(), πg.NewUnicode("fr").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("ngerman").ToObject(), πg.NewUnicode("de").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("russian").ToObject(), πg.NewUnicode("ru").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πg.NewUnicode("spanish").ToObject(), πg.NewUnicode("es").ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßlanguages.ToObject(), πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TranslationConfig").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTranslationConfig.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 984: class CommandLineParser(object):
			πF.SetLineno(984)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("CommandLineParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 985: "A parser for runtime options"
					πF.SetLineno(985)
					// line 985: "A parser for runtime options"
					πF.SetLineno(985)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parser for runtime options").ToObject()); πE != nil {
						continue
					}
					// line 987: def __init__(self, options):
					πF.SetLineno(987)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "options", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µoptions *πg.Object = πArgs[1]
						_ = µoptions
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 988: self.options = options
							πF.SetLineno(988)
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µoptions); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoptions, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 990: def parseoptions(self, args):
					πF.SetLineno(990)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "args", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parseoptions", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µargs *πg.Object = πArgs[1]
						_ = µargs
						var µkey *πg.Object = πg.UnboundLocal
						_ = µkey
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 991: "Parse command line options"
							πF.SetLineno(991)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp002[0] = µargs
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 992: if len(args) == 0:
							πF.SetLineno(992)
						Label1:
							// line 993: return None
							πF.SetLineno(993)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 994: while len(args) > 0 and args[0].startswith('--'):
							πF.SetLineno(994)
							πF.PushCheckpoint(4)
							πTemp005 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label5
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp002[0] = µargs
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GT(πF, πTemp008, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp007 {
								goto Label6
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("--").ToObject()
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µargs, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001 = πTemp004
						Label6:
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 995: key, value = self.readoption(args)
							πF.SetLineno(995)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp002[0] = µargs
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreadoption, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µkey = πTemp001
							µvalue = πTemp004
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µkey); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label7
							}
							goto Label8
							// line 996: if not key:
							πF.SetLineno(996)
						Label7:
							// line 997: return 'Option ' + value + ' not recognized'
							πF.SetLineno(997)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Option ").ToObject(), µvalue); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr(" not recognized").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label8
						Label8:
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µvalue); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label9
							}
							goto Label10
							// line 998: if not value:
							πF.SetLineno(998)
						Label9:
							// line 999: return 'Option ' + key + ' needs a value'
							πF.SetLineno(999)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Option ").ToObject(), µkey); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr(" needs a value").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label10
						Label10:
							// line 1000: setattr(self.options, key, value)
							πF.SetLineno(1000)
							πTemp002 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoptions, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp002[1] = µkey
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp002[2] = µvalue
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							// line 1001: return None
							πF.SetLineno(1001)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseoptions.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 991: "Parse command line options"
					πF.SetLineno(991)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse command line options").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparseoptions); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1003: def readoption(self, args):
					πF.SetLineno(1003)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "args", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("readoption", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µargs *πg.Object = πArgs[1]
						_ = µargs
						var µarg *πg.Object = πg.UnboundLocal
						_ = µarg
						var µkey *πg.Object = πg.UnboundLocal
						_ = µkey
						var µcurrent *πg.Object = πg.UnboundLocal
						_ = µcurrent
						var µinitial *πg.Object = πg.UnboundLocal
						_ = µinitial
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1004: "Read the key and value for an option"
							πF.SetLineno(1004)
							// line 1005: arg = args[0][2:]
							πF.SetLineno(1005)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(2).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µargs, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µarg = πTemp002
							// line 1006: del args[0]
							πF.SetLineno(1006)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.DelItem(πF, µargs, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg, "arg"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µarg, πg.NewStr("=").ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1007: if '=' in arg:
							πF.SetLineno(1007)
						Label1:
							// line 1008: key = self.readequalskey(arg, args)
							πF.SetLineno(1008)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µarg, "arg"); πE != nil {
								continue
							}
							πTemp006[0] = µarg
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp006[1] = µargs
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreadequalskey, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µkey = πTemp002
							goto Label3
						Label2:
							// line 1010: key = arg.replace('-', '')
							πF.SetLineno(1010)
							πTemp006 = πF.MakeArgs(2)
							πTemp006[0] = πg.NewStr("-").ToObject()
							πTemp006[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µarg, "arg"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µarg, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µkey = πTemp002
							goto Label3
						Label3:
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoptions, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp002
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp006[1] = µkey
							if πTemp002, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 1011: if not hasattr(self.options, key):
							πF.SetLineno(1011)
						Label4:
							// line 1012: return None, key
							πF.SetLineno(1012)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, µkey).ToObject()
							πR = πTemp001
							continue
							goto Label5
						Label5:
							// line 1013: current = getattr(self.options, key)
							πF.SetLineno(1013)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoptions, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp006[1] = µkey
							if πTemp001, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µcurrent = πTemp002
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							πTemp006[0] = µcurrent
							if πTemp001, πE = πg.ResolveGlobal(πF, ßbool); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							goto Label7
							// line 1014: if isinstance(current, bool):
							πF.SetLineno(1014)
						Label6:
							// line 1015: return key, True
							πF.SetLineno(1015)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µkey, πTemp002).ToObject()
							πR = πTemp001
							continue
							goto Label7
						Label7:
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp006[0] = µargs
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Eq(πF, πTemp003, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label8
							}
							goto Label9
							// line 1017: if len(args) == 0:
							πF.SetLineno(1017)
						Label8:
							// line 1018: return key, None
							πF.SetLineno(1018)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µkey, πTemp002).ToObject()
							πR = πTemp001
							continue
							goto Label9
						Label9:
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("\"").ToObject()
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µargs, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label10
							}
							goto Label11
							// line 1019: if args[0].startswith('"'):
							πF.SetLineno(1019)
						Label10:
							// line 1020: initial = args[0]
							πF.SetLineno(1020)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µargs, πTemp001); πE != nil {
								continue
							}
							µinitial = πTemp002
							// line 1021: del args[0]
							πF.SetLineno(1021)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.DelItem(πF, µargs, πTemp001); πE != nil {
								continue
							}
							// line 1022: return key, self.readquoted(args, initial)
							πF.SetLineno(1022)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp006[0] = µargs
							if πE = πg.CheckLocal(πF, µinitial, "initial"); πE != nil {
								continue
							}
							πTemp006[1] = µinitial
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreadquoted, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp001 = πg.NewTuple2(µkey, πTemp003).ToObject()
							πR = πTemp001
							continue
							goto Label11
						Label11:
							// line 1023: value = args[0].decode('utf-8')
							πF.SetLineno(1023)
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("utf-8").ToObject()
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µargs, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßdecode, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µvalue = πTemp002
							// line 1024: del args[0]
							πF.SetLineno(1024)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.DelItem(πF, µargs, πTemp001); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							πTemp006[0] = µcurrent
							if πTemp001, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label12
							}
							goto Label13
							// line 1025: if isinstance(current, list):
							πF.SetLineno(1025)
						Label12:
							// line 1026: current.append(value)
							πF.SetLineno(1026)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp006[0] = µvalue
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcurrent, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 1027: return key, current
							πF.SetLineno(1027)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µkey, µcurrent).ToObject()
							πR = πTemp001
							continue
							goto Label13
						Label13:
							// line 1028: return key, value
							πF.SetLineno(1028)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µkey, µvalue).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreadoption.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1004: "Read the key and value for an option"
					πF.SetLineno(1004)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Read the key and value for an option").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßreadoption); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1030: def readquoted(self, args, initial):
					πF.SetLineno(1030)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "args", Def: nil}
					πTemp002[2] = πg.Param{Name: "initial", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("readquoted", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µargs *πg.Object = πArgs[1]
						_ = µargs
						var µinitial *πg.Object = πArgs[2]
						_ = µinitial
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1031: "Read a value between quotes"
							πF.SetLineno(1031)
							// line 1032: Trace.error('Oops')
							πF.SetLineno(1032)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßOops.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1033: value = initial[1:]
							πF.SetLineno(1033)
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinitial, "initial"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µinitial, πTemp002); πE != nil {
								continue
							}
							µvalue = πTemp003
							// line 1034: while len(args) > 0 and not args[0].endswith('"') and not args[0].startswith('--'):
							πF.SetLineno(1034)
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp001[0] = µargs
							if πTemp007, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.GT(πF, πTemp008, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp003
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp006 {
								goto Label4
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\"").ToObject()
							πTemp007 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µargs, πTemp007); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp008, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp009, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp009).ToObject()
							πTemp002 = πTemp003
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp006 {
								goto Label4
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("--").ToObject()
							πTemp007 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µargs, πTemp007); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp008, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp009, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp009).ToObject()
							πTemp002 = πTemp003
						Label4:
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1035: Trace.error('Appending ' + args[0])
							πF.SetLineno(1035)
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µargs, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Appending ").ToObject(), πTemp007); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1036: value += ' ' + args[0]
							πF.SetLineno(1036)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µargs, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr(" ").ToObject(), πTemp007); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µvalue, πTemp002); πE != nil {
								continue
							}
							µvalue = πTemp003
							// line 1037: del args[0]
							πF.SetLineno(1037)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.DelItem(πF, µargs, πTemp002); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp001[0] = µargs
							if πTemp007, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.Eq(πF, πTemp008, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp003
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("--").ToObject()
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µargs, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp007, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp002 = πTemp007
						Label5:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 1038: if len(args) == 0 or args[0].startswith('--'):
							πF.SetLineno(1038)
						Label6:
							// line 1039: return None
							πF.SetLineno(1039)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label7
						Label7:
							// line 1040: value += ' ' + args[0:-1]
							πF.SetLineno(1040)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(0).ToObject(), πTemp007, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µargs, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr(" ").ToObject(), πTemp007); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µvalue, πTemp002); πE != nil {
								continue
							}
							µvalue = πTemp003
							// line 1041: return value
							πF.SetLineno(1041)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πR = µvalue
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreadquoted.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1031: "Read a value between quotes"
					πF.SetLineno(1031)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Read a value between quotes").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßreadquoted); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 1043: def readequalskey(self, arg, args):
					πF.SetLineno(1043)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "arg", Def: nil}
					πTemp002[2] = πg.Param{Name: "args", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("readequalskey", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µarg *πg.Object = πArgs[1]
						_ = µarg
						var µargs *πg.Object = πArgs[2]
						_ = µargs
						var µsplit *πg.Object = πg.UnboundLocal
						_ = µsplit
						var µkey *πg.Object = πg.UnboundLocal
						_ = µkey
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1044: "Read a key using equals"
							πF.SetLineno(1044)
							// line 1045: split = arg.split('=', 1)
							πF.SetLineno(1045)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("=").ToObject()
							πTemp001[1] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µarg, "arg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µarg, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µsplit = πTemp003
							// line 1046: key = split[0]
							πF.SetLineno(1046)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µsplit, πTemp002); πE != nil {
								continue
							}
							µkey = πTemp003
							// line 1047: value = split[1]
							πF.SetLineno(1047)
							πTemp002 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µsplit, πTemp002); πE != nil {
								continue
							}
							µvalue = πTemp003
							// line 1048: args.insert(0, value)
							πF.SetLineno(1048)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp001[1] = µvalue
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µargs, ßinsert, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1049: return key
							πF.SetLineno(1049)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πR = µkey
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreadequalskey.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 1044: "Read a key using equals"
					πF.SetLineno(1044)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Read a key using equals").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßreadequalskey); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("CommandLineParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßCommandLineParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1052: class Options(object):
			πF.SetLineno(1052)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Options", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 []πg.Param
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1053: "A set of runtime options"
					πF.SetLineno(1053)
					// line 1053: "A set of runtime options"
					πF.SetLineno(1053)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A set of runtime options").ToObject()); πE != nil {
						continue
					}
					// line 1055: instance = None
					πF.SetLineno(1055)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßinstance.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1057: location = None
					πF.SetLineno(1057)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßlocation.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1058: nocopy = False
					πF.SetLineno(1058)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßnocopy.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1059: copyright = False
					πF.SetLineno(1059)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcopyright.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1060: debug = False
					πF.SetLineno(1060)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßdebug.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1061: quiet = False
					πF.SetLineno(1061)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßquiet.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1062: version = False
					πF.SetLineno(1062)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßversion.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1063: hardversion = False
					πF.SetLineno(1063)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßhardversion.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1064: versiondate = False
					πF.SetLineno(1064)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßversiondate.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1065: html = False
					πF.SetLineno(1065)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßhtml.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1066: help = False
					πF.SetLineno(1066)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßhelp.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1067: showlines = True
					πF.SetLineno(1067)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßTrue); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßshowlines.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1068: unicode = False
					πF.SetLineno(1068)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßunicode.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1069: iso885915 = False
					πF.SetLineno(1069)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßiso885915.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1070: css = []
					πF.SetLineno(1070)
					πTemp002 = make([]*πg.Object, 0)
					πTemp001 = πg.NewList(πTemp002...).ToObject()
					if πE = πClass.SetItem(πF, ßcss.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1071: favicon = ''
					πF.SetLineno(1071)
					if πE = πClass.SetItem(πF, ßfavicon.ToObject(), ß.ToObject()); πE != nil {
						continue
					}
					// line 1072: title = None
					πF.SetLineno(1072)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtitle.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1073: directory = None
					πF.SetLineno(1073)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßdirectory.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1074: destdirectory = None
					πF.SetLineno(1074)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßdestdirectory.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1075: toc = False
					πF.SetLineno(1075)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtoc.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1076: toctarget = ''
					πF.SetLineno(1076)
					if πE = πClass.SetItem(πF, ßtoctarget.ToObject(), ß.ToObject()); πE != nil {
						continue
					}
					// line 1077: tocfor = None
					πF.SetLineno(1077)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtocfor.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1078: forceformat = None
					πF.SetLineno(1078)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßforceformat.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1079: lyxformat = False
					πF.SetLineno(1079)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßlyxformat.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1080: target = None
					πF.SetLineno(1080)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtarget.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1081: splitpart = None
					πF.SetLineno(1081)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßsplitpart.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1082: memory = True
					πF.SetLineno(1082)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßTrue); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßmemory.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1083: lowmem = False
					πF.SetLineno(1083)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßlowmem.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1084: nobib = False
					πF.SetLineno(1084)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßnobib.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1085: converter = 'imagemagick'
					πF.SetLineno(1085)
					if πE = πClass.SetItem(πF, ßconverter.ToObject(), ßimagemagick.ToObject()); πE != nil {
						continue
					}
					// line 1086: raw = False
					πF.SetLineno(1086)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßraw.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1087: jsmath = None
					πF.SetLineno(1087)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßjsmath.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1088: mathjax = None
					πF.SetLineno(1088)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßmathjax.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1089: nofooter = False
					πF.SetLineno(1089)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßnofooter.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1090: simplemath = False
					πF.SetLineno(1090)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßsimplemath.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1091: template = None
					πF.SetLineno(1091)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtemplate.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1092: noconvert = False
					πF.SetLineno(1092)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßnoconvert.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1093: notoclabels = False
					πF.SetLineno(1093)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßnotoclabels.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1094: letterfoot = True
					πF.SetLineno(1094)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßTrue); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßletterfoot.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1095: numberfoot = False
					πF.SetLineno(1095)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßnumberfoot.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1096: symbolfoot = False
					πF.SetLineno(1096)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßsymbolfoot.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1097: hoverfoot = True
					πF.SetLineno(1097)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßTrue); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßhoverfoot.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1098: marginfoot = False
					πF.SetLineno(1098)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßmarginfoot.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1099: endfoot = False
					πF.SetLineno(1099)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßendfoot.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1100: supfoot = True
					πF.SetLineno(1100)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßTrue); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßsupfoot.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1101: alignfoot = False
					πF.SetLineno(1101)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßalignfoot.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1102: footnotes = None
					πF.SetLineno(1102)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßfootnotes.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1103: imageformat = None
					πF.SetLineno(1103)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßimageformat.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1104: copyimages = False
					πF.SetLineno(1104)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcopyimages.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1105: googlecharts = False
					πF.SetLineno(1105)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßgooglecharts.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1106: embedcss = []
					πF.SetLineno(1106)
					πTemp002 = make([]*πg.Object, 0)
					πTemp001 = πg.NewList(πTemp002...).ToObject()
					if πE = πClass.SetItem(πF, ßembedcss.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1108: branches = dict()
					πF.SetLineno(1108)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßdict); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßbranches.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1110: def parseoptions(self, args):
					πF.SetLineno(1110)
					πTemp004 = make([]πg.Param, 2)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp004[1] = πg.Param{Name: "args", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parseoptions", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µargs *πg.Object = πArgs[1]
						_ = µargs
						var µparser *πg.Object = πg.UnboundLocal
						_ = µparser
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1111: "Parse command line options"
							πF.SetLineno(1111)
							// line 1112: Options.location = args[0]
							πF.SetLineno(1112)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µargs, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßlocation, πTemp001); πE != nil {
								continue
							}
							// line 1113: del args[0]
							πF.SetLineno(1113)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.DelItem(πF, µargs, πTemp001); πE != nil {
								continue
							}
							// line 1114: parser = CommandLineParser(Options)
							πF.SetLineno(1114)
							πTemp004 = πF.MakeArgs(1)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßCommandLineParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µparser = πTemp002
							// line 1115: result = parser.parseoptions(args)
							πF.SetLineno(1115)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							πTemp004[0] = µargs
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µparser, ßparseoptions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µresult = πTemp002
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µresult); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1116: if result:
							πF.SetLineno(1116)
						Label1:
							// line 1117: Trace.error(result)
							πF.SetLineno(1117)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πTemp004[0] = µresult
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1118: self.usage()
							πF.SetLineno(1118)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßusage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 1119: self.processoptions()
							πF.SetLineno(1119)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßprocessoptions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseoptions.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1111: "Parse command line options"
					πF.SetLineno(1111)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse command line options").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparseoptions); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 1121: def processoptions(self):
					πF.SetLineno(1121)
					πTemp004 = make([]πg.Param, 1)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("processoptions", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µparam *πg.Object = πg.UnboundLocal
						_ = µparam
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.BaseException
						_ = πTemp006
						var πTemp007 *πg.Traceback
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 40:
								goto Label40
							case 14:
								goto Label14
							case 39:
								goto Label39
							default:
								panic("unexpected function state")
							}
							// line 1122: "Process all options parsed."
							πF.SetLineno(1122)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßhelp, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1123: if Options.help:
							πF.SetLineno(1123)
						Label1:
							// line 1124: self.usage()
							πF.SetLineno(1124)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßusage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label2
						Label2:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßversion, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 1125: if Options.version:
							πF.SetLineno(1125)
						Label3:
							// line 1126: self.showversion()
							πF.SetLineno(1126)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßshowversion, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label4
						Label4:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßhardversion, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							goto Label6
							// line 1127: if Options.hardversion:
							πF.SetLineno(1127)
						Label5:
							// line 1128: self.showhardversion()
							πF.SetLineno(1128)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßshowhardversion, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label6
						Label6:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßversiondate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label7
							}
							goto Label8
							// line 1129: if Options.versiondate:
							πF.SetLineno(1129)
						Label7:
							// line 1130: self.showversiondate()
							πF.SetLineno(1130)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßshowversiondate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label8
						Label8:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßlyxformat, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label9
							}
							goto Label10
							// line 1131: if Options.lyxformat:
							πF.SetLineno(1131)
						Label9:
							// line 1132: self.showlyxformat()
							πF.SetLineno(1132)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßshowlyxformat, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label10
						Label10:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsplitpart, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label11
							}
							goto Label12
							// line 1133: if Options.splitpart:
							πF.SetLineno(1133)
						Label11:
							// line 1134: try:
							πF.SetLineno(1134)
							πF.PushCheckpoint(14)
							// line 1135: Options.splitpart = int(Options.splitpart)
							πF.SetLineno(1135)
							πTemp004 = πF.MakeArgs(1)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsplitpart, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßsplitpart, πTemp001); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßsplitpart, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.LE(πF, πTemp005, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label15
							}
							goto Label16
							// line 1136: if Options.splitpart <= 0:
							πF.SetLineno(1136)
						Label15:
							// line 1137: Trace.error('--splitpart requires a number bigger than zero')
							πF.SetLineno(1137)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("--splitpart requires a number bigger than zero").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1138: self.usage()
							πF.SetLineno(1138)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßusage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label16
						Label16:
							πF.PopCheckpoint()
							goto Label13
						Label14:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp006, πTemp007 = πF.ExcInfo()
							goto Label17
							// line 1139: except:
							πF.SetLineno(1139)
						Label17:
							// line 1140: Trace.error('--splitpart needs a numeric argument, not ' + Options.splitpart)
							πF.SetLineno(1140)
							πTemp004 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßsplitpart, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("--splitpart needs a numeric argument, not ").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1141: self.usage()
							πF.SetLineno(1141)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßusage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πF.RestoreExc(nil, nil)
							goto Label13
						Label13:
							goto Label12
						Label12:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßlowmem, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp005
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label18
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßtoc, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp005
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label18
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßtocfor, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp005
						Label18:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label19
							}
							goto Label20
							// line 1142: if Options.lowmem or Options.toc or Options.tocfor:
							πF.SetLineno(1142)
						Label19:
							// line 1143: Options.memory = False
							πF.SetLineno(1143)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßmemory, πTemp002); πE != nil {
								continue
							}
							goto Label20
						Label20:
							// line 1144: self.parsefootnotes()
							πF.SetLineno(1144)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsefootnotes, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßforceformat, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp005
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label21
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp005, ßimageformat, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp009).ToObject()
							πTemp001 = πTemp002
						Label21:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label22
							}
							goto Label23
							// line 1145: if Options.forceformat and not Options.imageformat:
							πF.SetLineno(1145)
						Label22:
							// line 1146: Options.imageformat = Options.forceformat
							πF.SetLineno(1146)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßforceformat, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßimageformat, πTemp001); πE != nil {
								continue
							}
							goto Label23
						Label23:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßimageformat, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp005, ßcopy.ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label24
							}
							goto Label25
							// line 1147: if Options.imageformat == 'copy':
							πF.SetLineno(1147)
						Label24:
							// line 1148: Options.copyimages = True
							πF.SetLineno(1148)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßcopyimages, πTemp002); πE != nil {
								continue
							}
							goto Label25
						Label25:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßcss, nil); πE != nil {
								continue
							}
							πTemp004 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							if πTemp001, πE = πg.Eq(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label26
							}
							goto Label27
							// line 1149: if Options.css == []:
							πF.SetLineno(1149)
						Label26:
							// line 1150: Options.css = ['http://elyxer.nongnu.org/lyx.css']
							πF.SetLineno(1150)
							πTemp004 = make([]*πg.Object, 1)
							πTemp004[0] = πg.NewStr("http://elyxer.nongnu.org/lyx.css").ToObject()
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßcss, πTemp002); πE != nil {
								continue
							}
							goto Label27
						Label27:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßfavicon, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp005, ß.ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label28
							}
							goto Label29
							// line 1151: if Options.favicon == '':
							πF.SetLineno(1151)
						Label28:
							// line 1152: pass # no default favicon
							πF.SetLineno(1152)
							goto Label29
						Label29:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßhtml, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label30
							}
							goto Label31
							// line 1153: if Options.html:
							πF.SetLineno(1153)
						Label30:
							// line 1154: Options.simplemath = True
							πF.SetLineno(1154)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßsimplemath, πTemp002); πE != nil {
								continue
							}
							goto Label31
						Label31:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßtoc, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp005
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label32
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp005, ßtocfor, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp009).ToObject()
							πTemp001 = πTemp002
						Label32:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label33
							}
							goto Label34
							// line 1155: if Options.toc and not Options.tocfor:
							πF.SetLineno(1155)
						Label33:
							// line 1156: Trace.error('Option --toc is deprecated; use --tocfor "page" instead')
							πF.SetLineno(1156)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("Option --toc is deprecated; use --tocfor \"page\" instead").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1157: Options.tocfor = Options.toctarget
							πF.SetLineno(1157)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtoctarget, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßtocfor, πTemp001); πE != nil {
								continue
							}
							goto Label34
						Label34:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnocopy, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label35
							}
							goto Label36
							// line 1158: if Options.nocopy:
							πF.SetLineno(1158)
						Label35:
							// line 1159: Trace.error('Option --nocopy is deprecated; it is no longer needed')
							πF.SetLineno(1159)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("Option --nocopy is deprecated; it is no longer needed").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label36
						Label36:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßjsmath, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label37
							}
							goto Label38
							// line 1160: if Options.jsmath:
							πF.SetLineno(1160)
						Label37:
							// line 1161: Trace.error('Option --jsmath is deprecated; use --mathjax instead')
							πF.SetLineno(1161)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("Option --jsmath is deprecated; use --mathjax instead").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label38
						Label38:
							πTemp004 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßdir); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(40)
							πTemp003 = false
						Label39:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label41
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp009 = !isStop
							} else {
								πTemp009 = true
								µparam = πTemp002
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(39)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = ßmode.ToObject()
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparam, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp009, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label42
							}
							goto Label43
							// line 1164: if param.endswith('mode'):
							πF.SetLineno(1164)
						Label42:
							// line 1165: setattr(Trace, param, getattr(self, param[:-4]))
							πF.SetLineno(1165)
							πTemp004 = πF.MakeArgs(3)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							πTemp004[1] = µparam
							πTemp010 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp010[0] = µself
							if πTemp005, πE = πg.Neg(πF, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp005, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µparam, πTemp002); πE != nil {
								continue
							}
							πTemp010[1] = πTemp005
							if πTemp002, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp004[2] = πTemp005
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label43
						Label43:
							continue
						Label40:
							if πE != nil || πR != nil {
								continue
							}
						Label41:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocessoptions.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1122: "Process all options parsed."
					πF.SetLineno(1122)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Process all options parsed.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßprocessoptions); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1167: def usage(self):
					πF.SetLineno(1167)
					πTemp004 = make([]πg.Param, 1)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("usage", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1168: "Show correct usage"
							πF.SetLineno(1168)
							// line 1169: Trace.error('Usage: ' + os.path.basename(Options.location) + ' [options] [filein] [fileout]')
							πF.SetLineno(1169)
							πTemp001 = πF.MakeArgs(1)
							πTemp004 = πF.MakeArgs(1)
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßlocation, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp006
							if πTemp005, πE = πg.ResolveGlobal(πF, ßos); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßpath, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp006, ßbasename, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Usage: ").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr(" [options] [filein] [fileout]").ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1170: Trace.error('Convert LyX input file "filein" to HTML file "fileout".')
							πF.SetLineno(1170)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Convert LyX input file \"filein\" to HTML file \"fileout\".").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1171: Trace.error('If filein (or fileout) is not given use standard input (or output).')
							πF.SetLineno(1171)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("If filein (or fileout) is not given use standard input (or output).").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1172: Trace.error('Main program of the eLyXer package (http://elyxer.nongnu.org/).')
							πF.SetLineno(1172)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Main program of the eLyXer package (http://elyxer.nongnu.org/).").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1173: self.showoptions()
							πF.SetLineno(1173)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßshowoptions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßusage.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1168: "Show correct usage"
					πF.SetLineno(1168)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Show correct usage").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßusage); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 1175: def parsefootnotes(self):
					πF.SetLineno(1175)
					πTemp004 = make([]πg.Param, 1)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("parsefootnotes", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µoptions *πg.Object = πg.UnboundLocal
						_ = µoptions
						var µoption *πg.Object = πg.UnboundLocal
						_ = µoption
						var µfootoption *πg.Object = πg.UnboundLocal
						_ = µfootoption
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 1176: "Parse footnotes options."
							πF.SetLineno(1176)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßfootnotes, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1177: if not Options.footnotes:
							πF.SetLineno(1177)
						Label1:
							// line 1178: return
							πF.SetLineno(1178)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 1179: Options.marginfoot = False
							πF.SetLineno(1179)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßmarginfoot, πTemp002); πE != nil {
								continue
							}
							// line 1180: Options.letterfoot = False
							πF.SetLineno(1180)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßletterfoot, πTemp002); πE != nil {
								continue
							}
							// line 1181: Options.hoverfoot = False
							πF.SetLineno(1181)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßhoverfoot, πTemp002); πE != nil {
								continue
							}
							// line 1182: options = Options.footnotes.split(',')
							πF.SetLineno(1182)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = πg.NewStr(",").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßfootnotes, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µoptions = πTemp002
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µoptions); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp004 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µoption = πTemp002
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 1184: footoption = option + 'foot'
							πF.SetLineno(1184)
							if πE = πg.CheckLocal(πF, µoption, "option"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µoption, ßfoot.ToObject()); πE != nil {
								continue
							}
							µfootoption = πTemp002
							πTemp005 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πE = πg.CheckLocal(πF, µfootoption, "footoption"); πE != nil {
								continue
							}
							πTemp005[1] = µfootoption
							if πTemp002, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label6
							}
							goto Label7
							// line 1185: if hasattr(Options, footoption):
							πF.SetLineno(1185)
						Label6:
							// line 1186: setattr(Options, footoption, True)
							πF.SetLineno(1186)
							πTemp005 = πF.MakeArgs(3)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πE = πg.CheckLocal(πF, µfootoption, "footoption"); πE != nil {
								continue
							}
							πTemp005[1] = µfootoption
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp005[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label8
						Label7:
							// line 1188: Trace.error('Unknown footnotes option: ' + option)
							πF.SetLineno(1188)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption, "option"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Unknown footnotes option: ").ToObject(), µoption); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label8
						Label8:
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßendfoot, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp002
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label9
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßmarginfoot, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp002
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label9
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßhoverfoot, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp002
						Label9:
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label10
							}
							goto Label11
							// line 1189: if not Options.endfoot and not Options.marginfoot and not Options.hoverfoot:
							πF.SetLineno(1189)
						Label10:
							// line 1190: Options.hoverfoot = True
							πF.SetLineno(1190)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßhoverfoot, πTemp002); πE != nil {
								continue
							}
							goto Label11
						Label11:
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßnumberfoot, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp002
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label12
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßsymbolfoot, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp002
						Label12:
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label13
							}
							goto Label14
							// line 1191: if not Options.numberfoot and not Options.symbolfoot:
							πF.SetLineno(1191)
						Label13:
							// line 1192: Options.letterfoot = True
							πF.SetLineno(1192)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßletterfoot, πTemp002); πE != nil {
								continue
							}
							goto Label14
						Label14:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsefootnotes.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 1176: "Parse footnotes options."
					πF.SetLineno(1176)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Parse footnotes options.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßparsefootnotes); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 1194: def showoptions(self):
					πF.SetLineno(1194)
					πTemp004 = make([]πg.Param, 1)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("showoptions", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1195: "Show all possible options"
							πF.SetLineno(1195)
							// line 1196: Trace.error('  Common options:')
							πF.SetLineno(1196)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("  Common options:").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1197: Trace.error('    --help:                 show this online help')
							πF.SetLineno(1197)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --help:                 show this online help").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1198: Trace.error('    --quiet:                disables all runtime messages')
							πF.SetLineno(1198)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --quiet:                disables all runtime messages").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1199: Trace.error('')
							πF.SetLineno(1199)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ß.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1200: Trace.error('  Advanced options:')
							πF.SetLineno(1200)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("  Advanced options:").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1201: Trace.error('    --debug:                enable debugging messages (for developers)')
							πF.SetLineno(1201)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --debug:                enable debugging messages (for developers)").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1202: Trace.error('    --version:              show version number and release date')
							πF.SetLineno(1202)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --version:              show version number and release date").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1203: Trace.error('    --lyxformat:            return the highest LyX version supported')
							πF.SetLineno(1203)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --lyxformat:            return the highest LyX version supported").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1204: Trace.error('  Options for HTML output:')
							πF.SetLineno(1204)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("  Options for HTML output:").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1205: Trace.error('    --title "title":        set the generated page title')
							πF.SetLineno(1205)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --title \"title\":        set the generated page title").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1206: Trace.error('    --css "file.css":       use a custom CSS file')
							πF.SetLineno(1206)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --css \"file.css\":       use a custom CSS file").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1207: Trace.error('    --embedcss "file.css":  embed styles from a CSS file into the output')
							πF.SetLineno(1207)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --embedcss \"file.css\":  embed styles from a CSS file into the output").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1208: Trace.error('    --favicon "icon.ico":   insert the specified favicon in the header.')
							πF.SetLineno(1208)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --favicon \"icon.ico\":   insert the specified favicon in the header.").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1209: Trace.error('    --html:                 output HTML 4.0 instead of the default XHTML')
							πF.SetLineno(1209)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --html:                 output HTML 4.0 instead of the default XHTML").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1210: Trace.error('    --unicode:              full Unicode output')
							πF.SetLineno(1210)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --unicode:              full Unicode output").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1211: Trace.error('    --iso885915:            output a document with ISO-8859-15 encoding')
							πF.SetLineno(1211)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --iso885915:            output a document with ISO-8859-15 encoding").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1212: Trace.error('    --nofooter:             remove the footer "generated by eLyXer"')
							πF.SetLineno(1212)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --nofooter:             remove the footer \"generated by eLyXer\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1213: Trace.error('    --simplemath:           do not generate fancy math constructions')
							πF.SetLineno(1213)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --simplemath:           do not generate fancy math constructions").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1214: Trace.error('  Options for image output:')
							πF.SetLineno(1214)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("  Options for image output:").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1215: Trace.error('    --directory "img_dir":  look for images in the specified directory')
							πF.SetLineno(1215)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --directory \"img_dir\":  look for images in the specified directory").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1216: Trace.error('    --destdirectory "dest": put converted images into this directory')
							πF.SetLineno(1216)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --destdirectory \"dest\": put converted images into this directory").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1217: Trace.error('    --imageformat ".ext":   image output format, or "copy" to copy images')
							πF.SetLineno(1217)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --imageformat \".ext\":   image output format, or \"copy\" to copy images").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1218: Trace.error('    --noconvert:            do not convert images, use in original locations')
							πF.SetLineno(1218)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --noconvert:            do not convert images, use in original locations").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1219: Trace.error('    --converter "inkscape": use an alternative program to convert images')
							πF.SetLineno(1219)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --converter \"inkscape\": use an alternative program to convert images").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1220: Trace.error('  Options for footnote display:')
							πF.SetLineno(1220)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("  Options for footnote display:").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1221: Trace.error('    --numberfoot:           mark footnotes with numbers instead of letters')
							πF.SetLineno(1221)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --numberfoot:           mark footnotes with numbers instead of letters").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1222: Trace.error('    --symbolfoot:           mark footnotes with symbols (*, **...)')
							πF.SetLineno(1222)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --symbolfoot:           mark footnotes with symbols (*, **...)").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1223: Trace.error('    --hoverfoot:            show footnotes as hovering text (default)')
							πF.SetLineno(1223)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --hoverfoot:            show footnotes as hovering text (default)").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1224: Trace.error('    --marginfoot:           show footnotes on the page margin')
							πF.SetLineno(1224)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --marginfoot:           show footnotes on the page margin").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1225: Trace.error('    --endfoot:              show footnotes at the end of the page')
							πF.SetLineno(1225)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --endfoot:              show footnotes at the end of the page").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1226: Trace.error('    --supfoot:              use superscript for footnote markers (default)')
							πF.SetLineno(1226)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --supfoot:              use superscript for footnote markers (default)").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1227: Trace.error('    --alignfoot:            use aligned text for footnote markers')
							πF.SetLineno(1227)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --alignfoot:            use aligned text for footnote markers").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1228: Trace.error('    --footnotes "options":  specify several comma-separated footnotes options')
							πF.SetLineno(1228)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --footnotes \"options\":  specify several comma-separated footnotes options").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1229: Trace.error('      Available options are: "number", "symbol", "hover", "margin", "end",')
							πF.SetLineno(1229)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("      Available options are: \"number\", \"symbol\", \"hover\", \"margin\", \"end\",").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1230: Trace.error('        "sup", "align"')
							πF.SetLineno(1230)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("        \"sup\", \"align\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1231: Trace.error('  Advanced output options:')
							πF.SetLineno(1231)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("  Advanced output options:").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1232: Trace.error('    --splitpart "depth":    split the resulting webpage at the given depth')
							πF.SetLineno(1232)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --splitpart \"depth\":    split the resulting webpage at the given depth").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1233: Trace.error('    --tocfor "page":        generate a TOC that points to the given page')
							πF.SetLineno(1233)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --tocfor \"page\":        generate a TOC that points to the given page").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1234: Trace.error('    --target "frame":       make all links point to the given frame')
							πF.SetLineno(1234)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --target \"frame\":       make all links point to the given frame").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1235: Trace.error('    --notoclabels:          omit the part labels in the TOC, such as Chapter')
							πF.SetLineno(1235)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --notoclabels:          omit the part labels in the TOC, such as Chapter").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1236: Trace.error('    --lowmem:               do the conversion on the fly (conserve memory)')
							πF.SetLineno(1236)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --lowmem:               do the conversion on the fly (conserve memory)").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1237: Trace.error('    --raw:                  generate HTML without header or footer.')
							πF.SetLineno(1237)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --raw:                  generate HTML without header or footer.").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1238: Trace.error('    --mathjax remote:       use MathJax remotely to display equations')
							πF.SetLineno(1238)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --mathjax remote:       use MathJax remotely to display equations").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1239: Trace.error('    --mathjax "URL":        use MathJax from the given URL to display equations')
							πF.SetLineno(1239)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --mathjax \"URL\":        use MathJax from the given URL to display equations").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1240: Trace.error('    --googlecharts:         use Google Charts to generate formula images')
							πF.SetLineno(1240)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --googlecharts:         use Google Charts to generate formula images").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1241: Trace.error('    --template "file":      use a template, put everything in <!--$content-->')
							πF.SetLineno(1241)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --template \"file\":      use a template, put everything in <!--$content-->").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1242: Trace.error('    --copyright:            add a copyright notice at the bottom')
							πF.SetLineno(1242)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --copyright:            add a copyright notice at the bottom").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1243: Trace.error('  Deprecated options:')
							πF.SetLineno(1243)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("  Deprecated options:").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1244: Trace.error('    --toc:                  (deprecated) create a table of contents')
							πF.SetLineno(1244)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --toc:                  (deprecated) create a table of contents").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1245: Trace.error('    --toctarget "page":     (deprecated) generate a TOC for the given page')
							πF.SetLineno(1245)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --toctarget \"page\":     (deprecated) generate a TOC for the given page").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1246: Trace.error('    --nocopy:               (deprecated) maintained for backwards compatibility')
							πF.SetLineno(1246)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --nocopy:               (deprecated) maintained for backwards compatibility").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1247: Trace.error('    --jsmath "URL":         use jsMath from the given URL to display equations')
							πF.SetLineno(1247)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("    --jsmath \"URL\":         use jsMath from the given URL to display equations").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1248: sys.exit()
							πF.SetLineno(1248)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßexit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßshowoptions.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 1195: "Show all possible options"
					πF.SetLineno(1195)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Show all possible options").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßshowoptions); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 1250: def showversion(self):
					πF.SetLineno(1250)
					πTemp004 = make([]πg.Param, 1)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("showversion", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πg.UnboundLocal
						_ = µstring
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1251: "Return the current eLyXer version string"
							πF.SetLineno(1251)
							// line 1252: string = 'eLyXer version ' + GeneralConfig.version['number']
							πF.SetLineno(1252)
							πTemp002 = ßnumber.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßGeneralConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßversion, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("eLyXer version ").ToObject(), πTemp003); πE != nil {
								continue
							}
							µstring = πTemp001
							// line 1253: string += ' (' + GeneralConfig.version['date'] + ')'
							πF.SetLineno(1253)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp003 = ßdate.ToObject()
							if πTemp005, πE = πg.ResolveGlobal(πF, ßGeneralConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßversion, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp006, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr(" (").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(")").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µstring, πTemp001); πE != nil {
								continue
							}
							µstring = πTemp002
							// line 1254: Trace.error(string)
							πF.SetLineno(1254)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp007[0] = µstring
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 1255: sys.exit()
							πF.SetLineno(1255)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßexit, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßshowversion.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 1251: "Return the current eLyXer version string"
					πF.SetLineno(1251)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Return the current eLyXer version string").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßshowversion); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 1257: def showhardversion(self):
					πF.SetLineno(1257)
					πTemp004 = make([]πg.Param, 1)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("showhardversion", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1258: "Return just the version string"
							πF.SetLineno(1258)
							// line 1259: Trace.message(GeneralConfig.version['number'])
							πF.SetLineno(1259)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = ßnumber.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßGeneralConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßversion, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßmessage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1260: sys.exit()
							πF.SetLineno(1260)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßexit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßshowhardversion.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 1258: "Return just the version string"
					πF.SetLineno(1258)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Return just the version string").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßshowhardversion); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 1262: def showversiondate(self):
					πF.SetLineno(1262)
					πTemp004 = make([]πg.Param, 1)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("showversiondate", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1263: "Return just the version dte"
							πF.SetLineno(1263)
							// line 1264: Trace.message(GeneralConfig.version['date'])
							πF.SetLineno(1264)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = ßdate.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßGeneralConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßversion, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßmessage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1265: sys.exit()
							πF.SetLineno(1265)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßexit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßshowversiondate.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 1263: "Return just the version dte"
					πF.SetLineno(1263)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Return just the version dte").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßshowversiondate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
					// line 1267: def showlyxformat(self):
					πF.SetLineno(1267)
					πTemp004 = make([]πg.Param, 1)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("showlyxformat", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1268: "Return just the lyxformat parameter"
							πF.SetLineno(1268)
							// line 1269: Trace.message(GeneralConfig.version['lyxformat'])
							πF.SetLineno(1269)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = ßlyxformat.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßGeneralConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßversion, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßmessage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1270: sys.exit()
							πF.SetLineno(1270)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßexit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßshowlyxformat.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 1268: "Return just the lyxformat parameter"
					πF.SetLineno(1268)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Return just the lyxformat parameter").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßshowlyxformat); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Options").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßOptions.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1272: class BranchOptions(object):
			πF.SetLineno(1272)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BranchOptions", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 bool
				_ = πTemp009
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1273: "A set of options for a branch"
					πF.SetLineno(1273)
					// line 1273: "A set of options for a branch"
					πF.SetLineno(1273)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A set of options for a branch").ToObject()); πE != nil {
						continue
					}
					// line 1275: def __init__(self, name):
					πF.SetLineno(1275)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "name", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µname *πg.Object = πArgs[1]
						_ = µname
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Dict
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1276: self.name = name
							πF.SetLineno(1276)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µname); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßname, πTemp001); πE != nil {
								continue
							}
							// line 1277: self.options = {'color':'#ffffff'}
							πF.SetLineno(1277)
							πTemp002 = πg.NewDict()
							if πE = πTemp002.SetItem(πF, ßcolor.ToObject(), πg.NewStr("#ffffff").ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp002.ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoptions, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1279: def set(self, key, value):
					πF.SetLineno(1279)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "key", Def: nil}
					πTemp002[2] = πg.Param{Name: "value", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("set", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µkey *πg.Object = πArgs[1]
						_ = µkey
						var µvalue *πg.Object = πArgs[2]
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1280: "Set a branch option"
							πF.SetLineno(1280)
							πTemp002 = πF.MakeArgs(1)
							πTemp003 = ßstartcommand.ToObject()
							if πTemp005, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßstring, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp006, πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µkey, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 1281: if not key.startswith(ContainerConfig.string['startcommand']):
							πF.SetLineno(1281)
						Label1:
							// line 1282: Trace.error('Invalid branch option ' + key)
							πF.SetLineno(1282)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Invalid branch option ").ToObject(), µkey); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 1283: return
							πF.SetLineno(1283)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 1284: key = key.replace(ContainerConfig.string['startcommand'], '')
							πF.SetLineno(1284)
							πTemp002 = πF.MakeArgs(2)
							πTemp001 = ßstartcommand.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßstring, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							πTemp002[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µkey, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µkey = πTemp003
							// line 1285: self.options[key] = value
							πF.SetLineno(1285)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µvalue); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoptions, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp004 = µkey
							if πE = πg.SetItem(πF, πTemp003, πTemp004, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßset.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1280: "Set a branch option"
					πF.SetLineno(1280)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Set a branch option").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßset); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1287: def isselected(self):
					πF.SetLineno(1287)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("isselected", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1288: "Return if the branch is selected"
							πF.SetLineno(1288)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoptions, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp003, ßselected.ToObject()); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1289: if not 'selected' in self.options:
							πF.SetLineno(1289)
						Label1:
							// line 1290: return False
							πF.SetLineno(1290)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 1291: return self.options['selected'] == '1'
							πF.SetLineno(1291)
							πTemp002 = ßselected.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßoptions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, ß1.ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisselected.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1288: "Return if the branch is selected"
					πF.SetLineno(1288)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Return if the branch is selected").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßisselected); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1293: def __unicode__(self):
					πF.SetLineno(1293)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1294: "String representation"
							πF.SetLineno(1294)
							// line 1295: return 'options for ' + self.name + ': ' + unicode(self.options)
							πF.SetLineno(1295)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßname, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("options for ").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoptions, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp004); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1294: "String representation"
					πF.SetLineno(1294)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("String representation").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp007 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp006, πE = πg.GE(πF, πTemp008, πTemp007); πE != nil {
						continue
					}
					if πTemp009, πE = πg.IsTrue(πF, πTemp006); πE != nil {
						continue
					}
					if πTemp009 {
						goto Label1
					}
					goto Label2
					// line 1297: if sys.version_info >= (3, 0):
					πF.SetLineno(1297)
				Label1:
					// line 1298: __str__ = __unicode__
					πF.SetLineno(1298)
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp006); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BranchOptions").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBranchOptions.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1301: class Cloner(object):
			πF.SetLineno(1301)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Cloner", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 []*πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1302: "An object used to clone other objects."
					πF.SetLineno(1302)
					// line 1302: "An object used to clone other objects."
					πF.SetLineno(1302)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("An object used to clone other objects.").ToObject()); πE != nil {
						continue
					}
					// line 1304: def clone(cls, original):
					πF.SetLineno(1304)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "cls", Def: nil}
					πTemp002[1] = πg.Param{Name: "original", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("clone", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µcls *πg.Object = πArgs[0]
						_ = µcls
						var µoriginal *πg.Object = πArgs[1]
						_ = µoriginal
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1305: "Return an exact copy of an object."
							πF.SetLineno(1305)
							// line 1306: "The original object must have an empty constructor."
							πF.SetLineno(1306)
							// line 1307: return cls.create(original.__class__)
							πF.SetLineno(1307)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoriginal, "original"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoriginal, ß__class__, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µcls, "cls"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcls, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßclone.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1305: "Return an exact copy of an object."
					πF.SetLineno(1305)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Return an exact copy of an object.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßclone); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 1309: def create(cls, type):
					πF.SetLineno(1309)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "cls", Def: nil}
					πTemp002[1] = πg.Param{Name: "type", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("create", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µcls *πg.Object = πArgs[0]
						_ = µcls
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µclone *πg.Object = πg.UnboundLocal
						_ = µclone
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1310: "Create an object of a given class."
							πF.SetLineno(1310)
							// line 1311: clone = type.__new__(type)
							πF.SetLineno(1311)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µtype, ß__new__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µclone = πTemp003
							// line 1312: clone.__init__()
							πF.SetLineno(1312)
							if πE = πg.CheckLocal(πF, µclone, "clone"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µclone, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 1313: return clone
							πF.SetLineno(1313)
							if πE = πg.CheckLocal(πF, µclone, "clone"); πE != nil {
								continue
							}
							πR = µclone
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcreate.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1310: "Create an object of a given class."
					πF.SetLineno(1310)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Create an object of a given class.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßcreate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1315: clone = classmethod(clone)
					πF.SetLineno(1315)
					πTemp006 = πF.MakeArgs(1)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßclone); πE != nil {
						continue
					}
					πTemp006[0] = πTemp004
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßclassmethod); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πE = πClass.SetItem(πF, ßclone.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1316: create = classmethod(create)
					πF.SetLineno(1316)
					πTemp006 = πF.MakeArgs(1)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßcreate); πE != nil {
						continue
					}
					πTemp006[0] = πTemp004
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßclassmethod); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πE = πClass.SetItem(πF, ßcreate.ToObject(), πTemp005); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Cloner").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßCloner.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1318: class ContainerExtractor(object):
			πF.SetLineno(1318)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ContainerExtractor", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1319: "A class to extract certain containers."
					πF.SetLineno(1319)
					// line 1319: "A class to extract certain containers."
					πF.SetLineno(1319)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A class to extract certain containers.").ToObject()); πE != nil {
						continue
					}
					// line 1321: def __init__(self, config):
					πF.SetLineno(1321)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "config", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µconfig *πg.Object = πArgs[1]
						_ = µconfig
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1322: "The config parameter is a map containing three lists: allowed, copied and extracted."
							πF.SetLineno(1322)
							// line 1323: "Each of the three is a list of class names for containers."
							πF.SetLineno(1323)
							// line 1324: "Allowed containers are included as is into the result."
							πF.SetLineno(1324)
							// line 1325: "Cloned containers are cloned and placed into the result."
							πF.SetLineno(1325)
							// line 1326: "Extracted containers are looked into."
							πF.SetLineno(1326)
							// line 1327: "All other containers are silently ignored."
							πF.SetLineno(1327)
							// line 1328: self.allowed = config['allowed']
							πF.SetLineno(1328)
							πTemp001 = ßallowed.ToObject()
							if πE = πg.CheckLocal(πF, µconfig, "config"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µconfig, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßallowed, πTemp001); πE != nil {
								continue
							}
							// line 1329: self.cloned = config['cloned']
							πF.SetLineno(1329)
							πTemp001 = ßcloned.ToObject()
							if πE = πg.CheckLocal(πF, µconfig, "config"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µconfig, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcloned, πTemp001); πE != nil {
								continue
							}
							// line 1330: self.extracted = config['extracted']
							πF.SetLineno(1330)
							πTemp001 = ßextracted.ToObject()
							if πE = πg.CheckLocal(πF, µconfig, "config"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µconfig, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßextracted, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1322: "The config parameter is a map containing three lists: allowed, copied and extracted."
					πF.SetLineno(1322)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("The config parameter is a map containing three lists: allowed, copied and extracted.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 1332: def extract(self, container):
					πF.SetLineno(1332)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("extract", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µlist *πg.Object = πg.UnboundLocal
						_ = µlist
						var µlocate *πg.Object = πg.UnboundLocal
						_ = µlocate
						var µrecursive *πg.Object = πg.UnboundLocal
						_ = µrecursive
						var µprocess *πg.Object = πg.UnboundLocal
						_ = µprocess
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1333: "Extract a group of selected containers from elyxer.a container."
							πF.SetLineno(1333)
							// line 1334: list = []
							πF.SetLineno(1334)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µlist = πTemp002
							// line 1335: locate = lambda c: c.__class__.__name__ in self.allowed + self.cloned
							πF.SetLineno(1335)
							πTemp003 = make([]πg.Param, 1)
							πTemp003[0] = πg.Param{Name: "c", Def: nil}
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µc *πg.Object = πArgs[0]
								_ = µc
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πTemp006 bool
								_ = πTemp006
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1335: locate = lambda c: c.__class__.__name__ in self.allowed + self.cloned
									πF.SetLineno(1335)
									if πE = πg.CheckLocal(πF, µc, "c"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µc, ß__class__, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__name__, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.GetAttr(πF, µself, ßallowed, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp005, πE = πg.GetAttr(πF, µself, ßcloned, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πg.Add(πF, πTemp004, πTemp005); πE != nil {
										continue
									}
									if πTemp006, πE = πg.Contains(πF, πTemp002, πTemp003); πE != nil {
										continue
									}
									πTemp001 = πg.GetBool(πTemp006).ToObject()
									πR = πTemp001
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							µlocate = πTemp002
							// line 1336: recursive = lambda c: c.__class__.__name__ in self.extracted
							πF.SetLineno(1336)
							πTemp003 = make([]πg.Param, 1)
							πTemp003[0] = πg.Param{Name: "c", Def: nil}
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µc *πg.Object = πArgs[0]
								_ = µc
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1336: recursive = lambda c: c.__class__.__name__ in self.extracted
									πF.SetLineno(1336)
									if πE = πg.CheckLocal(πF, µc, "c"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µc, ß__class__, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__name__, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ßextracted, nil); πE != nil {
										continue
									}
									if πTemp004, πE = πg.Contains(πF, πTemp002, πTemp003); πE != nil {
										continue
									}
									πTemp001 = πg.GetBool(πTemp004).ToObject()
									πR = πTemp001
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							µrecursive = πTemp002
							// line 1337: process = lambda c: self.process(c, list)
							πF.SetLineno(1337)
							πTemp003 = make([]πg.Param, 1)
							πTemp003[0] = πg.Param{Name: "c", Def: nil}
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µc *πg.Object = πArgs[0]
								_ = µc
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1337: process = lambda c: self.process(c, list)
									πF.SetLineno(1337)
									πTemp001 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µc, "c"); πE != nil {
										continue
									}
									πTemp001[0] = µc
									if πE = πg.CheckLocal(πF, µlist, "list"); πE != nil {
										continue
									}
									πTemp001[1] = µlist
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ßprocess, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									πR = πTemp003
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							µprocess = πTemp002
							// line 1338: container.recursivesearch(locate, recursive, process)
							πF.SetLineno(1338)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µlocate, "locate"); πE != nil {
								continue
							}
							πTemp001[0] = µlocate
							if πE = πg.CheckLocal(πF, µrecursive, "recursive"); πE != nil {
								continue
							}
							πTemp001[1] = µrecursive
							if πE = πg.CheckLocal(πF, µprocess, "process"); πE != nil {
								continue
							}
							πTemp001[2] = µprocess
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßrecursivesearch, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1339: return list
							πF.SetLineno(1339)
							if πE = πg.CheckLocal(πF, µlist, "list"); πE != nil {
								continue
							}
							πR = µlist
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßextract.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1333: "Extract a group of selected containers from elyxer.a container."
					πF.SetLineno(1333)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Extract a group of selected containers from elyxer.a container.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßextract); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1341: def process(self, container, list):
					πF.SetLineno(1341)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp002[2] = πg.Param{Name: "list", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µlist *πg.Object = πArgs[2]
						_ = µlist
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1342: "Add allowed containers, clone cloned containers and add the clone."
							πF.SetLineno(1342)
							// line 1343: name = container.__class__.__name__
							πF.SetLineno(1343)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontainer, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ß__name__, nil); πE != nil {
								continue
							}
							µname = πTemp002
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßallowed, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Contains(πF, πTemp002, µname); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcloned, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Contains(πF, πTemp002, µname); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label2
							}
							goto Label3
							// line 1344: if name in self.allowed:
							πF.SetLineno(1344)
						Label1:
							// line 1345: list.append(container)
							πF.SetLineno(1345)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp004[0] = µcontainer
							if πE = πg.CheckLocal(πF, µlist, "list"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlist, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label4
							// line 1346: elif name in self.cloned:
							πF.SetLineno(1346)
						Label2:
							// line 1347: list.append(self.safeclone(container))
							πF.SetLineno(1347)
							πTemp004 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp005[0] = µcontainer
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsafeclone, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µlist, "list"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlist, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label4
						Label3:
							// line 1349: Trace.error('Unknown container class ' + name)
							πF.SetLineno(1349)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unknown container class ").ToObject(), µname); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label4
						Label4:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1342: "Add allowed containers, clone cloned containers and add the clone."
					πF.SetLineno(1342)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Add allowed containers, clone cloned containers and add the clone.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1351: def safeclone(self, container):
					πF.SetLineno(1351)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("safeclone", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µclone *πg.Object = πg.UnboundLocal
						_ = µclone
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1352: "Return a new container with contents only in a safe list, recursively."
							πF.SetLineno(1352)
							// line 1353: clone = Cloner.clone(container)
							πF.SetLineno(1353)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[0] = µcontainer
							if πTemp002, πE = πg.ResolveGlobal(πF, ßCloner); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclone, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µclone = πTemp002
							// line 1354: clone.output = container.output
							πF.SetLineno(1354)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µclone, "clone"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µclone, ßoutput, πTemp003); πE != nil {
								continue
							}
							// line 1355: clone.contents = self.extract(container)
							πF.SetLineno(1355)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[0] = µcontainer
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßextract, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µclone, "clone"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µclone, ßcontents, πTemp002); πE != nil {
								continue
							}
							// line 1356: return clone
							πF.SetLineno(1356)
							if πE = πg.CheckLocal(πF, µclone, "clone"); πE != nil {
								continue
							}
							πR = µclone
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsafeclone.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1352: "Return a new container with contents only in a safe list, recursively."
					πF.SetLineno(1352)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Return a new container with contents only in a safe list, recursively.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßsafeclone); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ContainerExtractor").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßContainerExtractor.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1363: class Parser(object):
			πF.SetLineno(1363)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Parser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 bool
				_ = πTemp012
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1364: "A generic parser"
					πF.SetLineno(1364)
					// line 1364: "A generic parser"
					πF.SetLineno(1364)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A generic parser").ToObject()); πE != nil {
						continue
					}
					// line 1366: def __init__(self):
					πF.SetLineno(1366)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1367: self.begin = 0
							πF.SetLineno(1367)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßbegin, πTemp001); πE != nil {
								continue
							}
							// line 1368: self.parameters = dict()
							πF.SetLineno(1368)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparameters, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1370: def parseheader(self, reader):
					πF.SetLineno(1370)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parseheader", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µheader *πg.Object = πg.UnboundLocal
						_ = µheader
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1371: "Parse the header"
							πF.SetLineno(1371)
							// line 1372: header = reader.currentline().split()
							πF.SetLineno(1372)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µheader = πTemp002
							// line 1373: reader.nextline()
							πF.SetLineno(1373)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 1374: self.begin = reader.linenumber
							πF.SetLineno(1374)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßlinenumber, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßbegin, πTemp002); πE != nil {
								continue
							}
							// line 1375: return header
							πF.SetLineno(1375)
							if πE = πg.CheckLocal(πF, µheader, "header"); πE != nil {
								continue
							}
							πR = µheader
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseheader.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1371: "Parse the header"
					πF.SetLineno(1371)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse the header").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparseheader); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1377: def parseparameter(self, reader):
					πF.SetLineno(1377)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parseparameter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µkey *πg.Object = πg.UnboundLocal
						_ = µkey
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var µsplit *πg.Object = πg.UnboundLocal
						_ = µsplit
						var µdoublesplit *πg.Object = πg.UnboundLocal
						_ = µdoublesplit
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1378: "Parse a parameter"
							πF.SetLineno(1378)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("<").ToObject()
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1379: if reader.currentline().strip().startswith('<'):
							πF.SetLineno(1379)
						Label1:
							// line 1380: key, value = self.parsexml(reader)
							πF.SetLineno(1380)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsexml, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}}}, πTemp003); πE != nil {
								continue
							}
							µkey = πTemp002
							µvalue = πTemp005
							// line 1381: self.parameters[key] = value
							πF.SetLineno(1381)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µvalue); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparameters, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp005 = µkey
							if πE = πg.SetItem(πF, πTemp003, πTemp005, πTemp002); πE != nil {
								continue
							}
							// line 1382: return
							πF.SetLineno(1382)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 1383: split = reader.currentline().strip().split(' ', 1)
							πF.SetLineno(1383)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr(" ").ToObject()
							πTemp001[1] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µsplit = πTemp003
							// line 1384: reader.nextline()
							πF.SetLineno(1384)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							πTemp001[0] = µsplit
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Eq(πF, πTemp005, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 1385: if len(split) == 0:
							πF.SetLineno(1385)
						Label3:
							// line 1386: return
							πF.SetLineno(1386)
							πR = πg.None
							continue
							goto Label4
						Label4:
							// line 1387: key = split[0]
							πF.SetLineno(1387)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µsplit, πTemp002); πE != nil {
								continue
							}
							µkey = πTemp003
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							πTemp001[0] = µsplit
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Eq(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 1388: if len(split) == 1:
							πF.SetLineno(1388)
						Label5:
							// line 1389: self.parameters[key] = True
							πF.SetLineno(1389)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßparameters, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp006 = µkey
							if πE = πg.SetItem(πF, πTemp005, πTemp006, πTemp003); πE != nil {
								continue
							}
							// line 1390: return
							πF.SetLineno(1390)
							πR = πg.None
							continue
							goto Label6
						Label6:
							πTemp005 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µsplit, πTemp005); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp006, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label7
							}
							goto Label8
							// line 1391: if not '"' in split[1]:
							πF.SetLineno(1391)
						Label7:
							// line 1392: self.parameters[key] = split[1].strip()
							πF.SetLineno(1392)
							πTemp002 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µsplit, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßparameters, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp006 = µkey
							if πE = πg.SetItem(πF, πTemp005, πTemp006, πTemp002); πE != nil {
								continue
							}
							// line 1393: return
							πF.SetLineno(1393)
							πR = πg.None
							continue
							goto Label8
						Label8:
							// line 1394: doublesplit = split[1].split('"')
							πF.SetLineno(1394)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\"").ToObject()
							πTemp002 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µsplit, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µdoublesplit = πTemp003
							// line 1395: self.parameters[key] = doublesplit[1]
							πF.SetLineno(1395)
							πTemp002 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µdoublesplit, "doublesplit"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µdoublesplit, πTemp002); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßparameters, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp006 = µkey
							if πE = πg.SetItem(πF, πTemp005, πTemp006, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseparameter.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1378: "Parse a parameter"
					πF.SetLineno(1378)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse a parameter").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparseparameter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1397: def parsexml(self, reader):
					πF.SetLineno(1397)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("parsexml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µstrip *πg.Object = πg.UnboundLocal
						_ = µstrip
						var µsplit *πg.Object = πg.UnboundLocal
						_ = µsplit
						var µkey *πg.Object = πg.UnboundLocal
						_ = µkey
						var µattrs *πg.Object = πg.UnboundLocal
						_ = µattrs
						var µattr *πg.Object = πg.UnboundLocal
						_ = µattr
						var µparts *πg.Object = πg.UnboundLocal
						_ = µparts
						var µattrkey *πg.Object = πg.UnboundLocal
						_ = µattrkey
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 8:
								goto Label8
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 1398: "Parse a parameter in xml form: <param attr1=value...>"
							πF.SetLineno(1398)
							// line 1399: strip = reader.currentline().strip()
							πF.SetLineno(1399)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µstrip = πTemp002
							// line 1400: reader.nextline()
							πF.SetLineno(1400)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr(">").ToObject()
							if πE = πg.CheckLocal(πF, µstrip, "strip"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µstrip, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1401: if not strip.endswith('>'):
							πF.SetLineno(1401)
						Label1:
							// line 1402: Trace.error('XML parameter ' + strip + ' should be <...>')
							πF.SetLineno(1402)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstrip, "strip"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("XML parameter ").ToObject(), µstrip); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(" should be <...>").ToObject()); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label2
						Label2:
							// line 1403: split = strip[1:-1].split()
							πF.SetLineno(1403)
							if πTemp002, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πTemp002, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstrip, "strip"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstrip, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µsplit = πTemp002
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							πTemp003[0] = µsplit
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 1404: if len(split) == 0:
							πF.SetLineno(1404)
						Label3:
							// line 1405: Trace.error('Empty XML parameter <>')
							πF.SetLineno(1405)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("Empty XML parameter <>").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1406: return None, None
							πF.SetLineno(1406)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, πTemp004).ToObject()
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 1407: key = split[0]
							πF.SetLineno(1407)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µsplit, πTemp001); πE != nil {
								continue
							}
							µkey = πTemp002
							// line 1408: del split[0]
							πF.SetLineno(1408)
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.DelItem(πF, µsplit, πTemp001); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							πTemp003[0] = µsplit
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							goto Label6
							// line 1409: if len(split) == 0:
							πF.SetLineno(1409)
						Label5:
							// line 1410: return key, dict()
							πF.SetLineno(1410)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µkey, πTemp004).ToObject()
							πR = πTemp001
							continue
							goto Label6
						Label6:
							// line 1411: attrs = dict()
							πF.SetLineno(1411)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µattrs = πTemp002
							if πE = πg.CheckLocal(πF, µsplit, "split"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µsplit); πE != nil {
								continue
							}
							πF.PushCheckpoint(8)
							πTemp005 = false
						Label7:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label9
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µattr = πTemp002
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(7)
							if πE = πg.CheckLocal(πF, µattr, "attr"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, µattr, πg.NewStr("=").ToObject()); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label10
							}
							goto Label11
							// line 1413: if not '=' in attr:
							πF.SetLineno(1413)
						Label10:
							// line 1414: Trace.error('Erroneous attribute for ' + key + ': ' + attr)
							πF.SetLineno(1414)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Add(πF, πg.NewStr("Erroneous attribute for ").ToObject(), µkey); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp007, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattr, "attr"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp004, µattr); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1415: attr += '="0"'
							πF.SetLineno(1415)
							if πE = πg.CheckLocal(πF, µattr, "attr"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µattr, πg.NewStr("=\"0\"").ToObject()); πE != nil {
								continue
							}
							µattr = πTemp002
							goto Label11
						Label11:
							// line 1416: parts = attr.split('=')
							πF.SetLineno(1416)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("=").ToObject()
							if πE = πg.CheckLocal(πF, µattr, "attr"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µattr, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µparts = πTemp004
							// line 1417: attrkey = parts[0]
							πF.SetLineno(1417)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µparts, πTemp002); πE != nil {
								continue
							}
							µattrkey = πTemp004
							// line 1418: value = parts[1].split('"')[1]
							πF.SetLineno(1418)
							πTemp002 = πg.NewInt(1).ToObject()
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("\"").ToObject()
							πTemp007 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µparts, πTemp007); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp008, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.GetItem(πF, πTemp008, πTemp002); πE != nil {
								continue
							}
							µvalue = πTemp004
							// line 1419: attrs[attrkey] = value
							πF.SetLineno(1419)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µvalue); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattrs, "attrs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattrkey, "attrkey"); πE != nil {
								continue
							}
							πTemp004 = µattrkey
							if πE = πg.SetItem(πF, µattrs, πTemp004, πTemp002); πE != nil {
								continue
							}
							continue
						Label8:
							if πE != nil || πR != nil {
								continue
							}
						Label9:
							// line 1420: return key, attrs
							πF.SetLineno(1420)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattrs, "attrs"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µkey, µattrs).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsexml.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1398: "Parse a parameter in xml form: <param attr1=value...>"
					πF.SetLineno(1398)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Parse a parameter in xml form: <param attr1=value...>").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßparsexml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 1422: def parseending(self, reader, process):
					πF.SetLineno(1422)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp002[2] = πg.Param{Name: "process", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("parseending", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µprocess *πg.Object = πArgs[2]
						_ = µprocess
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 1423: "Parse until the current ending is found"
							πF.SetLineno(1423)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1424: if not self.ending:
							πF.SetLineno(1424)
						Label1:
							// line 1425: Trace.error('No ending for ' + unicode(self))
							πF.SetLineno(1425)
							πTemp004 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp005[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.Add(πF, πg.NewStr("No ending for ").ToObject(), πTemp006); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1426: return
							πF.SetLineno(1426)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 1427: while not reader.currentline().startswith(self.ending):
							πF.SetLineno(1427)
							πF.PushCheckpoint(4)
							πTemp003 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label5
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp006, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp008, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp008).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 1428: process()
							πF.SetLineno(1428)
							if πE = πg.CheckLocal(πF, µprocess, "process"); πE != nil {
								continue
							}
							if πTemp001, πE = µprocess.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseending.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 1423: "Parse until the current ending is found"
					πF.SetLineno(1423)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Parse until the current ending is found").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßparseending); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 1430: def parsecontainer(self, reader, contents):
					πF.SetLineno(1430)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp002[2] = πg.Param{Name: "contents", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("parsecontainer", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µcontents *πg.Object = πArgs[2]
						_ = µcontents
						var µcontainer *πg.Object = πg.UnboundLocal
						_ = µcontainer
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1431: container = self.factory.createcontainer(reader)
							πF.SetLineno(1431)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßcreatecontainer, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µcontainer = πTemp002
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µcontainer); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1432: if container:
							πF.SetLineno(1432)
						Label1:
							// line 1433: container.parent = self.parent
							πF.SetLineno(1433)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µcontainer, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 1434: contents.append(container)
							πF.SetLineno(1434)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[0] = µcontainer
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontents, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsecontainer.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 1436: def __unicode__(self):
					πF.SetLineno(1436)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1437: "Return a description"
							πF.SetLineno(1437)
							// line 1438: return self.__class__.__name__ + ' (' + unicode(self.begin) + ')'
							πF.SetLineno(1438)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ß__name__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp005, πg.NewStr(" (").ToObject()); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßbegin, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Add(πF, πTemp003, πTemp005); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(")").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 1437: "Return a description"
					πF.SetLineno(1437)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Return a description").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp011, πE = πg.GetAttr(πF, πTemp010, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp010 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp009, πE = πg.GE(πF, πTemp011, πTemp010); πE != nil {
						continue
					}
					if πTemp012, πE = πg.IsTrue(πF, πTemp009); πE != nil {
						continue
					}
					if πTemp012 {
						goto Label1
					}
					goto Label2
					// line 1440: if sys.version_info >= (3, 0):
					πF.SetLineno(1440)
				Label1:
					// line 1441: __str__ = __unicode__
					πF.SetLineno(1441)
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp009); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Parser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1444: class LoneCommand(Parser):
			πF.SetLineno(1444)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LoneCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1445: "A parser for just one command line"
					πF.SetLineno(1445)
					// line 1445: "A parser for just one command line"
					πF.SetLineno(1445)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parser for just one command line").ToObject()); πE != nil {
						continue
					}
					// line 1447: def parse(self, reader):
					πF.SetLineno(1447)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1448: "Read nothing"
							πF.SetLineno(1448)
							// line 1449: return []
							πF.SetLineno(1449)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1448: "Read nothing"
					πF.SetLineno(1448)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Read nothing").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LoneCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLoneCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1451: class TextParser(Parser):
			πF.SetLineno(1451)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TextParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1452: "A parser for a command and a bit of text"
					πF.SetLineno(1452)
					// line 1452: "A parser for a command and a bit of text"
					πF.SetLineno(1452)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parser for a command and a bit of text").ToObject()); πE != nil {
						continue
					}
					// line 1454: stack = []
					πF.SetLineno(1454)
					πTemp001 = make([]*πg.Object, 0)
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πE = πClass.SetItem(πF, ßstack.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 1456: def __init__(self, container):
					πF.SetLineno(1456)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "container", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1457: Parser.__init__(self)
							πF.SetLineno(1457)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßParser); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1458: self.ending = None
							πF.SetLineno(1458)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßending, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ß__name__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßendings, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 1459: if container.__class__.__name__ in ContainerConfig.endings:
							πF.SetLineno(1459)
						Label1:
							// line 1460: self.ending = ContainerConfig.endings[container.__class__.__name__]
							πF.SetLineno(1460)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ß__name__, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßendings, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßending, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 1461: self.endings = []
							πF.SetLineno(1461)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßendings, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 1463: def parse(self, reader):
					πF.SetLineno(1463)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "reader", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µcontents *πg.Object = πg.UnboundLocal
						_ = µcontents
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1464: "Parse lines as long as they are text"
							πF.SetLineno(1464)
							// line 1465: TextParser.stack.append(self.ending)
							πF.SetLineno(1465)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTextParser); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstack, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1466: self.endings = TextParser.stack + [ContainerConfig.endings['Layout'],
							πF.SetLineno(1466)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTextParser); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstack, nil); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 3)
							πTemp003 = ßLayout.ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßendings, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp007, πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp005
							πTemp003 = ßInset.ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßendings, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp007, πTemp003); πE != nil {
								continue
							}
							πTemp001[1] = πTemp005
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp003
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πTemp002, πE = πg.Add(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßendings, πTemp003); πE != nil {
								continue
							}
							// line 1468: contents = []
							πF.SetLineno(1468)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µcontents = πTemp002
							// line 1469: while not self.isending(reader):
							πF.SetLineno(1469)
							πF.PushCheckpoint(2)
							πTemp008 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp008 {
								πF.PopCheckpoint()
								goto Label3
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßisending, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp010, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp010).ToObject()
							if πTemp009, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1470: self.parsecontainer(reader, contents)
							πF.SetLineno(1470)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp001[1] = µcontents
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsecontainer, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1471: return contents
							πF.SetLineno(1471)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πR = µcontents
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1464: "Parse lines as long as they are text"
					πF.SetLineno(1464)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse lines as long as they are text").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1473: def isending(self, reader):
					πF.SetLineno(1473)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "reader", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("isending", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µcurrent *πg.Object = πg.UnboundLocal
						_ = µcurrent
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1474: "Check if text is ending"
							πF.SetLineno(1474)
							// line 1475: current = reader.currentline().split()
							πF.SetLineno(1475)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µcurrent = πTemp002
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							πTemp003[0] = µcurrent
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1476: if len(current) == 0:
							πF.SetLineno(1476)
						Label1:
							// line 1477: return False
							πF.SetLineno(1477)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µcurrent, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp002, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 1478: if current[0] in self.endings:
							πF.SetLineno(1478)
						Label3:
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µcurrent, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTextParser); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp002, ßstack, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp006, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							goto Label6
							// line 1479: if current[0] in TextParser.stack:
							πF.SetLineno(1479)
						Label5:
							// line 1480: TextParser.stack.remove(current[0])
							πF.SetLineno(1480)
							πTemp003 = πF.MakeArgs(1)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcurrent, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTextParser); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßstack, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßremove, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label7
						Label6:
							// line 1482: TextParser.stack = []
							πF.SetLineno(1482)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTextParser); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßstack, πTemp002); πE != nil {
								continue
							}
							goto Label7
						Label7:
							// line 1483: return True
							πF.SetLineno(1483)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 1484: return False
							πF.SetLineno(1484)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisending.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1474: "Check if text is ending"
					πF.SetLineno(1474)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Check if text is ending").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßisending); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TextParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTextParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1486: class ExcludingParser(Parser):
			πF.SetLineno(1486)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ExcludingParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1487: "A parser that excludes the final line"
					πF.SetLineno(1487)
					// line 1487: "A parser that excludes the final line"
					πF.SetLineno(1487)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parser that excludes the final line").ToObject()); πE != nil {
						continue
					}
					// line 1489: def parse(self, reader):
					πF.SetLineno(1489)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µcontents *πg.Object = πg.UnboundLocal
						_ = µcontents
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1490: "Parse everything up to (and excluding) the final line"
							πF.SetLineno(1490)
							// line 1491: contents = []
							πF.SetLineno(1491)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µcontents = πTemp002
							// line 1492: self.parseending(reader, lambda: self.parsecontainer(reader, contents))
							πF.SetLineno(1492)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1492: self.parseending(reader, lambda: self.parsecontainer(reader, contents))
									πF.SetLineno(1492)
									πTemp001 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
										continue
									}
									πTemp001[0] = µreader
									if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
										continue
									}
									πTemp001[1] = µcontents
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ßparsecontainer, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									πR = πTemp003
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseending, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1493: return contents
							πF.SetLineno(1493)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πR = µcontents
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1490: "Parse everything up to (and excluding) the final line"
					πF.SetLineno(1490)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse everything up to (and excluding) the final line").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ExcludingParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßExcludingParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1495: class BoundedParser(ExcludingParser):
			πF.SetLineno(1495)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßExcludingParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BoundedParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1496: "A parser bound by a final line"
					πF.SetLineno(1496)
					// line 1496: "A parser bound by a final line"
					πF.SetLineno(1496)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parser bound by a final line").ToObject()); πE != nil {
						continue
					}
					// line 1498: def parse(self, reader):
					πF.SetLineno(1498)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µcontents *πg.Object = πg.UnboundLocal
						_ = µcontents
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1499: "Parse everything, including the final line"
							πF.SetLineno(1499)
							// line 1500: contents = ExcludingParser.parse(self, reader)
							πF.SetLineno(1500)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[1] = µreader
							if πTemp002, πE = πg.ResolveGlobal(πF, ßExcludingParser); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µcontents = πTemp002
							// line 1502: reader.nextline()
							πF.SetLineno(1502)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 1503: return contents
							πF.SetLineno(1503)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πR = µcontents
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1499: "Parse everything, including the final line"
					πF.SetLineno(1499)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse everything, including the final line").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BoundedParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBoundedParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1505: class BoundedDummy(Parser):
			πF.SetLineno(1505)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BoundedDummy", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1506: "A bound parser that ignores everything"
					πF.SetLineno(1506)
					// line 1506: "A bound parser that ignores everything"
					πF.SetLineno(1506)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A bound parser that ignores everything").ToObject()); πE != nil {
						continue
					}
					// line 1508: def parse(self, reader):
					πF.SetLineno(1508)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1509: "Parse the contents of the container"
							πF.SetLineno(1509)
							// line 1510: self.parseending(reader, lambda: reader.nextline())
							πF.SetLineno(1510)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1510: self.parseending(reader, lambda: reader.nextline())
									πF.SetLineno(1510)
									if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
										continue
									}
									πR = πTemp002
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseending, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1512: reader.nextline()
							πF.SetLineno(1512)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 1513: return []
							πF.SetLineno(1513)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1509: "Parse the contents of the container"
					πF.SetLineno(1509)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the contents of the container").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BoundedDummy").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBoundedDummy.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1515: class StringParser(Parser):
			πF.SetLineno(1515)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("StringParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1516: "Parses just a string"
					πF.SetLineno(1516)
					// line 1516: "Parses just a string"
					πF.SetLineno(1516)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Parses just a string").ToObject()); πE != nil {
						continue
					}
					// line 1518: def parseheader(self, reader):
					πF.SetLineno(1518)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parseheader", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1519: "Do nothing, just take note"
							πF.SetLineno(1519)
							// line 1520: self.begin = reader.linenumber + 1
							πF.SetLineno(1520)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßlinenumber, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßbegin, πTemp002); πE != nil {
								continue
							}
							// line 1521: return []
							πF.SetLineno(1521)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseheader.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1519: "Do nothing, just take note"
					πF.SetLineno(1519)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Do nothing, just take note").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparseheader); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 1523: def parse(self, reader):
					πF.SetLineno(1523)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µcontents *πg.Object = πg.UnboundLocal
						_ = µcontents
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1524: "Parse a single line"
							πF.SetLineno(1524)
							// line 1525: contents = reader.currentline()
							πF.SetLineno(1525)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µcontents = πTemp002
							// line 1526: reader.nextline()
							πF.SetLineno(1526)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 1527: return contents
							πF.SetLineno(1527)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πR = µcontents
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1524: "Parse a single line"
					πF.SetLineno(1524)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse a single line").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("StringParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStringParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1529: class InsetParser(BoundedParser):
			πF.SetLineno(1529)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßBoundedParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("InsetParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1530: "Parses a LyX inset"
					πF.SetLineno(1530)
					// line 1530: "Parses a LyX inset"
					πF.SetLineno(1530)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Parses a LyX inset").ToObject()); πE != nil {
						continue
					}
					// line 1532: def parse(self, reader):
					πF.SetLineno(1532)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µstartcommand *πg.Object = πg.UnboundLocal
						_ = µstartcommand
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1533: "Parse inset parameters into a dictionary"
							πF.SetLineno(1533)
							// line 1534: startcommand = ContainerConfig.string['startcommand']
							πF.SetLineno(1534)
							πTemp001 = ßstartcommand.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstring, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µstartcommand = πTemp002
							// line 1535: while reader.currentline() != '' and not reader.currentline().startswith(startcommand):
							πF.SetLineno(1535)
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.NE(πF, πTemp004, ß.ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp007 {
								goto Label4
							}
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstartcommand, "startcommand"); πE != nil {
								continue
							}
							πTemp008[0] = µstartcommand
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp009, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp009).ToObject()
							πTemp001 = πTemp002
						Label4:
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1536: self.parseparameter(reader)
							πF.SetLineno(1536)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp008[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparseparameter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1537: return BoundedParser.parse(self, reader)
							πF.SetLineno(1537)
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp008[0] = µself
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp008[1] = µreader
							if πTemp001, πE = πg.ResolveGlobal(πF, ßBoundedParser); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßparse, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1533: "Parse inset parameters into a dictionary"
					πF.SetLineno(1533)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse inset parameters into a dictionary").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("InsetParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßInsetParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1544: class ContainerOutput(object):
			πF.SetLineno(1544)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ContainerOutput", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1545: "The generic HTML output for a container."
					πF.SetLineno(1545)
					// line 1545: "The generic HTML output for a container."
					πF.SetLineno(1545)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("The generic HTML output for a container.").ToObject()); πE != nil {
						continue
					}
					// line 1547: def gethtml(self, container):
					πF.SetLineno(1547)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("gethtml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1548: "Show an error."
							πF.SetLineno(1548)
							// line 1549: Trace.error('gethtml() not implemented for ' + unicode(self))
							πF.SetLineno(1549)
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[0] = µself
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Add(πF, πg.NewStr("gethtml() not implemented for ").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgethtml.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1548: "Show an error."
					πF.SetLineno(1548)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Show an error.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßgethtml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 1551: def isempty(self):
					πF.SetLineno(1551)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("isempty", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1552: "Decide if the output is empty: by default, not empty."
							πF.SetLineno(1552)
							// line 1553: return False
							πF.SetLineno(1553)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisempty.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1552: "Decide if the output is empty: by default, not empty."
					πF.SetLineno(1552)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Decide if the output is empty: by default, not empty.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßisempty); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ContainerOutput").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßContainerOutput.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1555: class EmptyOutput(ContainerOutput):
			πF.SetLineno(1555)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainerOutput); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("EmptyOutput", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1557: def gethtml(self, container):
					πF.SetLineno(1557)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("gethtml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1558: "Return empty HTML code."
							πF.SetLineno(1558)
							// line 1559: return []
							πF.SetLineno(1559)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgethtml.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1558: "Return empty HTML code."
					πF.SetLineno(1558)
					// line 1558: "Return empty HTML code."
					πF.SetLineno(1558)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Return empty HTML code.").ToObject()); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Return empty HTML code.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßgethtml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 1561: def isempty(self):
					πF.SetLineno(1561)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("isempty", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1562: "This output is particularly empty."
							πF.SetLineno(1562)
							// line 1563: return True
							πF.SetLineno(1563)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisempty.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1562: "This output is particularly empty."
					πF.SetLineno(1562)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("This output is particularly empty.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßisempty); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("EmptyOutput").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßEmptyOutput.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1565: class FixedOutput(ContainerOutput):
			πF.SetLineno(1565)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainerOutput); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FixedOutput", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1566: "Fixed output"
					πF.SetLineno(1566)
					// line 1566: "Fixed output"
					πF.SetLineno(1566)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Fixed output").ToObject()); πE != nil {
						continue
					}
					// line 1568: def gethtml(self, container):
					πF.SetLineno(1568)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("gethtml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1569: "Return constant HTML code"
							πF.SetLineno(1569)
							// line 1570: return container.html
							πF.SetLineno(1570)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontainer, ßhtml, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgethtml.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1569: "Return constant HTML code"
					πF.SetLineno(1569)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Return constant HTML code").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßgethtml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FixedOutput").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFixedOutput.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1572: class ContentsOutput(ContainerOutput):
			πF.SetLineno(1572)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainerOutput); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ContentsOutput", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1573: "Outputs the contents converted to HTML"
					πF.SetLineno(1573)
					// line 1573: "Outputs the contents converted to HTML"
					πF.SetLineno(1573)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Outputs the contents converted to HTML").ToObject()); πE != nil {
						continue
					}
					// line 1575: def gethtml(self, container):
					πF.SetLineno(1575)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("gethtml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µhtml *πg.Object = πg.UnboundLocal
						_ = µhtml
						var µelement *πg.Object = πg.UnboundLocal
						_ = µelement
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 1576: "Return the HTML code"
							πF.SetLineno(1576)
							// line 1577: html = []
							πF.SetLineno(1577)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µhtml = πTemp002
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1578: if container.contents == None:
							πF.SetLineno(1578)
						Label1:
							// line 1579: return html
							πF.SetLineno(1579)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							πR = µhtml
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp005 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µelement = πTemp003
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(3)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							πTemp001[0] = µelement
							πTemp001[1] = ßgethtml.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp006, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label6
							}
							goto Label7
							// line 1581: if not hasattr(element, 'gethtml'):
							πF.SetLineno(1581)
						Label6:
							// line 1582: Trace.error('No html in ' + element.__class__.__name__ + ': ' + unicode(element))
							πF.SetLineno(1582)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µelement, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, πTemp008, ß__name__, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Add(πF, πg.NewStr("No html in ").ToObject(), πTemp009); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp007, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							πTemp010[0] = µelement
							if πTemp007, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							if πTemp003, πE = πg.Add(πF, πTemp004, πTemp008); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßerror, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1583: return html
							πF.SetLineno(1583)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							πR = µhtml
							continue
							goto Label7
						Label7:
							// line 1584: html += element.gethtml()
							πF.SetLineno(1584)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µelement, ßgethtml, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µhtml, πTemp004); πE != nil {
								continue
							}
							µhtml = πTemp003
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							// line 1585: return html
							πF.SetLineno(1585)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							πR = µhtml
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgethtml.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1576: "Return the HTML code"
					πF.SetLineno(1576)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Return the HTML code").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßgethtml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ContentsOutput").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßContentsOutput.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1587: class TaggedOutput(ContentsOutput):
			πF.SetLineno(1587)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContentsOutput); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TaggedOutput", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1588: "Outputs an HTML tag surrounding the contents."
					πF.SetLineno(1588)
					// line 1588: "Outputs an HTML tag surrounding the contents."
					πF.SetLineno(1588)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Outputs an HTML tag surrounding the contents.").ToObject()); πE != nil {
						continue
					}
					// line 1590: tag = None
					πF.SetLineno(1590)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtag.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1591: breaklines = False
					πF.SetLineno(1591)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßbreaklines.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1592: empty = False
					πF.SetLineno(1592)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßempty.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1594: def settag(self, tag, breaklines=False, empty=False):
					πF.SetLineno(1594)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "tag", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "breaklines", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "empty", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("settag", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtag *πg.Object = πArgs[1]
						_ = µtag
						var µbreaklines *πg.Object = πArgs[2]
						_ = µbreaklines
						var µempty *πg.Object = πArgs[3]
						_ = µempty
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1595: "Set the value for the tag and other attributes."
							πF.SetLineno(1595)
							// line 1596: self.tag = tag
							πF.SetLineno(1596)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µtag); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtag, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbreaklines, "breaklines"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µbreaklines); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1597: if breaklines:
							πF.SetLineno(1597)
						Label1:
							// line 1598: self.breaklines = breaklines
							πF.SetLineno(1598)
							if πE = πg.CheckLocal(πF, µbreaklines, "breaklines"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µbreaklines); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßbreaklines, πTemp001); πE != nil {
								continue
							}
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µempty, "empty"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µempty); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 1599: if empty:
							πF.SetLineno(1599)
						Label3:
							// line 1600: self.empty = empty
							πF.SetLineno(1600)
							if πE = πg.CheckLocal(πF, µempty, "empty"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µempty); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßempty, πTemp001); πE != nil {
								continue
							}
							goto Label4
						Label4:
							// line 1601: return self
							πF.SetLineno(1601)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsettag.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1595: "Set the value for the tag and other attributes."
					πF.SetLineno(1595)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Set the value for the tag and other attributes.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßsettag); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 1603: def setbreaklines(self, breaklines):
					πF.SetLineno(1603)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "breaklines", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("setbreaklines", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbreaklines *πg.Object = πArgs[1]
						_ = µbreaklines
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1604: "Set the value for breaklines."
							πF.SetLineno(1604)
							// line 1605: self.breaklines = breaklines
							πF.SetLineno(1605)
							if πE = πg.CheckLocal(πF, µbreaklines, "breaklines"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µbreaklines); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßbreaklines, πTemp001); πE != nil {
								continue
							}
							// line 1606: return self
							πF.SetLineno(1606)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetbreaklines.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1604: "Set the value for breaklines."
					πF.SetLineno(1604)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Set the value for breaklines.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßsetbreaklines); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1608: def gethtml(self, container):
					πF.SetLineno(1608)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("gethtml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µhtml *πg.Object = πg.UnboundLocal
						_ = µhtml
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1609: "Return the HTML code."
							πF.SetLineno(1609)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßempty, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1610: if self.empty:
							πF.SetLineno(1610)
						Label1:
							// line 1611: return [self.selfclosing(container)]
							πF.SetLineno(1611)
							πTemp003 = make([]*πg.Object, 1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp004[0] = µcontainer
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßselfclosing, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp005
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 1612: html = [self.open(container)]
							πF.SetLineno(1612)
							πTemp003 = make([]*πg.Object, 1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp004[0] = µcontainer
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßopen, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp005
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							µhtml = πTemp001
							// line 1613: html += ContentsOutput.gethtml(self, container)
							πF.SetLineno(1613)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[0] = µself
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp003[1] = µcontainer
							if πTemp001, πE = πg.ResolveGlobal(πF, ßContentsOutput); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp001, ßgethtml, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp005, πE = πg.IAdd(πF, µhtml, πTemp001); πE != nil {
								continue
							}
							µhtml = πTemp005
							// line 1614: html.append(self.close(container))
							πF.SetLineno(1614)
							πTemp003 = πF.MakeArgs(1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp004[0] = µcontainer
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßclose, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp005
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µhtml, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1615: return html
							πF.SetLineno(1615)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							πR = µhtml
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgethtml.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1609: "Return the HTML code."
					πF.SetLineno(1609)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Return the HTML code.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßgethtml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1617: def open(self, container):
					πF.SetLineno(1617)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("open", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µopen *πg.Object = πg.UnboundLocal
						_ = µopen
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1618: "Get opening line."
							πF.SetLineno(1618)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp002[0] = µcontainer
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßchecktag, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1619: if not self.checktag(container):
							πF.SetLineno(1619)
						Label1:
							// line 1620: return ''
							πF.SetLineno(1620)
							πR = ß.ToObject()
							continue
							goto Label2
						Label2:
							// line 1621: open = '<' + self.tag + '>'
							πF.SetLineno(1621)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßtag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("<").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr(">").ToObject()); πE != nil {
								continue
							}
							µopen = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßbreaklines, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 1622: if self.breaklines:
							πF.SetLineno(1622)
						Label3:
							// line 1623: return open + '\n'
							πF.SetLineno(1623)
							if πE = πg.CheckLocal(πF, µopen, "open"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µopen, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 1624: return open
							πF.SetLineno(1624)
							if πE = πg.CheckLocal(πF, µopen, "open"); πE != nil {
								continue
							}
							πR = µopen
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßopen.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1618: "Get opening line."
					πF.SetLineno(1618)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Get opening line.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßopen); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 1626: def close(self, container):
					πF.SetLineno(1626)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("close", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µclose *πg.Object = πg.UnboundLocal
						_ = µclose
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1627: "Get closing line."
							πF.SetLineno(1627)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp002[0] = µcontainer
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßchecktag, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1628: if not self.checktag(container):
							πF.SetLineno(1628)
						Label1:
							// line 1629: return ''
							πF.SetLineno(1629)
							πR = ß.ToObject()
							continue
							goto Label2
						Label2:
							// line 1630: close = '</' + self.tag.split()[0] + '>'
							πF.SetLineno(1630)
							πTemp004 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßtag, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp008.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, πTemp007, πTemp004); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("</").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr(">").ToObject()); πE != nil {
								continue
							}
							µclose = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßbreaklines, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 1631: if self.breaklines:
							πF.SetLineno(1631)
						Label3:
							// line 1632: return '\n' + close + '\n'
							πF.SetLineno(1632)
							if πE = πg.CheckLocal(πF, µclose, "close"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("\n").ToObject(), µclose); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 1633: return close
							πF.SetLineno(1633)
							if πE = πg.CheckLocal(πF, µclose, "close"); πE != nil {
								continue
							}
							πR = µclose
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßclose.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 1627: "Get closing line."
					πF.SetLineno(1627)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Get closing line.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßclose); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 1635: def selfclosing(self, container):
					πF.SetLineno(1635)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("selfclosing", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µselfclosing *πg.Object = πg.UnboundLocal
						_ = µselfclosing
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1636: "Get self-closing line."
							πF.SetLineno(1636)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp002[0] = µcontainer
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßchecktag, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1637: if not self.checktag(container):
							πF.SetLineno(1637)
						Label1:
							// line 1638: return ''
							πF.SetLineno(1638)
							πR = ß.ToObject()
							continue
							goto Label2
						Label2:
							// line 1639: selfclosing = '<' + self.tag + '/>'
							πF.SetLineno(1639)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßtag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("<").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr("/>").ToObject()); πE != nil {
								continue
							}
							µselfclosing = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßbreaklines, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 1640: if self.breaklines:
							πF.SetLineno(1640)
						Label3:
							// line 1641: return selfclosing + '\n'
							πF.SetLineno(1641)
							if πE = πg.CheckLocal(πF, µselfclosing, "selfclosing"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µselfclosing, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 1642: return selfclosing
							πF.SetLineno(1642)
							if πE = πg.CheckLocal(πF, µselfclosing, "selfclosing"); πE != nil {
								continue
							}
							πR = µselfclosing
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßselfclosing.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 1636: "Get self-closing line."
					πF.SetLineno(1636)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Get self-closing line.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßselfclosing); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 1644: def checktag(self, container):
					πF.SetLineno(1644)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("checktag", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1645: "Check that the tag is valid."
							πF.SetLineno(1645)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1646: if not self.tag:
							πF.SetLineno(1646)
						Label1:
							// line 1647: Trace.error('No tag in ' + unicode(container))
							πF.SetLineno(1647)
							πTemp004 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp005[0] = µcontainer
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.Add(πF, πg.NewStr("No tag in ").ToObject(), πTemp006); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1648: return False
							πF.SetLineno(1648)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtag, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp002, ß.ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 1649: if self.tag == '':
							πF.SetLineno(1649)
						Label3:
							// line 1650: return False
							πF.SetLineno(1650)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 1651: return True
							πF.SetLineno(1651)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßchecktag.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 1645: "Check that the tag is valid."
					πF.SetLineno(1645)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Check that the tag is valid.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßchecktag); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TaggedOutput").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTaggedOutput.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1653: class FilteredOutput(ContentsOutput):
			πF.SetLineno(1653)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContentsOutput); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FilteredOutput", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1654: "Returns the output in the contents, but filtered:"
					πF.SetLineno(1654)
					// line 1654: "Returns the output in the contents, but filtered:"
					πF.SetLineno(1654)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Returns the output in the contents, but filtered:").ToObject()); πE != nil {
						continue
					}
					// line 1655: "some strings are replaced by others."
					πF.SetLineno(1655)
					// line 1657: def __init__(self):
					πF.SetLineno(1657)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1658: "Initialize the filters."
							πF.SetLineno(1658)
							// line 1659: self.filters = []
							πF.SetLineno(1659)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfilters, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1658: "Initialize the filters."
					πF.SetLineno(1658)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Initialize the filters.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 1661: def addfilter(self, original, replacement):
					πF.SetLineno(1661)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "original", Def: nil}
					πTemp002[2] = πg.Param{Name: "replacement", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("addfilter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µoriginal *πg.Object = πArgs[1]
						_ = µoriginal
						var µreplacement *πg.Object = πArgs[2]
						_ = µreplacement
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1662: "Add a new filter: replace the original by the replacement."
							πF.SetLineno(1662)
							// line 1663: self.filters.append((original, replacement))
							πF.SetLineno(1663)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoriginal, "original"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreplacement, "replacement"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(µoriginal, µreplacement).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfilters, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßaddfilter.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1662: "Add a new filter: replace the original by the replacement."
					πF.SetLineno(1662)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Add a new filter: replace the original by the replacement.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßaddfilter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1665: def gethtml(self, container):
					πF.SetLineno(1665)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("gethtml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µhtml *πg.Object = πg.UnboundLocal
						_ = µhtml
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1666: "Return the HTML code"
							πF.SetLineno(1666)
							// line 1667: result = []
							πF.SetLineno(1667)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µresult = πTemp002
							// line 1668: html = ContentsOutput.gethtml(self, container)
							πF.SetLineno(1668)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[1] = µcontainer
							if πTemp002, πE = πg.ResolveGlobal(πF, ßContentsOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßgethtml, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µhtml = πTemp002
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µhtml); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µline = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1670: result.append(self.filter(line))
							πF.SetLineno(1670)
							πTemp001 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp006[0] = µline
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfilter, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp001[0] = πTemp007
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1671: return result
							πF.SetLineno(1671)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgethtml.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1666: "Return the HTML code"
					πF.SetLineno(1666)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Return the HTML code").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßgethtml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1673: def filter(self, line):
					πF.SetLineno(1673)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "line", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("filter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µline *πg.Object = πArgs[1]
						_ = µline
						var µoriginal *πg.Object = πg.UnboundLocal
						_ = µoriginal
						var µreplacement *πg.Object = πg.UnboundLocal
						_ = µreplacement
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1674: "Filter a single line with all available filters."
							πF.SetLineno(1674)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfilters, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp002); πE != nil {
									continue
								}
								µoriginal = πTemp005
								µreplacement = πTemp006
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µoriginal, "original"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, µline, µoriginal); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 1676: if original in line:
							πF.SetLineno(1676)
						Label4:
							// line 1677: line = line.replace(original, replacement)
							πF.SetLineno(1677)
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µoriginal, "original"); πE != nil {
								continue
							}
							πTemp007[0] = µoriginal
							if πE = πg.CheckLocal(πF, µreplacement, "replacement"); πE != nil {
								continue
							}
							πTemp007[1] = µreplacement
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µline, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							µline = πTemp005
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1678: return line
							πF.SetLineno(1678)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πR = µline
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfilter.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1674: "Filter a single line with all available filters."
					πF.SetLineno(1674)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Filter a single line with all available filters.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßfilter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FilteredOutput").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFilteredOutput.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1680: class StringOutput(ContainerOutput):
			πF.SetLineno(1680)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainerOutput); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("StringOutput", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1681: "Returns a bare string as output"
					πF.SetLineno(1681)
					// line 1681: "Returns a bare string as output"
					πF.SetLineno(1681)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Returns a bare string as output").ToObject()); πE != nil {
						continue
					}
					// line 1683: def gethtml(self, container):
					πF.SetLineno(1683)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("gethtml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1684: "Return a bare string"
							πF.SetLineno(1684)
							// line 1685: return [container.string]
							πF.SetLineno(1685)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßstring, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgethtml.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1684: "Return a bare string"
					πF.SetLineno(1684)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Return a bare string").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßgethtml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("StringOutput").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStringOutput.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1688: class LineReader(object):
			πF.SetLineno(1688)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LineReader", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1689: "Reads a file line by line"
					πF.SetLineno(1689)
					// line 1689: "Reads a file line by line"
					πF.SetLineno(1689)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Reads a file line by line").ToObject()); πE != nil {
						continue
					}
					// line 1691: def __init__(self, filename):
					πF.SetLineno(1691)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "filename", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µfilename *πg.Object = πArgs[1]
						_ = µfilename
						var µgzip *πg.Object = πg.UnboundLocal
						_ = µgzip
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 5:
								goto Label5
							default:
								panic("unexpected function state")
							}
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µfilename, "filename"); πE != nil {
								continue
							}
							πTemp001[0] = µfilename
							if πTemp002, πE = πg.ResolveGlobal(πF, ßfile); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1692: if isinstance(filename, file):
							πF.SetLineno(1692)
						Label1:
							// line 1693: self.file = filename
							πF.SetLineno(1693)
							if πE = πg.CheckLocal(πF, µfilename, "filename"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µfilename); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfile, πTemp002); πE != nil {
								continue
							}
							goto Label3
						Label2:
							// line 1695: self.file = codecs.open(filename, 'rU', 'utf-8')
							πF.SetLineno(1695)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µfilename, "filename"); πE != nil {
								continue
							}
							πTemp001[0] = µfilename
							πTemp001[1] = ßrU.ToObject()
							πTemp001[2] = πg.NewStr("utf-8").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßcodecs); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßopen, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfile, πTemp003); πE != nil {
								continue
							}
							goto Label3
						Label3:
							// line 1696: self.linenumber = 1
							πF.SetLineno(1696)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlinenumber, πTemp002); πE != nil {
								continue
							}
							// line 1697: self.lastline = None
							πF.SetLineno(1697)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlastline, πTemp003); πE != nil {
								continue
							}
							// line 1698: self.current = None
							πF.SetLineno(1698)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcurrent, πTemp003); πE != nil {
								continue
							}
							// line 1699: self.mustread = True
							πF.SetLineno(1699)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmustread, πTemp003); πE != nil {
								continue
							}
							// line 1700: self.depleted = False
							πF.SetLineno(1700)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdepleted, πTemp003); πE != nil {
								continue
							}
							// line 1701: try:
							πF.SetLineno(1701)
							πF.PushCheckpoint(5)
							// line 1702: self.readline()
							πF.SetLineno(1702)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreadline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πF.PopCheckpoint()
							goto Label4
						Label5:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßUnicodeDecodeError); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 1703: except UnicodeDecodeError:
							πF.SetLineno(1703)
						Label6:
							// line 1705: import gzip
							πF.SetLineno(1705)
							if πTemp001, πE = πg.ImportModule(πF, "gzip"); πE != nil {
								continue
							}
							πTemp002 = πTemp001[0]
							µgzip = πTemp002
							// line 1706: self.file = gzip.open(filename, 'rb')
							πF.SetLineno(1706)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µfilename, "filename"); πE != nil {
								continue
							}
							πTemp001[0] = µfilename
							πTemp001[1] = ßrb.ToObject()
							if πE = πg.CheckLocal(πF, µgzip, "gzip"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µgzip, ßopen, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfile, πTemp002); πE != nil {
								continue
							}
							// line 1707: self.readline()
							πF.SetLineno(1707)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreadline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πF.RestoreExc(nil, nil)
							goto Label4
						Label4:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1709: def setstart(self, firstline):
					πF.SetLineno(1709)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "firstline", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("setstart", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µfirstline *πg.Object = πArgs[1]
						_ = µfirstline
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1710: "Set the first line to read."
							πF.SetLineno(1710)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfirstline, "firstline"); πE != nil {
								continue
							}
							πTemp002[0] = µfirstline
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µi = πTemp003
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1712: self.file.readline()
							πF.SetLineno(1712)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfile, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßreadline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1713: self.linenumber = firstline
							πF.SetLineno(1713)
							if πE = πg.CheckLocal(πF, µfirstline, "firstline"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µfirstline); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlinenumber, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetstart.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1710: "Set the first line to read."
					πF.SetLineno(1710)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Set the first line to read.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßsetstart); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1715: def setend(self, lastline):
					πF.SetLineno(1715)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "lastline", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("setend", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlastline *πg.Object = πArgs[1]
						_ = µlastline
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1716: "Set the last line to read."
							πF.SetLineno(1716)
							// line 1717: self.lastline = lastline
							πF.SetLineno(1717)
							if πE = πg.CheckLocal(πF, µlastline, "lastline"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µlastline); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlastline, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetend.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1716: "Set the last line to read."
					πF.SetLineno(1716)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Set the last line to read.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßsetend); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1719: def currentline(self):
					πF.SetLineno(1719)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("currentline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1720: "Get the current line"
							πF.SetLineno(1720)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmustread, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1721: if self.mustread:
							πF.SetLineno(1721)
						Label1:
							// line 1722: self.readline()
							πF.SetLineno(1722)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreadline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 1723: return self.current
							πF.SetLineno(1723)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcurrentline.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1720: "Get the current line"
					πF.SetLineno(1720)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Get the current line").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßcurrentline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 1725: def nextline(self):
					πF.SetLineno(1725)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("nextline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1726: "Go to next line"
							πF.SetLineno(1726)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdepleted, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1727: if self.depleted:
							πF.SetLineno(1727)
						Label1:
							// line 1728: Trace.fatal('Read beyond file end')
							πF.SetLineno(1728)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("Read beyond file end").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßfatal, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label2
						Label2:
							// line 1729: self.mustread = True
							πF.SetLineno(1729)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmustread, πTemp004); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßnextline.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 1726: "Go to next line"
					πF.SetLineno(1726)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Go to next line").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßnextline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 1731: def readline(self):
					πF.SetLineno(1731)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("readline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1732: "Read a line from elyxer.file"
							πF.SetLineno(1732)
							// line 1733: self.current = self.file.readline()
							πF.SetLineno(1733)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfile, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßreadline, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcurrent, πTemp002); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfile, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßcodecs); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßStreamReaderWriter, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp004
							if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1734: if not isinstance(self.file, codecs.StreamReaderWriter):
							πF.SetLineno(1734)
						Label1:
							// line 1735: self.current = self.current.decode('utf-8')
							πF.SetLineno(1735)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("utf-8").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßdecode, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcurrent, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 1736: if len(self.current) == 0:
							πF.SetLineno(1736)
						Label3:
							// line 1737: self.depleted = True
							πF.SetLineno(1737)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdepleted, πTemp002); πE != nil {
								continue
							}
							goto Label4
						Label4:
							// line 1738: self.current = self.current.rstrip('\n\r')
							πF.SetLineno(1738)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("\n\r").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcurrent, πTemp002); πE != nil {
								continue
							}
							// line 1739: self.linenumber += 1
							πF.SetLineno(1739)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßlinenumber, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlinenumber, πTemp002); πE != nil {
								continue
							}
							// line 1740: self.mustread = False
							πF.SetLineno(1740)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmustread, πTemp002); πE != nil {
								continue
							}
							// line 1741: Trace.prefix = 'Line ' + unicode(self.linenumber) + ': '
							πF.SetLineno(1741)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßlinenumber, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Line ").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßprefix, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßlinenumber, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πTemp004, πg.NewInt(1000).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp002, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							goto Label6
							// line 1742: if self.linenumber % 1000 == 0:
							πF.SetLineno(1742)
						Label5:
							// line 1743: Trace.message('Parsing')
							πF.SetLineno(1743)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßParsing.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßmessage, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label6
						Label6:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreadline.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 1732: "Read a line from elyxer.file"
					πF.SetLineno(1732)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Read a line from elyxer.file").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßreadline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 1745: def finished(self):
					πF.SetLineno(1745)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("finished", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1746: "Find out if the file is finished"
							πF.SetLineno(1746)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßlastline, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßlinenumber, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßlastline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 1747: if self.lastline and self.linenumber == self.lastline:
							πF.SetLineno(1747)
						Label2:
							// line 1748: return True
							πF.SetLineno(1748)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label3
						Label3:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmustread, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 1749: if self.mustread:
							πF.SetLineno(1749)
						Label4:
							// line 1750: self.readline()
							πF.SetLineno(1750)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreadline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label5
						Label5:
							// line 1751: return self.depleted
							πF.SetLineno(1751)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdepleted, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfinished.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 1746: "Find out if the file is finished"
					πF.SetLineno(1746)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Find out if the file is finished").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßfinished); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 1753: def close(self):
					πF.SetLineno(1753)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("close", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1754: self.file.close()
							πF.SetLineno(1754)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfile, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßclose, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßclose.ToObject(), πTemp009); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LineReader").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLineReader.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1756: class LineWriter(object):
			πF.SetLineno(1756)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LineWriter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1757: "Writes a file as a series of lists"
					πF.SetLineno(1757)
					// line 1757: "Writes a file as a series of lists"
					πF.SetLineno(1757)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Writes a file as a series of lists").ToObject()); πE != nil {
						continue
					}
					// line 1759: file = False
					πF.SetLineno(1759)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßfile.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1761: def __init__(self, filename):
					πF.SetLineno(1761)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "filename", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µfilename *πg.Object = πArgs[1]
						_ = µfilename
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µfilename, "filename"); πE != nil {
								continue
							}
							πTemp001[0] = µfilename
							if πTemp002, πE = πg.ResolveGlobal(πF, ßfile); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1762: if isinstance(filename, file):
							πF.SetLineno(1762)
						Label1:
							// line 1763: self.file = filename
							πF.SetLineno(1763)
							if πE = πg.CheckLocal(πF, µfilename, "filename"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µfilename); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfile, πTemp002); πE != nil {
								continue
							}
							// line 1764: self.filename = None
							πF.SetLineno(1764)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfilename, πTemp003); πE != nil {
								continue
							}
							goto Label3
						Label2:
							// line 1766: self.filename = filename
							πF.SetLineno(1766)
							if πE = πg.CheckLocal(πF, µfilename, "filename"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µfilename); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfilename, πTemp002); πE != nil {
								continue
							}
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1768: def write(self, strings):
					πF.SetLineno(1768)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "strings", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("write", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstrings *πg.Object = πArgs[1]
						_ = µstrings
						var µstring *πg.Object = πg.UnboundLocal
						_ = µstring
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1769: "Write a list of strings"
							πF.SetLineno(1769)
							if πE = πg.CheckLocal(πF, µstrings, "strings"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µstrings); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp002 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp003 = !isStop
							} else {
								πTemp003 = true
								µstring = πTemp004
							}
							if πE != nil || !πTemp003 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp005[0] = µstring
							if πTemp006, πE = πg.ResolveGlobal(πF, ßbasestring); πE != nil {
								continue
							}
							πTemp005[1] = πTemp006
							if πTemp006, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp003, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 1771: if not isinstance(string, basestring):
							πF.SetLineno(1771)
						Label4:
							// line 1772: Trace.error('Not a string: ' + unicode(string) + ' in ' + unicode(strings))
							πF.SetLineno(1772)
							πTemp005 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp008[0] = µstring
							if πTemp009, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp009.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp007, πE = πg.Add(πF, πg.NewStr("Not a string: ").ToObject(), πTemp010); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Add(πF, πTemp007, πg.NewStr(" in ").ToObject()); πE != nil {
								continue
							}
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstrings, "strings"); πE != nil {
								continue
							}
							πTemp008[0] = µstrings
							if πTemp007, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp007.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp004, πE = πg.Add(πF, πTemp006, πTemp009); πE != nil {
								continue
							}
							πTemp005[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp004, ßerror, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp006.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 1773: return
							πF.SetLineno(1773)
							πR = πg.None
							continue
							goto Label5
						Label5:
							// line 1774: self.writestring(string)
							πF.SetLineno(1774)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp005[0] = µstring
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßwritestring, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßwrite.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1769: "Write a list of strings"
					πF.SetLineno(1769)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Write a list of strings").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßwrite); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1776: def writestring(self, string):
					πF.SetLineno(1776)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("writestring", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1777: "Write a string"
							πF.SetLineno(1777)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfile, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1778: if not self.file:
							πF.SetLineno(1778)
						Label1:
							// line 1779: self.file = codecs.open(self.filename, 'w', "utf-8")
							πF.SetLineno(1779)
							πTemp004 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfilename, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							πTemp004[1] = ßw.ToObject()
							πTemp004[2] = πg.NewStr("utf-8").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßcodecs); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßopen, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfile, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßfile, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßstdout, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp005, πTemp007); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label3
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßversion_info, nil); πE != nil {
								continue
							}
							πTemp005 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
							if πTemp002, πE = πg.LT(πF, πTemp006, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πTemp002
						Label3:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 1780: if self.file == sys.stdout and sys.version_info < (3, 0):
							πF.SetLineno(1780)
						Label4:
							// line 1781: string = string.encode('utf-8')
							πF.SetLineno(1781)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("utf-8").ToObject()
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µstring, ßencode, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µstring = πTemp002
							goto Label5
						Label5:
							// line 1782: self.file.write(string)
							πF.SetLineno(1782)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp004[0] = µstring
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfile, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwrite, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßwritestring.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1777: "Write a string"
					πF.SetLineno(1777)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Write a string").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßwritestring); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1784: def writeline(self, line):
					πF.SetLineno(1784)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "line", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("writeline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µline *πg.Object = πArgs[1]
						_ = µline
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1785: "Write a line to file"
							πF.SetLineno(1785)
							// line 1786: self.writestring(line + '\n')
							πF.SetLineno(1786)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µline, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßwritestring, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßwriteline.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1785: "Write a line to file"
					πF.SetLineno(1785)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Write a line to file").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßwriteline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 1788: def close(self):
					πF.SetLineno(1788)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("close", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1789: self.file.close()
							πF.SetLineno(1789)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfile, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßclose, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßclose.ToObject(), πTemp006); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LineWriter").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLineWriter.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1796: class Globable(object):
			πF.SetLineno(1796)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Globable", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				var πTemp019 *πg.Object
				_ = πTemp019
				var πTemp020 *πg.Object
				_ = πTemp020
				var πTemp021 *πg.Object
				_ = πTemp021
				var πTemp022 *πg.Object
				_ = πTemp022
				var πTemp023 *πg.Object
				_ = πTemp023
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1797: """A bit of text which can be globbed (lumped together in bits).
					πF.SetLineno(1797)
					// line 1797: """A bit of text which can be globbed (lumped together in bits).
					πF.SetLineno(1797)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A bit of text which can be globbed (lumped together in bits).\n  Methods current(), skipcurrent(), checkfor() and isout() have to be\n  implemented by subclasses.").ToObject()); πE != nil {
						continue
					}
					// line 1801: leavepending = False
					πF.SetLineno(1801)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßleavepending.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1803: def __init__(self):
					πF.SetLineno(1803)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1804: self.endinglist = EndingList()
							πF.SetLineno(1804)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEndingList); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßendinglist, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1806: def checkbytemark(self):
					πF.SetLineno(1806)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("checkbytemark", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1807: "Check for a Unicode byte mark and skip it."
							πF.SetLineno(1807)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1808: if self.finished():
							πF.SetLineno(1808)
						Label1:
							// line 1809: return
							πF.SetLineno(1809)
							πR = πg.None
							continue
							goto Label2
						Label2:
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp005
							if πTemp002, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Eq(πF, πTemp005, πg.NewInt(65279).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 1810: if ord(self.current()) == 0xfeff:
							πF.SetLineno(1810)
						Label3:
							// line 1811: self.skipcurrent()
							πF.SetLineno(1811)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label4
						Label4:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckbytemark.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1807: "Check for a Unicode byte mark and skip it."
					πF.SetLineno(1807)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Check for a Unicode byte mark and skip it.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßcheckbytemark); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1813: def isout(self):
					πF.SetLineno(1813)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("isout", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1814: "Find out if we are out of the position yet."
							πF.SetLineno(1814)
							// line 1815: Trace.error('Unimplemented isout()')
							πF.SetLineno(1815)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Unimplemented isout()").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1816: return True
							πF.SetLineno(1816)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisout.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1814: "Find out if we are out of the position yet."
					πF.SetLineno(1814)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Find out if we are out of the position yet.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßisout); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1818: def current(self):
					πF.SetLineno(1818)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("current", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1819: "Return the current character."
							πF.SetLineno(1819)
							// line 1820: Trace.error('Unimplemented current()')
							πF.SetLineno(1820)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Unimplemented current()").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1821: return ''
							πF.SetLineno(1821)
							πR = ß.ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcurrent.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1819: "Return the current character."
					πF.SetLineno(1819)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Return the current character.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßcurrent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 1823: def checkfor(self, string):
					πF.SetLineno(1823)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("checkfor", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1824: "Check for the given string in the current position."
							πF.SetLineno(1824)
							// line 1825: Trace.error('Unimplemented checkfor()')
							πF.SetLineno(1825)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Unimplemented checkfor()").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1826: return False
							πF.SetLineno(1826)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckfor.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 1824: "Check for the given string in the current position."
					πF.SetLineno(1824)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Check for the given string in the current position.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßcheckfor); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 1828: def finished(self):
					πF.SetLineno(1828)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("finished", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1829: "Find out if the current text has finished."
							πF.SetLineno(1829)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßisout, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1830: if self.isout():
							πF.SetLineno(1830)
						Label1:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßleavepending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 1831: if not self.leavepending:
							πF.SetLineno(1831)
						Label3:
							// line 1832: self.endinglist.checkpending()
							πF.SetLineno(1832)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßendinglist, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcheckpending, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label4
						Label4:
							// line 1833: return True
							πF.SetLineno(1833)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 1834: return self.endinglist.checkin(self)
							πF.SetLineno(1834)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp004[0] = µself
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßendinglist, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcheckin, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfinished.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 1829: "Find out if the current text has finished."
					πF.SetLineno(1829)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Find out if the current text has finished.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßfinished); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 1836: def skipcurrent(self):
					πF.SetLineno(1836)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("skipcurrent", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1837: "Return the current character and skip it."
							πF.SetLineno(1837)
							// line 1838: Trace.error('Unimplemented skipcurrent()')
							πF.SetLineno(1838)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Unimplemented skipcurrent()").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1839: return ''
							πF.SetLineno(1839)
							πR = ß.ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßskipcurrent.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 1837: "Return the current character and skip it."
					πF.SetLineno(1837)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Return the current character and skip it.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßskipcurrent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 1841: def glob(self, currentcheck):
					πF.SetLineno(1841)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "currentcheck", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("glob", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcurrentcheck *πg.Object = πArgs[1]
						_ = µcurrentcheck
						var µglob *πg.Object = πg.UnboundLocal
						_ = µglob
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1842: "Glob a bit of text that satisfies a check on the current char."
							πF.SetLineno(1842)
							// line 1843: glob = ''
							πF.SetLineno(1843)
							µglob = ß.ToObject()
							// line 1844: while not self.finished() and currentcheck():
							πF.SetLineno(1844)
							πF.PushCheckpoint(2)
							πTemp001 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp001 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(!πTemp008).ToObject()
							πTemp003 = πTemp005
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µcurrentcheck, "currentcheck"); πE != nil {
								continue
							}
							if πTemp005, πE = µcurrentcheck.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003 = πTemp005
						Label4:
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πE != nil || !πTemp002 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1845: glob += self.skipcurrent()
							πF.SetLineno(1845)
							if πE = πg.CheckLocal(πF, µglob, "glob"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µglob, πTemp005); πE != nil {
								continue
							}
							µglob = πTemp003
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1846: return glob
							πF.SetLineno(1846)
							if πE = πg.CheckLocal(πF, µglob, "glob"); πE != nil {
								continue
							}
							πR = µglob
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßglob.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 1842: "Glob a bit of text that satisfies a check on the current char."
					πF.SetLineno(1842)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Glob a bit of text that satisfies a check on the current char.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßglob); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 1848: def globalpha(self):
					πF.SetLineno(1848)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("globalpha", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1849: "Glob a bit of alpha text"
							πF.SetLineno(1849)
							// line 1850: return self.glob(lambda: self.current().isalpha())
							πF.SetLineno(1850)
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1850: return self.glob(lambda: self.current().isalpha())
									πF.SetLineno(1850)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßisalpha, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
										continue
									}
									πR = πTemp002
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßglob, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßglobalpha.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 1849: "Glob a bit of alpha text"
					πF.SetLineno(1849)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Glob a bit of alpha text").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßglobalpha); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
					// line 1852: def globnumber(self):
					πF.SetLineno(1852)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("globnumber", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1853: "Glob a row of digits."
							πF.SetLineno(1853)
							// line 1854: return self.glob(lambda: self.current().isdigit())
							πF.SetLineno(1854)
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1854: return self.glob(lambda: self.current().isdigit())
									πF.SetLineno(1854)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßisdigit, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
										continue
									}
									πR = πTemp002
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßglob, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßglobnumber.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 1853: "Glob a row of digits."
					πF.SetLineno(1853)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Glob a row of digits.").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßglobnumber); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
					// line 1856: def isidentifier(self):
					πF.SetLineno(1856)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("isidentifier", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1857: "Return if the current character is alphanumeric or _."
							πF.SetLineno(1857)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßisalnum, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, πTemp005, ß_.ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 1858: if self.current().isalnum() or self.current() == '_':
							πF.SetLineno(1858)
						Label2:
							// line 1859: return True
							πF.SetLineno(1859)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label3
						Label3:
							// line 1860: return False
							πF.SetLineno(1860)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisidentifier.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 1857: "Return if the current character is alphanumeric or _."
					πF.SetLineno(1857)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp013}, πg.NewStr("Return if the current character is alphanumeric or _.").ToObject()); πE != nil {
						continue
					}
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßisidentifier); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp014, ß__doc__, πTemp013); πE != nil {
						continue
					}
					// line 1862: def globidentifier(self):
					πF.SetLineno(1862)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("globidentifier", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1863: "Glob alphanumeric and _ symbols."
							πF.SetLineno(1863)
							// line 1864: return self.glob(self.isidentifier)
							πF.SetLineno(1864)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßisidentifier, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßglob, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßglobidentifier.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 1863: "Glob alphanumeric and _ symbols."
					πF.SetLineno(1863)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp014}, πg.NewStr("Glob alphanumeric and _ symbols.").ToObject()); πE != nil {
						continue
					}
					if πTemp015, πE = πg.ResolveClass(πF, πClass, nil, ßglobidentifier); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp015, ß__doc__, πTemp014); πE != nil {
						continue
					}
					// line 1866: def isvalue(self):
					πF.SetLineno(1866)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("isvalue", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1867: "Return if the current character is a value character:"
							πF.SetLineno(1867)
							// line 1868: "not a bracket or a space."
							πF.SetLineno(1868)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßisspace, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1869: if self.current().isspace():
							πF.SetLineno(1869)
						Label1:
							// line 1870: return False
							πF.SetLineno(1870)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Contains(πF, πg.NewStr("{}()").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 1871: if self.current() in '{}()':
							πF.SetLineno(1871)
						Label3:
							// line 1872: return False
							πF.SetLineno(1872)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 1873: return True
							πF.SetLineno(1873)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisvalue.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 1867: "Return if the current character is a value character:"
					πF.SetLineno(1867)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp015}, πg.NewStr("Return if the current character is a value character:").ToObject()); πE != nil {
						continue
					}
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ßisvalue); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp016, ß__doc__, πTemp015); πE != nil {
						continue
					}
					// line 1875: def globvalue(self):
					πF.SetLineno(1875)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp015 = πg.NewFunction(πg.NewCode("globvalue", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1876: "Glob a value: any symbols but brackets."
							πF.SetLineno(1876)
							// line 1877: return self.glob(self.isvalue)
							πF.SetLineno(1877)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßisvalue, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßglob, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßglobvalue.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 1876: "Glob a value: any symbols but brackets."
					πF.SetLineno(1876)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp016}, πg.NewStr("Glob a value: any symbols but brackets.").ToObject()); πE != nil {
						continue
					}
					if πTemp017, πE = πg.ResolveClass(πF, πClass, nil, ßglobvalue); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp017, ß__doc__, πTemp016); πE != nil {
						continue
					}
					// line 1879: def skipspace(self):
					πF.SetLineno(1879)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp016 = πg.NewFunction(πg.NewCode("skipspace", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1880: "Skip all whitespace at current position."
							πF.SetLineno(1880)
							// line 1881: return self.glob(lambda: self.current().isspace())
							πF.SetLineno(1881)
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1881: return self.glob(lambda: self.current().isspace())
									πF.SetLineno(1881)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßisspace, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
										continue
									}
									πR = πTemp002
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßglob, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßskipspace.ToObject(), πTemp016); πE != nil {
						continue
					}
					// line 1880: "Skip all whitespace at current position."
					πF.SetLineno(1880)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp017}, πg.NewStr("Skip all whitespace at current position.").ToObject()); πE != nil {
						continue
					}
					if πTemp018, πE = πg.ResolveClass(πF, πClass, nil, ßskipspace); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp018, ß__doc__, πTemp017); πE != nil {
						continue
					}
					// line 1883: def globincluding(self, magicchar):
					πF.SetLineno(1883)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "magicchar", Def: nil}
					πTemp017 = πg.NewFunction(πg.NewCode("globincluding", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmagicchar *πg.Object = πArgs[1]
						_ = µmagicchar
						var µglob *πg.Object = πg.UnboundLocal
						_ = µglob
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1884: "Glob a bit of text up to (including) the magic char."
							πF.SetLineno(1884)
							// line 1885: glob = self.glob(lambda: self.current() != magicchar) + magicchar
							πF.SetLineno(1885)
							πTemp002 = πF.MakeArgs(1)
							πTemp004 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1885: glob = self.glob(lambda: self.current() != magicchar) + magicchar
									πF.SetLineno(1885)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µmagicchar, "magicchar"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.NE(πF, πTemp003, µmagicchar); πE != nil {
										continue
									}
									πR = πTemp001
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßglob, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.CheckLocal(πF, µmagicchar, "magicchar"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp005, µmagicchar); πE != nil {
								continue
							}
							µglob = πTemp001
							// line 1886: self.skip(magicchar)
							πF.SetLineno(1886)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmagicchar, "magicchar"); πE != nil {
								continue
							}
							πTemp002[0] = µmagicchar
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 1887: return glob
							πF.SetLineno(1887)
							if πE = πg.CheckLocal(πF, µglob, "glob"); πE != nil {
								continue
							}
							πR = µglob
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßglobincluding.ToObject(), πTemp017); πE != nil {
						continue
					}
					// line 1884: "Glob a bit of text up to (including) the magic char."
					πF.SetLineno(1884)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp018}, πg.NewStr("Glob a bit of text up to (including) the magic char.").ToObject()); πE != nil {
						continue
					}
					if πTemp019, πE = πg.ResolveClass(πF, πClass, nil, ßglobincluding); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp019, ß__doc__, πTemp018); πE != nil {
						continue
					}
					// line 1889: def globexcluding(self, excluded):
					πF.SetLineno(1889)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "excluded", Def: nil}
					πTemp018 = πg.NewFunction(πg.NewCode("globexcluding", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µexcluded *πg.Object = πArgs[1]
						_ = µexcluded
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1890: "Glob a bit of text up until (excluding) any excluded character."
							πF.SetLineno(1890)
							// line 1891: return self.glob(lambda: self.current() not in excluded)
							πF.SetLineno(1891)
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 1891: return self.glob(lambda: self.current() not in excluded)
									πF.SetLineno(1891)
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
										continue
									}
									if πE = πg.CheckLocal(πF, µexcluded, "excluded"); πE != nil {
										continue
									}
									if πTemp004, πE = πg.Contains(πF, µexcluded, πTemp003); πE != nil {
										continue
									}
									πTemp001 = πg.GetBool(!πTemp004).ToObject()
									πR = πTemp001
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßglob, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßglobexcluding.ToObject(), πTemp018); πE != nil {
						continue
					}
					// line 1890: "Glob a bit of text up until (excluding) any excluded character."
					πF.SetLineno(1890)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp019}, πg.NewStr("Glob a bit of text up until (excluding) any excluded character.").ToObject()); πE != nil {
						continue
					}
					if πTemp020, πE = πg.ResolveClass(πF, πClass, nil, ßglobexcluding); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp020, ß__doc__, πTemp019); πE != nil {
						continue
					}
					// line 1893: def pushending(self, ending, optional = False):
					πF.SetLineno(1893)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "ending", Def: nil}
					if πTemp020, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "optional", Def: πTemp020}
					πTemp019 = πg.NewFunction(πg.NewCode("pushending", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µending *πg.Object = πArgs[1]
						_ = µending
						var µoptional *πg.Object = πArgs[2]
						_ = µoptional
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1894: "Push a new ending to the bottom"
							πF.SetLineno(1894)
							// line 1895: self.endinglist.add(ending, optional)
							πF.SetLineno(1895)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp001[0] = µending
							if πE = πg.CheckLocal(πF, µoptional, "optional"); πE != nil {
								continue
							}
							πTemp001[1] = µoptional
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßendinglist, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßadd, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßpushending.ToObject(), πTemp019); πE != nil {
						continue
					}
					// line 1894: "Push a new ending to the bottom"
					πF.SetLineno(1894)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp020}, πg.NewStr("Push a new ending to the bottom").ToObject()); πE != nil {
						continue
					}
					if πTemp021, πE = πg.ResolveClass(πF, πClass, nil, ßpushending); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp021, ß__doc__, πTemp020); πE != nil {
						continue
					}
					// line 1897: def popending(self, expected = None):
					πF.SetLineno(1897)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp021, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "expected", Def: πTemp021}
					πTemp020 = πg.NewFunction(πg.NewCode("popending", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µexpected *πg.Object = πArgs[1]
						_ = µexpected
						var µending *πg.Object = πg.UnboundLocal
						_ = µending
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1898: "Pop the ending found at the current position"
							πF.SetLineno(1898)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßisout, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßleavepending, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 1899: if self.isout() and self.leavepending:
							πF.SetLineno(1899)
						Label2:
							// line 1900: return expected
							πF.SetLineno(1900)
							if πE = πg.CheckLocal(πF, µexpected, "expected"); πE != nil {
								continue
							}
							πR = µexpected
							continue
							goto Label3
						Label3:
							// line 1901: ending = self.endinglist.pop(self)
							πF.SetLineno(1901)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp005[0] = µself
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßendinglist, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßpop, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µending = πTemp001
							if πE = πg.CheckLocal(πF, µexpected, "expected"); πE != nil {
								continue
							}
							πTemp001 = µexpected
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µexpected, "expected"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.NE(πF, µexpected, µending); πE != nil {
								continue
							}
							πTemp001 = πTemp003
						Label4:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label5
							}
							goto Label6
							// line 1902: if expected and expected != ending:
							πF.SetLineno(1902)
						Label5:
							// line 1903: Trace.error('Expected ending ' + expected + ', got ' + ending)
							πF.SetLineno(1903)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µexpected, "expected"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πg.NewStr("Expected ending ").ToObject(), µexpected); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, πg.NewStr(", got ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, µending); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label6
						Label6:
							// line 1904: self.skip(ending)
							πF.SetLineno(1904)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp005[0] = µending
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 1905: return ending
							πF.SetLineno(1905)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πR = µending
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßpopending.ToObject(), πTemp020); πE != nil {
						continue
					}
					// line 1898: "Pop the ending found at the current position"
					πF.SetLineno(1898)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp021}, πg.NewStr("Pop the ending found at the current position").ToObject()); πE != nil {
						continue
					}
					if πTemp022, πE = πg.ResolveClass(πF, πClass, nil, ßpopending); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp022, ß__doc__, πTemp021); πE != nil {
						continue
					}
					// line 1907: def nextending(self):
					πF.SetLineno(1907)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp021 = πg.NewFunction(πg.NewCode("nextending", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µnextending *πg.Object = πg.UnboundLocal
						_ = µnextending
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1908: "Return the next ending in the queue."
							πF.SetLineno(1908)
							// line 1909: nextending = self.endinglist.findending(self)
							πF.SetLineno(1909)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßendinglist, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßfindending, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µnextending = πTemp002
							if πE = πg.CheckLocal(πF, µnextending, "nextending"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µnextending); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1910: if not nextending:
							πF.SetLineno(1910)
						Label1:
							// line 1911: return None
							πF.SetLineno(1911)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 1912: return nextending.ending
							πF.SetLineno(1912)
							if πE = πg.CheckLocal(πF, µnextending, "nextending"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µnextending, ßending, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßnextending.ToObject(), πTemp021); πE != nil {
						continue
					}
					// line 1908: "Return the next ending in the queue."
					πF.SetLineno(1908)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp022}, πg.NewStr("Return the next ending in the queue.").ToObject()); πE != nil {
						continue
					}
					if πTemp023, πE = πg.ResolveClass(πF, πClass, nil, ßnextending); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp023, ß__doc__, πTemp022); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Globable").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßGlobable.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1914: class EndingList(object):
			πF.SetLineno(1914)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("EndingList", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 bool
				_ = πTemp013
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1915: "A list of position endings"
					πF.SetLineno(1915)
					// line 1915: "A list of position endings"
					πF.SetLineno(1915)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A list of position endings").ToObject()); πE != nil {
						continue
					}
					// line 1917: def __init__(self):
					πF.SetLineno(1917)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1918: self.endings = []
							πF.SetLineno(1918)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßendings, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1920: def add(self, ending, optional = False):
					πF.SetLineno(1920)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "ending", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "optional", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("add", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µending *πg.Object = πArgs[1]
						_ = µending
						var µoptional *πg.Object = πArgs[2]
						_ = µoptional
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1921: "Add a new ending to the list"
							πF.SetLineno(1921)
							// line 1922: self.endings.append(PositionEnding(ending, optional))
							πF.SetLineno(1922)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp002[0] = µending
							if πE = πg.CheckLocal(πF, µoptional, "optional"); πE != nil {
								continue
							}
							πTemp002[1] = µoptional
							if πTemp003, πE = πg.ResolveGlobal(πF, ßPositionEnding); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1921: "Add a new ending to the list"
					πF.SetLineno(1921)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Add a new ending to the list").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßadd); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1924: def pickpending(self, pos):
					πF.SetLineno(1924)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("pickpending", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1925: "Pick any pending endings from a parse position."
							πF.SetLineno(1925)
							// line 1926: self.endings += pos.endinglist.endings
							πF.SetLineno(1926)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßendinglist, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßendings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßendings, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßpickpending.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1925: "Pick any pending endings from a parse position."
					πF.SetLineno(1925)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Pick any pending endings from a parse position.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßpickpending); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 1928: def checkin(self, pos):
					πF.SetLineno(1928)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("checkin", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1929: "Search for an ending"
							πF.SetLineno(1929)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfindending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1930: if self.findending(pos):
							πF.SetLineno(1930)
						Label1:
							// line 1931: return True
							πF.SetLineno(1931)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 1932: return False
							πF.SetLineno(1932)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckin.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1929: "Search for an ending"
					πF.SetLineno(1929)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Search for an ending").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßcheckin); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 1934: def pop(self, pos):
					πF.SetLineno(1934)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("pop", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µending *πg.Object = πg.UnboundLocal
						_ = µending
						var µeach *πg.Object = πg.UnboundLocal
						_ = µeach
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 5:
								goto Label5
							case 6:
								goto Label6
							default:
								panic("unexpected function state")
							}
							// line 1935: "Remove the ending at the current position"
							πF.SetLineno(1935)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßisout, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1936: if pos.isout():
							πF.SetLineno(1936)
						Label1:
							// line 1937: Trace.error('No ending out of bounds')
							πF.SetLineno(1937)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("No ending out of bounds").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1938: return ''
							πF.SetLineno(1938)
							πR = ß.ToObject()
							continue
							goto Label2
						Label2:
							// line 1939: ending = self.findending(pos)
							πF.SetLineno(1939)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp004[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfindending, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µending = πTemp002
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, µending); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 1940: if not ending:
							πF.SetLineno(1940)
						Label3:
							// line 1941: Trace.error('No ending at ' + pos.current())
							πF.SetLineno(1941)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("No ending at ").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1942: return ''
							πF.SetLineno(1942)
							πR = ß.ToObject()
							continue
							goto Label4
						Label4:
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßreversed); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(6)
							πTemp003 = false
						Label5:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label7
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µeach = πTemp002
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(5)
							// line 1944: self.endings.remove(each)
							πF.SetLineno(1944)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µeach, "each"); πE != nil {
								continue
							}
							πTemp004[0] = µeach
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßremove, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µeach, "each"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µeach, µending); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µeach, "each"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µeach, ßoptional, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label9
							}
							goto Label10
							// line 1945: if each == ending:
							πF.SetLineno(1945)
						Label8:
							// line 1946: return each.ending
							πF.SetLineno(1946)
							if πE = πg.CheckLocal(πF, µeach, "each"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µeach, ßending, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label10
							// line 1947: elif not each.optional:
							πF.SetLineno(1947)
						Label9:
							// line 1948: Trace.error('Removed non-optional ending ' + each)
							πF.SetLineno(1948)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µeach, "each"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Removed non-optional ending ").ToObject(), µeach); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label10
						Label10:
							continue
						Label6:
							if πE != nil || πR != nil {
								continue
							}
						Label7:
							// line 1949: Trace.error('No endings left')
							πF.SetLineno(1949)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("No endings left").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1950: return ''
							πF.SetLineno(1950)
							πR = ß.ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßpop.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 1935: "Remove the ending at the current position"
					πF.SetLineno(1935)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Remove the ending at the current position").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßpop); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 1952: def findending(self, pos):
					πF.SetLineno(1952)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("findending", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var µending *πg.Object = πg.UnboundLocal
						_ = µending
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 1953: "Find the ending at the current position"
							πF.SetLineno(1953)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1954: if len(self.endings) == 0:
							πF.SetLineno(1954)
						Label1:
							// line 1955: return None
							πF.SetLineno(1955)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							πTemp002 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßreversed); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp002[0] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßenumerate); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp005 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp008}}}, πTemp003); πE != nil {
									continue
								}
								µindex = πTemp004
								µending = πTemp008
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(3)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[0] = µpos
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µending, ßcheckin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label6
							}
							goto Label7
							// line 1957: if ending.checkin(pos):
							πF.SetLineno(1957)
						Label6:
							// line 1958: return ending
							πF.SetLineno(1958)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πR = µending
							continue
							goto Label7
						Label7:
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µending, ßoptional, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label8
							}
							goto Label9
							// line 1959: if not ending.optional:
							πF.SetLineno(1959)
						Label8:
							// line 1960: return None
							πF.SetLineno(1960)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label9
						Label9:
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							// line 1961: return None
							πF.SetLineno(1961)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfindending.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 1953: "Find the ending at the current position"
					πF.SetLineno(1953)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Find the ending at the current position").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßfindending); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 1963: def checkpending(self):
					πF.SetLineno(1963)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("checkpending", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1964: "Check if there are any pending endings"
							πF.SetLineno(1964)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.NE(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1965: if len(self.endings) != 0:
							πF.SetLineno(1965)
						Label1:
							// line 1966: Trace.error('Pending ' + unicode(self) + ' left open')
							πF.SetLineno(1966)
							πTemp002 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp006[0] = µself
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Pending ").ToObject(), πTemp007); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr(" left open").ToObject()); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckpending.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 1964: "Check if there are any pending endings"
					πF.SetLineno(1964)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Check if there are any pending endings").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßcheckpending); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 1968: def __unicode__(self):
					πF.SetLineno(1968)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πg.UnboundLocal
						_ = µstring
						var µending *πg.Object = πg.UnboundLocal
						_ = µending
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1969: "Printable representation"
							πF.SetLineno(1969)
							// line 1970: string = 'endings ['
							πF.SetLineno(1970)
							µstring = πg.NewStr("endings [").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µending = πTemp002
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1972: string += unicode(ending) + ','
							πF.SetLineno(1972)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp005[0] = µending
							if πTemp006, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp002, πE = πg.Add(πF, πTemp007, πg.NewStr(",").ToObject()); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IAdd(πF, µstring, πTemp002); πE != nil {
								continue
							}
							µstring = πTemp006
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßendings, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.GT(πF, πTemp006, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 1973: if len(self.endings) > 0:
							πF.SetLineno(1973)
						Label4:
							// line 1974: string = string[:-1]
							πF.SetLineno(1974)
							if πTemp002, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp002, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							µstring = πTemp002
							goto Label5
						Label5:
							// line 1975: return string + ']'
							πF.SetLineno(1975)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µstring, πg.NewStr("]").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 1969: "Printable representation"
					πF.SetLineno(1969)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Printable representation").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp012, πE = πg.GetAttr(πF, πTemp011, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp011 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp010, πE = πg.GE(πF, πTemp012, πTemp011); πE != nil {
						continue
					}
					if πTemp013, πE = πg.IsTrue(πF, πTemp010); πE != nil {
						continue
					}
					if πTemp013 {
						goto Label1
					}
					goto Label2
					// line 1977: if sys.version_info >= (3, 0):
					πF.SetLineno(1977)
				Label1:
					// line 1978: __str__ = __unicode__
					πF.SetLineno(1978)
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp010); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("EndingList").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßEndingList.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 1981: class PositionEnding(object):
			πF.SetLineno(1981)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("PositionEnding", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 bool
				_ = πTemp008
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1982: "An ending for a parsing position"
					πF.SetLineno(1982)
					// line 1982: "An ending for a parsing position"
					πF.SetLineno(1982)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("An ending for a parsing position").ToObject()); πE != nil {
						continue
					}
					// line 1984: def __init__(self, ending, optional):
					πF.SetLineno(1984)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "ending", Def: nil}
					πTemp002[2] = πg.Param{Name: "optional", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µending *πg.Object = πArgs[1]
						_ = µending
						var µoptional *πg.Object = πArgs[2]
						_ = µoptional
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1985: self.ending = ending
							πF.SetLineno(1985)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µending); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßending, πTemp001); πE != nil {
								continue
							}
							// line 1986: self.optional = optional
							πF.SetLineno(1986)
							if πE = πg.CheckLocal(πF, µoptional, "optional"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µoptional); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoptional, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1988: def checkin(self, pos):
					πF.SetLineno(1988)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("checkin", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1989: "Check for the ending"
							πF.SetLineno(1989)
							// line 1990: return pos.checkfor(self.ending)
							πF.SetLineno(1990)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckfor, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckin.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 1989: "Check for the ending"
					πF.SetLineno(1989)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Check for the ending").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßcheckin); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 1992: def __unicode__(self):
					πF.SetLineno(1992)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πg.UnboundLocal
						_ = µstring
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1993: "Printable representation"
							πF.SetLineno(1993)
							// line 1994: string = 'Ending ' + self.ending
							πF.SetLineno(1994)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Ending ").ToObject(), πTemp002); πE != nil {
								continue
							}
							µstring = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoptional, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1995: if self.optional:
							πF.SetLineno(1995)
						Label1:
							// line 1996: string += ' (optional)'
							πF.SetLineno(1996)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µstring, πg.NewStr(" (optional)").ToObject()); πE != nil {
								continue
							}
							µstring = πTemp001
							goto Label2
						Label2:
							// line 1997: return string
							πF.SetLineno(1997)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πR = µstring
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 1993: "Printable representation"
					πF.SetLineno(1993)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Printable representation").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp006 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp005, πE = πg.GE(πF, πTemp007, πTemp006); πE != nil {
						continue
					}
					if πTemp008, πE = πg.IsTrue(πF, πTemp005); πE != nil {
						continue
					}
					if πTemp008 {
						goto Label1
					}
					goto Label2
					// line 1999: if sys.version_info >= (3, 0):
					πF.SetLineno(1999)
				Label1:
					// line 2000: __str__ = __unicode__
					πF.SetLineno(2000)
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp005); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("PositionEnding").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßPositionEnding.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2003: class Position(Globable):
			πF.SetLineno(2003)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßGlobable); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Position", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 bool
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2004: """A position in a text to parse.
					πF.SetLineno(2004)
					// line 2004: """A position in a text to parse.
					πF.SetLineno(2004)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A position in a text to parse.\n  Including those in Globable, functions to implement by subclasses are:\n  skip(), identifier(), extract(), isout() and current().").ToObject()); πE != nil {
						continue
					}
					// line 2008: def __init__(self):
					πF.SetLineno(2008)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2009: Globable.__init__(self)
							πF.SetLineno(2009)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßGlobable); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2011: def skip(self, string):
					πF.SetLineno(2011)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("skip", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2012: "Skip a string"
							πF.SetLineno(2012)
							// line 2013: Trace.error('Unimplemented skip()')
							πF.SetLineno(2013)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Unimplemented skip()").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßskip.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2012: "Skip a string"
					πF.SetLineno(2012)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Skip a string").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßskip); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2015: def identifier(self):
					πF.SetLineno(2015)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("identifier", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2016: "Return an identifier for the current position."
							πF.SetLineno(2016)
							// line 2017: Trace.error('Unimplemented identifier()')
							πF.SetLineno(2017)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Unimplemented identifier()").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2018: return 'Error'
							πF.SetLineno(2018)
							πR = ßError.ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßidentifier.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2016: "Return an identifier for the current position."
					πF.SetLineno(2016)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Return an identifier for the current position.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßidentifier); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2020: def extract(self, length):
					πF.SetLineno(2020)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "length", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("extract", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlength *πg.Object = πArgs[1]
						_ = µlength
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2021: "Extract the next string of the given length, or None if not enough text,"
							πF.SetLineno(2021)
							// line 2022: "without advancing the parse position."
							πF.SetLineno(2022)
							// line 2023: Trace.error('Unimplemented extract()')
							πF.SetLineno(2023)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Unimplemented extract()").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2024: return None
							πF.SetLineno(2024)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßextract.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2021: "Extract the next string of the given length, or None if not enough text,"
					πF.SetLineno(2021)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Extract the next string of the given length, or None if not enough text,").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßextract); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 2026: def checkfor(self, string):
					πF.SetLineno(2026)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("checkfor", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2027: "Check for a string at the given position."
							πF.SetLineno(2027)
							// line 2028: return string == self.extract(len(string))
							πF.SetLineno(2028)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp003[0] = µstring
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp002[0] = πTemp005
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßextract, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Eq(πF, µstring, πTemp005); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckfor.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2027: "Check for a string at the given position."
					πF.SetLineno(2027)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Check for a string at the given position.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßcheckfor); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2030: def checkforlower(self, string):
					πF.SetLineno(2030)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("checkforlower", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var µextracted *πg.Object = πg.UnboundLocal
						_ = µextracted
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2031: "Check for a string in lower case."
							πF.SetLineno(2031)
							// line 2032: extracted = self.extract(len(string))
							πF.SetLineno(2032)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp002[0] = µstring
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßextract, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µextracted = πTemp004
							if πE = πg.CheckLocal(πF, µextracted, "extracted"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µextracted); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2033: if not extracted:
							πF.SetLineno(2033)
						Label1:
							// line 2034: return False
							πF.SetLineno(2034)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label2
						Label2:
							// line 2035: return string.lower() == self.extract(len(string)).lower()
							πF.SetLineno(2035)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µstring, ßlower, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp002[0] = µstring
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp007
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßextract, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.GetAttr(πF, πTemp007, ßlower, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, πTemp006, πTemp007); πE != nil {
								continue
							}
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckforlower.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2031: "Check for a string in lower case."
					πF.SetLineno(2031)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Check for a string in lower case.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßcheckforlower); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 2037: def skipcurrent(self):
					πF.SetLineno(2037)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("skipcurrent", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcurrent *πg.Object = πg.UnboundLocal
						_ = µcurrent
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2038: "Return the current character and skip it."
							πF.SetLineno(2038)
							// line 2039: current = self.current()
							πF.SetLineno(2039)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µcurrent = πTemp002
							// line 2040: self.skip(current)
							πF.SetLineno(2040)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							πTemp003[0] = µcurrent
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßskip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2041: return current
							πF.SetLineno(2041)
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							πR = µcurrent
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßskipcurrent.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 2038: "Return the current character and skip it."
					πF.SetLineno(2038)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Return the current character and skip it.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßskipcurrent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 2043: def __next__(self):
					πF.SetLineno(2043)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("__next__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2044: "Advance the position and return the next character."
							πF.SetLineno(2044)
							// line 2045: self.skipcurrent()
							πF.SetLineno(2045)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2046: return self.current()
							πF.SetLineno(2046)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__next__.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 2044: "Advance the position and return the next character."
					πF.SetLineno(2044)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Advance the position and return the next character.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ß__next__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp012, πE = πg.GetAttr(πF, πTemp011, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp011 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp010, πE = πg.LT(πF, πTemp012, πTemp011); πE != nil {
						continue
					}
					if πTemp013, πE = πg.IsTrue(πF, πTemp010); πE != nil {
						continue
					}
					if πTemp013 {
						goto Label1
					}
					goto Label2
					// line 2048: if sys.version_info < (3, 0):
					πF.SetLineno(2048)
				Label1:
					// line 2049: next = __next__
					πF.SetLineno(2049)
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ß__next__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßnext.ToObject(), πTemp010); πE != nil {
						continue
					}
					goto Label2
				Label2:
					// line 2051: def checkskip(self, string):
					πF.SetLineno(2051)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("checkskip", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2052: "Check for a string at the given position; if there, skip it"
							πF.SetLineno(2052)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp002[0] = µstring
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcheckfor, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2053: if not self.checkfor(string):
							πF.SetLineno(2053)
						Label1:
							// line 2054: return False
							πF.SetLineno(2054)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 2055: self.skip(string)
							πF.SetLineno(2055)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp002[0] = µstring
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 2056: return True
							πF.SetLineno(2056)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckskip.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 2052: "Check for a string at the given position; if there, skip it"
					πF.SetLineno(2052)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Check for a string at the given position; if there, skip it").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßcheckskip); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
					// line 2058: def error(self, message):
					πF.SetLineno(2058)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "message", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("error", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmessage *πg.Object = πArgs[1]
						_ = µmessage
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2059: "Show an error message and the position identifier."
							πF.SetLineno(2059)
							// line 2060: Trace.error(message + ': ' + self.identifier())
							πF.SetLineno(2060)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µmessage, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßidentifier, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßerror.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 2059: "Show an error message and the position identifier."
					πF.SetLineno(2059)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Show an error message and the position identifier.").ToObject()); πE != nil {
						continue
					}
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßerror); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp014, ß__doc__, πTemp012); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Position").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßPosition.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2062: class TextPosition(Position):
			πF.SetLineno(2062)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßPosition); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TextPosition", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2063: "A parse position based on a raw text."
					πF.SetLineno(2063)
					// line 2063: "A parse position based on a raw text."
					πF.SetLineno(2063)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parse position based on a raw text.").ToObject()); πE != nil {
						continue
					}
					// line 2065: def __init__(self, text):
					πF.SetLineno(2065)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2066: "Create the position from elyxer.some text."
							πF.SetLineno(2066)
							// line 2067: Position.__init__(self)
							πF.SetLineno(2067)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßPosition); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2068: self.pos = 0
							πF.SetLineno(2068)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßpos, πTemp002); πE != nil {
								continue
							}
							// line 2069: self.text = text
							πF.SetLineno(2069)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µtext); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtext, πTemp002); πE != nil {
								continue
							}
							// line 2070: self.checkbytemark()
							πF.SetLineno(2070)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcheckbytemark, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2066: "Create the position from elyxer.some text."
					πF.SetLineno(2066)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Create the position from elyxer.some text.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2072: def skip(self, string):
					πF.SetLineno(2072)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("skip", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2073: "Skip a string of characters."
							πF.SetLineno(2073)
							// line 2074: self.pos += len(string)
							πF.SetLineno(2074)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp002[0] = µstring
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.IAdd(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßpos, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßskip.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2073: "Skip a string of characters."
					πF.SetLineno(2073)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Skip a string of characters.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßskip); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2076: def identifier(self):
					πF.SetLineno(2076)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("identifier", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlength *πg.Object = πg.UnboundLocal
						_ = µlength
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2077: "Return a sample of the remaining text."
							πF.SetLineno(2077)
							// line 2078: length = 30
							πF.SetLineno(2078)
							µlength = πg.NewInt(30).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, µlength); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtext, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.GT(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 2079: if self.pos + length > len(self.text):
							πF.SetLineno(2079)
						Label1:
							// line 2080: length = len(self.text) - self.pos
							πF.SetLineno(2080)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtext, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp003, πTemp002); πE != nil {
								continue
							}
							µlength = πTemp001
							goto Label2
						Label2:
							// line 2081: return '*' + self.text[self.pos:self.pos + length] + '*'
							πF.SetLineno(2081)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Add(πF, πTemp008, µlength); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πTemp005, πTemp007, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßtext, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp007, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("*").ToObject(), πTemp005); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßidentifier.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2077: "Return a sample of the remaining text."
					πF.SetLineno(2077)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Return a sample of the remaining text.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßidentifier); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2083: def isout(self):
					πF.SetLineno(2083)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("isout", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2084: "Find out if we are out of the text yet."
							πF.SetLineno(2084)
							// line 2085: return self.pos >= len(self.text)
							πF.SetLineno(2085)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßtext, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.GE(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisout.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2084: "Find out if we are out of the text yet."
					πF.SetLineno(2084)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Find out if we are out of the text yet.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßisout); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 2087: def current(self):
					πF.SetLineno(2087)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("current", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2088: "Return the current character, assuming we are not out."
							πF.SetLineno(2088)
							// line 2089: return self.text[self.pos]
							πF.SetLineno(2089)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtext, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcurrent.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2088: "Return the current character, assuming we are not out."
					πF.SetLineno(2088)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Return the current character, assuming we are not out.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßcurrent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2091: def extract(self, length):
					πF.SetLineno(2091)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "length", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("extract", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlength *πg.Object = πArgs[1]
						_ = µlength
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2092: "Extract the next string of the given length, or None if not enough text."
							πF.SetLineno(2092)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, µlength); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtext, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.GT(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 2093: if self.pos + length > len(self.text):
							πF.SetLineno(2093)
						Label1:
							// line 2094: return None
							πF.SetLineno(2094)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 2095: return self.text[self.pos : self.pos + length]
							πF.SetLineno(2095)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp005, µlength); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp002, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtext, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßextract.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2092: "Extract the next string of the given length, or None if not enough text."
					πF.SetLineno(2092)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Extract the next string of the given length, or None if not enough text.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßextract); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TextPosition").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTextPosition.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2097: class FilePosition(Position):
			πF.SetLineno(2097)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßPosition); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FilePosition", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2098: "A parse position based on an underlying file."
					πF.SetLineno(2098)
					// line 2098: "A parse position based on an underlying file."
					πF.SetLineno(2098)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parse position based on an underlying file.").ToObject()); πE != nil {
						continue
					}
					// line 2100: def __init__(self, filename):
					πF.SetLineno(2100)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "filename", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µfilename *πg.Object = πArgs[1]
						_ = µfilename
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2101: "Create the position from a file."
							πF.SetLineno(2101)
							// line 2102: Position.__init__(self)
							πF.SetLineno(2102)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßPosition); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2103: self.reader = LineReader(filename)
							πF.SetLineno(2103)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfilename, "filename"); πE != nil {
								continue
							}
							πTemp001[0] = µfilename
							if πTemp002, πE = πg.ResolveGlobal(πF, ßLineReader); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßreader, πTemp002); πE != nil {
								continue
							}
							// line 2104: self.pos = 0
							πF.SetLineno(2104)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßpos, πTemp002); πE != nil {
								continue
							}
							// line 2105: self.checkbytemark()
							πF.SetLineno(2105)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcheckbytemark, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2101: "Create the position from a file."
					πF.SetLineno(2101)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Create the position from a file.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2107: def skip(self, string):
					πF.SetLineno(2107)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("skip", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var µlength *πg.Object = πg.UnboundLocal
						_ = µlength
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2108: "Skip a string of characters."
							πF.SetLineno(2108)
							// line 2109: length = len(string)
							πF.SetLineno(2109)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp001[0] = µstring
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µlength = πTemp003
							// line 2110: while self.pos + length > len(self.reader.currentline()):
							πF.SetLineno(2110)
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp006, µlength); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp007.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp006
							if πTemp006, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GT(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2111: length -= len(self.reader.currentline()) - self.pos + 1
							πF.SetLineno(2111)
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp007.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp006
							if πTemp006, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Sub(πF, πTemp007, πTemp006); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ISub(πF, µlength, πTemp002); πE != nil {
								continue
							}
							µlength = πTemp003
							// line 2112: self.nextline()
							πF.SetLineno(2112)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2113: self.pos += length
							πF.SetLineno(2113)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µlength); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßpos, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßskip.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2108: "Skip a string of characters."
					πF.SetLineno(2108)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Skip a string of characters.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßskip); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2115: def currentline(self):
					πF.SetLineno(2115)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("currentline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2116: "Get the current line of the underlying file."
							πF.SetLineno(2116)
							// line 2117: return self.reader.currentline()
							πF.SetLineno(2117)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcurrentline.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2116: "Get the current line of the underlying file."
					πF.SetLineno(2116)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Get the current line of the underlying file.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßcurrentline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2119: def nextline(self):
					πF.SetLineno(2119)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("nextline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2120: "Go to the next line."
							πF.SetLineno(2120)
							// line 2121: self.reader.nextline()
							πF.SetLineno(2121)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2122: self.pos = 0
							πF.SetLineno(2122)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßpos, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßnextline.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2120: "Go to the next line."
					πF.SetLineno(2120)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Go to the next line.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßnextline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 2124: def linenumber(self):
					πF.SetLineno(2124)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("linenumber", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2125: "Return the line number of the file."
							πF.SetLineno(2125)
							// line 2126: return self.reader.linenumber + 1
							πF.SetLineno(2126)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßlinenumber, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßlinenumber.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2125: "Return the line number of the file."
					πF.SetLineno(2125)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Return the line number of the file.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßlinenumber); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2128: def identifier(self):
					πF.SetLineno(2128)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("identifier", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbefore *πg.Object = πg.UnboundLocal
						_ = µbefore
						var µafter *πg.Object = πg.UnboundLocal
						_ = µafter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2129: "Return the current line and line number in the file."
							πF.SetLineno(2129)
							// line 2130: before = self.reader.currentline()[:self.pos - 1]
							πF.SetLineno(2130)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Sub(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp002, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µbefore = πTemp002
							// line 2131: after = self.reader.currentline()[self.pos:]
							πF.SetLineno(2131)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp002, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µafter = πTemp002
							// line 2132: return 'line ' + unicode(self.getlinenumber()) + ': ' + before + '*' + after
							πF.SetLineno(2132)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßgetlinenumber, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp008
							if πTemp007, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp005, πE = πg.Add(πF, πg.NewStr("line ").ToObject(), πTemp008); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp005, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, µbefore); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µafter, "after"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µafter); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßidentifier.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2129: "Return the current line and line number in the file."
					πF.SetLineno(2129)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Return the current line and line number in the file.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßidentifier); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 2134: def isout(self):
					πF.SetLineno(2134)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("isout", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2135: "Find out if we are out of the text yet."
							πF.SetLineno(2135)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.GT(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 2136: if self.pos > len(self.reader.currentline()):
							πF.SetLineno(2136)
						Label1:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp005, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp007.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.Add(πF, πTemp007, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GT(πF, πTemp002, πTemp004); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label3
							}
							goto Label4
							// line 2137: if self.pos > len(self.reader.currentline()) + 1:
							πF.SetLineno(2137)
						Label3:
							// line 2138: Trace.error('Out of the line ' + self.reader.currentline() + ': ' + unicode(self.pos))
							πF.SetLineno(2138)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp005, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp007.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πg.NewStr("Out of the line ").ToObject(), πTemp005); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp004, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label4
						Label4:
							// line 2139: self.nextline()
							πF.SetLineno(2139)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 2140: return self.reader.finished()
							πF.SetLineno(2140)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisout.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 2135: "Find out if we are out of the text yet."
					πF.SetLineno(2135)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Find out if we are out of the text yet.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßisout); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 2142: def current(self):
					πF.SetLineno(2142)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("current", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2143: "Return the current character, assuming we are not out."
							πF.SetLineno(2143)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Eq(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 2144: if self.pos == len(self.reader.currentline()):
							πF.SetLineno(2144)
						Label1:
							// line 2145: return '\n'
							πF.SetLineno(2145)
							πR = πg.NewStr("\n").ToObject()
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.GT(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label3
							}
							goto Label4
							// line 2146: if self.pos > len(self.reader.currentline()):
							πF.SetLineno(2146)
						Label3:
							// line 2147: Trace.error('Out of the line ' + self.reader.currentline() + ': ' + unicode(self.pos))
							πF.SetLineno(2147)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp005, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp007.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πg.NewStr("Out of the line ").ToObject(), πTemp005); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp004, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2148: return '*'
							πF.SetLineno(2148)
							πR = πg.NewStr("*").ToObject()
							continue
							goto Label4
						Label4:
							// line 2149: return self.reader.currentline()[self.pos]
							πF.SetLineno(2149)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcurrent.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 2143: "Return the current character, assuming we are not out."
					πF.SetLineno(2143)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Return the current character, assuming we are not out.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßcurrent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 2151: def extract(self, length):
					πF.SetLineno(2151)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "length", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("extract", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlength *πg.Object = πArgs[1]
						_ = µlength
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2152: "Extract the next string of the given length, or None if not enough text."
							πF.SetLineno(2152)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, µlength); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.GT(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 2153: if self.pos + length > len(self.reader.currentline()):
							πF.SetLineno(2153)
						Label1:
							// line 2154: return None
							πF.SetLineno(2154)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 2155: return self.reader.currentline()[self.pos : self.pos + length]
							πF.SetLineno(2155)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßpos, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp005, µlength); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp002, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreader, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßextract.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 2152: "Extract the next string of the given length, or None if not enough text."
					πF.SetLineno(2152)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Extract the next string of the given length, or None if not enough text.").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßextract); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FilePosition").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFilePosition.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2159: class Container(object):
			πF.SetLineno(2159)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Container", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				var πTemp019 *πg.Object
				_ = πTemp019
				var πTemp020 *πg.Object
				_ = πTemp020
				var πTemp021 *πg.Object
				_ = πTemp021
				var πTemp022 *πg.Object
				_ = πTemp022
				var πTemp023 *πg.Object
				_ = πTemp023
				var πTemp024 bool
				_ = πTemp024
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2160: "A container for text and objects in a lyx file"
					πF.SetLineno(2160)
					// line 2160: "A container for text and objects in a lyx file"
					πF.SetLineno(2160)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A container for text and objects in a lyx file").ToObject()); πE != nil {
						continue
					}
					// line 2162: partkey = None
					πF.SetLineno(2162)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßpartkey.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2163: parent = None
					πF.SetLineno(2163)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßparent.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2164: begin = None
					πF.SetLineno(2164)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßbegin.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2166: def __init__(self):
					πF.SetLineno(2166)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2167: self.contents = list()
							πF.SetLineno(2167)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2169: def process(self):
					πF.SetLineno(2169)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2170: "Process contents"
							πF.SetLineno(2170)
							// line 2171: pass
							πF.SetLineno(2171)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2170: "Process contents"
					πF.SetLineno(2170)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Process contents").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2173: def gethtml(self):
					πF.SetLineno(2173)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("gethtml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µhtml *πg.Object = πg.UnboundLocal
						_ = µhtml
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2174: "Get the resulting HTML"
							πF.SetLineno(2174)
							// line 2175: html = self.output.gethtml(self)
							πF.SetLineno(2175)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßgethtml, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µhtml = πTemp002
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							πTemp001[0] = µhtml
							if πTemp002, πE = πg.ResolveGlobal(πF, ßbasestring); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 2176: if isinstance(html, basestring):
							πF.SetLineno(2176)
						Label1:
							// line 2177: Trace.error('Raw string ' + html)
							πF.SetLineno(2177)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Raw string ").ToObject(), µhtml); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2178: html = [html]
							πF.SetLineno(2178)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							πTemp001[0] = µhtml
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µhtml = πTemp002
							goto Label2
						Label2:
							// line 2179: return self.escapeall(html)
							πF.SetLineno(2179)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µhtml, "html"); πE != nil {
								continue
							}
							πTemp001[0] = µhtml
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßescapeall, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgethtml.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2174: "Get the resulting HTML"
					πF.SetLineno(2174)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Get the resulting HTML").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßgethtml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2181: def escapeall(self, lines):
					πF.SetLineno(2181)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "lines", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("escapeall", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlines *πg.Object = πArgs[1]
						_ = µlines
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2182: "Escape all lines in an array according to the output options."
							πF.SetLineno(2182)
							// line 2183: result = []
							πF.SetLineno(2183)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µresult = πTemp002
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µlines); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp005, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µline = πTemp005
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßhtml, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 2185: if Options.html:
							πF.SetLineno(2185)
						Label4:
							// line 2186: line = self.escape(line, EscapeConfig.html)
							πF.SetLineno(2186)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πTemp005, πE = πg.ResolveGlobal(πF, ßEscapeConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßhtml, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp006
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßescape, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µline = πTemp006
							goto Label5
						Label5:
							if πTemp005, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßiso885915, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							if πTemp006, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßunicode, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label7
							}
							goto Label8
							// line 2187: if Options.iso885915:
							πF.SetLineno(2187)
						Label6:
							// line 2188: line = self.escape(line, EscapeConfig.iso885915)
							πF.SetLineno(2188)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πTemp005, πE = πg.ResolveGlobal(πF, ßEscapeConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßiso885915, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp006
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßescape, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µline = πTemp006
							// line 2189: line = self.escapeentities(line)
							πF.SetLineno(2189)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßescapeentities, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µline = πTemp006
							goto Label8
							// line 2190: elif not Options.unicode:
							πF.SetLineno(2190)
						Label7:
							// line 2191: line = self.escape(line, EscapeConfig.nonunicode)
							πF.SetLineno(2191)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πTemp005, πE = πg.ResolveGlobal(πF, ßEscapeConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßnonunicode, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp006
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßescape, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µline = πTemp006
							goto Label8
						Label8:
							// line 2192: result.append(line)
							πF.SetLineno(2192)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2193: return result
							πF.SetLineno(2193)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßescapeall.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2182: "Escape all lines in an array according to the output options."
					πF.SetLineno(2182)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Escape all lines in an array according to the output options.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßescapeall); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 2195: def escape(self, line, replacements = EscapeConfig.entities):
					πF.SetLineno(2195)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "line", Def: nil}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßEscapeConfig); πE != nil {
						continue
					}
					if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßentities, nil); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "replacements", Def: πTemp008}
					πTemp006 = πg.NewFunction(πg.NewCode("escape", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µline *πg.Object = πArgs[1]
						_ = µline
						var µreplacements *πg.Object = πArgs[2]
						_ = µreplacements
						var µpieces *πg.Object = πg.UnboundLocal
						_ = µpieces
						var µpiece *πg.Object = πg.UnboundLocal
						_ = µpiece
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2196: "Escape a line with replacements from elyxer.a map"
							πF.SetLineno(2196)
							// line 2197: pieces = sorted(replacements.keys())
							πF.SetLineno(2197)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreplacements, "replacements"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreplacements, ßkeys, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsorted); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µpieces = πTemp003
							if πE = πg.CheckLocal(πF, µpieces, "pieces"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µpieces); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µpiece = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µpiece, "piece"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µline, µpiece); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 2200: if piece in line:
							πF.SetLineno(2200)
						Label4:
							// line 2201: line = line.replace(piece, replacements[piece])
							πF.SetLineno(2201)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpiece, "piece"); πE != nil {
								continue
							}
							πTemp001[0] = µpiece
							if πE = πg.CheckLocal(πF, µpiece, "piece"); πE != nil {
								continue
							}
							πTemp003 = µpiece
							if πE = πg.CheckLocal(πF, µreplacements, "replacements"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µreplacements, πTemp003); πE != nil {
								continue
							}
							πTemp001[1] = πTemp006
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µline, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µline = πTemp006
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2202: return line
							πF.SetLineno(2202)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πR = µline
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßescape.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2196: "Escape a line with replacements from elyxer.a map"
					πF.SetLineno(2196)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Escape a line with replacements from elyxer.a map").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßescape); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2204: def escapeentities(self, line):
					πF.SetLineno(2204)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "line", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("escapeentities", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µline *πg.Object = πArgs[1]
						_ = µline
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µpos *πg.Object = πg.UnboundLocal
						_ = µpos
						var µcodepoint *πg.Object = πg.UnboundLocal
						_ = µcodepoint
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2205: "Escape all Unicode characters to HTML entities."
							πF.SetLineno(2205)
							// line 2206: result = ''
							πF.SetLineno(2206)
							µresult = ß.ToObject()
							// line 2207: pos = TextPosition(line)
							πF.SetLineno(2207)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTextPosition); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µpos = πTemp003
							// line 2208: while not pos.finished():
							πF.SetLineno(2208)
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp007).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp006
							if πTemp003, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GT(πF, πTemp006, πg.NewInt(128).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 2209: if ord(pos.current()) > 128:
							πF.SetLineno(2209)
						Label4:
							// line 2210: codepoint = hex(ord(pos.current()))
							πF.SetLineno(2210)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßhex); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µcodepoint = πTemp003
							if πE = πg.CheckLocal(πF, µcodepoint, "codepoint"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µcodepoint, ß0xd835.ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							goto Label8
							// line 2211: if codepoint == '0xd835':
							πF.SetLineno(2211)
						Label7:
							// line 2212: codepoint = hex(ord(next(pos)) + 0xf800)
							πF.SetLineno(2212)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp009[0] = µpos
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnext); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp008[0] = πTemp006
							if πTemp003, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp002, πE = πg.Add(πF, πTemp006, πg.NewInt(63488).ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßhex); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µcodepoint = πTemp003
							goto Label8
						Label8:
							// line 2213: result += '&#' + codepoint[1:] + ';'
							πF.SetLineno(2213)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcodepoint, "codepoint"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetItem(πF, µcodepoint, πTemp006); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("&#").ToObject(), πTemp010); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr(";").ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µresult, πTemp002); πE != nil {
								continue
							}
							µresult = πTemp003
							goto Label6
						Label5:
							// line 2215: result += pos.current()
							πF.SetLineno(2215)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µresult, πTemp003); πE != nil {
								continue
							}
							µresult = πTemp002
							goto Label6
						Label6:
							// line 2216: pos.skipcurrent()
							πF.SetLineno(2216)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2217: return result
							πF.SetLineno(2217)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßescapeentities.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2205: "Escape all Unicode characters to HTML entities."
					πF.SetLineno(2205)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Escape all Unicode characters to HTML entities.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßescapeentities); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 2219: def searchall(self, type):
					πF.SetLineno(2219)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "type", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("searchall", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µlist *πg.Object = πg.UnboundLocal
						_ = µlist
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2220: "Search for all embedded containers of a given type"
							πF.SetLineno(2220)
							// line 2221: list = []
							πF.SetLineno(2221)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µlist = πTemp002
							// line 2222: self.searchprocess(type, lambda container: list.append(container))
							πF.SetLineno(2222)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							πTemp003 = make([]πg.Param, 1)
							πTemp003[0] = πg.Param{Name: "container", Def: nil}
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µcontainer *πg.Object = πArgs[0]
								_ = µcontainer
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 2222: self.searchprocess(type, lambda container: list.append(container))
									πF.SetLineno(2222)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
										continue
									}
									πTemp001[0] = µcontainer
									if πE = πg.CheckLocal(πF, µlist, "list"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µlist, ßappend, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									πR = πTemp003
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsearchprocess, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2223: return list
							πF.SetLineno(2223)
							if πE = πg.CheckLocal(πF, µlist, "list"); πE != nil {
								continue
							}
							πR = µlist
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsearchall.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 2220: "Search for all embedded containers of a given type"
					πF.SetLineno(2220)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Search for all embedded containers of a given type").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßsearchall); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 2225: def searchremove(self, type):
					πF.SetLineno(2225)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "type", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("searchremove", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µlist *πg.Object = πg.UnboundLocal
						_ = µlist
						var µcontainer *πg.Object = πg.UnboundLocal
						_ = µcontainer
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2226: "Search for all containers of a type and remove them"
							πF.SetLineno(2226)
							// line 2227: list = self.searchall(type)
							πF.SetLineno(2227)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsearchall, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µlist = πTemp003
							if πE = πg.CheckLocal(πF, µlist, "list"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µlist); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µcontainer = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2229: container.parent.contents.remove(container)
							πF.SetLineno(2229)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[0] = µcontainer
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ßparent, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp006, ßremove, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2230: return list
							πF.SetLineno(2230)
							if πE = πg.CheckLocal(πF, µlist, "list"); πE != nil {
								continue
							}
							πR = µlist
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsearchremove.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 2226: "Search for all containers of a type and remove them"
					πF.SetLineno(2226)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Search for all containers of a type and remove them").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßsearchremove); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 2232: def searchprocess(self, type, process):
					πF.SetLineno(2232)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "type", Def: nil}
					πTemp002[2] = πg.Param{Name: "process", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("searchprocess", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µprocess *πg.Object = πArgs[2]
						_ = µprocess
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2233: "Search for elements of a given type and process them"
							πF.SetLineno(2233)
							// line 2234: self.locateprocess(lambda container: isinstance(container, type), process)
							πF.SetLineno(2234)
							πTemp001 = πF.MakeArgs(2)
							πTemp003 = make([]πg.Param, 1)
							πTemp003[0] = πg.Param{Name: "container", Def: nil}
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µcontainer *πg.Object = πArgs[0]
								_ = µcontainer
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 2234: self.locateprocess(lambda container: isinstance(container, type), process)
									πF.SetLineno(2234)
									πTemp001 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
										continue
									}
									πTemp001[0] = µcontainer
									if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
										continue
									}
									πTemp001[1] = µtype
									if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									πR = πTemp003
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µprocess, "process"); πE != nil {
								continue
							}
							πTemp001[1] = µprocess
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßlocateprocess, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsearchprocess.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 2233: "Search for elements of a given type and process them"
					πF.SetLineno(2233)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Search for elements of a given type and process them").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßsearchprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
					// line 2236: def locateprocess(self, locate, process):
					πF.SetLineno(2236)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "locate", Def: nil}
					πTemp002[2] = πg.Param{Name: "process", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("locateprocess", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlocate *πg.Object = πArgs[1]
						_ = µlocate
						var µprocess *πg.Object = πArgs[2]
						_ = µprocess
						var µcontainer *πg.Object = πg.UnboundLocal
						_ = µcontainer
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2237: "Search for all embedded containers and process them"
							πF.SetLineno(2237)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µcontainer = πTemp002
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2239: container.locateprocess(locate, process)
							πF.SetLineno(2239)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µlocate, "locate"); πE != nil {
								continue
							}
							πTemp005[0] = µlocate
							if πE = πg.CheckLocal(πF, µprocess, "process"); πE != nil {
								continue
							}
							πTemp005[1] = µprocess
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßlocateprocess, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp005[0] = µcontainer
							if πE = πg.CheckLocal(πF, µlocate, "locate"); πE != nil {
								continue
							}
							if πTemp002, πE = µlocate.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 2240: if locate(container):
							πF.SetLineno(2240)
						Label4:
							// line 2241: process(container)
							πF.SetLineno(2241)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp005[0] = µcontainer
							if πE = πg.CheckLocal(πF, µprocess, "process"); πE != nil {
								continue
							}
							if πTemp002, πE = µprocess.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßlocateprocess.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 2237: "Search for all embedded containers and process them"
					πF.SetLineno(2237)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Search for all embedded containers and process them").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßlocateprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
					// line 2243: def recursivesearch(self, locate, recursive, process):
					πF.SetLineno(2243)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "locate", Def: nil}
					πTemp002[2] = πg.Param{Name: "recursive", Def: nil}
					πTemp002[3] = πg.Param{Name: "process", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("recursivesearch", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlocate *πg.Object = πArgs[1]
						_ = µlocate
						var µrecursive *πg.Object = πArgs[2]
						_ = µrecursive
						var µprocess *πg.Object = πArgs[3]
						_ = µprocess
						var µcontainer *πg.Object = πg.UnboundLocal
						_ = µcontainer
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2244: "Perform a recursive search in the container."
							πF.SetLineno(2244)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µcontainer = πTemp002
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp005[0] = µcontainer
							if πE = πg.CheckLocal(πF, µrecursive, "recursive"); πE != nil {
								continue
							}
							if πTemp002, πE = µrecursive.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 2246: if recursive(container):
							πF.SetLineno(2246)
						Label4:
							// line 2247: container.recursivesearch(locate, recursive, process)
							πF.SetLineno(2247)
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µlocate, "locate"); πE != nil {
								continue
							}
							πTemp005[0] = µlocate
							if πE = πg.CheckLocal(πF, µrecursive, "recursive"); πE != nil {
								continue
							}
							πTemp005[1] = µrecursive
							if πE = πg.CheckLocal(πF, µprocess, "process"); πE != nil {
								continue
							}
							πTemp005[2] = µprocess
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßrecursivesearch, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label5
						Label5:
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp005[0] = µcontainer
							if πE = πg.CheckLocal(πF, µlocate, "locate"); πE != nil {
								continue
							}
							if πTemp002, πE = µlocate.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 2248: if locate(container):
							πF.SetLineno(2248)
						Label6:
							// line 2249: process(container)
							πF.SetLineno(2249)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp005[0] = µcontainer
							if πE = πg.CheckLocal(πF, µprocess, "process"); πE != nil {
								continue
							}
							if πTemp002, πE = µprocess.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label7
						Label7:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßrecursivesearch.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 2244: "Perform a recursive search in the container."
					πF.SetLineno(2244)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp013}, πg.NewStr("Perform a recursive search in the container.").ToObject()); πE != nil {
						continue
					}
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßrecursivesearch); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp014, ß__doc__, πTemp013); πE != nil {
						continue
					}
					// line 2251: def extracttext(self):
					πF.SetLineno(2251)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("extracttext", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µconstants *πg.Object = πg.UnboundLocal
						_ = µconstants
						var µconstant *πg.Object = πg.UnboundLocal
						_ = µconstant
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2252: "Extract all text from elyxer.allowed containers."
							πF.SetLineno(2252)
							// line 2253: result = ''
							πF.SetLineno(2253)
							µresult = ß.ToObject()
							// line 2254: constants = ContainerExtractor(ContainerConfig.extracttext).extract(self)
							πF.SetLineno(2254)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							πTemp002 = πF.MakeArgs(1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßextracttext, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßContainerExtractor); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßextract, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µconstants = πTemp004
							if πE = πg.CheckLocal(πF, µconstants, "constants"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Iter(πF, µconstants); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp003); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µconstant = πTemp004
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2256: result += constant.string
							πF.SetLineno(2256)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µconstant, "constant"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µconstant, ßstring, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IAdd(πF, µresult, πTemp004); πE != nil {
								continue
							}
							µresult = πTemp007
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2257: return result
							πF.SetLineno(2257)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßextracttext.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 2252: "Extract all text from elyxer.allowed containers."
					πF.SetLineno(2252)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp014}, πg.NewStr("Extract all text from elyxer.allowed containers.").ToObject()); πE != nil {
						continue
					}
					if πTemp015, πE = πg.ResolveClass(πF, πClass, nil, ßextracttext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp015, ß__doc__, πTemp014); πE != nil {
						continue
					}
					// line 2259: def group(self, index, group, isingroup):
					πF.SetLineno(2259)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "index", Def: nil}
					πTemp002[2] = πg.Param{Name: "group", Def: nil}
					πTemp002[3] = πg.Param{Name: "isingroup", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("group", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindex *πg.Object = πArgs[1]
						_ = µindex
						var µgroup *πg.Object = πArgs[2]
						_ = µgroup
						var µisingroup *πg.Object = πArgs[3]
						_ = µisingroup
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 5:
								goto Label5
							case 6:
								goto Label6
							default:
								panic("unexpected function state")
							}
							// line 2260: "Group some adjoining elements into a group"
							πF.SetLineno(2260)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.GE(πF, µindex, πTemp004); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2261: if index >= len(self.contents):
							πF.SetLineno(2261)
						Label1:
							// line 2262: return
							πF.SetLineno(2262)
							πR = πg.None
							continue
							goto Label2
						Label2:
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001 = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							πTemp002[1] = ßgrouped.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 2263: if hasattr(self.contents[index], 'grouped'):
							πF.SetLineno(2263)
						Label3:
							// line 2264: return
							πF.SetLineno(2264)
							πR = πg.None
							continue
							goto Label4
						Label4:
							// line 2265: while index < len(self.contents) and isingroup(self.contents[index]):
							πF.SetLineno(2265)
							πF.PushCheckpoint(6)
							πTemp005 = false
						Label5:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label7
							}
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.LT(πF, µindex, πTemp008); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp007 {
								goto Label8
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp003 = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp008, πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µisingroup, "isingroup"); πE != nil {
								continue
							}
							if πTemp003, πE = µisingroup.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001 = πTemp003
						Label8:
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(5)
							// line 2266: self.contents[index].grouped = True
							πF.SetLineno(2266)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004 = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, πTemp009, πTemp004); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp008, ßgrouped, πTemp003); πE != nil {
								continue
							}
							// line 2267: group.contents.append(self.contents[index])
							πF.SetLineno(2267)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001 = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µgroup, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßappend, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 2268: self.contents.pop(index)
							πF.SetLineno(2268)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002[0] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßpop, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							continue
						Label6:
							if πE != nil || πR != nil {
								continue
							}
						Label7:
							// line 2269: self.contents.insert(index, group)
							πF.SetLineno(2269)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002[0] = µindex
							if πE = πg.CheckLocal(πF, µgroup, "group"); πE != nil {
								continue
							}
							πTemp002[1] = µgroup
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßinsert, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgroup.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 2260: "Group some adjoining elements into a group"
					πF.SetLineno(2260)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp015}, πg.NewStr("Group some adjoining elements into a group").ToObject()); πE != nil {
						continue
					}
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ßgroup); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp016, ß__doc__, πTemp015); πE != nil {
						continue
					}
					// line 2271: def remove(self, index):
					πF.SetLineno(2271)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "index", Def: nil}
					πTemp015 = πg.NewFunction(πg.NewCode("remove", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindex *πg.Object = πArgs[1]
						_ = µindex
						var µcontainer *πg.Object = πg.UnboundLocal
						_ = µcontainer
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2272: "Remove a container but leave its contents"
							πF.SetLineno(2272)
							// line 2273: container = self.contents[index]
							πF.SetLineno(2273)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001 = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µcontainer = πTemp002
							// line 2274: self.contents.pop(index)
							πF.SetLineno(2274)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[0] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßpop, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 2275: while len(container.contents) > 0:
							πF.SetLineno(2275)
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßcontents, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.GT(πF, πTemp003, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2276: self.contents.insert(index, container.contents.pop())
							πF.SetLineno(2276)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[0] = µindex
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontainer, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßpop, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinsert, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßremove.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 2272: "Remove a container but leave its contents"
					πF.SetLineno(2272)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp016}, πg.NewStr("Remove a container but leave its contents").ToObject()); πE != nil {
						continue
					}
					if πTemp017, πE = πg.ResolveClass(πF, πClass, nil, ßremove); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp017, ß__doc__, πTemp016); πE != nil {
						continue
					}
					// line 2278: def tree(self, level = 0):
					πF.SetLineno(2278)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "level", Def: πg.NewInt(0).ToObject()}
					πTemp016 = πg.NewFunction(πg.NewCode("tree", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlevel *πg.Object = πArgs[1]
						_ = µlevel
						var µcontainer *πg.Object = πg.UnboundLocal
						_ = µcontainer
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2279: "Show in a tree"
							πF.SetLineno(2279)
							// line 2280: Trace.debug("  " * level + unicode(self))
							πF.SetLineno(2280)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlevel, "level"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Mul(πF, πg.NewStr("  ").ToObject(), µlevel); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp004[0] = µself
							if πTemp005, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.Add(πF, πTemp003, πTemp006); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßdebug, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp007 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								µcontainer = πTemp003
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2282: container.tree(level + 1)
							πF.SetLineno(2282)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlevel, "level"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µlevel, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ßtree, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtree.ToObject(), πTemp016); πE != nil {
						continue
					}
					// line 2279: "Show in a tree"
					πF.SetLineno(2279)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp017}, πg.NewStr("Show in a tree").ToObject()); πE != nil {
						continue
					}
					if πTemp018, πE = πg.ResolveClass(πF, πClass, nil, ßtree); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp018, ß__doc__, πTemp017); πE != nil {
						continue
					}
					// line 2284: def getparameter(self, name):
					πF.SetLineno(2284)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "name", Def: nil}
					πTemp017 = πg.NewFunction(πg.NewCode("getparameter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µname *πg.Object = πArgs[1]
						_ = µname
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2285: "Get the value of a parameter, if present."
							πF.SetLineno(2285)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparameters, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp003, µname); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 2286: if not name in self.parameters:
							πF.SetLineno(2286)
						Label1:
							// line 2287: return None
							πF.SetLineno(2287)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 2288: return self.parameters[name]
							πF.SetLineno(2288)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001 = µname
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparameters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetparameter.ToObject(), πTemp017); πE != nil {
						continue
					}
					// line 2285: "Get the value of a parameter, if present."
					πF.SetLineno(2285)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp018}, πg.NewStr("Get the value of a parameter, if present.").ToObject()); πE != nil {
						continue
					}
					if πTemp019, πE = πg.ResolveClass(πF, πClass, nil, ßgetparameter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp019, ß__doc__, πTemp018); πE != nil {
						continue
					}
					// line 2290: def getparameterlist(self, name):
					πF.SetLineno(2290)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "name", Def: nil}
					πTemp018 = πg.NewFunction(πg.NewCode("getparameterlist", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µname *πg.Object = πArgs[1]
						_ = µname
						var µparamtext *πg.Object = πg.UnboundLocal
						_ = µparamtext
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2291: "Get the value of a comma-separated parameter as a list."
							πF.SetLineno(2291)
							// line 2292: paramtext = self.getparameter(name)
							πF.SetLineno(2292)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[0] = µname
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µparamtext = πTemp003
							if πE = πg.CheckLocal(πF, µparamtext, "paramtext"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µparamtext); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 2293: if not paramtext:
							πF.SetLineno(2293)
						Label1:
							// line 2294: return []
							πF.SetLineno(2294)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 2295: return paramtext.split(',')
							πF.SetLineno(2295)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr(",").ToObject()
							if πE = πg.CheckLocal(πF, µparamtext, "paramtext"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparamtext, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetparameterlist.ToObject(), πTemp018); πE != nil {
						continue
					}
					// line 2291: "Get the value of a comma-separated parameter as a list."
					πF.SetLineno(2291)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp019}, πg.NewStr("Get the value of a comma-separated parameter as a list.").ToObject()); πE != nil {
						continue
					}
					if πTemp020, πE = πg.ResolveClass(πF, πClass, nil, ßgetparameterlist); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp020, ß__doc__, πTemp019); πE != nil {
						continue
					}
					// line 2297: def hasemptyoutput(self):
					πF.SetLineno(2297)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp019 = πg.NewFunction(πg.NewCode("hasemptyoutput", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcurrent *πg.Object = πg.UnboundLocal
						_ = µcurrent
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2298: "Check if the parent's output is empty."
							πF.SetLineno(2298)
							// line 2299: current = self.parent
							πF.SetLineno(2299)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							µcurrent = πTemp001
							// line 2300: while current:
							πF.SetLineno(2300)
							πF.PushCheckpoint(2)
							πTemp002 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, µcurrent); πE != nil {
								continue
							}
							if πE != nil || !πTemp003 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcurrent, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßisempty, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 2301: if current.output.isempty():
							πF.SetLineno(2301)
						Label4:
							// line 2302: return True
							πF.SetLineno(2302)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label5
						Label5:
							// line 2303: current = current.parent
							πF.SetLineno(2303)
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcurrent, ßparent, nil); πE != nil {
								continue
							}
							µcurrent = πTemp001
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2304: return False
							πF.SetLineno(2304)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßhasemptyoutput.ToObject(), πTemp019); πE != nil {
						continue
					}
					// line 2298: "Check if the parent's output is empty."
					πF.SetLineno(2298)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp020}, πg.NewStr("Check if the parent's output is empty.").ToObject()); πE != nil {
						continue
					}
					if πTemp021, πE = πg.ResolveClass(πF, πClass, nil, ßhasemptyoutput); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp021, ß__doc__, πTemp020); πE != nil {
						continue
					}
					// line 2306: def __unicode__(self):
					πF.SetLineno(2306)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp020 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2307: "Get a description"
							πF.SetLineno(2307)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßbegin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 2308: if not self.begin:
							πF.SetLineno(2308)
						Label1:
							// line 2309: return self.__class__.__name__
							πF.SetLineno(2309)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ß__name__, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 2310: return self.__class__.__name__ + '@' + unicode(self.begin)
							πF.SetLineno(2310)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ß__name__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp005, πg.NewStr("@").ToObject()); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßbegin, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp020); πE != nil {
						continue
					}
					// line 2307: "Get a description"
					πF.SetLineno(2307)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp021}, πg.NewStr("Get a description").ToObject()); πE != nil {
						continue
					}
					if πTemp022, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp022, ß__doc__, πTemp021); πE != nil {
						continue
					}
					if πTemp022, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp023, πE = πg.GetAttr(πF, πTemp022, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp022 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp021, πE = πg.GE(πF, πTemp023, πTemp022); πE != nil {
						continue
					}
					if πTemp024, πE = πg.IsTrue(πF, πTemp021); πE != nil {
						continue
					}
					if πTemp024 {
						goto Label1
					}
					goto Label2
					// line 2312: if sys.version_info >= (3, 0):
					πF.SetLineno(2312)
				Label1:
					// line 2313: __str__ = __unicode__
					πF.SetLineno(2313)
					if πTemp021, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp021); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Container").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßContainer.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2316: class BlackBox(Container):
			πF.SetLineno(2316)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BlackBox", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2317: "A container that does not output anything"
					πF.SetLineno(2317)
					// line 2317: "A container that does not output anything"
					πF.SetLineno(2317)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A container that does not output anything").ToObject()); πE != nil {
						continue
					}
					// line 2319: def __init__(self):
					πF.SetLineno(2319)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2320: self.parser = LoneCommand()
							πF.SetLineno(2320)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßLoneCommand); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 2321: self.output = EmptyOutput()
							πF.SetLineno(2321)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEmptyOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 2322: self.contents = []
							πF.SetLineno(2322)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BlackBox").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBlackBox.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2324: class LyXFormat(BlackBox):
			πF.SetLineno(2324)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßBlackBox); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LyXFormat", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2325: "Read the lyxformat command"
					πF.SetLineno(2325)
					// line 2325: "Read the lyxformat command"
					πF.SetLineno(2325)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Read the lyxformat command").ToObject()); πE != nil {
						continue
					}
					// line 2327: def process(self):
					πF.SetLineno(2327)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µversion *πg.Object = πg.UnboundLocal
						_ = µversion
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2328: "Show warning if version < 276"
							πF.SetLineno(2328)
							// line 2329: version = int(self.header[1])
							πF.SetLineno(2329)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µversion = πTemp003
							if πE = πg.CheckLocal(πF, µversion, "version"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.LT(πF, µversion, πg.NewInt(276).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2330: if version < 276:
							πF.SetLineno(2330)
						Label1:
							// line 2331: Trace.error('Warning: unsupported old format version ' + str(version))
							πF.SetLineno(2331)
							πTemp001 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µversion, "version"); πE != nil {
								continue
							}
							πTemp006[0] = µversion
							if πTemp003, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Warning: unsupported old format version ").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µversion, "version"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = ßlyxformat.ToObject()
							if πTemp007, πE = πg.ResolveGlobal(πF, ßGeneralConfig); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßversion, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp008, πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GT(πF, µversion, πTemp004); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 2332: if version > int(GeneralConfig.version['lyxformat']):
							πF.SetLineno(2332)
						Label3:
							// line 2333: Trace.error('Warning: unsupported new format version ' + str(version))
							πF.SetLineno(2333)
							πTemp001 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µversion, "version"); πE != nil {
								continue
							}
							πTemp006[0] = µversion
							if πTemp003, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Warning: unsupported new format version ").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label4
						Label4:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2328: "Show warning if version < 276"
					πF.SetLineno(2328)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Show warning if version < 276").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LyXFormat").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLyXFormat.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2335: class StringContainer(Container):
			πF.SetLineno(2335)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("StringContainer", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 bool
				_ = πTemp011
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2336: "A container for a single string"
					πF.SetLineno(2336)
					// line 2336: "A container for a single string"
					πF.SetLineno(2336)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A container for a single string").ToObject()); πE != nil {
						continue
					}
					// line 2338: parsed = None
					πF.SetLineno(2338)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßparsed.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2340: def __init__(self):
					πF.SetLineno(2340)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2341: self.parser = StringParser()
							πF.SetLineno(2341)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßStringParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 2342: self.output = StringOutput()
							πF.SetLineno(2342)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßStringOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 2343: self.string = ''
							πF.SetLineno(2343)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ß.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßstring, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2345: def process(self):
					πF.SetLineno(2345)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2346: "Replace special chars from elyxer.the contents."
							πF.SetLineno(2346)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsed, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 2347: if self.parsed:
							πF.SetLineno(2347)
						Label1:
							// line 2348: self.string = self.replacespecial(self.parsed)
							πF.SetLineno(2348)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsed, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreplacespecial, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßstring, πTemp001); πE != nil {
								continue
							}
							// line 2349: self.parsed = None
							πF.SetLineno(2349)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparsed, πTemp004); πE != nil {
								continue
							}
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2346: "Replace special chars from elyxer.the contents."
					πF.SetLineno(2346)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Replace special chars from elyxer.the contents.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2351: def replacespecial(self, line):
					πF.SetLineno(2351)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "line", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("replacespecial", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µline *πg.Object = πArgs[1]
						_ = µline
						var µreplaced *πg.Object = πg.UnboundLocal
						_ = µreplaced
						var µmessage *πg.Object = πg.UnboundLocal
						_ = µmessage
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2352: "Replace all special chars from elyxer.a line"
							πF.SetLineno(2352)
							// line 2353: replaced = self.escape(line, EscapeConfig.entities)
							πF.SetLineno(2353)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πTemp002, πE = πg.ResolveGlobal(πF, ßEscapeConfig); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßentities, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßescape, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µreplaced = πTemp003
							// line 2354: replaced = self.changeline(replaced)
							πF.SetLineno(2354)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreplaced, "replaced"); πE != nil {
								continue
							}
							πTemp001[0] = µreplaced
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßchangeline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µreplaced = πTemp003
							πTemp005 = ßstartcommand.ToObject()
							if πTemp007, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßstring, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, πTemp008, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreplaced, "replaced"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Contains(πF, µreplaced, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp009).ToObject()
							πTemp002 = πTemp003
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label1
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreplaced, "replaced"); πE != nil {
								continue
							}
							πTemp001[0] = µreplaced
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.GT(πF, πTemp006, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp003
						Label1:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							goto Label3
							// line 2355: if ContainerConfig.string['startcommand'] in replaced and len(replaced) > 1:
							πF.SetLineno(2355)
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßbegin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 2357: if self.begin:
							πF.SetLineno(2357)
						Label4:
							// line 2358: message = 'Unknown command at ' + unicode(self.begin) + ': '
							πF.SetLineno(2358)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßbegin, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Unknown command at ").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							µmessage = πTemp002
							goto Label6
						Label5:
							// line 2360: message = 'Unknown command: '
							πF.SetLineno(2360)
							µmessage = πg.NewStr("Unknown command: ").ToObject()
							goto Label6
						Label6:
							// line 2361: Trace.error(message + replaced.strip())
							πF.SetLineno(2361)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreplaced, "replaced"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreplaced, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µmessage, πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label3
						Label3:
							// line 2362: return replaced
							πF.SetLineno(2362)
							if πE = πg.CheckLocal(πF, µreplaced, "replaced"); πE != nil {
								continue
							}
							πR = µreplaced
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreplacespecial.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2352: "Replace all special chars from elyxer.a line"
					πF.SetLineno(2352)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Replace all special chars from elyxer.a line").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßreplacespecial); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2364: def changeline(self, line):
					πF.SetLineno(2364)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "line", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("changeline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µline *πg.Object = πArgs[1]
						_ = µline
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2365: line = self.escape(line, EscapeConfig.chars)
							πF.SetLineno(2365)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πTemp002, πE = πg.ResolveGlobal(πF, ßEscapeConfig); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßchars, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßescape, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µline = πTemp003
							πTemp004 = ßstartcommand.ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ßContainerConfig); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßstring, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp007, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Contains(πF, µline, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp008).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp008).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label1
							}
							goto Label2
							// line 2366: if not ContainerConfig.string['startcommand'] in line:
							πF.SetLineno(2366)
						Label1:
							// line 2367: return line
							πF.SetLineno(2367)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πR = µline
							continue
							goto Label2
						Label2:
							// line 2368: line = self.escape(line, EscapeConfig.commands)
							πF.SetLineno(2368)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πTemp002, πE = πg.ResolveGlobal(πF, ßEscapeConfig); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßcommands, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßescape, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µline = πTemp003
							// line 2369: return line
							πF.SetLineno(2369)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πR = µline
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßchangeline.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2371: def extracttext(self):
					πF.SetLineno(2371)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("extracttext", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2372: "Return all text."
							πF.SetLineno(2372)
							// line 2373: return self.string
							πF.SetLineno(2373)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstring, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßextracttext.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2372: "Return all text."
					πF.SetLineno(2372)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Return all text.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßextracttext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2375: def __unicode__(self):
					πF.SetLineno(2375)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µellipsis *πg.Object = πg.UnboundLocal
						_ = µellipsis
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2376: "Return a printable representation."
							πF.SetLineno(2376)
							// line 2377: result = 'StringContainer'
							πF.SetLineno(2377)
							µresult = ßStringContainer.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßbegin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 2378: if self.begin:
							πF.SetLineno(2378)
						Label1:
							// line 2379: result += '@' + unicode(self.begin)
							πF.SetLineno(2379)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßbegin, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Add(πF, πg.NewStr("@").ToObject(), πTemp005); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IAdd(πF, µresult, πTemp001); πE != nil {
								continue
							}
							µresult = πTemp004
							goto Label2
						Label2:
							// line 2380: ellipsis = '...'
							πF.SetLineno(2380)
							µellipsis = πg.NewStr("...").ToObject()
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstring, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.LE(πF, πTemp005, πg.NewInt(15).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 2381: if len(self.string.strip()) <= 15:
							πF.SetLineno(2381)
						Label3:
							// line 2382: ellipsis = ''
							πF.SetLineno(2382)
							µellipsis = ß.ToObject()
							goto Label4
						Label4:
							// line 2383: return result + ' (' + self.string.strip()[:15] + ellipsis + ')'
							πF.SetLineno(2383)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Add(πF, µresult, πg.NewStr(" (").ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.NewInt(15).ToObject(), πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, µself, ßstring, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetAttr(πF, πTemp009, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp010.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, πTemp009, πTemp007); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πTemp006, πTemp008); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µellipsis, "ellipsis"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp005, µellipsis); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewStr(")").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2376: "Return a printable representation."
					πF.SetLineno(2376)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp010, πE = πg.GetAttr(πF, πTemp009, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp009 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp008, πE = πg.GE(πF, πTemp010, πTemp009); πE != nil {
						continue
					}
					if πTemp011, πE = πg.IsTrue(πF, πTemp008); πE != nil {
						continue
					}
					if πTemp011 {
						goto Label1
					}
					goto Label2
					// line 2385: if sys.version_info >= (3, 0):
					πF.SetLineno(2385)
				Label1:
					// line 2386: __str__ = __unicode__
					πF.SetLineno(2386)
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp008); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("StringContainer").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStringContainer.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2389: class Constant(StringContainer):
			πF.SetLineno(2389)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßStringContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Constant", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2390: "A constant string"
					πF.SetLineno(2390)
					// line 2390: "A constant string"
					πF.SetLineno(2390)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A constant string").ToObject()); πE != nil {
						continue
					}
					// line 2392: def __init__(self, text):
					πF.SetLineno(2392)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2393: self.contents = []
							πF.SetLineno(2393)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp003); πE != nil {
								continue
							}
							// line 2394: self.string = text
							πF.SetLineno(2394)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µtext); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßstring, πTemp002); πE != nil {
								continue
							}
							// line 2395: self.output = StringOutput()
							πF.SetLineno(2395)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßStringOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2397: def __unicode__(self):
					πF.SetLineno(2397)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2398: return 'Constant: ' + self.string
							πF.SetLineno(2398)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstring, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Constant: ").ToObject(), πTemp002); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp003); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp005 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp004, πE = πg.GE(πF, πTemp006, πTemp005); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label1
					}
					goto Label2
					// line 2400: if sys.version_info >= (3, 0):
					πF.SetLineno(2400)
				Label1:
					// line 2401: __str__ = __unicode__
					πF.SetLineno(2401)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp004); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Constant").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßConstant.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2404: class TaggedText(Container):
			πF.SetLineno(2404)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TaggedText", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 bool
				_ = πTemp009
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2405: "Text inside a tag"
					πF.SetLineno(2405)
					// line 2405: "Text inside a tag"
					πF.SetLineno(2405)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Text inside a tag").ToObject()); πE != nil {
						continue
					}
					// line 2407: output = None
					πF.SetLineno(2407)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßoutput.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2409: def __init__(self):
					πF.SetLineno(2409)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2410: self.parser = TextParser(self)
							πF.SetLineno(2410)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTextParser); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp002); πE != nil {
								continue
							}
							// line 2411: self.output = TaggedOutput()
							πF.SetLineno(2411)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2413: def complete(self, contents, tag, breaklines=False):
					πF.SetLineno(2413)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "tag", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "breaklines", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("complete", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µtag *πg.Object = πArgs[2]
						_ = µtag
						var µbreaklines *πg.Object = πArgs[3]
						_ = µbreaklines
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2414: "Complete the tagged text and return it"
							πF.SetLineno(2414)
							// line 2415: self.contents = contents
							πF.SetLineno(2415)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µcontents); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp001); πE != nil {
								continue
							}
							// line 2416: self.output.tag = tag
							πF.SetLineno(2416)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µtag); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
							// line 2417: self.output.breaklines = breaklines
							πF.SetLineno(2417)
							if πE = πg.CheckLocal(πF, µbreaklines, "breaklines"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µbreaklines); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßbreaklines, πTemp001); πE != nil {
								continue
							}
							// line 2418: return self
							πF.SetLineno(2418)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcomplete.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2414: "Complete the tagged text and return it"
					πF.SetLineno(2414)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Complete the tagged text and return it").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßcomplete); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2420: def constant(self, text, tag, breaklines=False):
					πF.SetLineno(2420)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp002[2] = πg.Param{Name: "tag", Def: nil}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "breaklines", Def: πTemp005}
					πTemp004 = πg.NewFunction(πg.NewCode("constant", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var µtag *πg.Object = πArgs[2]
						_ = µtag
						var µbreaklines *πg.Object = πArgs[3]
						_ = µbreaklines
						var µconstant *πg.Object = πg.UnboundLocal
						_ = µconstant
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2421: "Complete the tagged text with a constant"
							πF.SetLineno(2421)
							// line 2422: constant = Constant(text)
							πF.SetLineno(2422)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πTemp002, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µconstant = πTemp003
							// line 2423: return self.complete([constant], tag, breaklines)
							πF.SetLineno(2423)
							πTemp001 = πF.MakeArgs(3)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µconstant, "constant"); πE != nil {
								continue
							}
							πTemp004[0] = µconstant
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp001[1] = µtag
							if πE = πg.CheckLocal(πF, µbreaklines, "breaklines"); πE != nil {
								continue
							}
							πTemp001[2] = µbreaklines
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßconstant.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2421: "Complete the tagged text with a constant"
					πF.SetLineno(2421)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Complete the tagged text with a constant").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßconstant); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2425: def __unicode__(self):
					πF.SetLineno(2425)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2426: "Return a printable representation."
							πF.SetLineno(2426)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							πTemp002[1] = ßtag.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2427: if not hasattr(self.output, 'tag'):
							πF.SetLineno(2427)
						Label1:
							// line 2428: return 'Emtpy tagged text'
							πF.SetLineno(2428)
							πR = πg.NewStr("Emtpy tagged text").ToObject()
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßtag, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 2429: if not self.output.tag:
							πF.SetLineno(2429)
						Label3:
							// line 2430: return 'Tagged <unknown tag>'
							πF.SetLineno(2430)
							πR = πg.NewStr("Tagged <unknown tag>").ToObject()
							continue
							goto Label4
						Label4:
							// line 2431: return 'Tagged <' + self.output.tag + '>'
							πF.SetLineno(2431)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp004, ßtag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Tagged <").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr(">").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2426: "Return a printable representation."
					πF.SetLineno(2426)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp007 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp006, πE = πg.GE(πF, πTemp008, πTemp007); πE != nil {
						continue
					}
					if πTemp009, πE = πg.IsTrue(πF, πTemp006); πE != nil {
						continue
					}
					if πTemp009 {
						goto Label1
					}
					goto Label2
					// line 2433: if sys.version_info >= (3, 0):
					πF.SetLineno(2433)
				Label1:
					// line 2434: __str__ = __unicode__
					πF.SetLineno(2434)
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp006); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TaggedText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTaggedText.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2437: class DocumentParameters(object):
			πF.SetLineno(2437)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("DocumentParameters", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2438: "Global parameters for the document."
					πF.SetLineno(2438)
					// line 2438: "Global parameters for the document."
					πF.SetLineno(2438)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Global parameters for the document.").ToObject()); πE != nil {
						continue
					}
					// line 2440: pdftitle = None
					πF.SetLineno(2440)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßpdftitle.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2441: indentstandard = False
					πF.SetLineno(2441)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßindentstandard.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2442: tocdepth = 10
					πF.SetLineno(2442)
					if πE = πClass.SetItem(πF, ßtocdepth.ToObject(), πg.NewInt(10).ToObject()); πE != nil {
						continue
					}
					// line 2443: startinglevel = 0
					πF.SetLineno(2443)
					if πE = πClass.SetItem(πF, ßstartinglevel.ToObject(), πg.NewInt(0).ToObject()); πE != nil {
						continue
					}
					// line 2444: maxdepth = 10
					πF.SetLineno(2444)
					if πE = πClass.SetItem(πF, ßmaxdepth.ToObject(), πg.NewInt(10).ToObject()); πE != nil {
						continue
					}
					// line 2445: language = None
					πF.SetLineno(2445)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßlanguage.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2446: bibliography = None
					πF.SetLineno(2446)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßbibliography.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2447: outputchanges = False
					πF.SetLineno(2447)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßoutputchanges.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2448: displaymode = False
					πF.SetLineno(2448)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßdisplaymode.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("DocumentParameters").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßDocumentParameters.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2455: class FormulaParser(Parser):
			πF.SetLineno(2455)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2456: "Parses a formula"
					πF.SetLineno(2456)
					// line 2456: "Parses a formula"
					πF.SetLineno(2456)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Parses a formula").ToObject()); πE != nil {
						continue
					}
					// line 2458: def parseheader(self, reader):
					πF.SetLineno(2458)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parseheader", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µtype *πg.Object = πg.UnboundLocal
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2459: "See if the formula is inlined"
							πF.SetLineno(2459)
							// line 2460: self.begin = reader.linenumber + 1
							πF.SetLineno(2460)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßlinenumber, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßbegin, πTemp002); πE != nil {
								continue
							}
							// line 2461: type = self.parsetype(reader)
							πF.SetLineno(2461)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp003[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsetype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtype = πTemp002
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µtype); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 2462: if not type:
							πF.SetLineno(2462)
						Label1:
							// line 2463: reader.nextline()
							πF.SetLineno(2463)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2464: type = self.parsetype(reader)
							πF.SetLineno(2464)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp003[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsetype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtype = πTemp002
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µtype); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 2465: if not type:
							πF.SetLineno(2465)
						Label3:
							// line 2466: Trace.error('Unknown formula type in ' + reader.currentline().strip())
							πF.SetLineno(2466)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp005, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unknown formula type in ").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2467: return ['unknown']
							πF.SetLineno(2467)
							πTemp003 = make([]*πg.Object, 1)
							πTemp003[0] = ßunknown.ToObject()
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							πR = πTemp001
							continue
							goto Label4
						Label4:
							goto Label2
						Label2:
							// line 2468: return [type]
							πF.SetLineno(2468)
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseheader.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2459: "See if the formula is inlined"
					πF.SetLineno(2459)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("See if the formula is inlined").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparseheader); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2470: def parsetype(self, reader):
					πF.SetLineno(2470)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsetype", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2471: "Get the formula type from the first line."
							πF.SetLineno(2471)
							πTemp002 = πF.MakeArgs(1)
							πTemp003 = ßsimple.ToObject()
							if πTemp005, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp006, πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßfind, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.GE(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 2472: if reader.currentline().find(FormulaConfig.starts['simple']) >= 0:
							πF.SetLineno(2472)
						Label1:
							// line 2473: return 'inline'
							πF.SetLineno(2473)
							πR = ßinline.ToObject()
							continue
							goto Label2
						Label2:
							πTemp002 = πF.MakeArgs(1)
							πTemp003 = ßcomplex.ToObject()
							if πTemp005, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp006, πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßfind, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.GE(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label3
							}
							goto Label4
							// line 2474: if reader.currentline().find(FormulaConfig.starts['complex']) >= 0:
							πF.SetLineno(2474)
						Label3:
							// line 2475: return 'block'
							πF.SetLineno(2475)
							πR = ßblock.ToObject()
							continue
							goto Label4
						Label4:
							πTemp002 = πF.MakeArgs(1)
							πTemp003 = ßunnumbered.ToObject()
							if πTemp005, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp006, πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßfind, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.GE(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label5
							}
							goto Label6
							// line 2476: if reader.currentline().find(FormulaConfig.starts['unnumbered']) >= 0:
							πF.SetLineno(2476)
						Label5:
							// line 2477: return 'block'
							πF.SetLineno(2477)
							πR = ßblock.ToObject()
							continue
							goto Label6
						Label6:
							πTemp002 = πF.MakeArgs(1)
							πTemp003 = ßbeginbefore.ToObject()
							if πTemp005, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp006, πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßfind, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.GE(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label7
							}
							goto Label8
							// line 2478: if reader.currentline().find(FormulaConfig.starts['beginbefore']) >= 0:
							πF.SetLineno(2478)
						Label7:
							// line 2479: return 'numbered'
							πF.SetLineno(2479)
							πR = ßnumbered.ToObject()
							continue
							goto Label8
						Label8:
							// line 2480: return None
							πF.SetLineno(2480)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsetype.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2471: "Get the formula type from the first line."
					πF.SetLineno(2471)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Get the formula type from the first line.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsetype); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2482: def parse(self, reader):
					πF.SetLineno(2482)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µformula *πg.Object = πg.UnboundLocal
						_ = µformula
						var µstripped *πg.Object = πg.UnboundLocal
						_ = µstripped
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2483: "Parse the formula until the end"
							πF.SetLineno(2483)
							// line 2484: formula = self.parseformula(reader)
							πF.SetLineno(2484)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseformula, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µformula = πTemp003
							// line 2485: while not reader.currentline().startswith(self.ending):
							πF.SetLineno(2485)
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp006, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp007, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp007).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2486: stripped = reader.currentline().strip()
							πF.SetLineno(2486)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µstripped = πTemp003
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstripped, "stripped"); πE != nil {
								continue
							}
							πTemp001[0] = µstripped
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GT(πF, πTemp006, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 2487: if len(stripped) > 0:
							πF.SetLineno(2487)
						Label4:
							// line 2488: Trace.error('Unparsed formula line ' + stripped)
							πF.SetLineno(2488)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstripped, "stripped"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Unparsed formula line ").ToObject(), µstripped); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label5
						Label5:
							// line 2489: reader.nextline()
							πF.SetLineno(2489)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2490: reader.nextline()
							πF.SetLineno(2490)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2491: return formula
							πF.SetLineno(2491)
							if πE = πg.CheckLocal(πF, µformula, "formula"); πE != nil {
								continue
							}
							πR = µformula
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2483: "Parse the formula until the end"
					πF.SetLineno(2483)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse the formula until the end").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2493: def parseformula(self, reader):
					πF.SetLineno(2493)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("parseformula", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µsimple *πg.Object = πg.UnboundLocal
						_ = µsimple
						var µrest *πg.Object = πg.UnboundLocal
						_ = µrest
						var µbeginbefore *πg.Object = πg.UnboundLocal
						_ = µbeginbefore
						var µbeginafter *πg.Object = πg.UnboundLocal
						_ = µbeginafter
						var µcurrent *πg.Object = πg.UnboundLocal
						_ = µcurrent
						var µendsplit *πg.Object = πg.UnboundLocal
						_ = µendsplit
						var µstartpiece *πg.Object = πg.UnboundLocal
						_ = µstartpiece
						var µendbefore *πg.Object = πg.UnboundLocal
						_ = µendbefore
						var µendafter *πg.Object = πg.UnboundLocal
						_ = µendafter
						var µendpiece *πg.Object = πg.UnboundLocal
						_ = µendpiece
						var µbegincommand *πg.Object = πg.UnboundLocal
						_ = µbegincommand
						var µbeginbracket *πg.Object = πg.UnboundLocal
						_ = µbeginbracket
						var µendbracket *πg.Object = πg.UnboundLocal
						_ = µendbracket
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2494: "Parse the formula contents"
							πF.SetLineno(2494)
							// line 2495: simple = FormulaConfig.starts['simple']
							πF.SetLineno(2495)
							πTemp001 = ßsimple.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µsimple = πTemp002
							if πE = πg.CheckLocal(πF, µsimple, "simple"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp003, µsimple); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2496: if simple in reader.currentline():
							πF.SetLineno(2496)
						Label1:
							// line 2497: rest = reader.currentline().split(simple, 1)[1]
							πF.SetLineno(2497)
							πTemp001 = πg.NewInt(1).ToObject()
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsimple, "simple"); πE != nil {
								continue
							}
							πTemp006[0] = µsimple
							πTemp006[1] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µrest = πTemp002
							if πE = πg.CheckLocal(πF, µsimple, "simple"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrest, "rest"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µrest, µsimple); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 2498: if simple in rest:
							πF.SetLineno(2498)
						Label3:
							// line 2500: return self.parsesingleliner(reader, simple, simple)
							πF.SetLineno(2500)
							πTemp006 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp006[0] = µreader
							if πE = πg.CheckLocal(πF, µsimple, "simple"); πE != nil {
								continue
							}
							πTemp006[1] = µsimple
							if πE = πg.CheckLocal(πF, µsimple, "simple"); πE != nil {
								continue
							}
							πTemp006[2] = µsimple
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsesingleliner, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πR = πTemp002
							continue
							goto Label4
						Label4:
							// line 2502: return self.parsemultiliner(reader, simple, simple)
							πF.SetLineno(2502)
							πTemp006 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp006[0] = µreader
							if πE = πg.CheckLocal(πF, µsimple, "simple"); πE != nil {
								continue
							}
							πTemp006[1] = µsimple
							if πE = πg.CheckLocal(πF, µsimple, "simple"); πE != nil {
								continue
							}
							πTemp006[2] = µsimple
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsemultiliner, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πR = πTemp002
							continue
							goto Label2
						Label2:
							πTemp002 = ßcomplex.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp004, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp007, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							goto Label6
							// line 2503: if FormulaConfig.starts['complex'] in reader.currentline():
							πF.SetLineno(2503)
						Label5:
							// line 2505: return self.parsemultiliner(reader, FormulaConfig.starts['complex'],
							πF.SetLineno(2505)
							πTemp006 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp006[0] = µreader
							πTemp001 = ßcomplex.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πTemp006[1] = πTemp002
							πTemp001 = ßcomplex.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßendings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πTemp006[2] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsemultiliner, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πR = πTemp002
							continue
							goto Label6
						Label6:
							// line 2507: beginbefore = FormulaConfig.starts['beginbefore']
							πF.SetLineno(2507)
							πTemp001 = ßbeginbefore.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µbeginbefore = πTemp002
							// line 2508: beginafter = FormulaConfig.starts['beginafter']
							πF.SetLineno(2508)
							πTemp001 = ßbeginafter.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µbeginafter = πTemp002
							if πE = πg.CheckLocal(πF, µbeginbefore, "beginbefore"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp003, µbeginbefore); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							goto Label8
							// line 2509: if beginbefore in reader.currentline():
							πF.SetLineno(2509)
						Label7:
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbeginafter, "beginafter"); πE != nil {
								continue
							}
							πTemp006[0] = µbeginafter
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label9
							}
							goto Label10
							// line 2510: if reader.currentline().strip().endswith(beginafter):
							πF.SetLineno(2510)
						Label9:
							// line 2511: current = reader.currentline().strip()
							πF.SetLineno(2511)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µcurrent = πTemp002
							// line 2512: endsplit = current.split(beginbefore)[1].split(beginafter)
							πF.SetLineno(2512)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbeginafter, "beginafter"); πE != nil {
								continue
							}
							πTemp006[0] = µbeginafter
							πTemp001 = πg.NewInt(1).ToObject()
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbeginbefore, "beginbefore"); πE != nil {
								continue
							}
							πTemp008[0] = µbeginbefore
							if πE = πg.CheckLocal(πF, µcurrent, "current"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcurrent, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µendsplit = πTemp002
							// line 2513: startpiece = beginbefore + endsplit[0] + beginafter
							πF.SetLineno(2513)
							if πE = πg.CheckLocal(πF, µbeginbefore, "beginbefore"); πE != nil {
								continue
							}
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µendsplit, "endsplit"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µendsplit, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µbeginbefore, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbeginafter, "beginafter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µbeginafter); πE != nil {
								continue
							}
							µstartpiece = πTemp001
							// line 2514: endbefore = FormulaConfig.endings['endbefore']
							πF.SetLineno(2514)
							πTemp001 = ßendbefore.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßendings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µendbefore = πTemp002
							// line 2515: endafter = FormulaConfig.endings['endafter']
							πF.SetLineno(2515)
							πTemp001 = ßendafter.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßendings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µendafter = πTemp002
							// line 2516: endpiece = endbefore + endsplit[0] + endafter
							πF.SetLineno(2516)
							if πE = πg.CheckLocal(πF, µendbefore, "endbefore"); πE != nil {
								continue
							}
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µendsplit, "endsplit"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µendsplit, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µendbefore, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µendafter, "endafter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µendafter); πE != nil {
								continue
							}
							µendpiece = πTemp001
							// line 2517: return startpiece + self.parsemultiliner(reader, startpiece, endpiece) + endpiece
							πF.SetLineno(2517)
							if πE = πg.CheckLocal(πF, µstartpiece, "startpiece"); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp006[0] = µreader
							if πE = πg.CheckLocal(πF, µstartpiece, "startpiece"); πE != nil {
								continue
							}
							πTemp006[1] = µstartpiece
							if πE = πg.CheckLocal(πF, µendpiece, "endpiece"); πE != nil {
								continue
							}
							πTemp006[2] = µendpiece
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparsemultiliner, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Add(πF, µstartpiece, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µendpiece, "endpiece"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µendpiece); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label10
						Label10:
							// line 2518: Trace.error('Missing ' + beginafter + ' in ' + reader.currentline())
							πF.SetLineno(2518)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbeginafter, "beginafter"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Missing ").ToObject(), µbeginafter); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr(" in ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp004); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 2519: return ''
							πF.SetLineno(2519)
							πR = ß.ToObject()
							continue
							goto Label8
						Label8:
							// line 2520: begincommand = FormulaConfig.starts['command']
							πF.SetLineno(2520)
							πTemp001 = ßcommand.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µbegincommand = πTemp002
							// line 2521: beginbracket = FormulaConfig.starts['bracket']
							πF.SetLineno(2521)
							πTemp001 = ßbracket.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µbeginbracket = πTemp002
							if πE = πg.CheckLocal(πF, µbegincommand, "begincommand"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Contains(πF, πTemp004, µbegincommand); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp009).ToObject()
							πTemp001 = πTemp002
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label11
							}
							if πE = πg.CheckLocal(πF, µbeginbracket, "beginbracket"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Contains(πF, πTemp004, µbeginbracket); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp009).ToObject()
							πTemp001 = πTemp002
						Label11:
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label12
							}
							goto Label13
							// line 2522: if begincommand in reader.currentline() and beginbracket in reader.currentline():
							πF.SetLineno(2522)
						Label12:
							// line 2523: endbracket = FormulaConfig.endings['bracket']
							πF.SetLineno(2523)
							πTemp001 = ßbracket.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßendings, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µendbracket = πTemp002
							// line 2524: return self.parsemultiliner(reader, beginbracket, endbracket)
							πF.SetLineno(2524)
							πTemp006 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp006[0] = µreader
							if πE = πg.CheckLocal(πF, µbeginbracket, "beginbracket"); πE != nil {
								continue
							}
							πTemp006[1] = µbeginbracket
							if πE = πg.CheckLocal(πF, µendbracket, "endbracket"); πE != nil {
								continue
							}
							πTemp006[2] = µendbracket
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsemultiliner, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πR = πTemp002
							continue
							goto Label13
						Label13:
							// line 2525: Trace.error('Formula beginning ' + reader.currentline() + ' is unknown')
							πF.SetLineno(2525)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Formula beginning ").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(" is unknown").ToObject()); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 2526: return ''
							πF.SetLineno(2526)
							πR = ß.ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseformula.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2494: "Parse the formula contents"
					πF.SetLineno(2494)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Parse the formula contents").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßparseformula); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 2528: def parsesingleliner(self, reader, start, ending):
					πF.SetLineno(2528)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp002[2] = πg.Param{Name: "start", Def: nil}
					πTemp002[3] = πg.Param{Name: "ending", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("parsesingleliner", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µstart *πg.Object = πArgs[2]
						_ = µstart
						var µending *πg.Object = πArgs[3]
						_ = µending
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var µrest *πg.Object = πg.UnboundLocal
						_ = µrest
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2529: "Parse a formula in one line"
							πF.SetLineno(2529)
							// line 2530: line = reader.currentline().strip()
							πF.SetLineno(2530)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µline = πTemp002
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Contains(πF, µline, µstart); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 2531: if not start in line:
							πF.SetLineno(2531)
						Label1:
							// line 2532: Trace.error('Line ' + line + ' does not contain formula start ' + start)
							πF.SetLineno(2532)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πg.NewStr("Line ").ToObject(), µline); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp005, πg.NewStr(" does not contain formula start ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µstart); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 2533: return ''
							πF.SetLineno(2533)
							πR = ß.ToObject()
							continue
							goto Label2
						Label2:
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp004[0] = µending
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µline, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp003, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 2534: if not line.endswith(ending):
							πF.SetLineno(2534)
						Label3:
							// line 2535: Trace.error('Formula ' + line + ' does not end with ' + ending)
							πF.SetLineno(2535)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πg.NewStr("Formula ").ToObject(), µline); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp005, πg.NewStr(" does not end with ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µending); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 2536: return ''
							πF.SetLineno(2536)
							πR = ß.ToObject()
							continue
							goto Label4
						Label4:
							// line 2537: index = line.index(start)
							πF.SetLineno(2537)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp004[0] = µstart
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µline, ßindex, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µindex = πTemp002
							// line 2538: rest = line[index + len(start):-len(ending)]
							πF.SetLineno(2538)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp004[0] = µstart
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.Add(πF, µindex, πTemp006); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp004[0] = µending
							if πTemp006, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp005, πE = πg.Neg(πF, πTemp007); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp002, πTemp005, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µline, πTemp001); πE != nil {
								continue
							}
							µrest = πTemp002
							// line 2539: reader.nextline()
							πF.SetLineno(2539)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2540: return rest
							πF.SetLineno(2540)
							if πE = πg.CheckLocal(πF, µrest, "rest"); πE != nil {
								continue
							}
							πR = µrest
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsesingleliner.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2529: "Parse a formula in one line"
					πF.SetLineno(2529)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Parse a formula in one line").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßparsesingleliner); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2542: def parsemultiliner(self, reader, start, ending):
					πF.SetLineno(2542)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp002[2] = πg.Param{Name: "start", Def: nil}
					πTemp002[3] = πg.Param{Name: "ending", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("parsemultiliner", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µstart *πg.Object = πArgs[2]
						_ = µstart
						var µending *πg.Object = πArgs[3]
						_ = µending
						var µformula *πg.Object = πg.UnboundLocal
						_ = µformula
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 2543: "Parse a formula in multiple lines"
							πF.SetLineno(2543)
							// line 2544: formula = ''
							πF.SetLineno(2544)
							µformula = ß.ToObject()
							// line 2545: line = reader.currentline()
							πF.SetLineno(2545)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µline = πTemp002
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Contains(πF, µline, µstart); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 2546: if not start in line:
							πF.SetLineno(2546)
						Label1:
							// line 2547: Trace.error('Line ' + line.strip() + ' does not contain formula start ' + start)
							πF.SetLineno(2547)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µline, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πg.NewStr("Line ").ToObject(), πTemp007); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp005, πg.NewStr(" does not contain formula start ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µstart); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 2548: return ''
							πF.SetLineno(2548)
							πR = ß.ToObject()
							continue
							goto Label2
						Label2:
							// line 2549: index = line.index(start)
							πF.SetLineno(2549)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp004[0] = µstart
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µline, ßindex, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µindex = πTemp002
							// line 2550: line = line[index + len(start):].strip()
							πF.SetLineno(2550)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp004[0] = µstart
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.Add(πF, µindex, πTemp006); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp002, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µline, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µline = πTemp002
							// line 2551: while not line.endswith(ending):
							πF.SetLineno(2551)
							πF.PushCheckpoint(4)
							πTemp003 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label5
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp004[0] = µending
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µline, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp009, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp009).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 2552: formula += line + '\n'
							πF.SetLineno(2552)
							if πE = πg.CheckLocal(πF, µformula, "formula"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µline, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µformula, πTemp001); πE != nil {
								continue
							}
							µformula = πTemp002
							// line 2553: reader.nextline()
							πF.SetLineno(2553)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2554: line = reader.currentline()
							πF.SetLineno(2554)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µline = πTemp002
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							// line 2555: formula += line[:-len(ending)]
							πF.SetLineno(2555)
							if πE = πg.CheckLocal(πF, µformula, "formula"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp004[0] = µending
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.Neg(πF, πTemp006); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp002, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µline, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µformula, πTemp002); πE != nil {
								continue
							}
							µformula = πTemp001
							// line 2556: reader.nextline()
							πF.SetLineno(2556)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2557: return formula
							πF.SetLineno(2557)
							if πE = πg.CheckLocal(πF, µformula, "formula"); πE != nil {
								continue
							}
							πR = µformula
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsemultiliner.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2543: "Parse a formula in multiple lines"
					πF.SetLineno(2543)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Parse a formula in multiple lines").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßparsemultiliner); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2559: class MacroParser(FormulaParser):
			πF.SetLineno(2559)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("MacroParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2560: "A parser for a formula macro."
					πF.SetLineno(2560)
					// line 2560: "A parser for a formula macro."
					πF.SetLineno(2560)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parser for a formula macro.").ToObject()); πE != nil {
						continue
					}
					// line 2562: def parseheader(self, reader):
					πF.SetLineno(2562)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parseheader", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2563: "See if the formula is inlined"
							πF.SetLineno(2563)
							// line 2564: self.begin = reader.linenumber + 1
							πF.SetLineno(2564)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßlinenumber, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßbegin, πTemp002); πE != nil {
								continue
							}
							// line 2565: return ['inline']
							πF.SetLineno(2565)
							πTemp003 = make([]*πg.Object, 1)
							πTemp003[0] = ßinline.ToObject()
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseheader.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2563: "See if the formula is inlined"
					πF.SetLineno(2563)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("See if the formula is inlined").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparseheader); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2567: def parse(self, reader):
					πF.SetLineno(2567)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µformula *πg.Object = πg.UnboundLocal
						_ = µformula
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2568: "Parse the formula until the end"
							πF.SetLineno(2568)
							// line 2569: formula = self.parsemultiliner(reader, self.parent.start, self.ending)
							πF.SetLineno(2569)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstart, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsemultiliner, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µformula = πTemp003
							// line 2570: reader.nextline()
							πF.SetLineno(2570)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2571: return formula
							πF.SetLineno(2571)
							if πE = πg.CheckLocal(πF, µformula, "formula"); πE != nil {
								continue
							}
							πR = µformula
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2568: "Parse the formula until the end"
					πF.SetLineno(2568)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse the formula until the end").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("MacroParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMacroParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2574: class FormulaBit(Container):
			πF.SetLineno(2574)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaBit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 bool
				_ = πTemp012
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2575: "A bit of a formula"
					πF.SetLineno(2575)
					// line 2575: "A bit of a formula"
					πF.SetLineno(2575)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A bit of a formula").ToObject()); πE != nil {
						continue
					}
					// line 2577: type = None
					πF.SetLineno(2577)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtype.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2578: size = 1
					πF.SetLineno(2578)
					if πE = πClass.SetItem(πF, ßsize.ToObject(), πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					// line 2579: original = ''
					πF.SetLineno(2579)
					if πE = πClass.SetItem(πF, ßoriginal.ToObject(), ß.ToObject()); πE != nil {
						continue
					}
					// line 2581: def __init__(self):
					πF.SetLineno(2581)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2582: "The formula bit type can be 'alpha', 'number', 'font'."
							πF.SetLineno(2582)
							// line 2583: self.contents = []
							πF.SetLineno(2583)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp003); πE != nil {
								continue
							}
							// line 2584: self.output = ContentsOutput()
							πF.SetLineno(2584)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßContentsOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2582: "The formula bit type can be 'alpha', 'number', 'font'."
					πF.SetLineno(2582)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("The formula bit type can be 'alpha', 'number', 'font'.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2586: def setfactory(self, factory):
					πF.SetLineno(2586)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "factory", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("setfactory", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µfactory *πg.Object = πArgs[1]
						_ = µfactory
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2587: "Set the internal formula factory."
							πF.SetLineno(2587)
							// line 2588: self.factory = factory
							πF.SetLineno(2588)
							if πE = πg.CheckLocal(πF, µfactory, "factory"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µfactory); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfactory, πTemp001); πE != nil {
								continue
							}
							// line 2589: return self
							πF.SetLineno(2589)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetfactory.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2587: "Set the internal formula factory."
					πF.SetLineno(2587)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Set the internal formula factory.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßsetfactory); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2591: def add(self, bit):
					πF.SetLineno(2591)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "bit", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("add", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbit *πg.Object = πArgs[1]
						_ = µbit
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2592: "Add any kind of formula bit already processed"
							πF.SetLineno(2592)
							// line 2593: self.contents.append(bit)
							πF.SetLineno(2593)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp001[0] = µbit
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2594: self.original += bit.original
							πF.SetLineno(2594)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µbit, ßoriginal, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IAdd(πF, πTemp002, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp004); πE != nil {
								continue
							}
							// line 2595: bit.parent = self
							πF.SetLineno(2595)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µself); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µbit, ßparent, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2592: "Add any kind of formula bit already processed"
					πF.SetLineno(2592)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Add any kind of formula bit already processed").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßadd); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2597: def skiporiginal(self, string, pos):
					πF.SetLineno(2597)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp002[2] = πg.Param{Name: "pos", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("skiporiginal", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var µpos *πg.Object = πArgs[2]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2598: "Skip a string and add it to the original formula"
							πF.SetLineno(2598)
							// line 2599: self.original += string
							πF.SetLineno(2599)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µstring); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp002); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp003[0] = µstring
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2600: if not pos.checkskip(string):
							πF.SetLineno(2600)
						Label1:
							// line 2601: Trace.error('String ' + string + ' not at ' + pos.identifier())
							πF.SetLineno(2601)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πg.NewStr("String ").ToObject(), µstring); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp004, πg.NewStr(" not at ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µpos, ßidentifier, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp006); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßskiporiginal.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2598: "Skip a string and add it to the original formula"
					πF.SetLineno(2598)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Skip a string and add it to the original formula").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßskiporiginal); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 2603: def computesize(self):
					πF.SetLineno(2603)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("computesize", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []πg.Param
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2604: "Compute the size of the bit as the max of the sizes of all contents."
							πF.SetLineno(2604)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2605: if len(self.contents) == 0:
							πF.SetLineno(2605)
						Label1:
							// line 2606: return 1
							πF.SetLineno(2606)
							πR = πg.NewInt(1).ToObject()
							continue
							goto Label2
						Label2:
							// line 2607: self.size = max([element.size for element in self.contents])
							πF.SetLineno(2607)
							πTemp002 = πF.MakeArgs(1)
							πTemp006 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µelement *πg.Object = πg.UnboundLocal
								_ = µelement
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 bool
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp003 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp003 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp004 = !isStop
										} else {
											πTemp004 = true
											µelement = πTemp002
										}
										if πE != nil || !πTemp004 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 2607: self.size = max([element.size for element in self.contents])
										πF.SetLineno(2607)
										if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
											continue
										}
										if πTemp002, πE = πg.GetAttr(πF, µelement, ßsize, nil); πE != nil {
											continue
										}
										πF.PushCheckpoint(4)
										return πTemp002, nil
									Label4:
										πTemp005 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßmax); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsize, πTemp001); πE != nil {
								continue
							}
							// line 2608: return self.size
							πF.SetLineno(2608)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsize, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcomputesize.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2604: "Compute the size of the bit as the max of the sizes of all contents."
					πF.SetLineno(2604)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Compute the size of the bit as the max of the sizes of all contents.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßcomputesize); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2610: def clone(self):
					πF.SetLineno(2610)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("clone", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2611: "Return a copy of itself."
							πF.SetLineno(2611)
							// line 2612: return self.factory.parseformula(self.original)
							πF.SetLineno(2612)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparseformula, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßclone.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2611: "Return a copy of itself."
					πF.SetLineno(2611)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Return a copy of itself.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßclone); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 2614: def __unicode__(self):
					πF.SetLineno(2614)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2615: "Get a string representation"
							πF.SetLineno(2615)
							// line 2616: return self.__class__.__name__ + ' read in ' + self.original
							πF.SetLineno(2616)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ß__name__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp004, πg.NewStr(" read in ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp003); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 2615: "Get a string representation"
					πF.SetLineno(2615)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Get a string representation").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp011, πE = πg.GetAttr(πF, πTemp010, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp010 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp009, πE = πg.GE(πF, πTemp011, πTemp010); πE != nil {
						continue
					}
					if πTemp012, πE = πg.IsTrue(πF, πTemp009); πE != nil {
						continue
					}
					if πTemp012 {
						goto Label1
					}
					goto Label2
					// line 2618: if sys.version_info >= (3, 0):
					πF.SetLineno(2618)
				Label1:
					// line 2619: __str__ = __unicode__
					πF.SetLineno(2619)
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp009); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaBit").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaBit.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2622: class TaggedBit(FormulaBit):
			πF.SetLineno(2622)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TaggedBit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2623: "A tagged string in a formula"
					πF.SetLineno(2623)
					// line 2623: "A tagged string in a formula"
					πF.SetLineno(2623)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A tagged string in a formula").ToObject()); πE != nil {
						continue
					}
					// line 2625: def constant(self, constant, tag):
					πF.SetLineno(2625)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "constant", Def: nil}
					πTemp002[2] = πg.Param{Name: "tag", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("constant", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µconstant *πg.Object = πArgs[1]
						_ = µconstant
						var µtag *πg.Object = πArgs[2]
						_ = µtag
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2626: "Set the constant and the tag"
							πF.SetLineno(2626)
							// line 2627: self.output = TaggedOutput().settag(tag)
							πF.SetLineno(2627)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp001[0] = µtag
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 2628: self.add(FormulaConstant(constant))
							πF.SetLineno(2628)
							πTemp001 = πF.MakeArgs(1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µconstant, "constant"); πE != nil {
								continue
							}
							πTemp004[0] = µconstant
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2629: return self
							πF.SetLineno(2629)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßconstant.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2626: "Set the constant and the tag"
					πF.SetLineno(2626)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Set the constant and the tag").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßconstant); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2631: def complete(self, contents, tag, breaklines = False):
					πF.SetLineno(2631)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "tag", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "breaklines", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("complete", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µtag *πg.Object = πArgs[2]
						_ = µtag
						var µbreaklines *πg.Object = πArgs[3]
						_ = µbreaklines
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2632: "Set the constant and the tag"
							πF.SetLineno(2632)
							// line 2633: self.contents = contents
							πF.SetLineno(2633)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µcontents); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp001); πE != nil {
								continue
							}
							// line 2634: self.output = TaggedOutput().settag(tag, breaklines)
							πF.SetLineno(2634)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp002[0] = µtag
							if πE = πg.CheckLocal(πF, µbreaklines, "breaklines"); πE != nil {
								continue
							}
							πTemp002[1] = µbreaklines
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 2635: return self
							πF.SetLineno(2635)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcomplete.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2632: "Set the constant and the tag"
					πF.SetLineno(2632)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Set the constant and the tag").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßcomplete); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2637: def selfcomplete(self, tag):
					πF.SetLineno(2637)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "tag", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("selfcomplete", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtag *πg.Object = πArgs[1]
						_ = µtag
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 πg.KWArgs
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2638: "Set the self-closing tag, no contents (as in <hr/>)."
							πF.SetLineno(2638)
							// line 2639: self.output = TaggedOutput().settag(tag, empty = True)
							πF.SetLineno(2639)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp001[0] = µtag
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003 = πg.KWArgs{
								{"empty", πTemp002},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp004, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 2640: return self
							πF.SetLineno(2640)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßselfcomplete.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2638: "Set the self-closing tag, no contents (as in <hr/>)."
					πF.SetLineno(2638)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Set the self-closing tag, no contents (as in <hr/>).").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßselfcomplete); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TaggedBit").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTaggedBit.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2642: class FormulaConstant(Constant):
			πF.SetLineno(2642)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaConstant", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 bool
				_ = πTemp009
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2643: "A constant string in a formula"
					πF.SetLineno(2643)
					// line 2643: "A constant string in a formula"
					πF.SetLineno(2643)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A constant string in a formula").ToObject()); πE != nil {
						continue
					}
					// line 2645: def __init__(self, string):
					πF.SetLineno(2645)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "string", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstring *πg.Object = πArgs[1]
						_ = µstring
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2646: "Set the constant string"
							πF.SetLineno(2646)
							// line 2647: Constant.__init__(self, string)
							πF.SetLineno(2647)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							πTemp001[1] = µstring
							if πTemp002, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2648: self.original = string
							πF.SetLineno(2648)
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µstring); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp002); πE != nil {
								continue
							}
							// line 2649: self.size = 1
							πF.SetLineno(2649)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsize, πTemp002); πE != nil {
								continue
							}
							// line 2650: self.type = None
							πF.SetLineno(2650)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2646: "Set the constant string"
					πF.SetLineno(2646)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Set the constant string").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2652: def computesize(self):
					πF.SetLineno(2652)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("computesize", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2653: "Compute the size of the constant: always 1."
							πF.SetLineno(2653)
							// line 2654: return self.size
							πF.SetLineno(2654)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsize, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcomputesize.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2653: "Compute the size of the constant: always 1."
					πF.SetLineno(2653)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Compute the size of the constant: always 1.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßcomputesize); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2656: def clone(self):
					πF.SetLineno(2656)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("clone", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2657: "Return a copy of itself."
							πF.SetLineno(2657)
							// line 2658: return FormulaConstant(self.original)
							πF.SetLineno(2658)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßclone.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2657: "Return a copy of itself."
					πF.SetLineno(2657)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Return a copy of itself.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßclone); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2660: def __unicode__(self):
					πF.SetLineno(2660)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2661: "Return a printable representation."
							πF.SetLineno(2661)
							// line 2662: return 'Formula constant: ' + self.string
							πF.SetLineno(2662)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstring, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Formula constant: ").ToObject(), πTemp002); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2661: "Return a printable representation."
					πF.SetLineno(2661)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp007 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp006, πE = πg.GE(πF, πTemp008, πTemp007); πE != nil {
						continue
					}
					if πTemp009, πE = πg.IsTrue(πF, πTemp006); πE != nil {
						continue
					}
					if πTemp009 {
						goto Label1
					}
					goto Label2
					// line 2664: if sys.version_info >= (3, 0):
					πF.SetLineno(2664)
				Label1:
					// line 2665: __str__ = __unicode__
					πF.SetLineno(2665)
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp006); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaConstant").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaConstant.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2668: class RawText(FormulaBit):
			πF.SetLineno(2668)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("RawText", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2669: "A bit of text inside a formula"
					πF.SetLineno(2669)
					// line 2669: "A bit of text inside a formula"
					πF.SetLineno(2669)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A bit of text inside a formula").ToObject()); πE != nil {
						continue
					}
					// line 2671: def detect(self, pos):
					πF.SetLineno(2671)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2672: "Detect a bit of raw text"
							πF.SetLineno(2672)
							// line 2673: return pos.current().isalpha()
							πF.SetLineno(2673)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßisalpha, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2672: "Detect a bit of raw text"
					πF.SetLineno(2672)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Detect a bit of raw text").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2675: def parsebit(self, pos):
					πF.SetLineno(2675)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µalpha *πg.Object = πg.UnboundLocal
						_ = µalpha
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2676: "Parse alphabetic text"
							πF.SetLineno(2676)
							// line 2677: alpha = pos.globalpha()
							πF.SetLineno(2677)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßglobalpha, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µalpha = πTemp002
							// line 2678: self.add(FormulaConstant(alpha))
							πF.SetLineno(2678)
							πTemp003 = πF.MakeArgs(1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µalpha, "alpha"); πE != nil {
								continue
							}
							πTemp004[0] = µalpha
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2679: self.type = 'alpha'
							πF.SetLineno(2679)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßalpha.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2676: "Parse alphabetic text"
					πF.SetLineno(2676)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse alphabetic text").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("RawText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßRawText.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2681: class FormulaSymbol(FormulaBit):
			πF.SetLineno(2681)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaSymbol", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 []πg.Param
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2682: "A symbol inside a formula"
					πF.SetLineno(2682)
					// line 2682: "A symbol inside a formula"
					πF.SetLineno(2682)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A symbol inside a formula").ToObject()); πE != nil {
						continue
					}
					// line 2684: modified = FormulaConfig.modified
					πF.SetLineno(2684)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßmodified, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßmodified.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2685: unmodified = FormulaConfig.unmodified['characters']
					πF.SetLineno(2685)
					πTemp001 = ßcharacters.ToObject()
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßunmodified, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßunmodified.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2687: def detect(self, pos):
					πF.SetLineno(2687)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2688: "Detect a symbol"
							πF.SetLineno(2688)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaSymbol); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßunmodified, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2689: if pos.current() in FormulaSymbol.unmodified:
							πF.SetLineno(2689)
						Label1:
							// line 2690: return True
							πF.SetLineno(2690)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaSymbol); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßmodified, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 2691: if pos.current() in FormulaSymbol.modified:
							πF.SetLineno(2691)
						Label3:
							// line 2692: return True
							πF.SetLineno(2692)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 2693: return False
							πF.SetLineno(2693)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2688: "Detect a symbol"
					πF.SetLineno(2688)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Detect a symbol").ToObject()); πE != nil {
						continue
					}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp003, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 2695: def parsebit(self, pos):
					πF.SetLineno(2695)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2696: "Parse the symbol"
							πF.SetLineno(2696)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaSymbol); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßunmodified, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2697: if pos.current() in FormulaSymbol.unmodified:
							πF.SetLineno(2697)
						Label1:
							// line 2698: self.addsymbol(pos.current(), pos)
							πF.SetLineno(2698)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp006[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßaddsymbol, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 2699: return
							πF.SetLineno(2699)
							πR = πg.None
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaSymbol); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßmodified, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 2700: if pos.current() in FormulaSymbol.modified:
							πF.SetLineno(2700)
						Label3:
							// line 2701: self.addsymbol(FormulaSymbol.modified[pos.current()], pos)
							πF.SetLineno(2701)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaSymbol); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßmodified, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πTemp006[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp006[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßaddsymbol, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 2702: return
							πF.SetLineno(2702)
							πR = πg.None
							continue
							goto Label4
						Label4:
							// line 2703: Trace.error('Symbol ' + pos.current() + ' not found')
							πF.SetLineno(2703)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Symbol ").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(" not found").ToObject()); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2696: "Parse the symbol"
					πF.SetLineno(2696)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the symbol").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2705: def addsymbol(self, symbol, pos):
					πF.SetLineno(2705)
					πTemp005 = make([]πg.Param, 3)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "symbol", Def: nil}
					πTemp005[2] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("addsymbol", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µsymbol *πg.Object = πArgs[1]
						_ = µsymbol
						var µpos *πg.Object = πArgs[2]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2706: "Add a symbol"
							πF.SetLineno(2706)
							// line 2707: self.skiporiginal(pos.current(), pos)
							πF.SetLineno(2707)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßskiporiginal, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2708: self.contents.append(FormulaConstant(symbol))
							πF.SetLineno(2708)
							πTemp001 = πF.MakeArgs(1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsymbol, "symbol"); πE != nil {
								continue
							}
							πTemp004[0] = µsymbol
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßaddsymbol.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2706: "Add a symbol"
					πF.SetLineno(2706)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Add a symbol").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßaddsymbol); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaSymbol").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaSymbol.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2710: class FormulaNumber(FormulaBit):
			πF.SetLineno(2710)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaNumber", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2711: "A string of digits in a formula"
					πF.SetLineno(2711)
					// line 2711: "A string of digits in a formula"
					πF.SetLineno(2711)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A string of digits in a formula").ToObject()); πE != nil {
						continue
					}
					// line 2713: def detect(self, pos):
					πF.SetLineno(2713)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2714: "Detect a digit"
							πF.SetLineno(2714)
							// line 2715: return pos.current().isdigit()
							πF.SetLineno(2715)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßisdigit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2714: "Detect a digit"
					πF.SetLineno(2714)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Detect a digit").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2717: def parsebit(self, pos):
					πF.SetLineno(2717)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µdigits *πg.Object = πg.UnboundLocal
						_ = µdigits
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2718: "Parse a bunch of digits"
							πF.SetLineno(2718)
							// line 2719: digits = pos.glob(lambda: pos.current().isdigit())
							πF.SetLineno(2719)
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 2719: digits = pos.glob(lambda: pos.current().isdigit())
									πF.SetLineno(2719)
									if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
										continue
									}
									if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßisdigit, nil); πE != nil {
										continue
									}
									if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
										continue
									}
									πR = πTemp002
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßglob, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µdigits = πTemp004
							// line 2720: self.add(FormulaConstant(digits))
							πF.SetLineno(2720)
							πTemp001 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdigits, "digits"); πE != nil {
								continue
							}
							πTemp005[0] = µdigits
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2721: self.type = 'number'
							πF.SetLineno(2721)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, ßnumber.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2718: "Parse a bunch of digits"
					πF.SetLineno(2718)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse a bunch of digits").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaNumber").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaNumber.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2723: class Comment(FormulaBit):
			πF.SetLineno(2723)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Comment", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 []πg.Param
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2724: "A LaTeX comment: % to the end of the line."
					πF.SetLineno(2724)
					// line 2724: "A LaTeX comment: % to the end of the line."
					πF.SetLineno(2724)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A LaTeX comment: % to the end of the line.").ToObject()); πE != nil {
						continue
					}
					// line 2726: start = FormulaConfig.starts['comment']
					πF.SetLineno(2726)
					πTemp001 = ßcomment.ToObject()
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstarts, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßstart.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2728: def detect(self, pos):
					πF.SetLineno(2728)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2729: "Detect the %."
							πF.SetLineno(2729)
							// line 2730: return pos.current() == self.start
							πF.SetLineno(2730)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstart, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, πTemp002); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2729: "Detect the %."
					πF.SetLineno(2729)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Detect the %.").ToObject()); πE != nil {
						continue
					}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp003, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 2732: def parsebit(self, pos):
					πF.SetLineno(2732)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2733: "Parse to the end of the line."
							πF.SetLineno(2733)
							// line 2734: self.original += pos.globincluding('\n')
							πF.SetLineno(2734)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("\n").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßglobincluding, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.IAdd(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2733: "Parse to the end of the line."
					πF.SetLineno(2733)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse to the end of the line.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Comment").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßComment.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2736: class WhiteSpace(FormulaBit):
			πF.SetLineno(2736)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("WhiteSpace", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 bool
				_ = πTemp008
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2737: "Some white space inside a formula."
					πF.SetLineno(2737)
					// line 2737: "Some white space inside a formula."
					πF.SetLineno(2737)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Some white space inside a formula.").ToObject()); πE != nil {
						continue
					}
					// line 2739: def detect(self, pos):
					πF.SetLineno(2739)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2740: "Detect the white space."
							πF.SetLineno(2740)
							// line 2741: return pos.current().isspace()
							πF.SetLineno(2741)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßisspace, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2740: "Detect the white space."
					πF.SetLineno(2740)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Detect the white space.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2743: def parsebit(self, pos):
					πF.SetLineno(2743)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2744: "Parse all whitespace."
							πF.SetLineno(2744)
							// line 2745: self.original += pos.skipspace()
							πF.SetLineno(2745)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßskipspace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2744: "Parse all whitespace."
					πF.SetLineno(2744)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse all whitespace.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2747: def __unicode__(self):
					πF.SetLineno(2747)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2748: "Return a printable representation."
							πF.SetLineno(2748)
							// line 2749: return 'Whitespace: *' + self.original + '*'
							πF.SetLineno(2749)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Whitespace: *").ToObject(), πTemp003); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2748: "Return a printable representation."
					πF.SetLineno(2748)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp006 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp005, πE = πg.GE(πF, πTemp007, πTemp006); πE != nil {
						continue
					}
					if πTemp008, πE = πg.IsTrue(πF, πTemp005); πE != nil {
						continue
					}
					if πTemp008 {
						goto Label1
					}
					goto Label2
					// line 2751: if sys.version_info >= (3, 0):
					πF.SetLineno(2751)
				Label1:
					// line 2752: __str__ = __unicode__
					πF.SetLineno(2752)
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp005); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("WhiteSpace").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßWhiteSpace.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2755: class Bracket(FormulaBit):
			πF.SetLineno(2755)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Bracket", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 []πg.Param
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2756: "A {} bracket inside a formula"
					πF.SetLineno(2756)
					// line 2756: "A {} bracket inside a formula"
					πF.SetLineno(2756)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A {} bracket inside a formula").ToObject()); πE != nil {
						continue
					}
					// line 2758: start = FormulaConfig.starts['bracket']
					πF.SetLineno(2758)
					πTemp001 = ßbracket.ToObject()
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstarts, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßstart.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2759: ending = FormulaConfig.endings['bracket']
					πF.SetLineno(2759)
					πTemp001 = ßbracket.ToObject()
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßendings, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßending.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2761: def __init__(self):
					πF.SetLineno(2761)
					πTemp005 = make([]πg.Param, 1)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2762: "Create a (possibly literal) new bracket"
							πF.SetLineno(2762)
							// line 2763: FormulaBit.__init__(self)
							πF.SetLineno(2763)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2764: self.inner = None
							πF.SetLineno(2764)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßinner, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2762: "Create a (possibly literal) new bracket"
					πF.SetLineno(2762)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Create a (possibly literal) new bracket").ToObject()); πE != nil {
						continue
					}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp003, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 2766: def detect(self, pos):
					πF.SetLineno(2766)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2767: "Detect the start of a bracket"
							πF.SetLineno(2767)
							// line 2768: return pos.checkfor(self.start)
							πF.SetLineno(2768)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstart, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckfor, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2767: "Detect the start of a bracket"
					πF.SetLineno(2767)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Detect the start of a bracket").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2770: def parsebit(self, pos):
					πF.SetLineno(2770)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2771: "Parse the bracket"
							πF.SetLineno(2771)
							// line 2772: self.parsecomplete(pos, self.innerformula)
							πF.SetLineno(2772)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinnerformula, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsecomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2773: return self
							πF.SetLineno(2773)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2771: "Parse the bracket"
					πF.SetLineno(2771)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse the bracket").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2775: def parsetext(self, pos):
					πF.SetLineno(2775)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parsetext", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2776: "Parse a text bracket"
							πF.SetLineno(2776)
							// line 2777: self.parsecomplete(pos, self.innertext)
							πF.SetLineno(2777)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinnertext, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsecomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2778: return self
							πF.SetLineno(2778)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsetext.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2776: "Parse a text bracket"
					πF.SetLineno(2776)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Parse a text bracket").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßparsetext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 2780: def parseliteral(self, pos):
					πF.SetLineno(2780)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("parseliteral", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2781: "Parse a literal bracket"
							πF.SetLineno(2781)
							// line 2782: self.parsecomplete(pos, self.innerliteral)
							πF.SetLineno(2782)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinnerliteral, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsecomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2783: return self
							πF.SetLineno(2783)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseliteral.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2781: "Parse a literal bracket"
					πF.SetLineno(2781)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Parse a literal bracket").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßparseliteral); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2785: def parsecomplete(self, pos, innerparser):
					πF.SetLineno(2785)
					πTemp005 = make([]πg.Param, 3)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp005[2] = πg.Param{Name: "innerparser", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("parsecomplete", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µinnerparser *πg.Object = πArgs[2]
						_ = µinnerparser
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2786: "Parse the start and end marks"
							πF.SetLineno(2786)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstart, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcheckfor, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2787: if not pos.checkfor(self.start):
							πF.SetLineno(2787)
						Label1:
							// line 2788: Trace.error('Bracket should start with ' + self.start + ' at ' + pos.identifier())
							πF.SetLineno(2788)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßstart, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πg.NewStr("Bracket should start with ").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, πg.NewStr(" at ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µpos, ßidentifier, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πTemp006); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 2789: return None
							πF.SetLineno(2789)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 2790: self.skiporiginal(self.start, pos)
							πF.SetLineno(2790)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstart, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßskiporiginal, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 2791: pos.pushending(self.ending)
							πF.SetLineno(2791)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßpushending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 2792: innerparser(pos)
							πF.SetLineno(2792)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[0] = µpos
							if πE = πg.CheckLocal(πF, µinnerparser, "innerparser"); πE != nil {
								continue
							}
							if πTemp001, πE = µinnerparser.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 2793: self.original += pos.popending(self.ending)
							πF.SetLineno(2793)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßpopending, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.IAdd(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp003); πE != nil {
								continue
							}
							// line 2794: self.computesize()
							πF.SetLineno(2794)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcomputesize, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsecomplete.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2786: "Parse the start and end marks"
					πF.SetLineno(2786)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Parse the start and end marks").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßparsecomplete); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 2796: def innerformula(self, pos):
					πF.SetLineno(2796)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("innerformula", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2797: "Parse a whole formula inside the bracket"
							πF.SetLineno(2797)
							// line 2798: while not pos.finished():
							πF.SetLineno(2798)
							πF.PushCheckpoint(2)
							πTemp001 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp001 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πE != nil || !πTemp002 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2799: self.add(self.factory.parseany(pos))
							πF.SetLineno(2799)
							πTemp007 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp008[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßparseany, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp007[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinnerformula.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 2797: "Parse a whole formula inside the bracket"
					πF.SetLineno(2797)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Parse a whole formula inside the bracket").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßinnerformula); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 2801: def innertext(self, pos):
					πF.SetLineno(2801)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("innertext", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µspecialchars *πg.Object = πg.UnboundLocal
						_ = µspecialchars
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2802: "Parse some text inside the bracket, following textual rules."
							πF.SetLineno(2802)
							// line 2803: specialchars = list(FormulaConfig.symbolfunctions.keys())
							πF.SetLineno(2803)
							πTemp001 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsymbolfunctions, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßkeys, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µspecialchars = πTemp003
							// line 2804: specialchars.append(FormulaConfig.starts['command'])
							πF.SetLineno(2804)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = ßcommand.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µspecialchars, "specialchars"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µspecialchars, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2805: specialchars.append(FormulaConfig.starts['bracket'])
							πF.SetLineno(2805)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = ßbracket.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßstarts, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µspecialchars, "specialchars"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µspecialchars, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2806: specialchars.append(Comment.start)
							πF.SetLineno(2806)
							πTemp001 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßComment); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstart, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µspecialchars, "specialchars"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µspecialchars, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2807: while not pos.finished():
							πF.SetLineno(2807)
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp008).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µspecialchars, "specialchars"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, µspecialchars, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 2808: if pos.current() in specialchars:
							πF.SetLineno(2808)
						Label4:
							// line 2809: self.add(self.factory.parseany(pos))
							πF.SetLineno(2809)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp009[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparseany, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr(" ").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label7
							}
							goto Label8
							// line 2810: if pos.checkskip(' '):
							πF.SetLineno(2810)
						Label7:
							// line 2811: self.original += ' '
							πF.SetLineno(2811)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, πg.NewStr(" ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp003); πE != nil {
								continue
							}
							goto Label8
						Label8:
							goto Label6
						Label5:
							// line 2813: self.add(FormulaConstant(pos.skipcurrent()))
							πF.SetLineno(2813)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp009[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinnertext.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 2802: "Parse some text inside the bracket, following textual rules."
					πF.SetLineno(2802)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Parse some text inside the bracket, following textual rules.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßinnertext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 2815: def innerliteral(self, pos):
					πF.SetLineno(2815)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("innerliteral", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2816: "Parse a literal inside the bracket, which does not generate HTML."
							πF.SetLineno(2816)
							// line 2817: self.literal = ''
							πF.SetLineno(2817)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ß.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßliteral, πTemp001); πE != nil {
								continue
							}
							// line 2818: while not pos.finished() and not pos.current() == self.ending:
							πF.SetLineno(2818)
							πF.PushCheckpoint(2)
							πTemp002 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(!πTemp008).ToObject()
							πTemp001 = πTemp005
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp007.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßending, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Eq(πF, πTemp009, πTemp007); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(!πTemp008).ToObject()
							πTemp001 = πTemp005
						Label4:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp003 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßstart, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp006, πTemp005); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							goto Label6
							// line 2819: if pos.current() == self.start:
							πF.SetLineno(2819)
						Label5:
							// line 2820: self.parseliteral(pos)
							πF.SetLineno(2820)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp010[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparseliteral, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							goto Label7
						Label6:
							// line 2822: self.literal += pos.skipcurrent()
							πF.SetLineno(2822)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßliteral, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IAdd(πF, πTemp001, πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßliteral, πTemp005); πE != nil {
								continue
							}
							goto Label7
						Label7:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2823: self.original += self.literal
							πF.SetLineno(2823)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßliteral, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IAdd(πF, πTemp001, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp006); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinnerliteral.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 2816: "Parse a literal inside the bracket, which does not generate HTML."
					πF.SetLineno(2816)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Parse a literal inside the bracket, which does not generate HTML.").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßinnerliteral); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Bracket").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBracket.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2825: class SquareBracket(Bracket):
			πF.SetLineno(2825)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßBracket); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("SquareBracket", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 []πg.Param
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2826: "A [] bracket inside a formula"
					πF.SetLineno(2826)
					// line 2826: "A [] bracket inside a formula"
					πF.SetLineno(2826)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A [] bracket inside a formula").ToObject()); πE != nil {
						continue
					}
					// line 2828: start = FormulaConfig.starts['squarebracket']
					πF.SetLineno(2828)
					πTemp001 = ßsquarebracket.ToObject()
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstarts, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßstart.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2829: ending = FormulaConfig.endings['squarebracket']
					πF.SetLineno(2829)
					πTemp001 = ßsquarebracket.ToObject()
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßendings, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßending.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2831: def clone(self):
					πF.SetLineno(2831)
					πTemp005 = make([]πg.Param, 1)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("clone", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbracket *πg.Object = πg.UnboundLocal
						_ = µbracket
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2832: "Return a new square bracket with the same contents."
							πF.SetLineno(2832)
							// line 2833: bracket = SquareBracket()
							πF.SetLineno(2833)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßSquareBracket); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µbracket = πTemp002
							// line 2834: bracket.contents = self.contents
							πF.SetLineno(2834)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µbracket, ßcontents, πTemp002); πE != nil {
								continue
							}
							// line 2835: return bracket
							πF.SetLineno(2835)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							πR = µbracket
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßclone.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2832: "Return a new square bracket with the same contents."
					πF.SetLineno(2832)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Return a new square bracket with the same contents.").ToObject()); πE != nil {
						continue
					}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßclone); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp003, ß__doc__, πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("SquareBracket").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßSquareBracket.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2838: class MathsProcessor(object):
			πF.SetLineno(2838)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("MathsProcessor", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2839: "A processor for a maths construction inside the FormulaProcessor."
					πF.SetLineno(2839)
					// line 2839: "A processor for a maths construction inside the FormulaProcessor."
					πF.SetLineno(2839)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A processor for a maths construction inside the FormulaProcessor.").ToObject()); πE != nil {
						continue
					}
					// line 2841: def process(self, contents, index):
					πF.SetLineno(2841)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2842: "Process an element inside a formula."
							πF.SetLineno(2842)
							// line 2843: Trace.error('Unimplemented process() in ' + unicode(self))
							πF.SetLineno(2843)
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[0] = µself
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Unimplemented process() in ").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2842: "Process an element inside a formula."
					πF.SetLineno(2842)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Process an element inside a formula.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2845: def __unicode__(self):
					πF.SetLineno(2845)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2846: "Return a printable description."
							πF.SetLineno(2846)
							// line 2847: return 'Maths processor ' + self.__class__.__name__
							πF.SetLineno(2847)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__name__, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Maths processor ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2846: "Return a printable description."
					πF.SetLineno(2846)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Return a printable description.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp005 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp004, πE = πg.GE(πF, πTemp006, πTemp005); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label1
					}
					goto Label2
					// line 2849: if sys.version_info >= (3, 0):
					πF.SetLineno(2849)
				Label1:
					// line 2850: __str__ = __unicode__
					πF.SetLineno(2850)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp004); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("MathsProcessor").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMathsProcessor.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2853: class FormulaProcessor(object):
			πF.SetLineno(2853)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaProcessor", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2854: "A processor specifically for formulas."
					πF.SetLineno(2854)
					// line 2854: "A processor specifically for formulas."
					πF.SetLineno(2854)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A processor specifically for formulas.").ToObject()); πE != nil {
						continue
					}
					// line 2856: processors = []
					πF.SetLineno(2856)
					πTemp001 = make([]*πg.Object, 0)
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πE = πClass.SetItem(πF, ßprocessors.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2858: def process(self, bit):
					πF.SetLineno(2858)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "bit", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbit *πg.Object = πArgs[1]
						_ = µbit
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2859: "Process the contents of every formula bit, recursively."
							πF.SetLineno(2859)
							// line 2860: self.processcontents(bit)
							πF.SetLineno(2860)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp001[0] = µbit
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßprocesscontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2861: self.processinsides(bit)
							πF.SetLineno(2861)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp001[0] = µbit
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßprocessinsides, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2862: self.traversewhole(bit)
							πF.SetLineno(2862)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp001[0] = µbit
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtraversewhole, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2859: "Process the contents of every formula bit, recursively."
					πF.SetLineno(2859)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Process the contents of every formula bit, recursively.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2864: def processcontents(self, bit):
					πF.SetLineno(2864)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "bit", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("processcontents", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbit *πg.Object = πArgs[1]
						_ = µbit
						var µelement *πg.Object = πg.UnboundLocal
						_ = µelement
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 2865: "Process the contents of a formula bit."
							πF.SetLineno(2865)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp002[0] = µbit
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
								continue
							}
							πTemp002[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2866: if not isinstance(bit, FormulaBit):
							πF.SetLineno(2866)
						Label1:
							// line 2867: return
							πF.SetLineno(2867)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 2868: bit.process()
							πF.SetLineno(2868)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µbit, ßprocess, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µbit, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp005 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µelement = πTemp003
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 2870: self.processcontents(element)
							πF.SetLineno(2870)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							πTemp002[0] = µelement
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßprocesscontents, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocesscontents.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2865: "Process the contents of a formula bit."
					πF.SetLineno(2865)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Process the contents of a formula bit.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßprocesscontents); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2872: def processinsides(self, bit):
					πF.SetLineno(2872)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "bit", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("processinsides", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbit *πg.Object = πArgs[1]
						_ = µbit
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var µelement *πg.Object = πg.UnboundLocal
						_ = µelement
						var µprocessor *πg.Object = πg.UnboundLocal
						_ = µprocessor
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							case 6:
								goto Label6
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 2873: "Process the insides (limits, brackets) in a formula bit."
							πF.SetLineno(2873)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp002[0] = µbit
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
								continue
							}
							πTemp002[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2874: if not isinstance(bit, FormulaBit):
							πF.SetLineno(2874)
						Label1:
							// line 2875: return
							πF.SetLineno(2875)
							πR = πg.None
							continue
							goto Label2
						Label2:
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µbit, ßcontents, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßenumerate); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp005 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp007}}}, πTemp003); πE != nil {
									continue
								}
								µindex = πTemp004
								µelement = πTemp007
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßprocessors, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(7)
							πTemp006 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πTemp004, πE = πg.Next(πF, πTemp003); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								µprocessor = πTemp004
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(6)
							// line 2878: processor.process(bit.contents, index)
							πF.SetLineno(2878)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µbit, ßcontents, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002[1] = µindex
							if πE = πg.CheckLocal(πF, µprocessor, "processor"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µprocessor, ßprocess, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
							// line 2880: self.processinsides(element)
							πF.SetLineno(2880)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							πTemp002[0] = µelement
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßprocessinsides, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocessinsides.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2873: "Process the insides (limits, brackets) in a formula bit."
					πF.SetLineno(2873)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Process the insides (limits, brackets) in a formula bit.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßprocessinsides); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 2882: def traversewhole(self, formula):
					πF.SetLineno(2882)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "formula", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("traversewhole", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µformula *πg.Object = πArgs[1]
						_ = µformula
						var µlast *πg.Object = πg.UnboundLocal
						_ = µlast
						var µbit *πg.Object = πg.UnboundLocal
						_ = µbit
						var µcontents *πg.Object = πg.UnboundLocal
						_ = µcontents
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2883: "Traverse over the contents to alter variables and space units."
							πF.SetLineno(2883)
							// line 2884: last = None
							πF.SetLineno(2884)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µlast = πTemp001
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µformula, "formula"); πE != nil {
								continue
							}
							πTemp002[0] = µformula
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtraverse, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp007}}}, πTemp003); πE != nil {
									continue
								}
								µbit = πTemp004
								µcontents = πTemp007
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µbit, ßtype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, πTemp004, ßalpha.ToObject()); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µbit, ßtype, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Eq(πF, πTemp007, ßfont.ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp004
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp006 {
								goto Label5
							}
							if πE = πg.CheckLocal(πF, µlast, "last"); πE != nil {
								continue
							}
							πTemp003 = µlast
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp006 {
								goto Label5
							}
							if πE = πg.CheckLocal(πF, µlast, "last"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µlast, ßtype, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Eq(πF, πTemp007, ßnumber.ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp004
						Label5:
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label6
							}
							goto Label7
							// line 2886: if bit.type == 'alpha':
							πF.SetLineno(2886)
						Label4:
							// line 2887: self.italicize(bit, contents)
							πF.SetLineno(2887)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp002[0] = µbit
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp002[1] = µcontents
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßitalicize, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label7
							// line 2888: elif bit.type == 'font' and last and last.type == 'number':
							πF.SetLineno(2888)
						Label6:
							// line 2889: bit.contents.insert(0, FormulaConstant(u' '))
							πF.SetLineno(2889)
							πTemp002 = πF.MakeArgs(2)
							πTemp002[0] = πg.NewInt(0).ToObject()
							πTemp008 = πF.MakeArgs(1)
							πTemp008[0] = πg.NewUnicode("\xe2\x81\x9f").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp002[1] = πTemp004
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µbit, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßinsert, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label7
						Label7:
							// line 2890: last = bit
							πF.SetLineno(2890)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							µlast = µbit
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtraversewhole.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2883: "Traverse over the contents to alter variables and space units."
					πF.SetLineno(2883)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Traverse over the contents to alter variables and space units.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßtraversewhole); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2892: def traverse(self, bit):
					πF.SetLineno(2892)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "bit", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("traverse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbit *πg.Object = πArgs[1]
						_ = µbit
						var µelement *πg.Object = πg.UnboundLocal
						_ = µelement
						var µpair *πg.Object = πg.UnboundLocal
						_ = µpair
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1:
									goto Label1
								case 2:
									goto Label2
								case 8:
									goto Label8
								case 9:
									goto Label9
								case 10:
									goto Label10
								case 12:
									goto Label12
								default:
									panic("unexpected function state")
								}
								// line 2893: "Traverse a formula and yield a flattened structure of (bit, list) pairs."
								πF.SetLineno(2893)
								if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
									continue
								}
								if πTemp002, πE = πg.GetAttr(πF, µbit, ßcontents, nil); πE != nil {
									continue
								}
								if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
									continue
								}
								πF.PushCheckpoint(2)
								πTemp003 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp003 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp004 = !isStop
								} else {
									πTemp004 = true
									µelement = πTemp002
								}
								if πE != nil || !πTemp004 {
									continue
								}
								πF.PushCheckpoint(1)
								πTemp005 = πF.MakeArgs(2)
								if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
									continue
								}
								πTemp005[0] = µelement
								πTemp005[1] = ßtype.ToObject()
								if πTemp006, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
									continue
								}
								if πTemp007, πE = πTemp006.Call(πF, πTemp005, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp005)
								πTemp002 = πTemp007
								if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
									continue
								}
								if !πTemp004 {
									goto Label4
								}
								if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
									continue
								}
								if πTemp006, πE = πg.GetAttr(πF, µelement, ßtype, nil); πE != nil {
									continue
								}
								πTemp002 = πTemp006
							Label4:
								if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
									continue
								}
								if πTemp004 {
									goto Label5
								}
								πTemp005 = πF.MakeArgs(2)
								if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
									continue
								}
								πTemp005[0] = µelement
								if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
									continue
								}
								πTemp005[1] = πTemp002
								if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
									continue
								}
								if πTemp006, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp005)
								if πTemp004, πE = πg.IsTrue(πF, πTemp006); πE != nil {
									continue
								}
								if πTemp004 {
									goto Label6
								}
								goto Label7
								// line 2895: if hasattr(element, 'type') and element.type:
								πF.SetLineno(2895)
							Label5:
								// line 2896: yield (element, bit.contents)
								πF.SetLineno(2896)
								if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
									continue
								}
								if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
									continue
								}
								if πTemp006, πE = πg.GetAttr(πF, µbit, ßcontents, nil); πE != nil {
									continue
								}
								πTemp002 = πg.NewTuple2(µelement, πTemp006).ToObject()
								πF.PushCheckpoint(8)
								return πTemp002, nil
							Label8:
								πTemp006 = πSent
								goto Label7
								// line 2897: elif isinstance(element, FormulaBit):
								πF.SetLineno(2897)
							Label6:
								πTemp005 = πF.MakeArgs(1)
								if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
									continue
								}
								πTemp005[0] = µelement
								if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
									continue
								}
								if πTemp007, πE = πg.GetAttr(πF, µself, ßtraverse, nil); πE != nil {
									continue
								}
								if πTemp008, πE = πTemp007.Call(πF, πTemp005, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp005)
								if πTemp006, πE = πg.Iter(πF, πTemp008); πE != nil {
									continue
								}
								πF.PushCheckpoint(10)
								πTemp004 = false
							Label9:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp004 {
									πF.PopCheckpoint()
									goto Label11
								}
								if πTemp007, πE = πg.Next(πF, πTemp006); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp009 = !isStop
								} else {
									πTemp009 = true
									µpair = πTemp007
								}
								if πE != nil || !πTemp009 {
									continue
								}
								πF.PushCheckpoint(9)
								// line 2899: yield pair
								πF.SetLineno(2899)
								if πE = πg.CheckLocal(πF, µpair, "pair"); πE != nil {
									continue
								}
								πF.PushCheckpoint(12)
								return µpair, nil
							Label12:
								πTemp007 = πSent
								continue
							Label10:
								if πE != nil || πR != nil {
									continue
								}
							Label11:
								goto Label7
							Label7:
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtraverse.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2893: "Traverse a formula and yield a flattened structure of (bit, list) pairs."
					πF.SetLineno(2893)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Traverse a formula and yield a flattened structure of (bit, list) pairs.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßtraverse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 2901: def italicize(self, bit, contents):
					πF.SetLineno(2901)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "bit", Def: nil}
					πTemp003[2] = πg.Param{Name: "contents", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("italicize", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbit *πg.Object = πArgs[1]
						_ = µbit
						var µcontents *πg.Object = πArgs[2]
						_ = µcontents
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2902: "Italicize the given bit of text."
							πF.SetLineno(2902)
							// line 2903: index = contents.index(bit)
							πF.SetLineno(2903)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp001[0] = µbit
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontents, ßindex, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µindex = πTemp003
							// line 2904: contents[index] = TaggedBit().complete([bit], 'i')
							πF.SetLineno(2904)
							πTemp001 = πF.MakeArgs(2)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp004[0] = µbit
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							πTemp001[0] = πTemp002
							πTemp001[1] = ßi.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp005 = µindex
							if πE = πg.SetItem(πF, µcontents, πTemp005, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßitalicize.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 2902: "Italicize the given bit of text."
					πF.SetLineno(2902)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Italicize the given bit of text.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßitalicize); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaProcessor").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaProcessor.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 2909: class Formula(Container):
			πF.SetLineno(2909)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Formula", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				var πTemp019 bool
				_ = πTemp019
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2910: "A LaTeX formula"
					πF.SetLineno(2910)
					// line 2910: "A LaTeX formula"
					πF.SetLineno(2910)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A LaTeX formula").ToObject()); πE != nil {
						continue
					}
					// line 2912: def __init__(self):
					πF.SetLineno(2912)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2913: self.parser = FormulaParser()
							πF.SetLineno(2913)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 2914: self.output = TaggedOutput().settag('span class="formula"')
							πF.SetLineno(2914)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("span class=\"formula\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2916: def process(self):
					πF.SetLineno(2916)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2917: "Convert the formula to tags"
							πF.SetLineno(2917)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, ßinline.ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2918: if self.header[0] == 'inline':
							πF.SetLineno(2918)
						Label1:
							// line 2919: DocumentParameters.displaymode = False
							πF.SetLineno(2919)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßdisplaymode, πTemp002); πE != nil {
								continue
							}
							goto Label3
						Label2:
							// line 2921: DocumentParameters.displaymode = True
							πF.SetLineno(2921)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßdisplaymode, πTemp002); πE != nil {
								continue
							}
							// line 2922: self.output.settag('div class="formula"', True)
							πF.SetLineno(2922)
							πTemp006 = πF.MakeArgs(2)
							πTemp006[0] = πg.NewStr("div class=\"formula\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							goto Label3
						Label3:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßjsmath, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßmathjax, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßgooglecharts, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							goto Label7
							// line 2923: if Options.jsmath:
							πF.SetLineno(2923)
						Label4:
							// line 2924: self.jsmath()
							πF.SetLineno(2924)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßjsmath, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label8
							// line 2925: elif Options.mathjax:
							πF.SetLineno(2925)
						Label5:
							// line 2926: self.mathjax()
							πF.SetLineno(2926)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmathjax, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label8
							// line 2927: elif Options.googlecharts:
							πF.SetLineno(2927)
						Label6:
							// line 2928: self.googlecharts()
							πF.SetLineno(2928)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgooglecharts, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label8
						Label7:
							// line 2930: self.classic()
							πF.SetLineno(2930)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßclassic, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label8
						Label8:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2917: "Convert the formula to tags"
					πF.SetLineno(2917)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Convert the formula to tags").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2932: def jsmath(self):
					πF.SetLineno(2932)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("jsmath", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2933: "Make the contents for jsMath."
							πF.SetLineno(2933)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.NE(πF, πTemp003, ßinline.ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2934: if self.header[0] != 'inline':
							πF.SetLineno(2934)
						Label1:
							// line 2935: self.output = TaggedOutput().settag('div class="math"')
							πF.SetLineno(2935)
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("div class=\"math\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							goto Label3
						Label2:
							// line 2937: self.output = TaggedOutput().settag('span class="math"')
							πF.SetLineno(2937)
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("span class=\"math\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							goto Label3
						Label3:
							// line 2938: self.contents = [Constant(self.parsed)]
							πF.SetLineno(2938)
							πTemp006 = make([]*πg.Object, 1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsed, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp006[0] = πTemp002
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßjsmath.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2933: "Make the contents for jsMath."
					πF.SetLineno(2933)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Make the contents for jsMath.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßjsmath); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2940: def mathjax(self):
					πF.SetLineno(2940)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("mathjax", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtag *πg.Object = πg.UnboundLocal
						_ = µtag
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2941: "Make the contents for MathJax."
							πF.SetLineno(2941)
							// line 2942: self.output.tag = 'span class="MathJax_Preview"'
							πF.SetLineno(2942)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewStr("span class=\"MathJax_Preview\"").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
							// line 2943: tag = 'script type="math/tex'
							πF.SetLineno(2943)
							µtag = πg.NewStr("script type=\"math/tex").ToObject()
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.NE(πF, πTemp003, ßinline.ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2944: if self.header[0] != 'inline':
							πF.SetLineno(2944)
						Label1:
							// line 2945: tag += ';mode=display'
							πF.SetLineno(2945)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µtag, πg.NewStr(";mode=display").ToObject()); πE != nil {
								continue
							}
							µtag = πTemp001
							goto Label2
						Label2:
							// line 2946: self.contents = [TaggedText().constant(self.parsed, tag + '"', True)]
							πF.SetLineno(2946)
							πTemp006 = make([]*πg.Object, 1)
							πTemp007 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsed, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µtag, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							πTemp007[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp007[2] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßconstant, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp006[0] = πTemp002
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßmathjax.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2941: "Make the contents for MathJax."
					πF.SetLineno(2941)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Make the contents for MathJax.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßmathjax); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 2948: def googlecharts(self):
					πF.SetLineno(2948)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("googlecharts", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µurl *πg.Object = πg.UnboundLocal
						_ = µurl
						var µimg *πg.Object = πg.UnboundLocal
						_ = µimg
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2949: "Make the contents using Google Charts http://code.google.com/apis/chart/."
							πF.SetLineno(2949)
							// line 2950: url = FormulaConfig.urls['googlecharts'] + quote_plus(self.parsed)
							πF.SetLineno(2950)
							πTemp002 = ßgooglecharts.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßurls, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsed, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßquote_plus); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Add(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							µurl = πTemp001
							// line 2951: img = '<img class="chart" src="' + url + '" alt="' + self.parsed + '"/>'
							πF.SetLineno(2951)
							if πE = πg.CheckLocal(πF, µurl, "url"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πg.NewStr("<img class=\"chart\" src=\"").ToObject(), µurl); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, πg.NewStr("\" alt=\"").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßparsed, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"/>").ToObject()); πE != nil {
								continue
							}
							µimg = πTemp001
							// line 2952: self.contents = [Constant(img)]
							πF.SetLineno(2952)
							πTemp006 = make([]*πg.Object, 1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µimg, "img"); πE != nil {
								continue
							}
							πTemp007[0] = µimg
							if πTemp001, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp006[0] = πTemp002
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgooglecharts.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 2949: "Make the contents using Google Charts http://code.google.com/apis/chart/."
					πF.SetLineno(2949)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Make the contents using Google Charts http://code.google.com/apis/chart/.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßgooglecharts); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 2954: def classic(self):
					πF.SetLineno(2954)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("classic", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µwhole *πg.Object = πg.UnboundLocal
						_ = µwhole
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2955: "Make the contents using classic output generation with XHTML and CSS."
							πF.SetLineno(2955)
							// line 2956: whole = FormulaFactory().parseformula(self.parsed)
							πF.SetLineno(2956)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsed, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaFactory); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßparseformula, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µwhole = πTemp003
							// line 2957: FormulaProcessor().process(whole)
							πF.SetLineno(2957)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
								continue
							}
							πTemp001[0] = µwhole
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaProcessor); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßprocess, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2958: whole.parent = self
							πF.SetLineno(2958)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µself); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µwhole, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2959: self.contents = [whole]
							πF.SetLineno(2959)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
								continue
							}
							πTemp001[0] = µwhole
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßclassic.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 2955: "Make the contents using classic output generation with XHTML and CSS."
					πF.SetLineno(2955)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Make the contents using classic output generation with XHTML and CSS.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßclassic); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 2961: def parse(self, pos):
					πF.SetLineno(2961)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2962: "Parse using a parse position instead of self.parser."
							πF.SetLineno(2962)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("$$").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("$").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\\(").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\\[").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 2963: if pos.checkskip('$$'):
							πF.SetLineno(2963)
						Label1:
							// line 2964: self.parsedollarblock(pos)
							πF.SetLineno(2964)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsedollarblock, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label6
							// line 2965: elif pos.checkskip('$'):
							πF.SetLineno(2965)
						Label2:
							// line 2966: self.parsedollarinline(pos)
							πF.SetLineno(2966)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsedollarinline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label6
							// line 2967: elif pos.checkskip('\\('):
							πF.SetLineno(2967)
						Label3:
							// line 2968: self.parseinlineto(pos, '\\)')
							πF.SetLineno(2968)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							πTemp001[1] = πg.NewStr("\\)").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseinlineto, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label6
							// line 2969: elif pos.checkskip('\\['):
							πF.SetLineno(2969)
						Label4:
							// line 2970: self.parseblockto(pos, '\\]')
							πF.SetLineno(2970)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							πTemp001[1] = πg.NewStr("\\]").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseblockto, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label6
						Label5:
							// line 2972: pos.error('Unparseable formula')
							πF.SetLineno(2972)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Unparseable formula").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßerror, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label6
						Label6:
							// line 2973: self.process()
							πF.SetLineno(2973)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßprocess, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2974: return self
							πF.SetLineno(2974)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 2962: "Parse using a parse position instead of self.parser."
					πF.SetLineno(2962)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Parse using a parse position instead of self.parser.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 2976: def parsedollarinline(self, pos):
					πF.SetLineno(2976)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("parsedollarinline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2977: "Parse a $...$ formula."
							πF.SetLineno(2977)
							// line 2978: self.header = ['inline']
							πF.SetLineno(2978)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = ßinline.ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßheader, πTemp003); πE != nil {
								continue
							}
							// line 2979: self.parsedollar(pos)
							πF.SetLineno(2979)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsedollar, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsedollarinline.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 2977: "Parse a $...$ formula."
					πF.SetLineno(2977)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Parse a $...$ formula.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßparsedollarinline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 2981: def parsedollarblock(self, pos):
					πF.SetLineno(2981)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("parsedollarblock", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2982: "Parse a $$...$$ formula."
							πF.SetLineno(2982)
							// line 2983: self.header = ['block']
							πF.SetLineno(2983)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = ßblock.ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßheader, πTemp003); πE != nil {
								continue
							}
							// line 2984: self.parsedollar(pos)
							πF.SetLineno(2984)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsedollar, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("$").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2985: if not pos.checkskip('$'):
							πF.SetLineno(2985)
						Label1:
							// line 2986: pos.error('Formula should be $$...$$, but last $ is missing.')
							πF.SetLineno(2986)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Formula should be $$...$$, but last $ is missing.").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßerror, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsedollarblock.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 2982: "Parse a $$...$$ formula."
					πF.SetLineno(2982)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Parse a $$...$$ formula.").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßparsedollarblock); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
					// line 2988: def parsedollar(self, pos):
					πF.SetLineno(2988)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("parsedollar", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2989: "Parse to the next $."
							πF.SetLineno(2989)
							// line 2990: pos.pushending('$')
							πF.SetLineno(2990)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("$").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßpushending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2991: self.parsed = pos.globexcluding('$')
							πF.SetLineno(2991)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("$").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßglobexcluding, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparsed, πTemp002); πE != nil {
								continue
							}
							// line 2992: pos.popending('$')
							πF.SetLineno(2992)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("$").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßpopending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsedollar.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 2989: "Parse to the next $."
					πF.SetLineno(2989)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Parse to the next $.").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßparsedollar); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
					// line 2994: def parseinlineto(self, pos, limit):
					πF.SetLineno(2994)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002[2] = πg.Param{Name: "limit", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("parseinlineto", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µlimit *πg.Object = πArgs[2]
						_ = µlimit
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2995: "Parse a \\(...\\) formula."
							πF.SetLineno(2995)
							// line 2996: self.header = ['inline']
							πF.SetLineno(2996)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = ßinline.ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßheader, πTemp003); πE != nil {
								continue
							}
							// line 2997: self.parseupto(pos, limit)
							πF.SetLineno(2997)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							πTemp001[1] = µlimit
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseupto, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseinlineto.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 2995: "Parse a \\(...\\) formula."
					πF.SetLineno(2995)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp013}, πg.NewStr("Parse a \\(...\\) formula.").ToObject()); πE != nil {
						continue
					}
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßparseinlineto); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp014, ß__doc__, πTemp013); πE != nil {
						continue
					}
					// line 2999: def parseblockto(self, pos, limit):
					πF.SetLineno(2999)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002[2] = πg.Param{Name: "limit", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("parseblockto", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µlimit *πg.Object = πArgs[2]
						_ = µlimit
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3000: "Parse a \\[...\\] formula."
							πF.SetLineno(3000)
							// line 3001: self.header = ['block']
							πF.SetLineno(3001)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = ßblock.ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßheader, πTemp003); πE != nil {
								continue
							}
							// line 3002: self.parseupto(pos, limit)
							πF.SetLineno(3002)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							πTemp001[1] = µlimit
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseupto, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseblockto.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 3000: "Parse a \\[...\\] formula."
					πF.SetLineno(3000)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp014}, πg.NewStr("Parse a \\[...\\] formula.").ToObject()); πE != nil {
						continue
					}
					if πTemp015, πE = πg.ResolveClass(πF, πClass, nil, ßparseblockto); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp015, ß__doc__, πTemp014); πE != nil {
						continue
					}
					// line 3004: def parseupto(self, pos, limit):
					πF.SetLineno(3004)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002[2] = πg.Param{Name: "limit", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("parseupto", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µlimit *πg.Object = πArgs[2]
						_ = µlimit
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3005: "Parse a formula that ends with the given command."
							πF.SetLineno(3005)
							// line 3006: pos.pushending(limit)
							πF.SetLineno(3006)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							πTemp001[0] = µlimit
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßpushending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3007: self.parsed = pos.glob(lambda: True)
							πF.SetLineno(3007)
							πTemp001 = πF.MakeArgs(1)
							πTemp004 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 *πg.Object
								_ = πTemp001
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 3007: self.parsed = pos.glob(lambda: True)
									πF.SetLineno(3007)
									if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
										continue
									}
									πR = πTemp001
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßglob, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparsed, πTemp002); πE != nil {
								continue
							}
							// line 3008: pos.popending(limit)
							πF.SetLineno(3008)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							πTemp001[0] = µlimit
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßpopending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseupto.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 3005: "Parse a formula that ends with the given command."
					πF.SetLineno(3005)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp015}, πg.NewStr("Parse a formula that ends with the given command.").ToObject()); πE != nil {
						continue
					}
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ßparseupto); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp016, ß__doc__, πTemp015); πE != nil {
						continue
					}
					// line 3010: def __unicode__(self):
					πF.SetLineno(3010)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp015 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3011: "Return a printable representation."
							πF.SetLineno(3011)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpartkey, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpartkey, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßnumber, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 3012: if self.partkey and self.partkey.number:
							πF.SetLineno(3012)
						Label2:
							// line 3013: return 'Formula (' + self.partkey.number + ')'
							πF.SetLineno(3013)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpartkey, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßnumber, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Formula (").ToObject(), πTemp005); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr(")").ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label3
						Label3:
							// line 3014: return 'Unnumbered formula'
							πF.SetLineno(3014)
							πR = πg.NewStr("Unnumbered formula").ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 3011: "Return a printable representation."
					πF.SetLineno(3011)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp016}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp017, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp017, ß__doc__, πTemp016); πE != nil {
						continue
					}
					if πTemp017, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp018, πE = πg.GetAttr(πF, πTemp017, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp017 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp016, πE = πg.GE(πF, πTemp018, πTemp017); πE != nil {
						continue
					}
					if πTemp019, πE = πg.IsTrue(πF, πTemp016); πE != nil {
						continue
					}
					if πTemp019 {
						goto Label1
					}
					goto Label2
					// line 3016: if sys.version_info >= (3, 0):
					πF.SetLineno(3016)
				Label1:
					// line 3017: __str__ = __unicode__
					πF.SetLineno(3017)
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp016); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Formula").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormula.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3020: class WholeFormula(FormulaBit):
			πF.SetLineno(3020)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("WholeFormula", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3021: "Parse a whole formula"
					πF.SetLineno(3021)
					// line 3021: "Parse a whole formula"
					πF.SetLineno(3021)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Parse a whole formula").ToObject()); πE != nil {
						continue
					}
					// line 3023: def detect(self, pos):
					πF.SetLineno(3023)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3024: "Not outside the formula is enough."
							πF.SetLineno(3024)
							// line 3025: return not pos.finished()
							πF.SetLineno(3025)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3024: "Not outside the formula is enough."
					πF.SetLineno(3024)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Not outside the formula is enough.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 3027: def parsebit(self, pos):
					πF.SetLineno(3027)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 3028: "Parse with any formula bit"
							πF.SetLineno(3028)
							// line 3029: while not pos.finished():
							πF.SetLineno(3029)
							πF.PushCheckpoint(2)
							πTemp001 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp001 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πE != nil || !πTemp002 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 3030: self.add(self.factory.parseany(pos))
							πF.SetLineno(3030)
							πTemp007 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp008[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßparseany, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp007[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3028: "Parse with any formula bit"
					πF.SetLineno(3028)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse with any formula bit").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("WholeFormula").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßWholeFormula.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3032: class FormulaFactory(object):
			πF.SetLineno(3032)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaFactory", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3033: "Construct bits of formula"
					πF.SetLineno(3033)
					// line 3033: "Construct bits of formula"
					πF.SetLineno(3033)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Construct bits of formula").ToObject()); πE != nil {
						continue
					}
					// line 3036: types = [FormulaSymbol, RawText, FormulaNumber, Bracket, Comment, WhiteSpace]
					πF.SetLineno(3036)
					πTemp001 = make([]*πg.Object, 6)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaSymbol); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßRawText); πE != nil {
						continue
					}
					πTemp001[1] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaNumber); πE != nil {
						continue
					}
					πTemp001[2] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßBracket); πE != nil {
						continue
					}
					πTemp001[3] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßComment); πE != nil {
						continue
					}
					πTemp001[4] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßWhiteSpace); πE != nil {
						continue
					}
					πTemp001[5] = πTemp002
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πE = πClass.SetItem(πF, ßtypes.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3037: skippedtypes = [Comment, WhiteSpace]
					πF.SetLineno(3037)
					πTemp001 = make([]*πg.Object, 2)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßComment); πE != nil {
						continue
					}
					πTemp001[0] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßWhiteSpace); πE != nil {
						continue
					}
					πTemp001[1] = πTemp002
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πE = πClass.SetItem(πF, ßskippedtypes.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3038: defining = False
					πF.SetLineno(3038)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßdefining.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3040: def __init__(self):
					πF.SetLineno(3040)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3041: "Initialize the map of instances."
							πF.SetLineno(3041)
							// line 3042: self.instances = dict()
							πF.SetLineno(3042)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßinstances, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3041: "Initialize the map of instances."
					πF.SetLineno(3041)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Initialize the map of instances.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 3044: def detecttype(self, type, pos):
					πF.SetLineno(3044)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp003[2] = πg.Param{Name: "pos", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("detecttype", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µpos *πg.Object = πArgs[2]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3045: "Detect a bit of a given type."
							πF.SetLineno(3045)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 3046: if pos.finished():
							πF.SetLineno(3046)
						Label1:
							// line 3047: return False
							πF.SetLineno(3047)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 3048: return self.instance(type).detect(pos)
							πF.SetLineno(3048)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp004[0] = µpos
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßinstance, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßdetect, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetecttype.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3045: "Detect a bit of a given type."
					πF.SetLineno(3045)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Detect a bit of a given type.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßdetecttype); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 3050: def instance(self, type):
					πF.SetLineno(3050)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("instance", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3051: "Get an instance of the given type."
							πF.SetLineno(3051)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßinstances, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, µtype); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp004 = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßinstances, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp007, πTemp004); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 3052: if not type in self.instances or not self.instances[type]:
							πF.SetLineno(3052)
						Label2:
							// line 3053: self.instances[type] = self.create(type)
							πF.SetLineno(3053)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp008[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßinstances, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005 = µtype
							if πE = πg.SetItem(πF, πTemp004, πTemp005, πTemp001); πE != nil {
								continue
							}
							goto Label3
						Label3:
							// line 3054: return self.instances[type]
							πF.SetLineno(3054)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001 = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßinstances, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinstance.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 3051: "Get an instance of the given type."
					πF.SetLineno(3051)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Get an instance of the given type.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßinstance); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 3056: def create(self, type):
					πF.SetLineno(3056)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("create", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3057: "Create a new formula bit of the given type."
							πF.SetLineno(3057)
							// line 3058: return Cloner.create(type).setfactory(self)
							πF.SetLineno(3058)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp002[0] = µtype
							if πTemp003, πE = πg.ResolveGlobal(πF, ßCloner); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßsetfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcreate.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 3057: "Create a new formula bit of the given type."
					πF.SetLineno(3057)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Create a new formula bit of the given type.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßcreate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 3060: def clearskipped(self, pos):
					πF.SetLineno(3060)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("clearskipped", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 3061: "Clear any skipped types."
							πF.SetLineno(3061)
							// line 3062: while not pos.finished():
							πF.SetLineno(3062)
							πF.PushCheckpoint(2)
							πTemp001 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp001 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πE != nil || !πTemp002 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp007[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßskipany, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp002, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 3063: if not self.skipany(pos):
							πF.SetLineno(3063)
						Label4:
							// line 3064: return
							πF.SetLineno(3064)
							πR = πg.None
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 3065: return
							πF.SetLineno(3065)
							πR = πg.None
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßclearskipped.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 3061: "Clear any skipped types."
					πF.SetLineno(3061)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Clear any skipped types.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßclearskipped); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 3067: def skipany(self, pos):
					πF.SetLineno(3067)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("skipany", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µtype *πg.Object = πg.UnboundLocal
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 3068: "Skip any skipped types."
							πF.SetLineno(3068)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßskippedtypes, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µtype = πTemp002
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp005[0] = µpos
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp006[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinstance, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.GetAttr(πF, πTemp007, ßdetect, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp004, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 3070: if self.instance(type).detect(pos):
							πF.SetLineno(3070)
						Label4:
							// line 3071: return self.parsetype(type, pos)
							πF.SetLineno(3071)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005[0] = µtype
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp005[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsetype, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πR = πTemp007
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 3072: return None
							πF.SetLineno(3072)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßskipany.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 3068: "Skip any skipped types."
					πF.SetLineno(3068)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Skip any skipped types.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßskipany); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 3074: def parseany(self, pos):
					πF.SetLineno(3074)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("parseany", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µtype *πg.Object = πg.UnboundLocal
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 3075: "Parse any formula bit at the current location."
							πF.SetLineno(3075)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtypes, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßskippedtypes, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µtype = πTemp002
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp007[0] = µtype
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp007[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label4
							}
							goto Label5
							// line 3077: if self.detecttype(type, pos):
							πF.SetLineno(3077)
						Label4:
							// line 3078: return self.parsetype(type, pos)
							πF.SetLineno(3078)
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp007[0] = µtype
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp007[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsetype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πR = πTemp003
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 3079: Trace.error('Unrecognized formula at ' + pos.identifier())
							πF.SetLineno(3079)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßidentifier, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unrecognized formula at ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 3080: return FormulaConstant(pos.skipcurrent())
							πF.SetLineno(3080)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseany.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 3075: "Parse any formula bit at the current location."
					πF.SetLineno(3075)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Parse any formula bit at the current location.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßparseany); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 3082: def parsetype(self, type, pos):
					πF.SetLineno(3082)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp003[2] = πg.Param{Name: "pos", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("parsetype", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µpos *πg.Object = πArgs[2]
						_ = µpos
						var µbit *πg.Object = πg.UnboundLocal
						_ = µbit
						var µreturnedbit *πg.Object = πg.UnboundLocal
						_ = µreturnedbit
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3083: "Parse the given type and return it."
							πF.SetLineno(3083)
							// line 3084: bit = self.instance(type)
							πF.SetLineno(3084)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinstance, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbit = πTemp003
							// line 3085: self.instances[type] = None
							πF.SetLineno(3085)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßinstances, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005 = µtype
							if πE = πg.SetItem(πF, πTemp004, πTemp005, πTemp003); πE != nil {
								continue
							}
							// line 3086: returnedbit = bit.parsebit(pos)
							πF.SetLineno(3086)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbit, ßparsebit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µreturnedbit = πTemp003
							if πE = πg.CheckLocal(πF, µreturnedbit, "returnedbit"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µreturnedbit); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 3087: if returnedbit:
							πF.SetLineno(3087)
						Label1:
							// line 3088: return returnedbit.setfactory(self)
							πF.SetLineno(3088)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µreturnedbit, "returnedbit"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreturnedbit, ßsetfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
							goto Label2
						Label2:
							// line 3089: return bit
							πF.SetLineno(3089)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πR = µbit
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsetype.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 3083: "Parse the given type and return it."
					πF.SetLineno(3083)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Parse the given type and return it.").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßparsetype); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
					// line 3091: def parseformula(self, formula):
					πF.SetLineno(3091)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "formula", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("parseformula", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µformula *πg.Object = πArgs[1]
						_ = µformula
						var µpos *πg.Object = πg.UnboundLocal
						_ = µpos
						var µwhole *πg.Object = πg.UnboundLocal
						_ = µwhole
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3092: "Parse a string of text that contains a whole formula."
							πF.SetLineno(3092)
							// line 3093: pos = TextPosition(formula)
							πF.SetLineno(3093)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µformula, "formula"); πE != nil {
								continue
							}
							πTemp001[0] = µformula
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTextPosition); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µpos = πTemp003
							// line 3094: whole = self.create(WholeFormula)
							πF.SetLineno(3094)
							πTemp001 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßWholeFormula); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µwhole = πTemp003
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µwhole, ßdetect, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 3095: if whole.detect(pos):
							πF.SetLineno(3095)
						Label1:
							// line 3096: whole.parsebit(pos)
							πF.SetLineno(3096)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µwhole, ßparsebit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3097: return whole
							πF.SetLineno(3097)
							if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
								continue
							}
							πR = µwhole
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 3099: if not pos.finished():
							πF.SetLineno(3099)
						Label3:
							// line 3100: Trace.error('Unknown formula at: ' + pos.identifier())
							πF.SetLineno(3100)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßidentifier, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Unknown formula at: ").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3101: whole.add(TaggedBit().constant(formula, 'span class="unknown"'))
							πF.SetLineno(3101)
							πTemp001 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µformula, "formula"); πE != nil {
								continue
							}
							πTemp006[0] = µformula
							πTemp006[1] = πg.NewStr("span class=\"unknown\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßconstant, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µwhole, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label4
						Label4:
							// line 3102: return whole
							πF.SetLineno(3102)
							if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
								continue
							}
							πR = µwhole
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseformula.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 3092: "Parse a string of text that contains a whole formula."
					πF.SetLineno(3092)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Parse a string of text that contains a whole formula.").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßparseformula); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaFactory").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaFactory.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3105: class Translator(object):
			πF.SetLineno(3105)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Translator", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 []*πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3106: "Reads the configuration file and tries to find a translation."
					πF.SetLineno(3106)
					// line 3106: "Reads the configuration file and tries to find a translation."
					πF.SetLineno(3106)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Reads the configuration file and tries to find a translation.").ToObject()); πE != nil {
						continue
					}
					// line 3107: "Otherwise falls back to the messages in the config file."
					πF.SetLineno(3107)
					// line 3109: instance = None
					πF.SetLineno(3109)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßinstance.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3111: def translate(cls, key):
					πF.SetLineno(3111)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "cls", Def: nil}
					πTemp002[1] = πg.Param{Name: "key", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("translate", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µcls *πg.Object = πArgs[0]
						_ = µcls
						var µkey *πg.Object = πArgs[1]
						_ = µkey
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3112: "Get the translated message for a key."
							πF.SetLineno(3112)
							// line 3113: return cls.instance.getmessage(key)
							πF.SetLineno(3113)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp001[0] = µkey
							if πE = πg.CheckLocal(πF, µcls, "cls"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcls, ßinstance, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßgetmessage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtranslate.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3112: "Get the translated message for a key."
					πF.SetLineno(3112)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Get the translated message for a key.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßtranslate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 3115: translate = classmethod(translate)
					πF.SetLineno(3115)
					πTemp005 = πF.MakeArgs(1)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßtranslate); πE != nil {
						continue
					}
					πTemp005[0] = πTemp003
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßclassmethod); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp005)
					if πE = πClass.SetItem(πF, ßtranslate.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3117: def __init__(self):
					πF.SetLineno(3117)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3118: self.translation = None
							πF.SetLineno(3118)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtranslation, πTemp002); πE != nil {
								continue
							}
							// line 3119: self.first = True
							πF.SetLineno(3119)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfirst, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3121: def findtranslation(self):
					πF.SetLineno(3121)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("findtranslation", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlangcodes *πg.Object = πg.UnboundLocal
						_ = µlangcodes
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.BaseException
						_ = πTemp008
						var πTemp009 *πg.Traceback
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 8:
								goto Label8
							default:
								panic("unexpected function state")
							}
							// line 3122: "Find the translation for the document language."
							πF.SetLineno(3122)
							// line 3123: self.langcodes = None
							πF.SetLineno(3123)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlangcodes, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßlanguage, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 3124: if not DocumentParameters.language:
							πF.SetLineno(3124)
						Label1:
							// line 3125: Trace.error('No language in document')
							πF.SetLineno(3125)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = πg.NewStr("No language in document").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 3126: return
							πF.SetLineno(3126)
							πR = πg.None
							continue
							goto Label2
						Label2:
							if πTemp003, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßlanguage, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTranslationConfig); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßlanguages, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp007, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 3127: if not DocumentParameters.language in TranslationConfig.languages:
							πF.SetLineno(3127)
						Label3:
							// line 3128: Trace.error('Unknown language ' + DocumentParameters.language)
							πF.SetLineno(3128)
							πTemp005 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßlanguage, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unknown language ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 3129: return
							πF.SetLineno(3129)
							πR = πg.None
							continue
							goto Label4
						Label4:
							if πTemp003, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßlanguage, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp006
							if πTemp006, πE = πg.ResolveGlobal(πF, ßTranslationConfig); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßlanguages, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp007, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, ßen.ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 3130: if TranslationConfig.languages[DocumentParameters.language] == 'en':
							πF.SetLineno(3130)
						Label5:
							// line 3131: return
							πF.SetLineno(3131)
							πR = πg.None
							continue
							goto Label6
						Label6:
							// line 3132: langcodes = [TranslationConfig.languages[DocumentParameters.language]]
							πF.SetLineno(3132)
							πTemp005 = make([]*πg.Object, 1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßlanguage, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTranslationConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßlanguages, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp006, πTemp001); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							µlangcodes = πTemp001
							// line 3133: try:
							πF.SetLineno(3133)
							πF.PushCheckpoint(8)
							// line 3134: self.translation = gettext.translation('elyxer', None, langcodes)
							πF.SetLineno(3134)
							πTemp005 = πF.MakeArgs(3)
							πTemp005[0] = ßelyxer.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µlangcodes, "langcodes"); πE != nil {
								continue
							}
							πTemp005[2] = µlangcodes
							if πTemp001, πE = πg.ResolveGlobal(πF, ßgettext); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtranslation, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtranslation, πTemp002); πE != nil {
								continue
							}
							πF.PopCheckpoint()
							goto Label7
						Label8:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp008, πTemp009 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßIOError); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsInstance(πF, πTemp008.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label9
							}
							πE = πF.Raise(πTemp008.ToObject(), nil, πTemp009.ToObject())
							continue
							// line 3135: except IOError:
							πF.SetLineno(3135)
						Label9:
							// line 3136: Trace.error('No translation for ' + unicode(langcodes))
							πF.SetLineno(3136)
							πTemp005 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlangcodes, "langcodes"); πE != nil {
								continue
							}
							πTemp010[0] = µlangcodes
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							if πTemp001, πE = πg.Add(πF, πg.NewStr("No translation for ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πF.RestoreExc(nil, nil)
							goto Label7
						Label7:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfindtranslation.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3122: "Find the translation for the document language."
					πF.SetLineno(3122)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Find the translation for the document language.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßfindtranslation); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 3138: def getmessage(self, key):
					πF.SetLineno(3138)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "key", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("getmessage", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µkey *πg.Object = πArgs[1]
						_ = µkey
						var µmessage *πg.Object = πg.UnboundLocal
						_ = µmessage
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 6:
								goto Label6
							default:
								panic("unexpected function state")
							}
							// line 3139: "Get the translated message for the given key."
							πF.SetLineno(3139)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfirst, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 3140: if self.first:
							πF.SetLineno(3140)
						Label1:
							// line 3141: self.findtranslation()
							πF.SetLineno(3141)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfindtranslation, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 3142: self.first = False
							πF.SetLineno(3142)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßfirst, πTemp003); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 3143: message = self.getuntranslated(key)
							πF.SetLineno(3143)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp004[0] = µkey
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetuntranslated, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µmessage = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtranslation, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 3144: if not self.translation:
							πF.SetLineno(3144)
						Label3:
							// line 3145: return message
							πF.SetLineno(3145)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πR = µmessage
							continue
							goto Label4
						Label4:
							// line 3146: try:
							πF.SetLineno(3146)
							πF.PushCheckpoint(6)
							// line 3147: message = self.translation.ugettext(message)
							πF.SetLineno(3147)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp004[0] = µmessage
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßtranslation, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßugettext, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µmessage = πTemp001
							πF.PopCheckpoint()
							goto Label5
						Label6:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßIOError); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label7
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 3148: except IOError:
							πF.SetLineno(3148)
						Label7:
							// line 3149: pass
							πF.SetLineno(3149)
							πF.RestoreExc(nil, nil)
							goto Label5
						Label5:
							// line 3150: return message
							πF.SetLineno(3150)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πR = µmessage
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetmessage.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 3139: "Get the translated message for the given key."
					πF.SetLineno(3139)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Get the translated message for the given key.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßgetmessage); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 3152: def getuntranslated(self, key):
					πF.SetLineno(3152)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "key", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("getuntranslated", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µkey *πg.Object = πArgs[1]
						_ = µkey
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3153: "Get the untranslated message."
							πF.SetLineno(3153)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTranslationConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßconstants, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, µkey); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3154: if not key in TranslationConfig.constants:
							πF.SetLineno(3154)
						Label1:
							// line 3155: Trace.error('Cannot translate ' + key)
							πF.SetLineno(3155)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Cannot translate ").ToObject(), µkey); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 3156: return key
							πF.SetLineno(3156)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πR = µkey
							continue
							goto Label2
						Label2:
							// line 3157: return TranslationConfig.constants[key]
							πF.SetLineno(3157)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp001 = µkey
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTranslationConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßconstants, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetuntranslated.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 3153: "Get the untranslated message."
					πF.SetLineno(3153)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Get the untranslated message.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßgetuntranslated); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Translator").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTranslator.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3159: Translator.instance = Translator()
			πF.SetLineno(3159)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßTranslator); πE != nil {
				continue
			}
			if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
				continue
			}
			if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
				continue
			}
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTranslator); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp004, ßinstance, πTemp001); πE != nil {
				continue
			}
			// line 3163: class NumberCounter(object):
			πF.SetLineno(3163)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("NumberCounter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 []*πg.Object
				_ = πTemp005
				var πTemp006 []πg.Param
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 bool
				_ = πTemp018
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3164: "A counter for numbers (by default)."
					πF.SetLineno(3164)
					// line 3164: "A counter for numbers (by default)."
					πF.SetLineno(3164)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A counter for numbers (by default).").ToObject()); πE != nil {
						continue
					}
					// line 3165: "The type can be changed to return letters, roman numbers..."
					πF.SetLineno(3165)
					// line 3167: name = None
					πF.SetLineno(3167)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßname.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3168: value = None
					πF.SetLineno(3168)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßvalue.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3169: mode = None
					πF.SetLineno(3169)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßmode.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3170: master = None
					πF.SetLineno(3170)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßmaster.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3172: letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
					πF.SetLineno(3172)
					if πE = πClass.SetItem(πF, ßletters.ToObject(), ßABCDEFGHIJKLMNOPQRSTUVWXYZ.ToObject()); πE != nil {
						continue
					}
					// line 3173: symbols = NumberingConfig.sequence['symbols']
					πF.SetLineno(3173)
					πTemp001 = ßsymbols.ToObject()
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNumberingConfig); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßsequence, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßsymbols.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3174: romannumerals = [
					πF.SetLineno(3174)
					πTemp005 = make([]*πg.Object, 13)
					πTemp001 = πg.NewTuple2(ßM.ToObject(), πg.NewInt(1000).ToObject()).ToObject()
					πTemp005[0] = πTemp001
					πTemp001 = πg.NewTuple2(ßCM.ToObject(), πg.NewInt(900).ToObject()).ToObject()
					πTemp005[1] = πTemp001
					πTemp001 = πg.NewTuple2(ßD.ToObject(), πg.NewInt(500).ToObject()).ToObject()
					πTemp005[2] = πTemp001
					πTemp001 = πg.NewTuple2(ßCD.ToObject(), πg.NewInt(400).ToObject()).ToObject()
					πTemp005[3] = πTemp001
					πTemp001 = πg.NewTuple2(ßC.ToObject(), πg.NewInt(100).ToObject()).ToObject()
					πTemp005[4] = πTemp001
					πTemp001 = πg.NewTuple2(ßXC.ToObject(), πg.NewInt(90).ToObject()).ToObject()
					πTemp005[5] = πTemp001
					πTemp001 = πg.NewTuple2(ßL.ToObject(), πg.NewInt(50).ToObject()).ToObject()
					πTemp005[6] = πTemp001
					πTemp001 = πg.NewTuple2(ßXL.ToObject(), πg.NewInt(40).ToObject()).ToObject()
					πTemp005[7] = πTemp001
					πTemp001 = πg.NewTuple2(ßX.ToObject(), πg.NewInt(10).ToObject()).ToObject()
					πTemp005[8] = πTemp001
					πTemp001 = πg.NewTuple2(ßIX.ToObject(), πg.NewInt(9).ToObject()).ToObject()
					πTemp005[9] = πTemp001
					πTemp001 = πg.NewTuple2(ßV.ToObject(), πg.NewInt(5).ToObject()).ToObject()
					πTemp005[10] = πTemp001
					πTemp001 = πg.NewTuple2(ßIV.ToObject(), πg.NewInt(4).ToObject()).ToObject()
					πTemp005[11] = πTemp001
					πTemp001 = πg.NewTuple2(ßI.ToObject(), πg.NewInt(1).ToObject()).ToObject()
					πTemp005[12] = πTemp001
					πTemp001 = πg.NewList(πTemp005...).ToObject()
					if πE = πClass.SetItem(πF, ßromannumerals.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3180: def __init__(self, name):
					πF.SetLineno(3180)
					πTemp006 = make([]πg.Param, 2)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "name", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µname *πg.Object = πArgs[1]
						_ = µname
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3181: "Give a name to the counter."
							πF.SetLineno(3181)
							// line 3182: self.name = name
							πF.SetLineno(3182)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µname); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßname, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3181: "Give a name to the counter."
					πF.SetLineno(3181)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Give a name to the counter.").ToObject()); πE != nil {
						continue
					}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp003, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 3184: def setmode(self, mode):
					πF.SetLineno(3184)
					πTemp006 = make([]πg.Param, 2)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "mode", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("setmode", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmode *πg.Object = πArgs[1]
						_ = µmode
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3185: "Set the counter mode. Can be changed at runtime."
							πF.SetLineno(3185)
							// line 3186: self.mode = mode
							πF.SetLineno(3186)
							if πE = πg.CheckLocal(πF, µmode, "mode"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µmode); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmode, πTemp001); πE != nil {
								continue
							}
							// line 3187: return self
							πF.SetLineno(3187)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetmode.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3185: "Set the counter mode. Can be changed at runtime."
					πF.SetLineno(3185)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Set the counter mode. Can be changed at runtime.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßsetmode); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 3189: def init(self, value):
					πF.SetLineno(3189)
					πTemp006 = make([]πg.Param, 2)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "value", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("init", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µvalue *πg.Object = πArgs[1]
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3190: "Set an initial value."
							πF.SetLineno(3190)
							// line 3191: self.value = value
							πF.SetLineno(3191)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µvalue); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalue, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinit.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3190: "Set an initial value."
					πF.SetLineno(3190)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Set an initial value.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßinit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 3193: def gettext(self):
					πF.SetLineno(3193)
					πTemp006 = make([]πg.Param, 1)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("gettext", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3194: "Get the next value as a text string."
							πF.SetLineno(3194)
							// line 3195: return unicode(self.value)
							πF.SetLineno(3195)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßvalue, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgettext.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3194: "Get the next value as a text string."
					πF.SetLineno(3194)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Get the next value as a text string.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßgettext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 3197: def getletter(self):
					πF.SetLineno(3197)
					πTemp006 = make([]πg.Param, 1)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("getletter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3198: "Get the next value as a letter."
							πF.SetLineno(3198)
							// line 3199: return self.getsequence(self.letters)
							πF.SetLineno(3199)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßletters, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetsequence, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetletter.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 3198: "Get the next value as a letter."
					πF.SetLineno(3198)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Get the next value as a letter.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßgetletter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 3201: def getsymbol(self):
					πF.SetLineno(3201)
					πTemp006 = make([]πg.Param, 1)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("getsymbol", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3202: "Get the next value as a symbol."
							πF.SetLineno(3202)
							// line 3203: return self.getsequence(self.symbols)
							πF.SetLineno(3203)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsymbols, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetsequence, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetsymbol.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 3202: "Get the next value as a symbol."
					πF.SetLineno(3202)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Get the next value as a symbol.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßgetsymbol); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 3205: def getsequence(self, sequence):
					πF.SetLineno(3205)
					πTemp006 = make([]πg.Param, 2)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "sequence", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("getsequence", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µsequence *πg.Object = πArgs[1]
						_ = µsequence
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3206: "Get the next value from elyxer.a sequence."
							πF.SetLineno(3206)
							// line 3207: return sequence[(self.value - 1) % len(sequence)]
							πF.SetLineno(3207)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Sub(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							πTemp005[0] = µsequence
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp002, πE = πg.Mod(πF, πTemp003, πTemp006); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µsequence, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetsequence.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 3206: "Get the next value from elyxer.a sequence."
					πF.SetLineno(3206)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Get the next value from elyxer.a sequence.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßgetsequence); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 3209: def getroman(self):
					πF.SetLineno(3209)
					πTemp006 = make([]πg.Param, 1)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("getroman", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µnumber *πg.Object = πg.UnboundLocal
						_ = µnumber
						var µnumeral *πg.Object = πg.UnboundLocal
						_ = µnumeral
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 3210: "Get the next value as a roman number."
							πF.SetLineno(3210)
							// line 3211: result = ''
							πF.SetLineno(3211)
							µresult = ß.ToObject()
							// line 3212: number = self.value
							πF.SetLineno(3212)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßvalue, nil); πE != nil {
								continue
							}
							µnumber = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßromannumerals, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp002); πE != nil {
									continue
								}
								µnumeral = πTemp005
								µvalue = πTemp006
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GE(πF, µnumber, µvalue); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 3214: if number >= value:
							πF.SetLineno(3214)
						Label4:
							// line 3215: result += numeral * (number / value)
							πF.SetLineno(3215)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnumeral, "numeral"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Div(πF, µnumber, µvalue); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mul(πF, µnumeral, πTemp005); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IAdd(πF, µresult, πTemp002); πE != nil {
								continue
							}
							µresult = πTemp005
							// line 3216: number = number % value
							πF.SetLineno(3216)
							if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, µnumber, µvalue); πE != nil {
								continue
							}
							µnumber = πTemp002
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 3217: return result
							πF.SetLineno(3217)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetroman.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 3210: "Get the next value as a roman number."
					πF.SetLineno(3210)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Get the next value as a roman number.").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßgetroman); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
					// line 3219: def getvalue(self):
					πF.SetLineno(3219)
					πTemp006 = make([]πg.Param, 1)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("getvalue", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3220: "Get the current value as configured in the current mode."
							πF.SetLineno(3220)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßmode, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp005).ToObject()
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßmode, nil); πE != nil {
								continue
							}
							πTemp006 = make([]*πg.Object, 2)
							πTemp006[0] = ßtext.ToObject()
							πTemp006[1] = ß1.ToObject()
							πTemp007 = πg.NewList(πTemp006...).ToObject()
							if πTemp005, πE = πg.Contains(πF, πTemp007, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp005).ToObject()
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 3221: if not self.mode or self.mode in ['text', '1']:
							πF.SetLineno(3221)
						Label2:
							// line 3222: return self.gettext()
							πF.SetLineno(3222)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgettext, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label3
						Label3:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßmode, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, ßA.ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 3223: if self.mode == 'A':
							πF.SetLineno(3223)
						Label4:
							// line 3224: return self.getletter()
							πF.SetLineno(3224)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetletter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label5
						Label5:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßmode, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, ßa.ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label6
							}
							goto Label7
							// line 3225: if self.mode == 'a':
							πF.SetLineno(3225)
						Label6:
							// line 3226: return self.getletter().lower()
							πF.SetLineno(3226)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetletter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßlower, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label7
						Label7:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßmode, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, ßI.ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label8
							}
							goto Label9
							// line 3227: if self.mode == 'I':
							πF.SetLineno(3227)
						Label8:
							// line 3228: return self.getroman()
							πF.SetLineno(3228)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetroman, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label9
						Label9:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßmode, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label10
							}
							goto Label11
							// line 3229: if self.mode == '*':
							πF.SetLineno(3229)
						Label10:
							// line 3230: return self.getsymbol()
							πF.SetLineno(3230)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetsymbol, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label11
						Label11:
							// line 3231: Trace.error('Unknown counter mode ' + self.mode)
							πF.SetLineno(3231)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßmode, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unknown counter mode ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 3232: return self.gettext()
							πF.SetLineno(3232)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgettext, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetvalue.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 3220: "Get the current value as configured in the current mode."
					πF.SetLineno(3220)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Get the current value as configured in the current mode.").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßgetvalue); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
					// line 3234: def getnext(self):
					πF.SetLineno(3234)
					πTemp006 = make([]πg.Param, 1)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("getnext", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3235: "Increase the current value and get the next value as configured."
							πF.SetLineno(3235)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 3236: if not self.value:
							πF.SetLineno(3236)
						Label1:
							// line 3237: self.value = 0
							πF.SetLineno(3237)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalue, πTemp001); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 3238: self.value += 1
							πF.SetLineno(3238)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßvalue, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalue, πTemp002); πE != nil {
								continue
							}
							// line 3239: return self.getvalue()
							πF.SetLineno(3239)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetvalue, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetnext.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 3235: "Increase the current value and get the next value as configured."
					πF.SetLineno(3235)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp013}, πg.NewStr("Increase the current value and get the next value as configured.").ToObject()); πE != nil {
						continue
					}
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßgetnext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp014, ß__doc__, πTemp013); πE != nil {
						continue
					}
					// line 3241: def reset(self):
					πF.SetLineno(3241)
					πTemp006 = make([]πg.Param, 1)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("reset", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3242: "Reset the counter."
							πF.SetLineno(3242)
							// line 3243: self.value = 0
							πF.SetLineno(3243)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalue, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreset.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 3242: "Reset the counter."
					πF.SetLineno(3242)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp014}, πg.NewStr("Reset the counter.").ToObject()); πE != nil {
						continue
					}
					if πTemp015, πE = πg.ResolveClass(πF, πClass, nil, ßreset); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp015, ß__doc__, πTemp014); πE != nil {
						continue
					}
					// line 3245: def __unicode__(self):
					πF.SetLineno(3245)
					πTemp006 = make([]πg.Param, 1)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3246: "Return a printable representation."
							πF.SetLineno(3246)
							// line 3247: result = 'Counter ' + self.name
							πF.SetLineno(3247)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßname, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Counter ").ToObject(), πTemp002); πE != nil {
								continue
							}
							µresult = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmode, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 3248: if self.mode:
							πF.SetLineno(3248)
						Label1:
							// line 3249: result += ' in mode ' + self.mode
							πF.SetLineno(3249)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßmode, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr(" in mode ").ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µresult, πTemp001); πE != nil {
								continue
							}
							µresult = πTemp002
							goto Label2
						Label2:
							// line 3250: return result
							πF.SetLineno(3250)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 3246: "Return a printable representation."
					πF.SetLineno(3246)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp015}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp016, ß__doc__, πTemp015); πE != nil {
						continue
					}
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp017, πE = πg.GetAttr(πF, πTemp016, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp016 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp015, πE = πg.GE(πF, πTemp017, πTemp016); πE != nil {
						continue
					}
					if πTemp018, πE = πg.IsTrue(πF, πTemp015); πE != nil {
						continue
					}
					if πTemp018 {
						goto Label1
					}
					goto Label2
					// line 3252: if sys.version_info >= (3, 0):
					πF.SetLineno(3252)
				Label1:
					// line 3253: __str__ = __unicode__
					πF.SetLineno(3253)
					if πTemp015, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp015); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("NumberCounter").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßNumberCounter.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3256: class DependentCounter(NumberCounter):
			πF.SetLineno(3256)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßNumberCounter); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("DependentCounter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3257: "A counter which depends on another one (the master)."
					πF.SetLineno(3257)
					// line 3257: "A counter which depends on another one (the master)."
					πF.SetLineno(3257)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A counter which depends on another one (the master).").ToObject()); πE != nil {
						continue
					}
					// line 3259: def setmaster(self, master):
					πF.SetLineno(3259)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "master", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("setmaster", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmaster *πg.Object = πArgs[1]
						_ = µmaster
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3260: "Set the master counter."
							πF.SetLineno(3260)
							// line 3261: self.master = master
							πF.SetLineno(3261)
							if πE = πg.CheckLocal(πF, µmaster, "master"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µmaster); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmaster, πTemp001); πE != nil {
								continue
							}
							// line 3262: self.last = self.master.getvalue()
							πF.SetLineno(3262)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmaster, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßgetvalue, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlast, πTemp002); πE != nil {
								continue
							}
							// line 3263: return self
							πF.SetLineno(3263)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetmaster.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3260: "Set the master counter."
					πF.SetLineno(3260)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Set the master counter.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßsetmaster); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 3265: def getnext(self):
					πF.SetLineno(3265)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("getnext", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3266: "Increase or, if the master counter has changed, restart."
							πF.SetLineno(3266)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßlast, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßmaster, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßgetvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.NE(πF, πTemp002, πTemp003); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3267: if self.last != self.master.getvalue():
							πF.SetLineno(3267)
						Label1:
							// line 3268: self.reset()
							πF.SetLineno(3268)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 3269: value = NumberCounter.getnext(self)
							πF.SetLineno(3269)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp006[0] = µself
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNumberCounter); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßgetnext, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µvalue = πTemp001
							// line 3270: self.last = self.master.getvalue()
							πF.SetLineno(3270)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmaster, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßgetvalue, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlast, πTemp002); πE != nil {
								continue
							}
							// line 3271: return value
							πF.SetLineno(3271)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πR = µvalue
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetnext.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3266: "Increase or, if the master counter has changed, restart."
					πF.SetLineno(3266)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Increase or, if the master counter has changed, restart.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßgetnext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 3273: def getvalue(self):
					πF.SetLineno(3273)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("getvalue", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3274: "Get the value of the combined counter: master.dependent."
							πF.SetLineno(3274)
							// line 3275: return self.master.getvalue() + '.' + NumberCounter.getvalue(self)
							πF.SetLineno(3275)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßmaster, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßgetvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr(".").ToObject()); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp005[0] = µself
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNumberCounter); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßgetvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp003); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetvalue.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3274: "Get the value of the combined counter: master.dependent."
					πF.SetLineno(3274)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Get the value of the combined counter: master.dependent.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßgetvalue); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("DependentCounter").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßDependentCounter.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3277: class NumberGenerator(object):
			πF.SetLineno(3277)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("NumberGenerator", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				var πTemp019 *πg.Object
				_ = πTemp019
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3278: "A number generator for unique sequences and hierarchical structures. Used in:"
					πF.SetLineno(3278)
					// line 3278: "A number generator for unique sequences and hierarchical structures. Used in:"
					πF.SetLineno(3278)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A number generator for unique sequences and hierarchical structures. Used in:").ToObject()); πE != nil {
						continue
					}
					// line 3279: "  * ordered part numbers: Chapter 3, Section 5.3."
					πF.SetLineno(3279)
					// line 3280: "  * unique part numbers: Footnote 15, Bibliography cite [15]."
					πF.SetLineno(3280)
					// line 3281: "  * chaptered part numbers: Figure 3.15, Equation (8.3)."
					πF.SetLineno(3281)
					// line 3282: "  * unique roman part numbers: Part I, Book IV."
					πF.SetLineno(3282)
					// line 3284: chaptered = None
					πF.SetLineno(3284)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßchaptered.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3285: generator = None
					πF.SetLineno(3285)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßgenerator.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3287: romanlayouts = [x.lower() for x in NumberingConfig.layouts['roman']]
					πF.SetLineno(3287)
					πTemp003 = make([]πg.Param, 0)
					πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µx *πg.Object = πg.UnboundLocal
						_ = µx
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1:
									goto Label1
								case 2:
									goto Label2
								case 4:
									goto Label4
								default:
									panic("unexpected function state")
								}
								πTemp002 = ßroman.ToObject()
								if πTemp004, πE = πg.ResolveGlobal(πF, ßNumberingConfig); πE != nil {
									continue
								}
								if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßlayouts, nil); πE != nil {
									continue
								}
								if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
									continue
								}
								if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
									continue
								}
								πF.PushCheckpoint(2)
								πTemp006 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp006 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp007 = !isStop
								} else {
									πTemp007 = true
									µx = πTemp002
								}
								if πE != nil || !πTemp007 {
									continue
								}
								πF.PushCheckpoint(1)
								// line 3287: romanlayouts = [x.lower() for x in NumberingConfig.layouts['roman']]
								πF.SetLineno(3287)
								if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
									continue
								}
								if πTemp002, πE = πg.GetAttr(πF, µx, ßlower, nil); πE != nil {
									continue
								}
								if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
									continue
								}
								πF.PushCheckpoint(4)
								return πTemp003, nil
							Label4:
								πTemp002 = πSent
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßromanlayouts.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3288: orderedlayouts = [x.lower() for x in NumberingConfig.layouts['ordered']]
					πF.SetLineno(3288)
					πTemp003 = make([]πg.Param, 0)
					πTemp004 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µx *πg.Object = πg.UnboundLocal
						_ = µx
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1:
									goto Label1
								case 2:
									goto Label2
								case 4:
									goto Label4
								default:
									panic("unexpected function state")
								}
								πTemp002 = ßordered.ToObject()
								if πTemp004, πE = πg.ResolveGlobal(πF, ßNumberingConfig); πE != nil {
									continue
								}
								if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßlayouts, nil); πE != nil {
									continue
								}
								if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
									continue
								}
								if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
									continue
								}
								πF.PushCheckpoint(2)
								πTemp006 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp006 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp007 = !isStop
								} else {
									πTemp007 = true
									µx = πTemp002
								}
								if πE != nil || !πTemp007 {
									continue
								}
								πF.PushCheckpoint(1)
								// line 3288: orderedlayouts = [x.lower() for x in NumberingConfig.layouts['ordered']]
								πF.SetLineno(3288)
								if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
									continue
								}
								if πTemp002, πE = πg.GetAttr(πF, µx, ßlower, nil); πE != nil {
									continue
								}
								if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
									continue
								}
								πF.PushCheckpoint(4)
								return πTemp003, nil
							Label4:
								πTemp002 = πSent
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßorderedlayouts.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3290: counters = dict()
					πF.SetLineno(3290)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßdict); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcounters.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 3291: appendix = None
					πF.SetLineno(3291)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßappendix.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3293: def deasterisk(self, type):
					πF.SetLineno(3293)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("deasterisk", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3294: "Remove the possible asterisk in a layout type."
							πF.SetLineno(3294)
							// line 3295: return type.replace('*', '')
							πF.SetLineno(3295)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("*").ToObject()
							πTemp001[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µtype, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdeasterisk.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3294: "Remove the possible asterisk in a layout type."
					πF.SetLineno(3294)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Remove the possible asterisk in a layout type.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßdeasterisk); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 3297: def isunique(self, type):
					πF.SetLineno(3297)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("isunique", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3298: "Find out if the layout type corresponds to a unique part."
							πF.SetLineno(3298)
							// line 3299: return self.isroman(type)
							πF.SetLineno(3299)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßisroman, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisunique.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 3298: "Find out if the layout type corresponds to a unique part."
					πF.SetLineno(3298)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Find out if the layout type corresponds to a unique part.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßisunique); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 3301: def isroman(self, type):
					πF.SetLineno(3301)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("isroman", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3302: "Find out if the layout type should have roman numeration."
							πF.SetLineno(3302)
							// line 3303: return self.deasterisk(type).lower() in self.romanlayouts
							πF.SetLineno(3303)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp002[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdeasterisk, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßlower, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßromanlayouts, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisroman.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 3302: "Find out if the layout type should have roman numeration."
					πF.SetLineno(3302)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Find out if the layout type should have roman numeration.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßisroman); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 3305: def isinordered(self, type):
					πF.SetLineno(3305)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("isinordered", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3306: "Find out if the layout type corresponds to an (un)ordered part."
							πF.SetLineno(3306)
							// line 3307: return self.deasterisk(type).lower() in self.orderedlayouts
							πF.SetLineno(3307)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp002[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdeasterisk, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßlower, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßorderedlayouts, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisinordered.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 3306: "Find out if the layout type corresponds to an (un)ordered part."
					πF.SetLineno(3306)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Find out if the layout type corresponds to an (un)ordered part.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßisinordered); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 3309: def isnumbered(self, type):
					πF.SetLineno(3309)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("isnumbered", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3310: "Find out if the type for a layout corresponds to a numbered layout."
							πF.SetLineno(3310)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, µtype, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 3311: if '*' in type:
							πF.SetLineno(3311)
						Label1:
							// line 3312: return False
							πF.SetLineno(3312)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßisroman, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 3313: if self.isroman(type):
							πF.SetLineno(3313)
						Label3:
							// line 3314: return True
							πF.SetLineno(3314)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßisinordered, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label5
							}
							goto Label6
							// line 3315: if not self.isinordered(type):
							πF.SetLineno(3315)
						Label5:
							// line 3316: return False
							πF.SetLineno(3316)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label6
						Label6:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßgetlevel, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp004, ßmaxdepth, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GT(πF, πTemp005, πTemp006); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label7
							}
							goto Label8
							// line 3317: if self.getlevel(type) > DocumentParameters.maxdepth:
							πF.SetLineno(3317)
						Label7:
							// line 3318: return False
							πF.SetLineno(3318)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label8
						Label8:
							// line 3319: return True
							πF.SetLineno(3319)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisnumbered.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 3310: "Find out if the type for a layout corresponds to a numbered layout."
					πF.SetLineno(3310)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Find out if the type for a layout corresponds to a numbered layout.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßisnumbered); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 3321: def isunordered(self, type):
					πF.SetLineno(3321)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("isunordered", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3322: "Find out if the type contains an asterisk, basically."
							πF.SetLineno(3322)
							// line 3323: return '*' in type
							πF.SetLineno(3323)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Contains(πF, µtype, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisunordered.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 3322: "Find out if the type contains an asterisk, basically."
					πF.SetLineno(3322)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Find out if the type contains an asterisk, basically.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßisunordered); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 3325: def getlevel(self, type):
					πF.SetLineno(3325)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("getlevel", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µlevel *πg.Object = πg.UnboundLocal
						_ = µlevel
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3326: "Get the level that corresponds to a layout type."
							πF.SetLineno(3326)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßisunique, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 3327: if self.isunique(type):
							πF.SetLineno(3327)
						Label1:
							// line 3328: return 0
							πF.SetLineno(3328)
							πR = πg.NewInt(0).ToObject()
							continue
							goto Label2
						Label2:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßisinordered, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 3329: if not self.isinordered(type):
							πF.SetLineno(3329)
						Label3:
							// line 3330: Trace.error('Unknown layout type ' + type)
							πF.SetLineno(3330)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Unknown layout type ").ToObject(), µtype); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3331: return 0
							πF.SetLineno(3331)
							πR = πg.NewInt(0).ToObject()
							continue
							goto Label4
						Label4:
							// line 3332: type = self.deasterisk(type).lower()
							πF.SetLineno(3332)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdeasterisk, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßlower, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtype = πTemp003
							// line 3333: level = self.orderedlayouts.index(type) + 1
							πF.SetLineno(3333)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßorderedlayouts, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßindex, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µlevel = πTemp002
							// line 3334: return level - DocumentParameters.startinglevel
							πF.SetLineno(3334)
							if πE = πg.CheckLocal(πF, µlevel, "level"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßstartinglevel, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Sub(πF, µlevel, πTemp005); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetlevel.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 3326: "Get the level that corresponds to a layout type."
					πF.SetLineno(3326)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Get the level that corresponds to a layout type.").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßgetlevel); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
					// line 3336: def getparttype(self, type):
					πF.SetLineno(3336)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("getparttype", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3337: "Obtain the type for the part: without the asterisk, "
							πF.SetLineno(3337)
							// line 3338: "and switched to Appendix if necessary."
							πF.SetLineno(3338)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNumberGenerator); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßappendix, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßgetlevel, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp003, πE = πg.Eq(πF, πTemp006, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 3339: if NumberGenerator.appendix and self.getlevel(type) == 1:
							πF.SetLineno(3339)
						Label2:
							// line 3340: return 'Appendix'
							πF.SetLineno(3340)
							πR = ßAppendix.ToObject()
							continue
							goto Label3
						Label3:
							// line 3341: return self.deasterisk(type)
							πF.SetLineno(3341)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdeasterisk, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetparttype.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 3337: "Obtain the type for the part: without the asterisk, "
					πF.SetLineno(3337)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Obtain the type for the part: without the asterisk, ").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßgetparttype); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
					// line 3343: def generate(self, type):
					πF.SetLineno(3343)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("generate", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3344: "Generate a number for a layout type."
							πF.SetLineno(3344)
							// line 3345: "Unique part types such as Part or Book generate roman numbers: Part I."
							πF.SetLineno(3345)
							// line 3346: "Ordered part types return dot-separated tuples: Chapter 5, Subsection 2.3.5."
							πF.SetLineno(3346)
							// line 3347: "Everything else generates unique numbers: Bibliography [1]."
							πF.SetLineno(3347)
							// line 3348: "Each invocation results in a new number."
							πF.SetLineno(3348)
							// line 3349: return self.getcounter(type).getnext()
							πF.SetLineno(3349)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetcounter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßgetnext, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgenerate.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 3344: "Generate a number for a layout type."
					πF.SetLineno(3344)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp013}, πg.NewStr("Generate a number for a layout type.").ToObject()); πE != nil {
						continue
					}
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßgenerate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp014, ß__doc__, πTemp013); πE != nil {
						continue
					}
					// line 3351: def getcounter(self, type):
					πF.SetLineno(3351)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("getcounter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3352: "Get the counter for the given type."
							πF.SetLineno(3352)
							// line 3353: type = type.lower()
							πF.SetLineno(3353)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtype, ßlower, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtype = πTemp002
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcounters, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp003, µtype); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 3354: if not type in self.counters:
							πF.SetLineno(3354)
						Label1:
							// line 3355: self.counters[type] = self.create(type)
							πF.SetLineno(3355)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcounters, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp006 = µtype
							if πE = πg.SetItem(πF, πTemp003, πTemp006, πTemp001); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 3356: return self.counters[type]
							πF.SetLineno(3356)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001 = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcounters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetcounter.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 3352: "Get the counter for the given type."
					πF.SetLineno(3352)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp014}, πg.NewStr("Get the counter for the given type.").ToObject()); πE != nil {
						continue
					}
					if πTemp015, πE = πg.ResolveClass(πF, πClass, nil, ßgetcounter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp015, ß__doc__, πTemp014); πE != nil {
						continue
					}
					// line 3358: def create(self, type):
					πF.SetLineno(3358)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("create", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var µabove *πg.Object = πg.UnboundLocal
						_ = µabove
						var µmaster *πg.Object = πg.UnboundLocal
						_ = µmaster
						var µcounter *πg.Object = πg.UnboundLocal
						_ = µcounter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3359: "Create a counter for the given type."
							πF.SetLineno(3359)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßisnumbered, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp001 = πTemp005
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßgetlevel, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.GT(πF, πTemp006, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp004
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 3360: if self.isnumbered(type) and self.getlevel(type) > 1:
							πF.SetLineno(3360)
						Label2:
							// line 3361: index = self.orderedlayouts.index(type)
							πF.SetLineno(3361)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßorderedlayouts, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßindex, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µindex = πTemp001
							// line 3362: above = self.orderedlayouts[index - 1]
							πF.SetLineno(3362)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Sub(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßorderedlayouts, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							µabove = πTemp004
							// line 3363: master = self.getcounter(above)
							πF.SetLineno(3363)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µabove, "above"); πE != nil {
								continue
							}
							πTemp003[0] = µabove
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetcounter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmaster = πTemp004
							// line 3364: return self.createdependent(type, master)
							πF.SetLineno(3364)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							if πE = πg.CheckLocal(πF, µmaster, "master"); πE != nil {
								continue
							}
							πTemp003[1] = µmaster
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcreatedependent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πR = πTemp004
							continue
							goto Label3
						Label3:
							// line 3365: counter = NumberCounter(type)
							πF.SetLineno(3365)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNumberCounter); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µcounter = πTemp004
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßisroman, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 3366: if self.isroman(type):
							πF.SetLineno(3366)
						Label4:
							// line 3367: counter.setmode('I')
							πF.SetLineno(3367)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßI.ToObject()
							if πE = πg.CheckLocal(πF, µcounter, "counter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcounter, ßsetmode, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label5
						Label5:
							// line 3368: return counter
							πF.SetLineno(3368)
							if πE = πg.CheckLocal(πF, µcounter, "counter"); πE != nil {
								continue
							}
							πR = µcounter
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcreate.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 3359: "Create a counter for the given type."
					πF.SetLineno(3359)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp015}, πg.NewStr("Create a counter for the given type.").ToObject()); πE != nil {
						continue
					}
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ßcreate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp016, ß__doc__, πTemp015); πE != nil {
						continue
					}
					// line 3370: def getdependentcounter(self, type, master):
					πF.SetLineno(3370)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp003[2] = πg.Param{Name: "master", Def: nil}
					πTemp015 = πg.NewFunction(πg.NewCode("getdependentcounter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µmaster *πg.Object = πArgs[2]
						_ = µmaster
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3371: "Get (or create) a counter of the given type that depends on another."
							πF.SetLineno(3371)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßcounters, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, µtype); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp004 = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßcounters, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp007, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ßmaster, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 3372: if not type in self.counters or not self.counters[type].master:
							πF.SetLineno(3372)
						Label2:
							// line 3373: self.counters[type] = self.createdependent(type, master)
							πF.SetLineno(3373)
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp008[0] = µtype
							if πE = πg.CheckLocal(πF, µmaster, "master"); πE != nil {
								continue
							}
							πTemp008[1] = µmaster
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcreatedependent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßcounters, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005 = µtype
							if πE = πg.SetItem(πF, πTemp004, πTemp005, πTemp001); πE != nil {
								continue
							}
							goto Label3
						Label3:
							// line 3374: return self.counters[type]
							πF.SetLineno(3374)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001 = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßcounters, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetdependentcounter.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 3371: "Get (or create) a counter of the given type that depends on another."
					πF.SetLineno(3371)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp016}, πg.NewStr("Get (or create) a counter of the given type that depends on another.").ToObject()); πE != nil {
						continue
					}
					if πTemp017, πE = πg.ResolveClass(πF, πClass, nil, ßgetdependentcounter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp017, ß__doc__, πTemp016); πE != nil {
						continue
					}
					// line 3376: def createdependent(self, type, master):
					πF.SetLineno(3376)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "type", Def: nil}
					πTemp003[2] = πg.Param{Name: "master", Def: nil}
					πTemp016 = πg.NewFunction(πg.NewCode("createdependent", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µmaster *πg.Object = πArgs[2]
						_ = µmaster
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3377: "Create a dependent counter given the master."
							πF.SetLineno(3377)
							// line 3378: return DependentCounter(type).setmaster(master)
							πF.SetLineno(3378)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmaster, "master"); πE != nil {
								continue
							}
							πTemp001[0] = µmaster
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp002[0] = µtype
							if πTemp003, πE = πg.ResolveGlobal(πF, ßDependentCounter); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßsetmaster, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcreatedependent.ToObject(), πTemp016); πE != nil {
						continue
					}
					// line 3377: "Create a dependent counter given the master."
					πF.SetLineno(3377)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp017}, πg.NewStr("Create a dependent counter given the master.").ToObject()); πE != nil {
						continue
					}
					if πTemp018, πE = πg.ResolveClass(πF, πClass, nil, ßcreatedependent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp018, ß__doc__, πTemp017); πE != nil {
						continue
					}
					// line 3380: def startappendix(self):
					πF.SetLineno(3380)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp017 = πg.NewFunction(πg.NewCode("startappendix", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µfirsttype *πg.Object = πg.UnboundLocal
						_ = µfirsttype
						var µcounter *πg.Object = πg.UnboundLocal
						_ = µcounter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3381: "Start appendices here."
							πF.SetLineno(3381)
							// line 3382: firsttype = self.orderedlayouts[DocumentParameters.startinglevel]
							πF.SetLineno(3382)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstartinglevel, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßorderedlayouts, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µfirsttype = πTemp002
							// line 3383: counter = self.getcounter(firsttype)
							πF.SetLineno(3383)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfirsttype, "firsttype"); πE != nil {
								continue
							}
							πTemp004[0] = µfirsttype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetcounter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µcounter = πTemp002
							// line 3384: counter.setmode('A').reset()
							πF.SetLineno(3384)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = ßA.ToObject()
							if πE = πg.CheckLocal(πF, µcounter, "counter"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcounter, ßsetmode, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßreset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 3385: NumberGenerator.appendix = True
							πF.SetLineno(3385)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNumberGenerator); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßappendix, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßstartappendix.ToObject(), πTemp017); πE != nil {
						continue
					}
					// line 3381: "Start appendices here."
					πF.SetLineno(3381)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp018}, πg.NewStr("Start appendices here.").ToObject()); πE != nil {
						continue
					}
					if πTemp019, πE = πg.ResolveClass(πF, πClass, nil, ßstartappendix); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp019, ß__doc__, πTemp018); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("NumberGenerator").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßNumberGenerator.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3387: class ChapteredGenerator(NumberGenerator):
			πF.SetLineno(3387)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßNumberGenerator); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ChapteredGenerator", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3388: "Generate chaptered numbers, as in Chapter.Number."
					πF.SetLineno(3388)
					// line 3388: "Generate chaptered numbers, as in Chapter.Number."
					πF.SetLineno(3388)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Generate chaptered numbers, as in Chapter.Number.").ToObject()); πE != nil {
						continue
					}
					// line 3389: "Used in equations, figures: Equation (5.3), figure 8.15."
					πF.SetLineno(3389)
					// line 3391: def generate(self, type):
					πF.SetLineno(3391)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "type", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("generate", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype *πg.Object = πArgs[1]
						_ = µtype
						var µchapter *πg.Object = πg.UnboundLocal
						_ = µchapter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3392: "Generate a number which goes with first-level numbers (chapters). "
							πF.SetLineno(3392)
							// line 3393: "For the article classes a unique number is generated."
							πF.SetLineno(3393)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstartinglevel, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GT(πF, πTemp003, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 3394: if DocumentParameters.startinglevel > 0:
							πF.SetLineno(3394)
						Label1:
							// line 3395: return NumberGenerator.generator.generate(type)
							πF.SetLineno(3395)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005[0] = µtype
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNumberGenerator); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßgenerator, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßgenerate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 3396: chapter = self.getcounter('Chapter')
							πF.SetLineno(3396)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = ßChapter.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetcounter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µchapter = πTemp002
							// line 3397: return self.getdependentcounter(type, chapter).getnext()
							πF.SetLineno(3397)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp005[0] = µtype
							if πE = πg.CheckLocal(πF, µchapter, "chapter"); πE != nil {
								continue
							}
							πTemp005[1] = µchapter
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetdependentcounter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßgetnext, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgenerate.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3392: "Generate a number which goes with first-level numbers (chapters). "
					πF.SetLineno(3392)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Generate a number which goes with first-level numbers (chapters). ").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßgenerate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ChapteredGenerator").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßChapteredGenerator.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3400: NumberGenerator.chaptered = ChapteredGenerator()
			πF.SetLineno(3400)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßChapteredGenerator); πE != nil {
				continue
			}
			if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
				continue
			}
			if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
				continue
			}
			if πTemp004, πE = πg.ResolveGlobal(πF, ßNumberGenerator); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp004, ßchaptered, πTemp001); πE != nil {
				continue
			}
			// line 3401: NumberGenerator.generator = NumberGenerator()
			πF.SetLineno(3401)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßNumberGenerator); πE != nil {
				continue
			}
			if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
				continue
			}
			if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
				continue
			}
			if πTemp004, πE = πg.ResolveGlobal(πF, ßNumberGenerator); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp004, ßgenerator, πTemp001); πE != nil {
				continue
			}
			// line 3408: class ContainerSize(object):
			πF.SetLineno(3408)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ContainerSize", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3409: "The size of a container."
					πF.SetLineno(3409)
					// line 3409: "The size of a container."
					πF.SetLineno(3409)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("The size of a container.").ToObject()); πE != nil {
						continue
					}
					// line 3411: width = None
					πF.SetLineno(3411)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßwidth.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3412: height = None
					πF.SetLineno(3412)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßheight.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3413: maxwidth = None
					πF.SetLineno(3413)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßmaxwidth.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3414: maxheight = None
					πF.SetLineno(3414)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßmaxheight.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3415: scale = None
					πF.SetLineno(3415)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßscale.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3417: def set(self, width = None, height = None):
					πF.SetLineno(3417)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "width", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "height", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("set", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µwidth *πg.Object = πArgs[1]
						_ = µwidth
						var µheight *πg.Object = πArgs[2]
						_ = µheight
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3418: "Set the proper size with width and height."
							πF.SetLineno(3418)
							// line 3419: self.setvalue('width', width)
							πF.SetLineno(3419)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = ßwidth.ToObject()
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							πTemp001[1] = µwidth
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsetvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3420: self.setvalue('height', height)
							πF.SetLineno(3420)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = ßheight.ToObject()
							if πE = πg.CheckLocal(πF, µheight, "height"); πE != nil {
								continue
							}
							πTemp001[1] = µheight
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsetvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3421: return self
							πF.SetLineno(3421)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßset.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3418: "Set the proper size with width and height."
					πF.SetLineno(3418)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Set the proper size with width and height.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßset); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 3423: def setmax(self, maxwidth = None, maxheight = None):
					πF.SetLineno(3423)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "maxwidth", Def: πTemp004}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "maxheight", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("setmax", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmaxwidth *πg.Object = πArgs[1]
						_ = µmaxwidth
						var µmaxheight *πg.Object = πArgs[2]
						_ = µmaxheight
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3424: "Set max width and/or height."
							πF.SetLineno(3424)
							// line 3425: self.setvalue('maxwidth', maxwidth)
							πF.SetLineno(3425)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = ßmaxwidth.ToObject()
							if πE = πg.CheckLocal(πF, µmaxwidth, "maxwidth"); πE != nil {
								continue
							}
							πTemp001[1] = µmaxwidth
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsetvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3426: self.setvalue('maxheight', maxheight)
							πF.SetLineno(3426)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = ßmaxheight.ToObject()
							if πE = πg.CheckLocal(πF, µmaxheight, "maxheight"); πE != nil {
								continue
							}
							πTemp001[1] = µmaxheight
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsetvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3427: return self
							πF.SetLineno(3427)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetmax.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3424: "Set max width and/or height."
					πF.SetLineno(3424)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Set max width and/or height.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßsetmax); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 3429: def readparameters(self, container):
					πF.SetLineno(3429)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("readparameters", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3430: "Read some size parameters off a container."
							πF.SetLineno(3430)
							// line 3431: self.setparameter(container, 'width')
							πF.SetLineno(3431)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[0] = µcontainer
							πTemp001[1] = ßwidth.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsetparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3432: self.setparameter(container, 'height')
							πF.SetLineno(3432)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[0] = µcontainer
							πTemp001[1] = ßheight.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsetparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3433: self.setparameter(container, 'scale')
							πF.SetLineno(3433)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[0] = µcontainer
							πTemp001[1] = ßscale.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsetparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3434: self.checkvalidheight(container)
							πF.SetLineno(3434)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp001[0] = µcontainer
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcheckvalidheight, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3435: return self
							πF.SetLineno(3435)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreadparameters.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3430: "Read some size parameters off a container."
					πF.SetLineno(3430)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Read some size parameters off a container.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßreadparameters); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 3437: def setparameter(self, container, name):
					πF.SetLineno(3437)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp002[2] = πg.Param{Name: "name", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("setparameter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µname *πg.Object = πArgs[2]
						_ = µname
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3438: "Read a size parameter off a container, and set it if present."
							πF.SetLineno(3438)
							// line 3439: value = container.getparameter(name)
							πF.SetLineno(3439)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[0] = µname
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßgetparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µvalue = πTemp003
							// line 3440: self.setvalue(name, value)
							πF.SetLineno(3440)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[0] = µname
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp001[1] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsetvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetparameter.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 3438: "Read a size parameter off a container, and set it if present."
					πF.SetLineno(3438)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Read a size parameter off a container, and set it if present.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßsetparameter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 3442: def setvalue(self, name, value):
					πF.SetLineno(3442)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "name", Def: nil}
					πTemp002[2] = πg.Param{Name: "value", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("setvalue", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µname *πg.Object = πArgs[1]
						_ = µname
						var µvalue *πg.Object = πArgs[2]
						_ = µvalue
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3443: "Set the value of a parameter name, only if it's valid."
							πF.SetLineno(3443)
							// line 3444: value = self.processparameter(value)
							πF.SetLineno(3444)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp001[0] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßprocessparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µvalue = πTemp003
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µvalue); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 3445: if value:
							πF.SetLineno(3445)
						Label1:
							// line 3446: setattr(self, name, value)
							πF.SetLineno(3446)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[1] = µname
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp001[2] = µvalue
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetvalue.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 3443: "Set the value of a parameter name, only if it's valid."
					πF.SetLineno(3443)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Set the value of a parameter name, only if it's valid.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßsetvalue); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 3448: def checkvalidheight(self, container):
					πF.SetLineno(3448)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("checkvalidheight", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µheightspecial *πg.Object = πg.UnboundLocal
						_ = µheightspecial
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3449: "Check if the height parameter is valid; otherwise erase it."
							πF.SetLineno(3449)
							// line 3450: heightspecial = container.getparameter('height_special')
							πF.SetLineno(3450)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßheight_special.ToObject()
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontainer, ßgetparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µheightspecial = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheight, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp003
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label1
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßheight, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp005
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßextractnumber, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.Eq(πF, πTemp006, ß1.ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp003
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µheightspecial, "heightspecial"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, µheightspecial, ßtotalheight.ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp003
						Label1:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							goto Label3
							// line 3451: if self.height and self.extractnumber(self.height) == '1' and heightspecial == 'totalheight':
							πF.SetLineno(3451)
						Label2:
							// line 3452: self.height = None
							πF.SetLineno(3452)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßheight, πTemp003); πE != nil {
								continue
							}
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckvalidheight.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 3449: "Check if the height parameter is valid; otherwise erase it."
					πF.SetLineno(3449)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Check if the height parameter is valid; otherwise erase it.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßcheckvalidheight); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 3454: def processparameter(self, value):
					πF.SetLineno(3454)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "value", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("processparameter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µvalue *πg.Object = πArgs[1]
						_ = µvalue
						var µignored *πg.Object = πg.UnboundLocal
						_ = µignored
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 5:
								goto Label5
							case 6:
								goto Label6
							default:
								panic("unexpected function state")
							}
							// line 3455: "Do the full processing on a parameter."
							πF.SetLineno(3455)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µvalue); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 3456: if not value:
							πF.SetLineno(3456)
						Label1:
							// line 3457: return None
							πF.SetLineno(3457)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp003[0] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßextractnumber, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Eq(πF, πTemp005, ß0.ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 3458: if self.extractnumber(value) == '0':
							πF.SetLineno(3458)
						Label3:
							// line 3459: return None
							πF.SetLineno(3459)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							πTemp004 = ßignoredtexts.ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ßStyleConfig); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßsize, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp007, πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(6)
							πTemp002 = false
						Label5:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label7
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								µignored = πTemp004
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(5)
							if πE = πg.CheckLocal(πF, µignored, "ignored"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Contains(πF, µvalue, µignored); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp008).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label8
							}
							goto Label9
							// line 3461: if ignored in value:
							πF.SetLineno(3461)
						Label8:
							// line 3462: value = value.replace(ignored, '')
							πF.SetLineno(3462)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µignored, "ignored"); πE != nil {
								continue
							}
							πTemp003[0] = µignored
							πTemp003[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µvalue, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µvalue = πTemp005
							goto Label9
						Label9:
							continue
						Label6:
							if πE != nil || πR != nil {
								continue
							}
						Label7:
							// line 3463: return value
							πF.SetLineno(3463)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πR = µvalue
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocessparameter.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 3455: "Do the full processing on a parameter."
					πF.SetLineno(3455)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Do the full processing on a parameter.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßprocessparameter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 3465: def extractnumber(self, text):
					πF.SetLineno(3465)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("extractnumber", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µdecimal *πg.Object = πg.UnboundLocal
						_ = µdecimal
						var µchar *πg.Object = πg.UnboundLocal
						_ = µchar
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 3466: "Extract the first number in the given text."
							πF.SetLineno(3466)
							// line 3467: result = ''
							πF.SetLineno(3467)
							µresult = ß.ToObject()
							// line 3468: decimal = False
							πF.SetLineno(3468)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							µdecimal = πTemp001
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µtext); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp002 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp003 = !isStop
							} else {
								πTemp003 = true
								µchar = πTemp004
							}
							if πE != nil || !πTemp003 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µchar, "char"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µchar, ßisdigit, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µchar, "char"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Eq(πF, µchar, πg.NewStr(".").ToObject()); πE != nil {
								continue
							}
							πTemp004 = πTemp005
							if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label5
							}
							if πE = πg.CheckLocal(πF, µdecimal, "decimal"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µdecimal); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(!πTemp006).ToObject()
							πTemp004 = πTemp005
						Label5:
							if πTemp003, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label6
							}
							goto Label7
							// line 3470: if char.isdigit():
							πF.SetLineno(3470)
						Label4:
							// line 3471: result += char
							πF.SetLineno(3471)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µchar, "char"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IAdd(πF, µresult, µchar); πE != nil {
								continue
							}
							µresult = πTemp004
							goto Label8
							// line 3472: elif char == '.' and not decimal:
							πF.SetLineno(3472)
						Label6:
							// line 3473: result += char
							πF.SetLineno(3473)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µchar, "char"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IAdd(πF, µresult, µchar); πE != nil {
								continue
							}
							µresult = πTemp004
							// line 3474: decimal = True
							πF.SetLineno(3474)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							µdecimal = πTemp004
							goto Label8
						Label7:
							// line 3476: return result
							πF.SetLineno(3476)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
							goto Label8
						Label8:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 3477: return result
							πF.SetLineno(3477)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßextractnumber.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 3466: "Extract the first number in the given text."
					πF.SetLineno(3466)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Extract the first number in the given text.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßextractnumber); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 3479: def checkimage(self, width, height):
					πF.SetLineno(3479)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "width", Def: nil}
					πTemp002[2] = πg.Param{Name: "height", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("checkimage", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µwidth *πg.Object = πArgs[1]
						_ = µwidth
						var µheight *πg.Object = πArgs[2]
						_ = µheight
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3480: "Check image dimensions, set them if possible."
							πF.SetLineno(3480)
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IsTrue(πF, µwidth); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label1
							}
							goto Label2
							// line 3481: if width:
							πF.SetLineno(3481)
						Label1:
							// line 3482: self.maxwidth = unicode(width) + 'px'
							πF.SetLineno(3482)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							πTemp003[0] = µwidth
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Add(πF, πTemp005, ßpx.ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmaxwidth, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßscale, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp004
							if πTemp001, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp001 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßwidth, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp006).ToObject()
							πTemp002 = πTemp004
						Label3:
							if πTemp001, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label4
							}
							goto Label5
							// line 3483: if self.scale and not self.width:
							πF.SetLineno(3483)
						Label4:
							// line 3484: self.width = self.scalevalue(width)
							πF.SetLineno(3484)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							πTemp003[0] = µwidth
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßscalevalue, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßwidth, πTemp002); πE != nil {
								continue
							}
							goto Label5
						Label5:
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µheight, "height"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IsTrue(πF, µheight); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label6
							}
							goto Label7
							// line 3485: if height:
							πF.SetLineno(3485)
						Label6:
							// line 3486: self.maxheight = unicode(height) + 'px'
							πF.SetLineno(3486)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µheight, "height"); πE != nil {
								continue
							}
							πTemp003[0] = µheight
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Add(πF, πTemp005, ßpx.ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmaxheight, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßscale, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp004
							if πTemp001, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp001 {
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßheight, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp006).ToObject()
							πTemp002 = πTemp004
						Label8:
							if πTemp001, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label9
							}
							goto Label10
							// line 3487: if self.scale and not self.height:
							πF.SetLineno(3487)
						Label9:
							// line 3488: self.height = self.scalevalue(height)
							πF.SetLineno(3488)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µheight, "height"); πE != nil {
								continue
							}
							πTemp003[0] = µheight
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßscalevalue, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßheight, πTemp002); πE != nil {
								continue
							}
							goto Label10
						Label10:
							goto Label7
						Label7:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßwidth, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp004
							if πTemp001, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp001 {
								goto Label11
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßheight, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp006).ToObject()
							πTemp002 = πTemp004
						Label11:
							if πTemp001, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label12
							}
							goto Label13
							// line 3489: if self.width and not self.height:
							πF.SetLineno(3489)
						Label12:
							// line 3490: self.height = 'auto'
							πF.SetLineno(3490)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, ßauto.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßheight, πTemp002); πE != nil {
								continue
							}
							goto Label13
						Label13:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßheight, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp004
							if πTemp001, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp001 {
								goto Label14
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßwidth, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp006).ToObject()
							πTemp002 = πTemp004
						Label14:
							if πTemp001, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label15
							}
							goto Label16
							// line 3491: if self.height and not self.width:
							πF.SetLineno(3491)
						Label15:
							// line 3492: self.width = 'auto'
							πF.SetLineno(3492)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, ßauto.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßwidth, πTemp002); πE != nil {
								continue
							}
							goto Label16
						Label16:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckimage.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 3480: "Check image dimensions, set them if possible."
					πF.SetLineno(3480)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Check image dimensions, set them if possible.").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßcheckimage); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
					// line 3494: def scalevalue(self, value):
					πF.SetLineno(3494)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "value", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("scalevalue", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µvalue *πg.Object = πArgs[1]
						_ = µvalue
						var µscaled *πg.Object = πg.UnboundLocal
						_ = µscaled
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3495: "Scale the value according to the image scale and return it as unicode."
							πF.SetLineno(3495)
							// line 3496: scaled = value * int(self.scale) / 100
							πF.SetLineno(3496)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßscale, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Mul(πF, µvalue, πTemp005); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Div(πF, πTemp002, πg.NewInt(100).ToObject()); πE != nil {
								continue
							}
							µscaled = πTemp001
							// line 3497: return unicode(int(scaled)) + 'px'
							πF.SetLineno(3497)
							πTemp003 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µscaled, "scaled"); πE != nil {
								continue
							}
							πTemp006[0] = µscaled
							if πTemp002, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp003[0] = πTemp004
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Add(πF, πTemp004, ßpx.ToObject()); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßscalevalue.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 3495: "Scale the value according to the image scale and return it as unicode."
					πF.SetLineno(3495)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Scale the value according to the image scale and return it as unicode.").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßscalevalue); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
					// line 3499: def removepercentwidth(self):
					πF.SetLineno(3499)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("removepercentwidth", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µwidth *πg.Object = πg.UnboundLocal
						_ = µwidth
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3500: "Remove percent width if present, to set it at the figure level."
							πF.SetLineno(3500)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßwidth, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 3501: if not self.width:
							πF.SetLineno(3501)
						Label1:
							// line 3502: return None
							πF.SetLineno(3502)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßwidth, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Contains(πF, πTemp004, πg.NewStr("%").ToObject()); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 3503: if not '%' in self.width:
							πF.SetLineno(3503)
						Label3:
							// line 3504: return None
							πF.SetLineno(3504)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 3505: width = self.width
							πF.SetLineno(3505)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßwidth, nil); πE != nil {
								continue
							}
							µwidth = πTemp001
							// line 3506: self.width = None
							πF.SetLineno(3506)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßwidth, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßheight, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp002, ßauto.ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							goto Label6
							// line 3507: if self.height == 'auto':
							πF.SetLineno(3507)
						Label5:
							// line 3508: self.height = None
							πF.SetLineno(3508)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßheight, πTemp002); πE != nil {
								continue
							}
							goto Label6
						Label6:
							// line 3509: return width
							πF.SetLineno(3509)
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							πR = µwidth
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßremovepercentwidth.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 3500: "Remove percent width if present, to set it at the figure level."
					πF.SetLineno(3500)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp013}, πg.NewStr("Remove percent width if present, to set it at the figure level.").ToObject()); πE != nil {
						continue
					}
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßremovepercentwidth); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp014, ß__doc__, πTemp013); πE != nil {
						continue
					}
					// line 3511: def addstyle(self, container):
					πF.SetLineno(3511)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "container", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("addstyle", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µtag *πg.Object = πg.UnboundLocal
						_ = µtag
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3512: "Add the proper style attribute to the output tag."
							πF.SetLineno(3512)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ßoutput, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							πTemp002[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3513: if not isinstance(container.output, TaggedOutput):
							πF.SetLineno(3513)
						Label1:
							// line 3514: Trace.error('No tag to add style, in ' + unicode(container))
							πF.SetLineno(3514)
							πTemp002 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp006[0] = µcontainer
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Add(πF, πg.NewStr("No tag to add style, in ").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßwidth, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp007).ToObject()
							πTemp001 = πTemp003
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßheight, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp007).ToObject()
							πTemp001 = πTemp003
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßmaxwidth, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp007).ToObject()
							πTemp001 = πTemp003
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßmaxheight, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp007).ToObject()
							πTemp001 = πTemp003
						Label3:
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 3515: if not self.width and not self.height and not self.maxwidth and not self.maxheight:
							πF.SetLineno(3515)
						Label4:
							// line 3517: return
							πF.SetLineno(3517)
							πR = πg.None
							continue
							goto Label5
						Label5:
							// line 3518: tag = ' style="'
							πF.SetLineno(3518)
							µtag = πg.NewStr(" style=\"").ToObject()
							// line 3519: tag += self.styleparameter('width')
							πF.SetLineno(3519)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßwidth.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstyleparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.IAdd(πF, µtag, πTemp003); πE != nil {
								continue
							}
							µtag = πTemp001
							// line 3520: tag += self.styleparameter('maxwidth')
							πF.SetLineno(3520)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßmaxwidth.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstyleparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.IAdd(πF, µtag, πTemp003); πE != nil {
								continue
							}
							µtag = πTemp001
							// line 3521: tag += self.styleparameter('height')
							πF.SetLineno(3521)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßheight.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstyleparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.IAdd(πF, µtag, πTemp003); πE != nil {
								continue
							}
							µtag = πTemp001
							// line 3522: tag += self.styleparameter('maxheight')
							πF.SetLineno(3522)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßmaxheight.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstyleparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.IAdd(πF, µtag, πTemp003); πE != nil {
								continue
							}
							µtag = πTemp001
							if πTemp004, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp004
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µtag, πTemp003); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewStr(" ").ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							goto Label7
							// line 3523: if tag[-1] == ' ':
							πF.SetLineno(3523)
						Label6:
							// line 3524: tag = tag[:-1]
							πF.SetLineno(3524)
							if πTemp003, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µtag, πTemp001); πE != nil {
								continue
							}
							µtag = πTemp003
							goto Label7
						Label7:
							// line 3525: tag += '"'
							πF.SetLineno(3525)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µtag, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							µtag = πTemp001
							// line 3526: container.output.tag += tag
							πF.SetLineno(3526)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontainer, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßtag, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, πTemp003, µtag); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µcontainer, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßtag, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßaddstyle.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 3512: "Add the proper style attribute to the output tag."
					πF.SetLineno(3512)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp014}, πg.NewStr("Add the proper style attribute to the output tag.").ToObject()); πE != nil {
						continue
					}
					if πTemp015, πE = πg.ResolveClass(πF, πClass, nil, ßaddstyle); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp015, ß__doc__, πTemp014); πE != nil {
						continue
					}
					// line 3528: def styleparameter(self, name):
					πF.SetLineno(3528)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "name", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("styleparameter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µname *πg.Object = πArgs[1]
						_ = µname
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3529: "Get the style for a single parameter."
							πF.SetLineno(3529)
							// line 3530: value = getattr(self, name)
							πF.SetLineno(3530)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[1] = µname
							if πTemp002, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µvalue = πTemp003
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µvalue); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 3531: if value:
							πF.SetLineno(3531)
						Label1:
							// line 3532: return name.replace('max', 'max-') + ': ' + value + '; '
							πF.SetLineno(3532)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = ßmax.ToObject()
							πTemp001[1] = πg.NewStr("max-").ToObject()
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µname, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.Add(πF, πTemp007, πg.NewStr(": ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp005, µvalue); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("; ").ToObject()); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 3533: return ''
							πF.SetLineno(3533)
							πR = ß.ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßstyleparameter.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 3529: "Get the style for a single parameter."
					πF.SetLineno(3529)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp015}, πg.NewStr("Get the style for a single parameter.").ToObject()); πE != nil {
						continue
					}
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ßstyleparameter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp016, ß__doc__, πTemp015); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ContainerSize").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßContainerSize.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3537: class QuoteContainer(Container):
			πF.SetLineno(3537)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("QuoteContainer", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3538: "A container for a pretty quote"
					πF.SetLineno(3538)
					// line 3538: "A container for a pretty quote"
					πF.SetLineno(3538)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A container for a pretty quote").ToObject()); πE != nil {
						continue
					}
					// line 3540: def __init__(self):
					πF.SetLineno(3540)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3541: self.parser = BoundedParser()
							πF.SetLineno(3541)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßBoundedParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 3542: self.output = FixedOutput()
							πF.SetLineno(3542)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFixedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3544: def process(self):
					πF.SetLineno(3544)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3545: "Process contents"
							πF.SetLineno(3545)
							// line 3546: self.type = self.header[2]
							πF.SetLineno(3546)
							πTemp001 = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßStyleConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßquotes, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 3547: if not self.type in StyleConfig.quotes:
							πF.SetLineno(3547)
						Label1:
							// line 3548: Trace.error('Quote type ' + self.type + ' not found')
							πF.SetLineno(3548)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Quote type ").ToObject(), πTemp003); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(" not found").ToObject()); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 3549: self.html = ['"']
							πF.SetLineno(3549)
							πTemp007 = make([]*πg.Object, 1)
							πTemp007[0] = πg.NewStr("\"").ToObject()
							πTemp001 = πg.NewList(πTemp007...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp002); πE != nil {
								continue
							}
							// line 3550: return
							πF.SetLineno(3550)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 3551: self.html = [StyleConfig.quotes[self.type]]
							πF.SetLineno(3551)
							πTemp007 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp003, πE = πg.ResolveGlobal(πF, ßStyleConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßquotes, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πTemp007[0] = πTemp002
							πTemp001 = πg.NewList(πTemp007...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3545: "Process contents"
					πF.SetLineno(3545)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Process contents").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("QuoteContainer").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßQuoteContainer.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3553: class LyXLine(Container):
			πF.SetLineno(3553)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LyXLine", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3554: "A Lyx line"
					πF.SetLineno(3554)
					// line 3554: "A Lyx line"
					πF.SetLineno(3554)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A Lyx line").ToObject()); πE != nil {
						continue
					}
					// line 3556: def __init__(self):
					πF.SetLineno(3556)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3557: self.parser = LoneCommand()
							πF.SetLineno(3557)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßLoneCommand); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 3558: self.output = FixedOutput()
							πF.SetLineno(3558)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFixedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3560: def process(self):
					πF.SetLineno(3560)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3561: self.html = ['<hr class="line" />']
							πF.SetLineno(3561)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = πg.NewStr("<hr class=\"line\" />").ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LyXLine").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLyXLine.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3563: class EmphaticText(TaggedText):
			πF.SetLineno(3563)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("EmphaticText", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3564: "Text with emphatic mode"
					πF.SetLineno(3564)
					// line 3564: "Text with emphatic mode"
					πF.SetLineno(3564)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Text with emphatic mode").ToObject()); πE != nil {
						continue
					}
					// line 3566: def process(self):
					πF.SetLineno(3566)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3567: self.output.tag = 'i'
							πF.SetLineno(3567)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßi.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("EmphaticText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßEmphaticText.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3569: class ShapedText(TaggedText):
			πF.SetLineno(3569)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ShapedText", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3570: "Text shaped (italic, slanted)"
					πF.SetLineno(3570)
					// line 3570: "Text shaped (italic, slanted)"
					πF.SetLineno(3570)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Text shaped (italic, slanted)").ToObject()); πE != nil {
						continue
					}
					// line 3572: def process(self):
					πF.SetLineno(3572)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3573: self.type = self.header[1]
							πF.SetLineno(3573)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTagConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßshaped, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 3574: if not self.type in TagConfig.shaped:
							πF.SetLineno(3574)
						Label1:
							// line 3575: Trace.error('Unrecognized shape ' + self.header[1])
							πF.SetLineno(3575)
							πTemp007 = πF.MakeArgs(1)
							πTemp002 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unrecognized shape ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 3576: self.output.tag = 'span'
							πF.SetLineno(3576)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßspan.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
							// line 3577: return
							πF.SetLineno(3577)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 3578: self.output.tag = TagConfig.shaped[self.type]
							πF.SetLineno(3578)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTagConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßshaped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßtag, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ShapedText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßShapedText.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3580: class VersalitasText(TaggedText):
			πF.SetLineno(3580)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("VersalitasText", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3581: "Text in versalitas"
					πF.SetLineno(3581)
					// line 3581: "Text in versalitas"
					πF.SetLineno(3581)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Text in versalitas").ToObject()); πE != nil {
						continue
					}
					// line 3583: def process(self):
					πF.SetLineno(3583)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3584: self.output.tag = 'span class="versalitas"'
							πF.SetLineno(3584)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewStr("span class=\"versalitas\"").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("VersalitasText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßVersalitasText.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3586: class ColorText(TaggedText):
			πF.SetLineno(3586)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ColorText", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3587: "Colored text"
					πF.SetLineno(3587)
					// line 3587: "Colored text"
					πF.SetLineno(3587)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Colored text").ToObject()); πE != nil {
						continue
					}
					// line 3589: def process(self):
					πF.SetLineno(3589)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3590: self.color = self.header[1]
							πF.SetLineno(3590)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcolor, πTemp001); πE != nil {
								continue
							}
							// line 3591: self.output.tag = 'span class="' + self.color + '"'
							πF.SetLineno(3591)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcolor, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("span class=\"").ToObject(), πTemp003); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßtag, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ColorText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßColorText.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3593: class SizeText(TaggedText):
			πF.SetLineno(3593)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("SizeText", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3594: "Sized text"
					πF.SetLineno(3594)
					// line 3594: "Sized text"
					πF.SetLineno(3594)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Sized text").ToObject()); πE != nil {
						continue
					}
					// line 3596: def process(self):
					πF.SetLineno(3596)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3597: self.size = self.header[1]
							πF.SetLineno(3597)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsize, πTemp001); πE != nil {
								continue
							}
							// line 3598: self.output.tag = 'span class="' + self.size + '"'
							πF.SetLineno(3598)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßsize, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("span class=\"").ToObject(), πTemp003); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßtag, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("SizeText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßSizeText.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3600: class BoldText(TaggedText):
			πF.SetLineno(3600)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BoldText", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3601: "Bold text"
					πF.SetLineno(3601)
					// line 3601: "Bold text"
					πF.SetLineno(3601)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Bold text").ToObject()); πE != nil {
						continue
					}
					// line 3603: def process(self):
					πF.SetLineno(3603)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3604: self.output.tag = 'b'
							πF.SetLineno(3604)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßb.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BoldText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBoldText.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3606: class TextFamily(TaggedText):
			πF.SetLineno(3606)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TextFamily", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3607: "A bit of text from elyxer.a different family"
					πF.SetLineno(3607)
					// line 3607: "A bit of text from elyxer.a different family"
					πF.SetLineno(3607)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A bit of text from elyxer.a different family").ToObject()); πE != nil {
						continue
					}
					// line 3609: def process(self):
					πF.SetLineno(3609)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3610: "Parse the type of family"
							πF.SetLineno(3610)
							// line 3611: self.type = self.header[1]
							πF.SetLineno(3611)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTagConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßfamily, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 3612: if not self.type in TagConfig.family:
							πF.SetLineno(3612)
						Label1:
							// line 3613: Trace.error('Unrecognized family ' + type)
							πF.SetLineno(3613)
							πTemp007 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßtype); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unrecognized family ").ToObject(), πTemp002); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 3614: self.output.tag = 'span'
							πF.SetLineno(3614)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßspan.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
							// line 3615: return
							πF.SetLineno(3615)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 3616: self.output.tag = TagConfig.family[self.type]
							πF.SetLineno(3616)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTagConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßfamily, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßtag, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3610: "Parse the type of family"
					πF.SetLineno(3610)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the type of family").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TextFamily").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTextFamily.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3618: class Hfill(TaggedText):
			πF.SetLineno(3618)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Hfill", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3619: "Horizontall fill"
					πF.SetLineno(3619)
					// line 3619: "Horizontall fill"
					πF.SetLineno(3619)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Horizontall fill").ToObject()); πE != nil {
						continue
					}
					// line 3621: def process(self):
					πF.SetLineno(3621)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3622: self.output.tag = 'span class="hfill"'
							πF.SetLineno(3622)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewStr("span class=\"hfill\"").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Hfill").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßHfill.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3624: class BarredText(TaggedText):
			πF.SetLineno(3624)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BarredText", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3625: "Text with a bar somewhere"
					πF.SetLineno(3625)
					// line 3625: "Text with a bar somewhere"
					πF.SetLineno(3625)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Text with a bar somewhere").ToObject()); πE != nil {
						continue
					}
					// line 3627: def process(self):
					πF.SetLineno(3627)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3628: "Parse the type of bar"
							πF.SetLineno(3628)
							// line 3629: self.type = self.header[1]
							πF.SetLineno(3629)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTagConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßbarred, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 3630: if not self.type in TagConfig.barred:
							πF.SetLineno(3630)
						Label1:
							// line 3631: Trace.error('Unknown bar type ' + self.type)
							πF.SetLineno(3631)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unknown bar type ").ToObject(), πTemp002); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 3632: self.output.tag = 'span'
							πF.SetLineno(3632)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßspan.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
							// line 3633: return
							πF.SetLineno(3633)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 3634: self.output.tag = TagConfig.barred[self.type]
							πF.SetLineno(3634)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTagConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßbarred, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßtag, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3628: "Parse the type of bar"
					πF.SetLineno(3628)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the type of bar").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BarredText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBarredText.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3636: class LangLine(TaggedText):
			πF.SetLineno(3636)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LangLine", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3637: "A line with language information"
					πF.SetLineno(3637)
					// line 3637: "A line with language information"
					πF.SetLineno(3637)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A line with language information").ToObject()); πE != nil {
						continue
					}
					// line 3639: def process(self):
					πF.SetLineno(3639)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlang *πg.Object = πg.UnboundLocal
						_ = µlang
						var µisolang *πg.Object = πg.UnboundLocal
						_ = µisolang
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3640: "Only generate a span with lang info when the language is recognized."
							πF.SetLineno(3640)
							// line 3641: lang = self.header[1]
							πF.SetLineno(3641)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µlang = πTemp002
							if πE = πg.CheckLocal(πF, µlang, "lang"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTranslationConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßlanguages, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, µlang); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3642: if not lang in TranslationConfig.languages:
							πF.SetLineno(3642)
						Label1:
							// line 3643: self.output = ContentsOutput()
							πF.SetLineno(3643)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßContentsOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 3644: return
							πF.SetLineno(3644)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 3645: isolang = TranslationConfig.languages[lang]
							πF.SetLineno(3645)
							if πE = πg.CheckLocal(πF, µlang, "lang"); πE != nil {
								continue
							}
							πTemp001 = µlang
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTranslationConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßlanguages, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µisolang = πTemp002
							// line 3646: self.output = TaggedOutput().settag('span lang="' + isolang + '"', False)
							πF.SetLineno(3646)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µisolang, "isolang"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("span lang=\"").ToObject(), µisolang); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3640: "Only generate a span with lang info when the language is recognized."
					πF.SetLineno(3640)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Only generate a span with lang info when the language is recognized.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LangLine").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLangLine.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3648: class InsetLength(BlackBox):
			πF.SetLineno(3648)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßBlackBox); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("InsetLength", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3649: "A length measure inside an inset."
					πF.SetLineno(3649)
					// line 3649: "A length measure inside an inset."
					πF.SetLineno(3649)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A length measure inside an inset.").ToObject()); πE != nil {
						continue
					}
					// line 3651: def process(self):
					πF.SetLineno(3651)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3652: self.length = self.header[1]
							πF.SetLineno(3652)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlength, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("InsetLength").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßInsetLength.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3654: class Space(Container):
			πF.SetLineno(3654)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Space", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3655: "A space of several types"
					πF.SetLineno(3655)
					// line 3655: "A space of several types"
					πF.SetLineno(3655)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A space of several types").ToObject()); πE != nil {
						continue
					}
					// line 3657: def __init__(self):
					πF.SetLineno(3657)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3658: self.parser = InsetParser()
							πF.SetLineno(3658)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßInsetParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 3659: self.output = FixedOutput()
							πF.SetLineno(3659)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFixedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3661: def process(self):
					πF.SetLineno(3661)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlength *πg.Object = πg.UnboundLocal
						_ = µlength
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3662: self.type = self.header[2]
							πF.SetLineno(3662)
							πTemp001 = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßStyleConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßhspaces, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3663: if self.type not in StyleConfig.hspaces:
							πF.SetLineno(3663)
						Label1:
							// line 3664: Trace.error('Unknown space type ' + self.type)
							πF.SetLineno(3664)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unknown space type ").ToObject(), πTemp002); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 3665: self.html = [' ']
							πF.SetLineno(3665)
							πTemp006 = make([]*πg.Object, 1)
							πTemp006[0] = πg.NewStr(" ").ToObject()
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp002); πE != nil {
								continue
							}
							// line 3666: return
							πF.SetLineno(3666)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 3667: self.html = [StyleConfig.hspaces[self.type]]
							πF.SetLineno(3667)
							πTemp006 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp003, πE = πg.ResolveGlobal(πF, ßStyleConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßhspaces, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πTemp006[0] = πTemp002
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp002); πE != nil {
								continue
							}
							// line 3668: length = self.getlength()
							πF.SetLineno(3668)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetlength, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlength = πTemp002
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µlength); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 3669: if not length:
							πF.SetLineno(3669)
						Label3:
							// line 3670: return
							πF.SetLineno(3670)
							πR = πg.None
							continue
							goto Label4
						Label4:
							// line 3671: self.output = TaggedOutput().settag('span class="hspace"', False)
							πF.SetLineno(3671)
							πTemp006 = πF.MakeArgs(2)
							πTemp006[0] = πg.NewStr("span class=\"hspace\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 3672: ContainerSize().set(length).addstyle(self)
							πF.SetLineno(3672)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp006[0] = µself
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlength, "length"); πE != nil {
								continue
							}
							πTemp007[0] = µlength
							if πTemp001, πE = πg.ResolveGlobal(πF, ßContainerSize); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßaddstyle, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3674: def getlength(self):
					πF.SetLineno(3674)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("getlength", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3675: "Get the space length from elyxer.the contents or parameters."
							πF.SetLineno(3675)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp003, πE = πg.Eq(πF, πTemp006, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							πTemp004 = πF.MakeArgs(2)
							πTemp005 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, πTemp007, πTemp005); πE != nil {
								continue
							}
							πTemp004[0] = πTemp006
							if πTemp005, πE = πg.ResolveGlobal(πF, ßInsetLength); πE != nil {
								continue
							}
							πTemp004[1] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp008, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp008).ToObject()
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 3676: if len(self.contents) == 0 or not isinstance(self.contents[0], InsetLength):
							πF.SetLineno(3676)
						Label2:
							// line 3677: return None
							πF.SetLineno(3677)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label3
						Label3:
							// line 3678: return self.contents[0].length
							πF.SetLineno(3678)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßlength, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetlength.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3675: "Get the space length from elyxer.the contents or parameters."
					πF.SetLineno(3675)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Get the space length from elyxer.the contents or parameters.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßgetlength); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Space").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßSpace.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3680: class VerticalSpace(Container):
			πF.SetLineno(3680)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("VerticalSpace", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3681: "An inset that contains a vertical space."
					πF.SetLineno(3681)
					// line 3681: "An inset that contains a vertical space."
					πF.SetLineno(3681)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("An inset that contains a vertical space.").ToObject()); πE != nil {
						continue
					}
					// line 3683: def __init__(self):
					πF.SetLineno(3683)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3684: self.parser = InsetParser()
							πF.SetLineno(3684)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßInsetParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 3685: self.output = FixedOutput()
							πF.SetLineno(3685)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFixedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3687: def process(self):
					πF.SetLineno(3687)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3688: "Set the correct tag"
							πF.SetLineno(3688)
							// line 3689: self.type = self.header[2]
							πF.SetLineno(3689)
							πTemp001 = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßStyleConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßvspaces, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3690: if self.type not in StyleConfig.vspaces:
							πF.SetLineno(3690)
						Label1:
							// line 3691: self.output = TaggedOutput().settag('div class="vspace" style="height: ' + self.type + ';"', True)
							πF.SetLineno(3691)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("div class=\"vspace\" style=\"height: ").ToObject(), πTemp003); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(";\"").ToObject()); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp006[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 3692: return
							πF.SetLineno(3692)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 3693: self.html = [StyleConfig.vspaces[self.type]]
							πF.SetLineno(3693)
							πTemp006 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtype, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp003, πE = πg.ResolveGlobal(πF, ßStyleConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßvspaces, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πTemp006[0] = πTemp002
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3688: "Set the correct tag"
					πF.SetLineno(3688)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Set the correct tag").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("VerticalSpace").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßVerticalSpace.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3695: class Align(Container):
			πF.SetLineno(3695)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Align", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3696: "Bit of aligned text"
					πF.SetLineno(3696)
					// line 3696: "Bit of aligned text"
					πF.SetLineno(3696)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Bit of aligned text").ToObject()); πE != nil {
						continue
					}
					// line 3698: def __init__(self):
					πF.SetLineno(3698)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3699: self.parser = ExcludingParser()
							πF.SetLineno(3699)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßExcludingParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 3700: self.output = TaggedOutput().setbreaklines(True)
							πF.SetLineno(3700)
							πTemp003 = πF.MakeArgs(1)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsetbreaklines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3702: def process(self):
					πF.SetLineno(3702)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3703: self.output.tag = 'div class="' + self.header[1] + '"'
							πF.SetLineno(3703)
							πTemp003 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßheader, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("div class=\"").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßtag, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Align").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßAlign.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3705: class Newline(Container):
			πF.SetLineno(3705)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Newline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3706: "A newline"
					πF.SetLineno(3706)
					// line 3706: "A newline"
					πF.SetLineno(3706)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A newline").ToObject()); πE != nil {
						continue
					}
					// line 3708: def __init__(self):
					πF.SetLineno(3708)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3709: self.parser = LoneCommand()
							πF.SetLineno(3709)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßLoneCommand); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 3710: self.output = FixedOutput()
							πF.SetLineno(3710)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFixedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3712: def process(self):
					πF.SetLineno(3712)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3713: "Process contents"
							πF.SetLineno(3713)
							// line 3714: self.html = ['<br/>\n']
							πF.SetLineno(3714)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = πg.NewStr("<br/>\n").ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3713: "Process contents"
					πF.SetLineno(3713)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Process contents").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Newline").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßNewline.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3716: class NewPage(Newline):
			πF.SetLineno(3716)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßNewline); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("NewPage", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3717: "A new page"
					πF.SetLineno(3717)
					// line 3717: "A new page"
					πF.SetLineno(3717)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A new page").ToObject()); πE != nil {
						continue
					}
					// line 3719: def process(self):
					πF.SetLineno(3719)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3720: "Process contents"
							πF.SetLineno(3720)
							// line 3721: self.html = ['<p><br/>\n</p>\n']
							πF.SetLineno(3721)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = πg.NewStr("<p><br/>\n</p>\n").ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3720: "Process contents"
					πF.SetLineno(3720)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Process contents").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("NewPage").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßNewPage.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3723: class Separator(Container):
			πF.SetLineno(3723)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Separator", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3724: "A separator string which is not extracted by extracttext()."
					πF.SetLineno(3724)
					// line 3724: "A separator string which is not extracted by extracttext()."
					πF.SetLineno(3724)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A separator string which is not extracted by extracttext().").ToObject()); πE != nil {
						continue
					}
					// line 3726: def __init__(self, constant):
					πF.SetLineno(3726)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "constant", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µconstant *πg.Object = πArgs[1]
						_ = µconstant
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3727: self.output = FixedOutput()
							πF.SetLineno(3727)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFixedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 3728: self.contents = []
							πF.SetLineno(3728)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp002); πE != nil {
								continue
							}
							// line 3729: self.html = [constant]
							πF.SetLineno(3729)
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µconstant, "constant"); πE != nil {
								continue
							}
							πTemp003[0] = µconstant
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Separator").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßSeparator.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3731: class StrikeOut(TaggedText):
			πF.SetLineno(3731)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßTaggedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("StrikeOut", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3732: "Striken out text."
					πF.SetLineno(3732)
					// line 3732: "Striken out text."
					πF.SetLineno(3732)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Striken out text.").ToObject()); πE != nil {
						continue
					}
					// line 3734: def process(self):
					πF.SetLineno(3734)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3735: "Set the output tag to strike."
							πF.SetLineno(3735)
							// line 3736: self.output.tag = 'strike'
							πF.SetLineno(3736)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßstrike.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp002, ßtag, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3735: "Set the output tag to strike."
					πF.SetLineno(3735)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Set the output tag to strike.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("StrikeOut").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStrikeOut.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3738: class StartAppendix(BlackBox):
			πF.SetLineno(3738)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßBlackBox); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("StartAppendix", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3739: "Mark to start an appendix here."
					πF.SetLineno(3739)
					// line 3739: "Mark to start an appendix here."
					πF.SetLineno(3739)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Mark to start an appendix here.").ToObject()); πE != nil {
						continue
					}
					// line 3740: "From this point on, all chapters become appendices."
					πF.SetLineno(3740)
					// line 3742: def process(self):
					πF.SetLineno(3742)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3743: "Activate the special numbering scheme for appendices, using letters."
							πF.SetLineno(3743)
							// line 3744: NumberGenerator.generator.startappendix()
							πF.SetLineno(3744)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNumberGenerator); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßgenerator, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstartappendix, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3743: "Activate the special numbering scheme for appendices, using letters."
					πF.SetLineno(3743)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Activate the special numbering scheme for appendices, using letters.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("StartAppendix").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStartAppendix.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3751: class Link(Container):
			πF.SetLineno(3751)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainer); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Link", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 bool
				_ = πTemp010
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3752: "A link to another part of the document"
					πF.SetLineno(3752)
					// line 3752: "A link to another part of the document"
					πF.SetLineno(3752)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A link to another part of the document").ToObject()); πE != nil {
						continue
					}
					// line 3754: anchor = None
					πF.SetLineno(3754)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßanchor.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3755: url = None
					πF.SetLineno(3755)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßurl.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3756: type = None
					πF.SetLineno(3756)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtype.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3757: page = None
					πF.SetLineno(3757)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßpage.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3758: target = None
					πF.SetLineno(3758)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtarget.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3759: destination = None
					πF.SetLineno(3759)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßdestination.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3760: title = None
					πF.SetLineno(3760)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtitle.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3762: def __init__(self):
					πF.SetLineno(3762)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3763: "Initialize the link, add target if configured."
							πF.SetLineno(3763)
							// line 3764: self.contents = []
							πF.SetLineno(3764)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp003); πE != nil {
								continue
							}
							// line 3765: self.parser = InsetParser()
							πF.SetLineno(3765)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßInsetParser); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp002); πE != nil {
								continue
							}
							// line 3766: self.output = LinkOutput()
							πF.SetLineno(3766)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßLinkOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtarget, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 3767: if Options.target:
							πF.SetLineno(3767)
						Label1:
							// line 3768: self.target = Options.target
							πF.SetLineno(3768)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtarget, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtarget, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3763: "Initialize the link, add target if configured."
					πF.SetLineno(3763)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Initialize the link, add target if configured.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 3770: def complete(self, text, anchor = None, url = None, type = None, title = None):
					πF.SetLineno(3770)
					πTemp002 = make([]πg.Param, 6)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "anchor", Def: πTemp004}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "url", Def: πTemp004}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "type", Def: πTemp004}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "title", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("complete", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var µanchor *πg.Object = πArgs[2]
						_ = µanchor
						var µurl *πg.Object = πArgs[3]
						_ = µurl
						var µtype *πg.Object = πArgs[4]
						_ = µtype
						var µtitle *πg.Object = πArgs[5]
						_ = µtitle
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3771: "Complete the link."
							πF.SetLineno(3771)
							// line 3772: self.contents = [Constant(text)]
							πF.SetLineno(3772)
							πTemp001 = make([]*πg.Object, 1)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp002[0] = µtext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µanchor, "anchor"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µanchor); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3773: if anchor:
							πF.SetLineno(3773)
						Label1:
							// line 3774: self.anchor = anchor
							πF.SetLineno(3774)
							if πE = πg.CheckLocal(πF, µanchor, "anchor"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µanchor); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßanchor, πTemp003); πE != nil {
								continue
							}
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µurl, "url"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µurl); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 3775: if url:
							πF.SetLineno(3775)
						Label3:
							// line 3776: self.url = url
							πF.SetLineno(3776)
							if πE = πg.CheckLocal(πF, µurl, "url"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µurl); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßurl, πTemp003); πE != nil {
								continue
							}
							goto Label4
						Label4:
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µtype); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							goto Label6
							// line 3777: if type:
							πF.SetLineno(3777)
						Label5:
							// line 3778: self.type = type
							πF.SetLineno(3778)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µtype); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp003); πE != nil {
								continue
							}
							goto Label6
						Label6:
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µtitle); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							goto Label8
							// line 3779: if title:
							πF.SetLineno(3779)
						Label7:
							// line 3780: self.title = title
							πF.SetLineno(3780)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µtitle); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtitle, πTemp003); πE != nil {
								continue
							}
							goto Label8
						Label8:
							// line 3781: return self
							πF.SetLineno(3781)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcomplete.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3771: "Complete the link."
					πF.SetLineno(3771)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Complete the link.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßcomplete); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 3783: def computedestination(self):
					πF.SetLineno(3783)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("computedestination", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3784: "Use the destination link to fill in the destination URL."
							πF.SetLineno(3784)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdestination, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 3785: if not self.destination:
							πF.SetLineno(3785)
						Label1:
							// line 3786: return
							πF.SetLineno(3786)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 3787: self.url = ''
							πF.SetLineno(3787)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ß.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßurl, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdestination, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßanchor, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 3788: if self.destination.anchor:
							πF.SetLineno(3788)
						Label3:
							// line 3789: self.url = '#' + self.destination.anchor
							πF.SetLineno(3789)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdestination, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßanchor, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("#").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßurl, πTemp002); πE != nil {
								continue
							}
							goto Label4
						Label4:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdestination, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßpage, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							goto Label6
							// line 3790: if self.destination.page:
							πF.SetLineno(3790)
						Label5:
							// line 3791: self.url = self.destination.page + self.url
							πF.SetLineno(3791)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdestination, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßpage, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßurl, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßurl, πTemp002); πE != nil {
								continue
							}
							goto Label6
						Label6:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcomputedestination.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3784: "Use the destination link to fill in the destination URL."
					πF.SetLineno(3784)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Use the destination link to fill in the destination URL.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßcomputedestination); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 3793: def setmutualdestination(self, destination):
					πF.SetLineno(3793)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "destination", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("setmutualdestination", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µdestination *πg.Object = πArgs[1]
						_ = µdestination
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3794: "Set another link as destination, and set its destination to this one."
							πF.SetLineno(3794)
							// line 3795: self.destination = destination
							πF.SetLineno(3795)
							if πE = πg.CheckLocal(πF, µdestination, "destination"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µdestination); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdestination, πTemp001); πE != nil {
								continue
							}
							// line 3796: destination.destination = self
							πF.SetLineno(3796)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µself); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdestination, "destination"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µdestination, ßdestination, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetmutualdestination.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 3794: "Set another link as destination, and set its destination to this one."
					πF.SetLineno(3794)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Set another link as destination, and set its destination to this one.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßsetmutualdestination); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 3798: def __unicode__(self):
					πF.SetLineno(3798)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3799: "Return a printable representation."
							πF.SetLineno(3799)
							// line 3800: result = 'Link'
							πF.SetLineno(3800)
							µresult = ßLink.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßanchor, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 3801: if self.anchor:
							πF.SetLineno(3801)
						Label1:
							// line 3802: result += ' #' + self.anchor
							πF.SetLineno(3802)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßanchor, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr(" #").ToObject(), πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µresult, πTemp001); πE != nil {
								continue
							}
							µresult = πTemp003
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßurl, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 3803: if self.url:
							πF.SetLineno(3803)
						Label3:
							// line 3804: result += ' to ' + self.url
							πF.SetLineno(3804)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßurl, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr(" to ").ToObject(), πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µresult, πTemp001); πE != nil {
								continue
							}
							µresult = πTemp003
							goto Label4
						Label4:
							// line 3805: return result
							πF.SetLineno(3805)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 3799: "Return a printable representation."
					πF.SetLineno(3799)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp009, πE = πg.GetAttr(πF, πTemp008, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp008 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp007, πE = πg.GE(πF, πTemp009, πTemp008); πE != nil {
						continue
					}
					if πTemp010, πE = πg.IsTrue(πF, πTemp007); πE != nil {
						continue
					}
					if πTemp010 {
						goto Label1
					}
					goto Label2
					// line 3807: if sys.version_info >= (3, 0):
					πF.SetLineno(3807)
				Label1:
					// line 3808: __str__ = __unicode__
					πF.SetLineno(3808)
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp007); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Link").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLink.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3811: class URL(Link):
			πF.SetLineno(3811)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßLink); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("URL", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3812: "A clickable URL"
					πF.SetLineno(3812)
					// line 3812: "A clickable URL"
					πF.SetLineno(3812)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A clickable URL").ToObject()); πE != nil {
						continue
					}
					// line 3814: def process(self):
					πF.SetLineno(3814)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtarget *πg.Object = πg.UnboundLocal
						_ = µtarget
						var µtype *πg.Object = πg.UnboundLocal
						_ = µtype
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3815: "Read URL from elyxer.parameters"
							πF.SetLineno(3815)
							// line 3816: target = self.escape(self.getparameter('target'))
							πF.SetLineno(3816)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßtarget.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßgetparameter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßescape, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtarget = πTemp004
							// line 3817: self.url = target
							πF.SetLineno(3817)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µtarget); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßurl, πTemp003); πE != nil {
								continue
							}
							// line 3818: type = self.getparameter('type')
							πF.SetLineno(3818)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßtype.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßgetparameter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtype = πTemp004
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µtype); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3819: if type:
							πF.SetLineno(3819)
						Label1:
							// line 3820: self.url = self.escape(type) + target
							πF.SetLineno(3820)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßescape, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp006, µtarget); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßurl, πTemp004); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 3821: name = self.getparameter('name')
							πF.SetLineno(3821)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßname.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßgetparameter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µname = πTemp004
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µname); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 3822: if not name:
							πF.SetLineno(3822)
						Label3:
							// line 3823: name = target
							πF.SetLineno(3823)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							µname = µtarget
							goto Label4
						Label4:
							// line 3824: self.contents = [Constant(name)]
							πF.SetLineno(3824)
							πTemp001 = make([]*πg.Object, 1)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp002[0] = µname
							if πTemp003, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp004); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3815: "Read URL from elyxer.parameters"
					πF.SetLineno(3815)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Read URL from elyxer.parameters").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("URL").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßURL.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3826: class FlexURL(URL):
			πF.SetLineno(3826)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßURL); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FlexURL", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3827: "A flexible URL"
					πF.SetLineno(3827)
					// line 3827: "A flexible URL"
					πF.SetLineno(3827)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A flexible URL").ToObject()); πE != nil {
						continue
					}
					// line 3829: def process(self):
					πF.SetLineno(3829)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3830: "Read URL from elyxer.contents"
							πF.SetLineno(3830)
							// line 3831: self.url = self.extracttext()
							πF.SetLineno(3831)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßextracttext, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßurl, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3830: "Read URL from elyxer.contents"
					πF.SetLineno(3830)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Read URL from elyxer.contents").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FlexURL").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFlexURL.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3833: class LinkOutput(ContainerOutput):
			πF.SetLineno(3833)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßContainerOutput); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LinkOutput", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3834: "A link pointing to some destination"
					πF.SetLineno(3834)
					// line 3834: "A link pointing to some destination"
					πF.SetLineno(3834)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A link pointing to some destination").ToObject()); πE != nil {
						continue
					}
					// line 3835: "Or an anchor (destination)"
					πF.SetLineno(3835)
					// line 3837: def gethtml(self, link):
					πF.SetLineno(3837)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "link", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("gethtml", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlink *πg.Object = πArgs[1]
						_ = µlink
						var µtype *πg.Object = πg.UnboundLocal
						_ = µtype
						var µtag *πg.Object = πg.UnboundLocal
						_ = µtag
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3838: "Get the HTML code for the link"
							πF.SetLineno(3838)
							// line 3839: type = link.__class__.__name__
							πF.SetLineno(3839)
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlink, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ß__name__, nil); πE != nil {
								continue
							}
							µtype = πTemp002
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlink, ßtype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 3840: if link.type:
							πF.SetLineno(3840)
						Label1:
							// line 3841: type = link.type
							πF.SetLineno(3841)
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlink, ßtype, nil); πE != nil {
								continue
							}
							µtype = πTemp001
							goto Label2
						Label2:
							// line 3842: tag = 'a class="' + type + '"'
							πF.SetLineno(3842)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("a class=\"").ToObject(), µtype); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							µtag = πTemp001
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlink, ßanchor, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 3843: if link.anchor:
							πF.SetLineno(3843)
						Label3:
							// line 3844: tag += ' name="' + link.anchor + '"'
							πF.SetLineno(3844)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µlink, ßanchor, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr(" name=\"").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µtag, πTemp001); πE != nil {
								continue
							}
							µtag = πTemp002
							goto Label4
						Label4:
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlink, ßdestination, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							goto Label6
							// line 3845: if link.destination:
							πF.SetLineno(3845)
						Label5:
							// line 3846: link.computedestination()
							πF.SetLineno(3846)
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlink, ßcomputedestination, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label6
						Label6:
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlink, ßurl, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label7
							}
							goto Label8
							// line 3847: if link.url:
							πF.SetLineno(3847)
						Label7:
							// line 3848: tag += ' href="' + link.url + '"'
							πF.SetLineno(3848)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µlink, ßurl, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr(" href=\"").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µtag, πTemp001); πE != nil {
								continue
							}
							µtag = πTemp002
							goto Label8
						Label8:
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlink, ßtarget, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label9
							}
							goto Label10
							// line 3849: if link.target:
							πF.SetLineno(3849)
						Label9:
							// line 3850: tag += ' target="' + link.target + '"'
							πF.SetLineno(3850)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µlink, ßtarget, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr(" target=\"").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µtag, πTemp001); πE != nil {
								continue
							}
							µtag = πTemp002
							goto Label10
						Label10:
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlink, ßtitle, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label11
							}
							goto Label12
							// line 3851: if link.title:
							πF.SetLineno(3851)
						Label11:
							// line 3852: tag += ' title="' + link.title + '"'
							πF.SetLineno(3852)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µlink, ßtitle, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr(" title=\"").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µtag, πTemp001); πE != nil {
								continue
							}
							µtag = πTemp002
							goto Label12
						Label12:
							// line 3853: return TaggedOutput().settag(tag).gethtml(link)
							πF.SetLineno(3853)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlink, "link"); πE != nil {
								continue
							}
							πTemp005[0] = µlink
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp006[0] = µtag
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßgethtml, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgethtml.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3838: "Get the HTML code for the link"
					πF.SetLineno(3838)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Get the HTML code for the link").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßgethtml); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LinkOutput").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLinkOutput.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3859: class Postprocessor(object):
			πF.SetLineno(3859)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Postprocessor", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3860: "Postprocess a container keeping some context"
					πF.SetLineno(3860)
					// line 3860: "Postprocess a container keeping some context"
					πF.SetLineno(3860)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Postprocess a container keeping some context").ToObject()); πE != nil {
						continue
					}
					// line 3862: stages = []
					πF.SetLineno(3862)
					πTemp001 = make([]*πg.Object, 0)
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πE = πClass.SetItem(πF, ßstages.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3864: def __init__(self):
					πF.SetLineno(3864)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3865: self.stages = StageDict(Postprocessor.stages, self)
							πF.SetLineno(3865)
							πTemp001 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßPostprocessor); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstages, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[1] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßStageDict); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßstages, πTemp002); πE != nil {
								continue
							}
							// line 3866: self.current = None
							πF.SetLineno(3866)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcurrent, πTemp003); πE != nil {
								continue
							}
							// line 3867: self.last = None
							πF.SetLineno(3867)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlast, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3869: def postprocess(self, next):
					πF.SetLineno(3869)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "next", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("postprocess", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µnext *πg.Object = πArgs[1]
						_ = µnext
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3870: "Postprocess a container and its contents."
							πF.SetLineno(3870)
							// line 3871: self.postrecursive(self.current)
							πF.SetLineno(3871)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpostrecursive, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3872: result = self.postcurrent(next)
							πF.SetLineno(3872)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnext, "next"); πE != nil {
								continue
							}
							πTemp001[0] = µnext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpostcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µresult = πTemp003
							// line 3873: self.last = self.current
							πF.SetLineno(3873)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlast, πTemp003); πE != nil {
								continue
							}
							// line 3874: self.current = next
							πF.SetLineno(3874)
							if πE = πg.CheckLocal(πF, µnext, "next"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µnext); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcurrent, πTemp002); πE != nil {
								continue
							}
							// line 3875: return result
							πF.SetLineno(3875)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßpostprocess.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3870: "Postprocess a container and its contents."
					πF.SetLineno(3870)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Postprocess a container and its contents.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßpostprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 3877: def postrecursive(self, container):
					πF.SetLineno(3877)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "container", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("postrecursive", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µpostprocessor *πg.Object = πg.UnboundLocal
						_ = µpostprocessor
						var µcontents *πg.Object = πg.UnboundLocal
						_ = µcontents
						var µelement *πg.Object = πg.UnboundLocal
						_ = µelement
						var µpost *πg.Object = πg.UnboundLocal
						_ = µpost
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 9:
								goto Label9
							case 10:
								goto Label10
							case 14:
								goto Label14
							case 15:
								goto Label15
							default:
								panic("unexpected function state")
							}
							// line 3878: "Postprocess the container contents recursively"
							πF.SetLineno(3878)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp002[0] = µcontainer
							πTemp002[1] = ßcontents.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3879: if not hasattr(container, 'contents'):
							πF.SetLineno(3879)
						Label1:
							// line 3880: return
							πF.SetLineno(3880)
							πR = πg.None
							continue
							goto Label2
						Label2:
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ßcontents, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 3881: if len(container.contents) == 0:
							πF.SetLineno(3881)
						Label3:
							// line 3882: return
							πF.SetLineno(3882)
							πR = πg.None
							continue
							goto Label4
						Label4:
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πTemp002[0] = µcontainer
							πTemp002[1] = ßpostprocess.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							goto Label6
							// line 3883: if hasattr(container, 'postprocess'):
							πF.SetLineno(3883)
						Label5:
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ßpostprocess, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							goto Label8
							// line 3884: if not container.postprocess:
							πF.SetLineno(3884)
						Label7:
							// line 3885: return
							πF.SetLineno(3885)
							πR = πg.None
							continue
							goto Label8
						Label8:
							goto Label6
						Label6:
							// line 3886: postprocessor = Postprocessor()
							πF.SetLineno(3886)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßPostprocessor); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µpostprocessor = πTemp003
							// line 3887: contents = []
							πF.SetLineno(3887)
							πTemp002 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp002...).ToObject()
							µcontents = πTemp001
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(10)
							πTemp005 = false
						Label9:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label11
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µelement = πTemp003
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(9)
							// line 3889: post = postprocessor.postprocess(element)
							πF.SetLineno(3889)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							πTemp002[0] = µelement
							if πE = πg.CheckLocal(πF, µpostprocessor, "postprocessor"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpostprocessor, ßpostprocess, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µpost = πTemp004
							if πE = πg.CheckLocal(πF, µpost, "post"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µpost); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label12
							}
							goto Label13
							// line 3890: if post:
							πF.SetLineno(3890)
						Label12:
							// line 3891: contents.append(post)
							πF.SetLineno(3891)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpost, "post"); πE != nil {
								continue
							}
							πTemp002[0] = µpost
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontents, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label13
						Label13:
							continue
						Label10:
							if πE != nil || πR != nil {
								continue
							}
						Label11:
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewInt(2).ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(15)
							πTemp005 = false
						Label14:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label16
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µi = πTemp003
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(14)
							// line 3894: post = postprocessor.postprocess(None)
							πF.SetLineno(3894)
							πTemp002 = πF.MakeArgs(1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpostprocessor, "postprocessor"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpostprocessor, ßpostprocess, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µpost = πTemp004
							if πE = πg.CheckLocal(πF, µpost, "post"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µpost); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label17
							}
							goto Label18
							// line 3895: if post:
							πF.SetLineno(3895)
						Label17:
							// line 3896: contents.append(post)
							πF.SetLineno(3896)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpost, "post"); πE != nil {
								continue
							}
							πTemp002[0] = µpost
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontents, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label18
						Label18:
							continue
						Label15:
							if πE != nil || πR != nil {
								continue
							}
						Label16:
							// line 3897: container.contents = contents
							πF.SetLineno(3897)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µcontents); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µcontainer, ßcontents, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßpostrecursive.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 3878: "Postprocess the container contents recursively"
					πF.SetLineno(3878)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Postprocess the container contents recursively").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßpostrecursive); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 3899: def postcurrent(self, next):
					πF.SetLineno(3899)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "next", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("postcurrent", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µnext *πg.Object = πArgs[1]
						_ = µnext
						var µstage *πg.Object = πg.UnboundLocal
						_ = µstage
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3900: "Postprocess the current element taking into account next and last."
							πF.SetLineno(3900)
							// line 3901: stage = self.stages.getstage(self.current)
							πF.SetLineno(3901)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstages, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßgetstage, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µstage = πTemp002
							if πE = πg.CheckLocal(πF, µstage, "stage"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µstage); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 3902: if not stage:
							πF.SetLineno(3902)
						Label1:
							// line 3903: return self.current
							πF.SetLineno(3903)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 3904: return stage.postprocess(self.last, self.current, next)
							πF.SetLineno(3904)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßlast, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcurrent, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µnext, "next"); πE != nil {
								continue
							}
							πTemp001[2] = µnext
							if πE = πg.CheckLocal(πF, µstage, "stage"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µstage, ßpostprocess, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßpostcurrent.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 3900: "Postprocess the current element taking into account next and last."
					πF.SetLineno(3900)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Postprocess the current element taking into account next and last.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßpostcurrent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Postprocessor").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßPostprocessor.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3906: class StageDict(object):
			πF.SetLineno(3906)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("StageDict", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3907: "A dictionary of stages corresponding to classes"
					πF.SetLineno(3907)
					// line 3907: "A dictionary of stages corresponding to classes"
					πF.SetLineno(3907)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A dictionary of stages corresponding to classes").ToObject()); πE != nil {
						continue
					}
					// line 3909: def __init__(self, classes, postprocessor):
					πF.SetLineno(3909)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "classes", Def: nil}
					πTemp002[2] = πg.Param{Name: "postprocessor", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µclasses *πg.Object = πArgs[1]
						_ = µclasses
						var µpostprocessor *πg.Object = πArgs[2]
						_ = µpostprocessor
						var µinstances *πg.Object = πg.UnboundLocal
						_ = µinstances
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3910: "Instantiate an element from elyxer.each class and store as a dictionary"
							πF.SetLineno(3910)
							// line 3911: instances = self.instantiate(classes, postprocessor)
							πF.SetLineno(3911)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µclasses, "classes"); πE != nil {
								continue
							}
							πTemp001[0] = µclasses
							if πE = πg.CheckLocal(πF, µpostprocessor, "postprocessor"); πE != nil {
								continue
							}
							πTemp001[1] = µpostprocessor
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinstantiate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µinstances = πTemp003
							// line 3912: self.stagedict = dict([(x.processedclass, x) for x in instances])
							πF.SetLineno(3912)
							πTemp001 = πF.MakeArgs(1)
							πTemp004 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µx *πg.Object = πg.UnboundLocal
								_ = µx
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µinstances, "instances"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µinstances); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µx = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 3912: self.stagedict = dict([(x.processedclass, x) for x in instances])
										πF.SetLineno(3912)
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										if πTemp005, πE = πg.GetAttr(πF, µx, ßprocessedclass, nil); πE != nil {
											continue
										}
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										πTemp004 = πg.NewTuple2(πTemp005, µx).ToObject()
										πF.PushCheckpoint(4)
										return πTemp004, nil
									Label4:
										πTemp005 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßstagedict, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3910: "Instantiate an element from elyxer.each class and store as a dictionary"
					πF.SetLineno(3910)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Instantiate an element from elyxer.each class and store as a dictionary").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 3914: def instantiate(self, classes, postprocessor):
					πF.SetLineno(3914)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "classes", Def: nil}
					πTemp002[2] = πg.Param{Name: "postprocessor", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("instantiate", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µclasses *πg.Object = πArgs[1]
						_ = µclasses
						var µpostprocessor *πg.Object = πArgs[2]
						_ = µpostprocessor
						var µstages *πg.Object = πg.UnboundLocal
						_ = µstages
						var µelement *πg.Object = πg.UnboundLocal
						_ = µelement
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 3915: "Instantiate an element from elyxer.each class"
							πF.SetLineno(3915)
							// line 3916: stages = [x.__new__(x) for x in classes]
							πF.SetLineno(3916)
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µx *πg.Object = πg.UnboundLocal
								_ = µx
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µclasses, "classes"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µclasses); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µx = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 3916: stages = [x.__new__(x) for x in classes]
										πF.SetLineno(3916)
										πTemp005 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										πTemp005[0] = µx
										if πE = πg.CheckLocal(πF, µx, "x"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GetAttr(πF, µx, ß__new__, nil); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
								continue
							}
							µstages = πTemp001
							if πE = πg.CheckLocal(πF, µstages, "stages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µstages); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µelement = πTemp004
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 3918: element.__init__()
							πF.SetLineno(3918)
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µelement, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 3919: element.postprocessor = postprocessor
							πF.SetLineno(3919)
							if πE = πg.CheckLocal(πF, µpostprocessor, "postprocessor"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, µpostprocessor); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µelement, ßpostprocessor, πTemp004); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 3920: return stages
							πF.SetLineno(3920)
							if πE = πg.CheckLocal(πF, µstages, "stages"); πE != nil {
								continue
							}
							πR = µstages
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinstantiate.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3915: "Instantiate an element from elyxer.each class"
					πF.SetLineno(3915)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Instantiate an element from elyxer.each class").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßinstantiate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 3922: def getstage(self, element):
					πF.SetLineno(3922)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "element", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("getstage", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µelement *πg.Object = πArgs[1]
						_ = µelement
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3923: "Get the stage for a given element, if the type is in the dict"
							πF.SetLineno(3923)
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µelement, ß__class__, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstagedict, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3924: if not element.__class__ in self.stagedict:
							πF.SetLineno(3924)
						Label1:
							// line 3925: return None
							πF.SetLineno(3925)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 3926: return self.stagedict[element.__class__]
							πF.SetLineno(3926)
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µelement, ß__class__, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstagedict, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetstage.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3923: "Get the stage for a given element, if the type is in the dict"
					πF.SetLineno(3923)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Get the stage for a given element, if the type is in the dict").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßgetstage); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("StageDict").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStageDict.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3930: class Label(Link):
			πF.SetLineno(3930)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßLink); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Label", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 bool
				_ = πTemp011
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3931: "A label to be referenced"
					πF.SetLineno(3931)
					// line 3931: "A label to be referenced"
					πF.SetLineno(3931)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A label to be referenced").ToObject()); πE != nil {
						continue
					}
					// line 3933: names = dict()
					πF.SetLineno(3933)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßdict); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßnames.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3934: lastlayout = None
					πF.SetLineno(3934)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßlastlayout.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3936: def __init__(self):
					πF.SetLineno(3936)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3937: Link.__init__(self)
							πF.SetLineno(3937)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßLink); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3938: self.lastnumbered = None
							πF.SetLineno(3938)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlastnumbered, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3940: def process(self):
					πF.SetLineno(3940)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µkey *πg.Object = πg.UnboundLocal
						_ = µkey
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3941: "Process a label container."
							πF.SetLineno(3941)
							// line 3942: key = self.getparameter('name')
							πF.SetLineno(3942)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßname.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µkey = πTemp003
							// line 3943: self.create(' ', key)
							πF.SetLineno(3943)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr(" ").ToObject()
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp001[1] = µkey
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3944: self.lastnumbered = Label.lastlayout
							πF.SetLineno(3944)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßLabel); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßlastlayout, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlastnumbered, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3941: "Process a label container."
					πF.SetLineno(3941)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Process a label container.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 3946: def create(self, text, key, type = 'Label'):
					πF.SetLineno(3946)
					πTemp003 = make([]πg.Param, 4)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "text", Def: nil}
					πTemp003[2] = πg.Param{Name: "key", Def: nil}
					πTemp003[3] = πg.Param{Name: "type", Def: ßLabel.ToObject()}
					πTemp004 = πg.NewFunction(πg.NewCode("create", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var µkey *πg.Object = πArgs[2]
						_ = µkey
						var µtype *πg.Object = πArgs[3]
						_ = µtype
						var µreference *πg.Object = πg.UnboundLocal
						_ = µreference
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 πg.KWArgs
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 3947: "Create the label for a given key."
							πF.SetLineno(3947)
							// line 3948: self.key = key
							πF.SetLineno(3948)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µkey); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßkey, πTemp001); πE != nil {
								continue
							}
							// line 3949: self.complete(text, anchor = key, type = type)
							πF.SetLineno(3949)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp002[0] = µtext
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp003 = πg.KWArgs{
								{"anchor", µkey},
								{"type", µtype},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp002, πTemp003); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 3950: Label.names[key] = self
							πF.SetLineno(3950)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µself); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßLabel); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßnames, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp004 = µkey
							if πE = πg.SetItem(πF, πTemp005, πTemp004, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßReference); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßreferences, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, µkey); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 3951: if key in Reference.references:
							πF.SetLineno(3951)
						Label1:
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp004 = µkey
							if πTemp007, πE = πg.ResolveGlobal(πF, ßReference); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßreferences, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp008, πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp006 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp009 = !isStop
							} else {
								πTemp009 = true
								µreference = πTemp004
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 3953: reference.destination = self
							πF.SetLineno(3953)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, µself); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µreference, ßdestination, πTemp004); πE != nil {
								continue
							}
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							goto Label2
						Label2:
							// line 3954: return self
							πF.SetLineno(3954)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcreate.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3947: "Create the label for a given key."
					πF.SetLineno(3947)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Create the label for a given key.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßcreate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 3956: def findpartkey(self):
					πF.SetLineno(3956)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("findpartkey", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µnumbered *πg.Object = πg.UnboundLocal
						_ = µnumbered
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3957: "Get the part key for the latest numbered container seen."
							πF.SetLineno(3957)
							// line 3958: numbered = self.numbered(self)
							πF.SetLineno(3958)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßnumbered, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µnumbered = πTemp003
							if πE = πg.CheckLocal(πF, µnumbered, "numbered"); πE != nil {
								continue
							}
							πTemp002 = µnumbered
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µnumbered, "numbered"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µnumbered, ßpartkey, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp003
						Label1:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							goto Label3
							// line 3959: if numbered and numbered.partkey:
							πF.SetLineno(3959)
						Label2:
							// line 3960: return numbered.partkey
							πF.SetLineno(3960)
							if πE = πg.CheckLocal(πF, µnumbered, "numbered"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µnumbered, ßpartkey, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label3
						Label3:
							// line 3961: return ''
							πF.SetLineno(3961)
							πR = ß.ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfindpartkey.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 3957: "Get the part key for the latest numbered container seen."
					πF.SetLineno(3957)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Get the part key for the latest numbered container seen.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßfindpartkey); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 3963: def numbered(self, container):
					πF.SetLineno(3963)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "container", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("numbered", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3964: "Get the numbered container for the label."
							πF.SetLineno(3964)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontainer, ßpartkey, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 3965: if container.partkey:
							πF.SetLineno(3965)
						Label1:
							// line 3966: return container
							πF.SetLineno(3966)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							πR = µcontainer
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcontainer, ßparent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 3967: if not container.parent:
							πF.SetLineno(3967)
						Label3:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßlastnumbered, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label5
							}
							goto Label6
							// line 3968: if self.lastnumbered:
							πF.SetLineno(3968)
						Label5:
							// line 3969: return self.lastnumbered
							πF.SetLineno(3969)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßlastnumbered, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label6
						Label6:
							// line 3970: return None
							πF.SetLineno(3970)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 3971: return self.numbered(container.parent)
							πF.SetLineno(3971)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontainer, ßparent, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnumbered, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßnumbered.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 3964: "Get the numbered container for the label."
					πF.SetLineno(3964)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Get the numbered container for the label.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßnumbered); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 3973: def __unicode__(self):
					πF.SetLineno(3973)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3974: "Return a printable representation."
							πF.SetLineno(3974)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[0] = µself
							πTemp002[1] = ßkey.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 3975: if not hasattr(self, 'key'):
							πF.SetLineno(3975)
						Label1:
							// line 3976: return 'Unnamed label'
							πF.SetLineno(3976)
							πR = πg.NewStr("Unnamed label").ToObject()
							continue
							goto Label2
						Label2:
							// line 3977: return 'Label ' + self.key
							πF.SetLineno(3977)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Label ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 3974: "Return a printable representation."
					πF.SetLineno(3974)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp010, πE = πg.GetAttr(πF, πTemp009, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp009 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp008, πE = πg.GE(πF, πTemp010, πTemp009); πE != nil {
						continue
					}
					if πTemp011, πE = πg.IsTrue(πF, πTemp008); πE != nil {
						continue
					}
					if πTemp011 {
						goto Label1
					}
					goto Label2
					// line 3979: if sys.version_info >= (3, 0):
					πF.SetLineno(3979)
				Label1:
					// line 3980: __str__ = __unicode__
					πF.SetLineno(3980)
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp008); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Label").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLabel.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 3983: class Reference(Link):
			πF.SetLineno(3983)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßLink); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Reference", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 bool
				_ = πTemp009
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3984: "A reference to a label."
					πF.SetLineno(3984)
					// line 3984: "A reference to a label."
					πF.SetLineno(3984)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A reference to a label.").ToObject()); πE != nil {
						continue
					}
					// line 3986: references = dict()
					πF.SetLineno(3986)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßdict); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßreferences.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3987: key = 'none'
					πF.SetLineno(3987)
					if πE = πClass.SetItem(πF, ßkey.ToObject(), ßnone.ToObject()); πE != nil {
						continue
					}
					// line 3989: def process(self):
					πF.SetLineno(3989)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlabel *πg.Object = πg.UnboundLocal
						_ = µlabel
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3990: "Read the reference and set the arrow."
							πF.SetLineno(3990)
							// line 3991: self.key = self.getparameter('reference')
							πF.SetLineno(3991)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßreference.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßkey, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßLabel); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßnames, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 3992: if self.key in Label.names:
							πF.SetLineno(3992)
						Label1:
							// line 3993: self.direction = u'↑'
							πF.SetLineno(3993)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewUnicode("\xe2\x86\x91").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdirection, πTemp002); πE != nil {
								continue
							}
							// line 3994: label = Label.names[self.key]
							πF.SetLineno(3994)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp003
							if πTemp004, πE = πg.ResolveGlobal(πF, ßLabel); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßnames, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							µlabel = πTemp003
							goto Label3
						Label2:
							// line 3996: self.direction = u'↓'
							πF.SetLineno(3996)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewUnicode("\xe2\x86\x93").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdirection, πTemp002); πE != nil {
								continue
							}
							// line 3997: label = Label().complete(' ', self.key, 'preref')
							πF.SetLineno(3997)
							πTemp001 = πF.MakeArgs(3)
							πTemp001[0] = πg.NewStr(" ").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							πTemp001[2] = ßpreref.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßLabel); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µlabel = πTemp003
							goto Label3
						Label3:
							// line 3998: self.destination = label
							πF.SetLineno(3998)
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µlabel); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdestination, πTemp002); πE != nil {
								continue
							}
							// line 3999: self.formatcontents()
							πF.SetLineno(3999)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßformatcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßReference); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp005, ßreferences, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp007, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label4
							}
							goto Label5
							// line 4000: if not self.key in Reference.references:
							πF.SetLineno(4000)
						Label4:
							// line 4001: Reference.references[self.key] = []
							πF.SetLineno(4001)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßReference); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßreferences, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							πTemp004 = πTemp007
							if πE = πg.SetItem(πF, πTemp005, πTemp004, πTemp003); πE != nil {
								continue
							}
							goto Label5
						Label5:
							// line 4002: Reference.references[self.key].append(self)
							πF.SetLineno(4002)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp003
							if πTemp004, πE = πg.ResolveGlobal(πF, ßReference); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßreferences, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 3990: "Read the reference and set the arrow."
					πF.SetLineno(3990)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Read the reference and set the arrow.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 4004: def formatcontents(self):
					πF.SetLineno(4004)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("formatcontents", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µformatkey *πg.Object = πg.UnboundLocal
						_ = µformatkey
						var µpartkey *πg.Object = πg.UnboundLocal
						_ = µpartkey
						var µpieces *πg.Object = πg.UnboundLocal
						_ = µpieces
						var µpiece *πg.Object = πg.UnboundLocal
						_ = µpiece
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 11:
								goto Label11
							case 12:
								goto Label12
							default:
								panic("unexpected function state")
							}
							// line 4005: "Format the reference contents."
							πF.SetLineno(4005)
							// line 4006: formatkey = self.getparameter('LatexCommand')
							πF.SetLineno(4006)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßLatexCommand.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µformatkey = πTemp003
							if πE = πg.CheckLocal(πF, µformatkey, "formatkey"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µformatkey); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4007: if not formatkey:
							πF.SetLineno(4007)
						Label1:
							// line 4008: formatkey = 'ref'
							πF.SetLineno(4008)
							µformatkey = ßref.ToObject()
							goto Label2
						Label2:
							// line 4009: self.formatted = u'↕'
							πF.SetLineno(4009)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewUnicode("\xe2\x86\x95").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßformatted, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µformatkey, "formatkey"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßStyleConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßreferenceformats, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp005, µformatkey); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 4010: if formatkey in StyleConfig.referenceformats:
							πF.SetLineno(4010)
						Label3:
							// line 4011: self.formatted = StyleConfig.referenceformats[formatkey]
							πF.SetLineno(4011)
							if πE = πg.CheckLocal(πF, µformatkey, "formatkey"); πE != nil {
								continue
							}
							πTemp002 = µformatkey
							if πTemp005, πE = πg.ResolveGlobal(πF, ßStyleConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßreferenceformats, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßformatted, πTemp002); πE != nil {
								continue
							}
							goto Label5
						Label4:
							// line 4013: Trace.error('Unknown reference format ' + formatkey)
							πF.SetLineno(4013)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µformatkey, "formatkey"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Unknown reference format ").ToObject(), µformatkey); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label5
						Label5:
							// line 4014: self.replace(u'↕', self.direction)
							πF.SetLineno(4014)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewUnicode("\xe2\x86\x95").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdirection, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4015: self.replace('#', '1')
							πF.SetLineno(4015)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("#").ToObject()
							πTemp001[1] = ß1.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4016: self.replace('on-page', Translator.translate('on-page'))
							πF.SetLineno(4016)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("on-page").ToObject()
							πTemp007 = πF.MakeArgs(1)
							πTemp007[0] = πg.NewStr("on-page").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTranslator); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtranslate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4017: partkey = self.destination.findpartkey()
							πF.SetLineno(4017)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdestination, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßfindpartkey, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µpartkey = πTemp002
							// line 4019: self.replace('@', partkey and partkey.number)
							πF.SetLineno(4019)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("@").ToObject()
							if πE = πg.CheckLocal(πF, µpartkey, "partkey"); πE != nil {
								continue
							}
							πTemp002 = µpartkey
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label6
							}
							if πE = πg.CheckLocal(πF, µpartkey, "partkey"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpartkey, ßnumber, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp003
						Label6:
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4020: self.replace(u'¶', partkey and partkey.tocentry)
							πF.SetLineno(4020)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewUnicode("\xc2\xb6").ToObject()
							if πE = πg.CheckLocal(πF, µpartkey, "partkey"); πE != nil {
								continue
							}
							πTemp002 = µpartkey
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label7
							}
							if πE = πg.CheckLocal(πF, µpartkey, "partkey"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpartkey, ßtocentry, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp003
						Label7:
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßformatted, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Contains(πF, πTemp006, πg.NewStr("$").ToObject()); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(πTemp008).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp008).ToObject()
							πTemp002 = πTemp003
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µpartkey, "partkey"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, µpartkey); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp008).ToObject()
							πTemp002 = πTemp003
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µpartkey, "partkey"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µpartkey, ßtitlecontents, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp008).ToObject()
							πTemp002 = πTemp003
						Label8:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label9
							}
							goto Label10
							// line 4021: if not '$' in self.formatted or not partkey or not partkey.titlecontents:
							πF.SetLineno(4021)
						Label9:
							// line 4023: self.contents = [Constant(self.formatted)]
							πF.SetLineno(4023)
							πTemp001 = make([]*πg.Object, 1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßformatted, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001[0] = πTemp003
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp003); πE != nil {
								continue
							}
							// line 4024: return
							πF.SetLineno(4024)
							πR = πg.None
							continue
							goto Label10
						Label10:
							// line 4025: pieces = self.formatted.split('$')
							πF.SetLineno(4025)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("$").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßformatted, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µpieces = πTemp002
							// line 4026: self.contents = [Constant(pieces[0])]
							πF.SetLineno(4026)
							πTemp001 = make([]*πg.Object, 1)
							πTemp007 = πF.MakeArgs(1)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µpieces, "pieces"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µpieces, πTemp002); πE != nil {
								continue
							}
							πTemp007[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001[0] = πTemp003
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpieces, "pieces"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µpieces, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(12)
							πTemp004 = false
						Label11:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label13
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								µpiece = πTemp003
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(11)
							// line 4028: self.contents += partkey.titlecontents
							πF.SetLineno(4028)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpartkey, "partkey"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µpartkey, ßtitlecontents, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IAdd(πF, πTemp003, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp006); πE != nil {
								continue
							}
							// line 4029: self.contents.append(Constant(piece))
							πF.SetLineno(4029)
							πTemp001 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpiece, "piece"); πE != nil {
								continue
							}
							πTemp007[0] = µpiece
							if πTemp003, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001[0] = πTemp005
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label12:
							if πE != nil || πR != nil {
								continue
							}
						Label13:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßformatcontents.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4005: "Format the reference contents."
					πF.SetLineno(4005)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Format the reference contents.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßformatcontents); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4031: def replace(self, key, value):
					πF.SetLineno(4031)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "key", Def: nil}
					πTemp003[2] = πg.Param{Name: "value", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("replace", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µkey *πg.Object = πArgs[1]
						_ = µkey
						var µvalue *πg.Object = πArgs[2]
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4032: "Replace a key in the format template with a value."
							πF.SetLineno(4032)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßformatted, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp003, µkey); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4033: if not key in self.formatted:
							πF.SetLineno(4033)
						Label1:
							// line 4034: return
							πF.SetLineno(4034)
							πR = πg.None
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µvalue); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 4035: if not value:
							πF.SetLineno(4035)
						Label3:
							// line 4036: value = ''
							πF.SetLineno(4036)
							µvalue = ß.ToObject()
							goto Label4
						Label4:
							// line 4037: self.formatted = self.formatted.replace(key, value)
							πF.SetLineno(4037)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp005[0] = µkey
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp005[1] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßformatted, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßformatted, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreplace.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4032: "Replace a key in the format template with a value."
					πF.SetLineno(4032)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Replace a key in the format template with a value.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßreplace); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4039: def __unicode__(self):
					πF.SetLineno(4039)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4040: "Return a printable representation."
							πF.SetLineno(4040)
							// line 4041: return 'Reference ' + self.key
							πF.SetLineno(4041)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Reference ").ToObject(), πTemp002); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4040: "Return a printable representation."
					πF.SetLineno(4040)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp007 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp006, πE = πg.GE(πF, πTemp008, πTemp007); πE != nil {
						continue
					}
					if πTemp009, πE = πg.IsTrue(πF, πTemp006); πE != nil {
						continue
					}
					if πTemp009 {
						goto Label1
					}
					goto Label2
					// line 4043: if sys.version_info >= (3, 0):
					πF.SetLineno(4043)
				Label1:
					// line 4044: __str__ = __unicode__
					πF.SetLineno(4044)
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp006); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Reference").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßReference.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4047: class FormulaCommand(FormulaBit):
			πF.SetLineno(4047)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 []πg.Param
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4048: "A LaTeX command inside a formula"
					πF.SetLineno(4048)
					// line 4048: "A LaTeX command inside a formula"
					πF.SetLineno(4048)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A LaTeX command inside a formula").ToObject()); πE != nil {
						continue
					}
					// line 4050: types = []
					πF.SetLineno(4050)
					πTemp001 = make([]*πg.Object, 0)
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πE = πClass.SetItem(πF, ßtypes.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4051: start = FormulaConfig.starts['command']
					πF.SetLineno(4051)
					πTemp002 = ßcommand.ToObject()
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßstarts, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßstart.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4052: commandmap = None
					πF.SetLineno(4052)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4054: def detect(self, pos):
					πF.SetLineno(4054)
					πTemp006 = make([]πg.Param, 2)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4055: "Find the current command."
							πF.SetLineno(4055)
							// line 4056: return pos.checkfor(FormulaCommand.start)
							πF.SetLineno(4056)
							πTemp001 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstart, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckfor, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4055: "Find the current command."
					πF.SetLineno(4055)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Find the current command.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4058: def parsebit(self, pos):
					πF.SetLineno(4058)
					πTemp006 = make([]πg.Param, 2)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µcommand *πg.Object = πg.UnboundLocal
						_ = µcommand
						var µbit *πg.Object = πg.UnboundLocal
						_ = µbit
						var µupgreek *πg.Object = πg.UnboundLocal
						_ = µupgreek
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4059: "Parse the command."
							πF.SetLineno(4059)
							// line 4060: command = self.extractcommand(pos)
							πF.SetLineno(4060)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßextractcommand, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µcommand = πTemp003
							// line 4061: bit = self.parsewithcommand(command, pos)
							πF.SetLineno(4061)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							πTemp001[0] = µcommand
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsewithcommand, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbit = πTemp003
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µbit); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4062: if bit:
							πF.SetLineno(4062)
						Label1:
							// line 4063: return bit
							πF.SetLineno(4063)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πR = µbit
							continue
							goto Label2
						Label2:
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\\up").ToObject()
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcommand, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp002 = πTemp005
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\\Up").ToObject()
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcommand, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp002 = πTemp005
						Label3:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 4064: if command.startswith('\\up') or command.startswith('\\Up'):
							πF.SetLineno(4064)
						Label4:
							// line 4065: upgreek = self.parseupgreek(command, pos)
							πF.SetLineno(4065)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							πTemp001[0] = µcommand
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseupgreek, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µupgreek = πTemp003
							if πE = πg.CheckLocal(πF, µupgreek, "upgreek"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µupgreek); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 4066: if upgreek:
							πF.SetLineno(4066)
						Label6:
							// line 4067: return upgreek
							πF.SetLineno(4067)
							if πE = πg.CheckLocal(πF, µupgreek, "upgreek"); πE != nil {
								continue
							}
							πR = µupgreek
							continue
							goto Label7
						Label7:
							goto Label5
						Label5:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßdefining, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label8
							}
							goto Label9
							// line 4068: if not self.factory.defining:
							πF.SetLineno(4068)
						Label8:
							// line 4069: Trace.error('Unknown command ' + command)
							πF.SetLineno(4069)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Unknown command ").ToObject(), µcommand); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label9
						Label9:
							// line 4070: self.output = TaggedOutput().settag('span class="unknown"')
							πF.SetLineno(4070)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("span class=\"unknown\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 4071: self.add(FormulaConstant(command))
							πF.SetLineno(4071)
							πTemp001 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							πTemp006[0] = µcommand
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4072: return None
							πF.SetLineno(4072)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4059: "Parse the command."
					πF.SetLineno(4059)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse the command.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4074: def parsewithcommand(self, command, pos):
					πF.SetLineno(4074)
					πTemp006 = make([]πg.Param, 3)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "command", Def: nil}
					πTemp006[2] = πg.Param{Name: "pos", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parsewithcommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcommand *πg.Object = πArgs[1]
						_ = µcommand
						var µpos *πg.Object = πArgs[2]
						_ = µpos
						var µtype *πg.Object = πg.UnboundLocal
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4075: "Parse the command type once we have the command."
							πF.SetLineno(4075)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtypes, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µtype = πTemp002
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µtype, ßcommandmap, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp003, µcommand); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 4077: if command in type.commandmap:
							πF.SetLineno(4077)
						Label4:
							// line 4078: return self.parsecommandtype(command, type, pos)
							πF.SetLineno(4078)
							πTemp006 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							πTemp006[0] = µcommand
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp006[1] = µtype
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp006[2] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsecommandtype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πR = πTemp003
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 4079: return None
							πF.SetLineno(4079)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsewithcommand.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4075: "Parse the command type once we have the command."
					πF.SetLineno(4075)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse the command type once we have the command.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßparsewithcommand); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4081: def parsecommandtype(self, command, type, pos):
					πF.SetLineno(4081)
					πTemp006 = make([]πg.Param, 4)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "command", Def: nil}
					πTemp006[2] = πg.Param{Name: "type", Def: nil}
					πTemp006[3] = πg.Param{Name: "pos", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("parsecommandtype", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcommand *πg.Object = πArgs[1]
						_ = µcommand
						var µtype *πg.Object = πArgs[2]
						_ = µtype
						var µpos *πg.Object = πArgs[3]
						_ = µpos
						var µbit *πg.Object = πg.UnboundLocal
						_ = µbit
						var µreturned *πg.Object = πg.UnboundLocal
						_ = µreturned
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4082: "Parse a given command type."
							πF.SetLineno(4082)
							// line 4083: bit = self.factory.create(type)
							πF.SetLineno(4083)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp001[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbit = πTemp002
							// line 4084: bit.setcommand(command)
							πF.SetLineno(4084)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							πTemp001[0] = µcommand
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbit, ßsetcommand, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4085: returned = bit.parsebit(pos)
							πF.SetLineno(4085)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbit, ßparsebit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µreturned = πTemp003
							if πE = πg.CheckLocal(πF, µreturned, "returned"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µreturned); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4086: if returned:
							πF.SetLineno(4086)
						Label1:
							// line 4087: return returned
							πF.SetLineno(4087)
							if πE = πg.CheckLocal(πF, µreturned, "returned"); πE != nil {
								continue
							}
							πR = µreturned
							continue
							goto Label2
						Label2:
							// line 4088: return bit
							πF.SetLineno(4088)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πR = µbit
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsecommandtype.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4082: "Parse a given command type."
					πF.SetLineno(4082)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Parse a given command type.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßparsecommandtype); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 4090: def extractcommand(self, pos):
					πF.SetLineno(4090)
					πTemp006 = make([]πg.Param, 2)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "pos", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("extractcommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µcommand *πg.Object = πg.UnboundLocal
						_ = µcommand
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4091: "Extract the command from elyxer.the current position."
							πF.SetLineno(4091)
							πTemp002 = πF.MakeArgs(1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstart, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4092: if not pos.checkskip(FormulaCommand.start):
							πF.SetLineno(4092)
						Label1:
							// line 4093: pos.error('Missing command start ' + FormulaCommand.start)
							πF.SetLineno(4093)
							πTemp002 = πF.MakeArgs(1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstart, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Missing command start ").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßerror, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 4094: return
							πF.SetLineno(4094)
							πR = πg.None
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 4095: if pos.finished():
							πF.SetLineno(4095)
						Label3:
							// line 4096: return self.emptycommand(pos)
							πF.SetLineno(4096)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßemptycommand, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πR = πTemp003
							continue
							goto Label4
						Label4:
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßisalpha, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							goto Label6
							// line 4097: if pos.current().isalpha():
							πF.SetLineno(4097)
						Label5:
							// line 4099: command = FormulaCommand.start + pos.globalpha()
							πF.SetLineno(4099)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstart, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßglobalpha, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πTemp006); πE != nil {
								continue
							}
							µcommand = πTemp001
							// line 4101: pos.checkskip('*')
							πF.SetLineno(4101)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("*").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 4102: return command
							πF.SetLineno(4102)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							πR = µcommand
							continue
							goto Label6
						Label6:
							// line 4104: return FormulaCommand.start + pos.skipcurrent()
							πF.SetLineno(4104)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßstart, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πTemp006); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßextractcommand.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 4091: "Extract the command from elyxer.the current position."
					πF.SetLineno(4091)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Extract the command from elyxer.the current position.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßextractcommand); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 4106: def emptycommand(self, pos):
					πF.SetLineno(4106)
					πTemp006 = make([]πg.Param, 2)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "pos", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("emptycommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µcommand *πg.Object = πg.UnboundLocal
						_ = µcommand
						var µending *πg.Object = πg.UnboundLocal
						_ = µending
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4107: """Check for an empty command: look for command disguised as ending.
							πF.SetLineno(4107)
							// line 4109: command = ''
							πF.SetLineno(4109)
							µcommand = ß.ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßisout, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4110: if not pos.isout():
							πF.SetLineno(4110)
						Label1:
							// line 4111: ending = pos.nextending()
							πF.SetLineno(4111)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßnextending, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µending = πTemp002
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp001 = µending
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label3
							}
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp005[0] = µending
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001 = πTemp003
						Label3:
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 4112: if ending and pos.checkskip(ending):
							πF.SetLineno(4112)
						Label4:
							// line 4113: command = ending
							πF.SetLineno(4113)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							µcommand = µending
							goto Label5
						Label5:
							goto Label2
						Label2:
							// line 4114: return FormulaCommand.start + command
							πF.SetLineno(4114)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstart, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, µcommand); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßemptycommand.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 4107: """Check for an empty command: look for command disguised as ending.
					πF.SetLineno(4107)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Check for an empty command: look for command disguised as ending.\n    Special case against '{ \\{ \\} }' situation.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßemptycommand); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 4116: def parseupgreek(self, command, pos):
					πF.SetLineno(4116)
					πTemp006 = make([]πg.Param, 3)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "command", Def: nil}
					πTemp006[2] = πg.Param{Name: "pos", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("parseupgreek", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcommand *πg.Object = πArgs[1]
						_ = µcommand
						var µpos *πg.Object = πArgs[2]
						_ = µpos
						var µupcommand *πg.Object = πg.UnboundLocal
						_ = µupcommand
						var µupgreek *πg.Object = πg.UnboundLocal
						_ = µupgreek
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4117: "Parse the Greek \\up command.."
							πF.SetLineno(4117)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							πTemp002[0] = µcommand
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.LT(πF, πTemp004, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4118: if len(command) < 4:
							πF.SetLineno(4118)
						Label1:
							// line 4119: return None
							πF.SetLineno(4119)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("\\up").ToObject()
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcommand, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("\\Up").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 4120: if command.startswith('\\up'):
							πF.SetLineno(4120)
						Label3:
							// line 4121: upcommand = '\\' + command[3:]
							πF.SetLineno(4121)
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(3).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µcommand, πTemp003); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("\\").ToObject(), πTemp004); πE != nil {
								continue
							}
							µupcommand = πTemp001
							goto Label6
							// line 4122: elif pos.checkskip('\\Up'):
							πF.SetLineno(4122)
						Label4:
							// line 4123: upcommand = '\\' + command[3:4].upper() + command[4:]
							πF.SetLineno(4123)
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(3).ToObject(), πg.NewInt(4).ToObject(), πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µcommand, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp006, ßupper, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("\\").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(4).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µcommand, πTemp004); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πTemp006); πE != nil {
								continue
							}
							µupcommand = πTemp001
							goto Label6
						Label5:
							// line 4125: Trace.error('Impossible upgreek command: ' + command)
							πF.SetLineno(4125)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Impossible upgreek command: ").ToObject(), µcommand); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 4126: return
							πF.SetLineno(4126)
							πR = πg.None
							continue
							goto Label6
						Label6:
							// line 4127: upgreek = self.parsewithcommand(upcommand, pos)
							πF.SetLineno(4127)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µupcommand, "upcommand"); πE != nil {
								continue
							}
							πTemp002[0] = µupcommand
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsewithcommand, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µupgreek = πTemp003
							if πE = πg.CheckLocal(πF, µupgreek, "upgreek"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µupgreek); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							goto Label8
							// line 4128: if upgreek:
							πF.SetLineno(4128)
						Label7:
							// line 4129: upgreek.type = 'font'
							πF.SetLineno(4129)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßfont.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µupgreek, "upgreek"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µupgreek, ßtype, πTemp001); πE != nil {
								continue
							}
							goto Label8
						Label8:
							// line 4130: return upgreek
							πF.SetLineno(4130)
							if πE = πg.CheckLocal(πF, µupgreek, "upgreek"); πE != nil {
								continue
							}
							πR = µupgreek
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseupgreek.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 4117: "Parse the Greek \\up command.."
					πF.SetLineno(4117)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Parse the Greek \\up command..").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßparseupgreek); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4132: class CommandBit(FormulaCommand):
			πF.SetLineno(4132)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("CommandBit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4133: "A formula bit that includes a command"
					πF.SetLineno(4133)
					// line 4133: "A formula bit that includes a command"
					πF.SetLineno(4133)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A formula bit that includes a command").ToObject()); πE != nil {
						continue
					}
					// line 4135: def setcommand(self, command):
					πF.SetLineno(4135)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "command", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("setcommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcommand *πg.Object = πArgs[1]
						_ = µcommand
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4136: "Set the command in the bit"
							πF.SetLineno(4136)
							// line 4137: self.command = command
							πF.SetLineno(4137)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µcommand); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcommand, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcommandmap, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 4138: if self.commandmap:
							πF.SetLineno(4138)
						Label1:
							// line 4139: self.original += command
							πF.SetLineno(4139)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp001, µcommand); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp003); πE != nil {
								continue
							}
							// line 4140: self.translated = self.commandmap[self.command]
							πF.SetLineno(4140)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcommand, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßcommandmap, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtranslated, πTemp001); πE != nil {
								continue
							}
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetcommand.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4136: "Set the command in the bit"
					πF.SetLineno(4136)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Set the command in the bit").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßsetcommand); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4142: def parseparameter(self, pos):
					πF.SetLineno(4142)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parseparameter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µparameter *πg.Object = πg.UnboundLocal
						_ = µparameter
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4143: "Parse a parameter at the current position"
							πF.SetLineno(4143)
							// line 4144: self.factory.clearskipped(pos)
							πF.SetLineno(4144)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4145: if pos.finished():
							πF.SetLineno(4145)
						Label1:
							// line 4146: return None
							πF.SetLineno(4146)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 4147: parameter = self.factory.parseany(pos)
							πF.SetLineno(4147)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparseany, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µparameter = πTemp002
							// line 4148: self.add(parameter)
							πF.SetLineno(4148)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparameter, "parameter"); πE != nil {
								continue
							}
							πTemp001[0] = µparameter
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4149: return parameter
							πF.SetLineno(4149)
							if πE = πg.CheckLocal(πF, µparameter, "parameter"); πE != nil {
								continue
							}
							πR = µparameter
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseparameter.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4143: "Parse a parameter at the current position"
					πF.SetLineno(4143)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse a parameter at the current position").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparseparameter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4151: def parsesquare(self, pos):
					πF.SetLineno(4151)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parsesquare", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µbracket *πg.Object = πg.UnboundLocal
						_ = µbracket
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4152: "Parse a square bracket"
							πF.SetLineno(4152)
							// line 4153: self.factory.clearskipped(pos)
							πF.SetLineno(4153)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßSquareBracket); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4154: if not self.factory.detecttype(SquareBracket, pos):
							πF.SetLineno(4154)
						Label1:
							// line 4155: return None
							πF.SetLineno(4155)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 4156: bracket = self.factory.parsetype(SquareBracket, pos)
							πF.SetLineno(4156)
							πTemp001 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßSquareBracket); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparsetype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbracket = πTemp002
							// line 4157: self.add(bracket)
							πF.SetLineno(4157)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							πTemp001[0] = µbracket
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4158: return bracket
							πF.SetLineno(4158)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							πR = µbracket
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsesquare.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4152: "Parse a square bracket"
					πF.SetLineno(4152)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse a square bracket").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparsesquare); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4160: def parseliteral(self, pos):
					πF.SetLineno(4160)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("parseliteral", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µbracket *πg.Object = πg.UnboundLocal
						_ = µbracket
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4161: "Parse a literal bracket."
							πF.SetLineno(4161)
							// line 4162: self.factory.clearskipped(pos)
							πF.SetLineno(4162)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßBracket); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4163: if not self.factory.detecttype(Bracket, pos):
							πF.SetLineno(4163)
						Label1:
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßisvalue, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 4164: if not pos.isvalue():
							πF.SetLineno(4164)
						Label3:
							// line 4165: Trace.error('No literal parameter found at: ' + pos.identifier())
							πF.SetLineno(4165)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßidentifier, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("No literal parameter found at: ").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4166: return None
							πF.SetLineno(4166)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label4
						Label4:
							// line 4167: return pos.globvalue()
							πF.SetLineno(4167)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßglobvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label2
						Label2:
							// line 4168: bracket = Bracket().setfactory(self.factory)
							πF.SetLineno(4168)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßBracket); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsetfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbracket = πTemp003
							// line 4169: self.add(bracket.parseliteral(pos))
							πF.SetLineno(4169)
							πTemp001 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp006[0] = µpos
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbracket, ßparseliteral, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4170: return bracket.literal
							πF.SetLineno(4170)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbracket, ßliteral, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseliteral.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4161: "Parse a literal bracket."
					πF.SetLineno(4161)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Parse a literal bracket.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßparseliteral); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 4172: def parsesquareliteral(self, pos):
					πF.SetLineno(4172)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("parsesquareliteral", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µbracket *πg.Object = πg.UnboundLocal
						_ = µbracket
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4173: "Parse a square bracket literally."
							πF.SetLineno(4173)
							// line 4174: self.factory.clearskipped(pos)
							πF.SetLineno(4174)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßSquareBracket); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4175: if not self.factory.detecttype(SquareBracket, pos):
							πF.SetLineno(4175)
						Label1:
							// line 4176: return None
							πF.SetLineno(4176)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 4177: bracket = SquareBracket().setfactory(self.factory)
							πF.SetLineno(4177)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßSquareBracket); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsetfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbracket = πTemp003
							// line 4178: self.add(bracket.parseliteral(pos))
							πF.SetLineno(4178)
							πTemp001 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp006[0] = µpos
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbracket, ßparseliteral, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4179: return bracket.literal
							πF.SetLineno(4179)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbracket, ßliteral, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsesquareliteral.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 4173: "Parse a square bracket literally."
					πF.SetLineno(4173)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Parse a square bracket literally.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßparsesquareliteral); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 4181: def parsetext(self, pos):
					πF.SetLineno(4181)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("parsetext", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µbracket *πg.Object = πg.UnboundLocal
						_ = µbracket
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4182: "Parse a text parameter."
							πF.SetLineno(4182)
							// line 4183: self.factory.clearskipped(pos)
							πF.SetLineno(4183)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßBracket); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4184: if not self.factory.detecttype(Bracket, pos):
							πF.SetLineno(4184)
						Label1:
							// line 4185: Trace.error('No text parameter for ' + self.command)
							πF.SetLineno(4185)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcommand, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("No text parameter for ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4186: return None
							πF.SetLineno(4186)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							// line 4187: bracket = Bracket().setfactory(self.factory).parsetext(pos)
							πF.SetLineno(4187)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßBracket); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsetfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßparsetext, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbracket = πTemp003
							// line 4188: self.add(bracket)
							πF.SetLineno(4188)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							πTemp001[0] = µbracket
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4189: return bracket
							πF.SetLineno(4189)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							πR = µbracket
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsetext.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 4182: "Parse a text parameter."
					πF.SetLineno(4182)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Parse a text parameter.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßparsetext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("CommandBit").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßCommandBit.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4191: class EmptyCommand(CommandBit):
			πF.SetLineno(4191)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("EmptyCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4192: "An empty command (without parameters)"
					πF.SetLineno(4192)
					// line 4192: "An empty command (without parameters)"
					πF.SetLineno(4192)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("An empty command (without parameters)").ToObject()); πE != nil {
						continue
					}
					// line 4194: commandmap = FormulaConfig.commands
					πF.SetLineno(4194)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcommands, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4196: def parsebit(self, pos):
					πF.SetLineno(4196)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4197: "Parse a command without parameters"
							πF.SetLineno(4197)
							// line 4198: self.contents = [FormulaConstant(self.translated)]
							πF.SetLineno(4198)
							πTemp001 = make([]*πg.Object, 1)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp004); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4197: "Parse a command without parameters"
					πF.SetLineno(4197)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a command without parameters").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("EmptyCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßEmptyCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4200: class SpacedCommand(CommandBit):
			πF.SetLineno(4200)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("SpacedCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4201: "An empty command which should have math spacing in formulas."
					πF.SetLineno(4201)
					// line 4201: "An empty command which should have math spacing in formulas."
					πF.SetLineno(4201)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("An empty command which should have math spacing in formulas.").ToObject()); πE != nil {
						continue
					}
					// line 4203: commandmap = FormulaConfig.spacedcommands
					πF.SetLineno(4203)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßspacedcommands, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4205: def parsebit(self, pos):
					πF.SetLineno(4205)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4206: "Place as contents the command translated and spaced."
							πF.SetLineno(4206)
							// line 4207: self.contents = [FormulaConstant(u' ' + self.translated + u' ')]
							πF.SetLineno(4207)
							πTemp001 = make([]*πg.Object, 1)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πg.NewUnicode("\xe2\x81\x9f").ToObject(), πTemp005); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, πg.NewUnicode("\xe2\x81\x9f").ToObject()); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp004); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4206: "Place as contents the command translated and spaced."
					πF.SetLineno(4206)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Place as contents the command translated and spaced.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("SpacedCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßSpacedCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4209: class AlphaCommand(EmptyCommand):
			πF.SetLineno(4209)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßEmptyCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("AlphaCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4210: "A command without paramters whose result is alphabetical"
					πF.SetLineno(4210)
					// line 4210: "A command without paramters whose result is alphabetical"
					πF.SetLineno(4210)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A command without paramters whose result is alphabetical").ToObject()); πE != nil {
						continue
					}
					// line 4212: commandmap = FormulaConfig.alphacommands
					πF.SetLineno(4212)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßalphacommands, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4214: def parsebit(self, pos):
					πF.SetLineno(4214)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4215: "Parse the command and set type to alpha"
							πF.SetLineno(4215)
							// line 4216: EmptyCommand.parsebit(self, pos)
							πF.SetLineno(4216)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πTemp002, πE = πg.ResolveGlobal(πF, ßEmptyCommand); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparsebit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4217: self.type = 'alpha'
							πF.SetLineno(4217)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, ßalpha.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4215: "Parse the command and set type to alpha"
					πF.SetLineno(4215)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse the command and set type to alpha").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("AlphaCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßAlphaCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4219: class OneParamFunction(CommandBit):
			πF.SetLineno(4219)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("OneParamFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4220: "A function of one parameter"
					πF.SetLineno(4220)
					// line 4220: "A function of one parameter"
					πF.SetLineno(4220)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A function of one parameter").ToObject()); πE != nil {
						continue
					}
					// line 4222: commandmap = FormulaConfig.onefunctions
					πF.SetLineno(4222)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßonefunctions, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4223: simplified = False
					πF.SetLineno(4223)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßsimplified.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4225: def parsebit(self, pos):
					πF.SetLineno(4225)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4226: "Parse a function with one parameter"
							πF.SetLineno(4226)
							// line 4227: self.output = TaggedOutput().settag(self.translated)
							πF.SetLineno(4227)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 4228: self.parseparameter(pos)
							πF.SetLineno(4228)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4229: self.simplifyifpossible()
							πF.SetLineno(4229)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsimplifyifpossible, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4226: "Parse a function with one parameter"
					πF.SetLineno(4226)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a function with one parameter").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 4231: def simplifyifpossible(self):
					πF.SetLineno(4231)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("simplifyifpossible", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4232: "Try to simplify to a single character."
							πF.SetLineno(4232)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcommandmap, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp003, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4233: if self.original in self.commandmap:
							πF.SetLineno(4233)
						Label1:
							// line 4234: self.output = FixedOutput()
							πF.SetLineno(4234)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFixedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 4235: self.html = [self.commandmap[self.original]]
							πF.SetLineno(4235)
							πTemp005 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcommandmap, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp002); πE != nil {
								continue
							}
							// line 4236: self.simplified = True
							πF.SetLineno(4236)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsimplified, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsimplifyifpossible.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4232: "Try to simplify to a single character."
					πF.SetLineno(4232)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Try to simplify to a single character.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßsimplifyifpossible); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("OneParamFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßOneParamFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4238: class SymbolFunction(CommandBit):
			πF.SetLineno(4238)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("SymbolFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4239: "Find a function which is represented by a symbol (like _ or ^)"
					πF.SetLineno(4239)
					// line 4239: "Find a function which is represented by a symbol (like _ or ^)"
					πF.SetLineno(4239)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Find a function which is represented by a symbol (like _ or ^)").ToObject()); πE != nil {
						continue
					}
					// line 4241: commandmap = FormulaConfig.symbolfunctions
					πF.SetLineno(4241)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsymbolfunctions, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4243: def detect(self, pos):
					πF.SetLineno(4243)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4244: "Find the symbol"
							πF.SetLineno(4244)
							// line 4245: return pos.current() in SymbolFunction.commandmap
							πF.SetLineno(4245)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßSymbolFunction); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßcommandmap, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp005).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4244: "Find the symbol"
					πF.SetLineno(4244)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Find the symbol").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 4247: def parsebit(self, pos):
					πF.SetLineno(4247)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4248: "Parse the symbol"
							πF.SetLineno(4248)
							// line 4249: self.setcommand(pos.current())
							πF.SetLineno(4249)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsetcommand, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4250: pos.skip(self.command)
							πF.SetLineno(4250)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcommand, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4251: self.output = TaggedOutput().settag(self.translated)
							πF.SetLineno(4251)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 4252: self.parseparameter(pos)
							πF.SetLineno(4252)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4248: "Parse the symbol"
					πF.SetLineno(4248)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse the symbol").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("SymbolFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßSymbolFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4254: class TextFunction(CommandBit):
			πF.SetLineno(4254)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TextFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4255: "A function where parameters are read as text."
					πF.SetLineno(4255)
					// line 4255: "A function where parameters are read as text."
					πF.SetLineno(4255)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A function where parameters are read as text.").ToObject()); πE != nil {
						continue
					}
					// line 4257: commandmap = FormulaConfig.textfunctions
					πF.SetLineno(4257)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtextfunctions, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4259: def parsebit(self, pos):
					πF.SetLineno(4259)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4260: "Parse a text parameter"
							πF.SetLineno(4260)
							// line 4261: self.output = TaggedOutput().settag(self.translated)
							πF.SetLineno(4261)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 4262: self.parsetext(pos)
							πF.SetLineno(4262)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsetext, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4260: "Parse a text parameter"
					πF.SetLineno(4260)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a text parameter").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 4264: def process(self):
					πF.SetLineno(4264)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4265: "Set the type to font"
							πF.SetLineno(4265)
							// line 4266: self.type = 'font'
							πF.SetLineno(4266)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßfont.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4265: "Set the type to font"
					πF.SetLineno(4265)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Set the type to font").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TextFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTextFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4268: class LabelFunction(CommandBit):
			πF.SetLineno(4268)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LabelFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4269: "A function that acts as a label"
					πF.SetLineno(4269)
					// line 4269: "A function that acts as a label"
					πF.SetLineno(4269)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A function that acts as a label").ToObject()); πE != nil {
						continue
					}
					// line 4271: commandmap = FormulaConfig.labelfunctions
					πF.SetLineno(4271)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßlabelfunctions, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4273: def parsebit(self, pos):
					πF.SetLineno(4273)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4274: "Parse a literal parameter"
							πF.SetLineno(4274)
							// line 4275: self.key = self.parseliteral(pos)
							πF.SetLineno(4275)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseliteral, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßkey, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4274: "Parse a literal parameter"
					πF.SetLineno(4274)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a literal parameter").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 4277: def process(self):
					πF.SetLineno(4277)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 πg.KWArgs
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4278: "Add an anchor with the label contents."
							πF.SetLineno(4278)
							// line 4279: self.type = 'font'
							πF.SetLineno(4279)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßfont.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							// line 4280: self.label = Label().create(' ', self.key, type = 'eqnumber')
							πF.SetLineno(4280)
							πTemp002 = πF.MakeArgs(2)
							πTemp002[0] = πg.NewStr(" ").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							πTemp002[1] = πTemp001
							πTemp003 = πg.KWArgs{
								{"type", ßeqnumber.ToObject()},
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßLabel); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp004, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp002, πTemp003); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlabel, πTemp001); πE != nil {
								continue
							}
							// line 4281: self.contents = [self.label]
							πF.SetLineno(4281)
							πTemp002 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßlabel, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							πTemp001 = πg.NewList(πTemp002...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp004); πE != nil {
								continue
							}
							// line 4283: Label.names[self.key] = self.label
							πF.SetLineno(4283)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßlabel, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp001); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßLabel); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßnames, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßkey, nil); πE != nil {
								continue
							}
							πTemp005 = πTemp007
							if πE = πg.SetItem(πF, πTemp006, πTemp005, πTemp004); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4278: "Add an anchor with the label contents."
					πF.SetLineno(4278)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Add an anchor with the label contents.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LabelFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLabelFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4285: class FontFunction(OneParamFunction):
			πF.SetLineno(4285)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßOneParamFunction); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FontFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4286: "A function of one parameter that changes the font"
					πF.SetLineno(4286)
					// line 4286: "A function of one parameter that changes the font"
					πF.SetLineno(4286)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A function of one parameter that changes the font").ToObject()); πE != nil {
						continue
					}
					// line 4288: commandmap = FormulaConfig.fontfunctions
					πF.SetLineno(4288)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßfontfunctions, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4290: def process(self):
					πF.SetLineno(4290)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4291: "Simplify if possible using a single character."
							πF.SetLineno(4291)
							// line 4292: self.type = 'font'
							πF.SetLineno(4292)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßfont.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							// line 4293: self.simplifyifpossible()
							πF.SetLineno(4293)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsimplifyifpossible, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4291: "Simplify if possible using a single character."
					πF.SetLineno(4291)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Simplify if possible using a single character.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FontFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFontFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4295: FormulaFactory.types += [FormulaCommand, SymbolFunction]
			πF.SetLineno(4295)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaFactory); πE != nil {
				continue
			}
			if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßtypes, nil); πE != nil {
				continue
			}
			πTemp002 = make([]*πg.Object, 2)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßSymbolFunction); πE != nil {
				continue
			}
			πTemp002[1] = πTemp001
			πTemp001 = πg.NewList(πTemp002...).ToObject()
			if πTemp004, πE = πg.IAdd(πF, πTemp003, πTemp001); πE != nil {
				continue
			}
			if πTemp007, πE = πg.ResolveGlobal(πF, ßFormulaFactory); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp007, ßtypes, πTemp004); πE != nil {
				continue
			}
			// line 4296: FormulaCommand.types = [
			πF.SetLineno(4296)
			πTemp002 = make([]*πg.Object, 7)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßAlphaCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßEmptyCommand); πE != nil {
				continue
			}
			πTemp002[1] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßOneParamFunction); πE != nil {
				continue
			}
			πTemp002[2] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßFontFunction); πE != nil {
				continue
			}
			πTemp002[3] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßLabelFunction); πE != nil {
				continue
			}
			πTemp002[4] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßTextFunction); πE != nil {
				continue
			}
			πTemp002[5] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßSpacedCommand); πE != nil {
				continue
			}
			πTemp002[6] = πTemp001
			πTemp001 = πg.NewList(πTemp002...).ToObject()
			if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
				continue
			}
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp004, ßtypes, πTemp003); πE != nil {
				continue
			}
			// line 4312: class BigSymbol(object):
			πF.SetLineno(4312)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BigSymbol", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4313: "A big symbol generator."
					πF.SetLineno(4313)
					// line 4313: "A big symbol generator."
					πF.SetLineno(4313)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A big symbol generator.").ToObject()); πE != nil {
						continue
					}
					// line 4315: symbols = FormulaConfig.bigsymbols
					πF.SetLineno(4315)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßbigsymbols, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßsymbols.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4317: def __init__(self, symbol):
					πF.SetLineno(4317)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "symbol", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µsymbol *πg.Object = πArgs[1]
						_ = µsymbol
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4318: "Create the big symbol."
							πF.SetLineno(4318)
							// line 4319: self.symbol = symbol
							πF.SetLineno(4319)
							if πE = πg.CheckLocal(πF, µsymbol, "symbol"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsymbol); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsymbol, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4318: "Create the big symbol."
					πF.SetLineno(4318)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Create the big symbol.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 4321: def getpieces(self):
					πF.SetLineno(4321)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("getpieces", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4322: "Get an array with all pieces."
							πF.SetLineno(4322)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßsymbol, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßsymbols, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4323: if not self.symbol in self.symbols:
							πF.SetLineno(4323)
						Label1:
							// line 4324: return [self.symbol]
							πF.SetLineno(4324)
							πTemp006 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsymbol, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							πR = πTemp001
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsmalllimit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							goto Label4
							// line 4325: if self.smalllimit():
							πF.SetLineno(4325)
						Label3:
							// line 4326: return [self.symbol]
							πF.SetLineno(4326)
							πTemp006 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsymbol, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 4327: return self.symbols[self.symbol]
							πF.SetLineno(4327)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsymbol, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßsymbols, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetpieces.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4322: "Get an array with all pieces."
					πF.SetLineno(4322)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Get an array with all pieces.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßgetpieces); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4329: def smalllimit(self):
					πF.SetLineno(4329)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("smalllimit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4330: "Decide if the limit should be a small, one-line symbol."
							πF.SetLineno(4330)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßdisplaymode, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4331: if not DocumentParameters.displaymode:
							πF.SetLineno(4331)
						Label1:
							// line 4332: return True
							πF.SetLineno(4332)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßsymbol, nil); πE != nil {
								continue
							}
							πTemp002 = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßsymbols, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							πTemp005[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.Eq(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 4333: if len(self.symbols[self.symbol]) == 1:
							πF.SetLineno(4333)
						Label3:
							// line 4334: return True
							πF.SetLineno(4334)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 4335: return Options.simplemath
							πF.SetLineno(4335)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsimplemath, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsmalllimit.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4330: "Decide if the limit should be a small, one-line symbol."
					πF.SetLineno(4330)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Decide if the limit should be a small, one-line symbol.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßsmalllimit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BigSymbol").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBigSymbol.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4337: class BigBracket(BigSymbol):
			πF.SetLineno(4337)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßBigSymbol); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BigBracket", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4338: "A big bracket generator."
					πF.SetLineno(4338)
					// line 4338: "A big bracket generator."
					πF.SetLineno(4338)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A big bracket generator.").ToObject()); πE != nil {
						continue
					}
					// line 4340: def __init__(self, size, bracket, alignment='l'):
					πF.SetLineno(4340)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "size", Def: nil}
					πTemp002[2] = πg.Param{Name: "bracket", Def: nil}
					πTemp002[3] = πg.Param{Name: "alignment", Def: ßl.ToObject()}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µsize *πg.Object = πArgs[1]
						_ = µsize
						var µbracket *πg.Object = πArgs[2]
						_ = µbracket
						var µalignment *πg.Object = πArgs[3]
						_ = µalignment
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4341: "Set the size and symbol for the bracket."
							πF.SetLineno(4341)
							// line 4342: self.size = size
							πF.SetLineno(4342)
							if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsize); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsize, πTemp001); πE != nil {
								continue
							}
							// line 4343: self.original = bracket
							πF.SetLineno(4343)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µbracket); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp001); πE != nil {
								continue
							}
							// line 4344: self.alignment = alignment
							πF.SetLineno(4344)
							if πE = πg.CheckLocal(πF, µalignment, "alignment"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µalignment); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßalignment, πTemp001); πE != nil {
								continue
							}
							// line 4345: self.pieces = None
							πF.SetLineno(4345)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßpieces, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßbigbrackets, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp003, µbracket); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4346: if bracket in FormulaConfig.bigbrackets:
							πF.SetLineno(4346)
						Label1:
							// line 4347: self.pieces = FormulaConfig.bigbrackets[bracket]
							πF.SetLineno(4347)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							πTemp001 = µbracket
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßbigbrackets, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßpieces, πTemp001); πE != nil {
								continue
							}
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4341: "Set the size and symbol for the bracket."
					πF.SetLineno(4341)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Set the size and symbol for the bracket.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__init__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4349: def getpiece(self, index):
					πF.SetLineno(4349)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "index", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("getpiece", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindex *πg.Object = πArgs[1]
						_ = µindex
						var µfunction *πg.Object = πg.UnboundLocal
						_ = µfunction
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4350: "Return the nth piece for the bracket."
							πF.SetLineno(4350)
							// line 4351: function = getattr(self, 'getpiece' + unicode(len(self.pieces)))
							πF.SetLineno(4351)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							πTemp003 = πF.MakeArgs(1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp006
							if πTemp005, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Add(πF, ßgetpiece.ToObject(), πTemp006); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µfunction = πTemp005
							// line 4352: return function(index)
							πF.SetLineno(4352)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[0] = µindex
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πTemp002, πE = µfunction.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetpiece.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4350: "Return the nth piece for the bracket."
					πF.SetLineno(4350)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Return the nth piece for the bracket.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßgetpiece); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4354: def getpiece1(self, index):
					πF.SetLineno(4354)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "index", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("getpiece1", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindex *πg.Object = πArgs[1]
						_ = µindex
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4355: "Return the only piece for a single-piece bracket."
							πF.SetLineno(4355)
							// line 4356: return self.pieces[0]
							πF.SetLineno(4356)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetpiece1.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4355: "Return the only piece for a single-piece bracket."
					πF.SetLineno(4355)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Return the only piece for a single-piece bracket.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßgetpiece1); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4358: def getpiece3(self, index):
					πF.SetLineno(4358)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "index", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("getpiece3", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindex *πg.Object = πArgs[1]
						_ = µindex
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4359: "Get the nth piece for a 3-piece bracket: parenthesis or square bracket."
							πF.SetLineno(4359)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µindex, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 4360: if index == 0:
							πF.SetLineno(4360)
						Label1:
							// line 4361: return self.pieces[0]
							πF.SetLineno(4361)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßsize, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Sub(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µindex, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 4362: if index == self.size - 1:
							πF.SetLineno(4362)
						Label3:
							// line 4363: return self.pieces[-1]
							πF.SetLineno(4363)
							if πTemp003, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label4
						Label4:
							// line 4364: return self.pieces[1]
							πF.SetLineno(4364)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetpiece3.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4359: "Get the nth piece for a 3-piece bracket: parenthesis or square bracket."
					πF.SetLineno(4359)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Get the nth piece for a 3-piece bracket: parenthesis or square bracket.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßgetpiece3); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 4366: def getpiece4(self, index):
					πF.SetLineno(4366)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "index", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("getpiece4", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindex *πg.Object = πArgs[1]
						_ = µindex
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4367: "Get the nth piece for a 4-piece bracket: curly bracket."
							πF.SetLineno(4367)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µindex, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 4368: if index == 0:
							πF.SetLineno(4368)
						Label1:
							// line 4369: return self.pieces[0]
							πF.SetLineno(4369)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßsize, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Sub(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µindex, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label3
							}
							goto Label4
							// line 4370: if index == self.size - 1:
							πF.SetLineno(4370)
						Label3:
							// line 4371: return self.pieces[3]
							πF.SetLineno(4371)
							πTemp001 = πg.NewInt(3).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label4
						Label4:
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßsize, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Sub(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Div(πF, πTemp004, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µindex, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label5
							}
							goto Label6
							// line 4372: if index == (self.size - 1)/2:
							πF.SetLineno(4372)
						Label5:
							// line 4373: return self.pieces[2]
							πF.SetLineno(4373)
							πTemp001 = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label6
						Label6:
							// line 4374: return self.pieces[1]
							πF.SetLineno(4374)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetpiece4.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 4367: "Get the nth piece for a 4-piece bracket: curly bracket."
					πF.SetLineno(4367)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Get the nth piece for a 4-piece bracket: curly bracket.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßgetpiece4); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 4376: def getcell(self, index):
					πF.SetLineno(4376)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "index", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("getcell", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindex *πg.Object = πArgs[1]
						_ = µindex
						var µpiece *πg.Object = πg.UnboundLocal
						_ = µpiece
						var µspan *πg.Object = πg.UnboundLocal
						_ = µspan
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4377: "Get the bracket piece as an array cell."
							πF.SetLineno(4377)
							// line 4378: piece = self.getpiece(index)
							πF.SetLineno(4378)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[0] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetpiece, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µpiece = πTemp003
							// line 4379: span = 'span class="bracket align-' + self.alignment + '"'
							πF.SetLineno(4379)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßalignment, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("span class=\"bracket align-").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							µspan = πTemp002
							// line 4380: return TaggedBit().constant(piece, span)
							πF.SetLineno(4380)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpiece, "piece"); πE != nil {
								continue
							}
							πTemp001[0] = µpiece
							if πE = πg.CheckLocal(πF, µspan, "span"); πE != nil {
								continue
							}
							πTemp001[1] = µspan
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßconstant, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetcell.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 4377: "Get the bracket piece as an array cell."
					πF.SetLineno(4377)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Get the bracket piece as an array cell.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßgetcell); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 4382: def getcontents(self):
					πF.SetLineno(4382)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("getcontents", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µrows *πg.Object = πg.UnboundLocal
						_ = µrows
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var µcell *πg.Object = πg.UnboundLocal
						_ = µcell
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 4:
								goto Label4
							case 5:
								goto Label5
							default:
								panic("unexpected function state")
							}
							// line 4383: "Get the bracket as an array or as a single bracket."
							πF.SetLineno(4383)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßsize, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßpieces, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp005).ToObject()
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 4384: if self.size == 1 or not self.pieces:
							πF.SetLineno(4384)
						Label2:
							// line 4385: return self.getsinglebracket()
							πF.SetLineno(4385)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetsinglebracket, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label3
						Label3:
							// line 4386: rows = []
							πF.SetLineno(4386)
							πTemp006 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							µrows = πTemp001
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßsize, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(5)
							πTemp002 = false
						Label4:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label6
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µindex = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(4)
							// line 4388: cell = self.getcell(index)
							πF.SetLineno(4388)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp006[0] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßgetcell, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µcell = πTemp004
							// line 4389: rows.append(TaggedBit().complete([cell], 'span class="arrayrow"'))
							πF.SetLineno(4389)
							πTemp006 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(2)
							πTemp008 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µcell, "cell"); πE != nil {
								continue
							}
							πTemp008[0] = µcell
							πTemp003 = πg.NewList(πTemp008...).ToObject()
							πTemp007[0] = πTemp003
							πTemp007[1] = πg.NewStr("span class=\"arrayrow\"").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp006[0] = πTemp004
							if πE = πg.CheckLocal(πF, µrows, "rows"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µrows, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							continue
						Label5:
							if πE != nil || πR != nil {
								continue
							}
						Label6:
							// line 4390: return [TaggedBit().complete(rows, 'span class="array"')]
							πF.SetLineno(4390)
							πTemp006 = make([]*πg.Object, 1)
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrows, "rows"); πE != nil {
								continue
							}
							πTemp007[0] = µrows
							πTemp007[1] = πg.NewStr("span class=\"array\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp006[0] = πTemp003
							πTemp001 = πg.NewList(πTemp006...).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetcontents.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 4383: "Get the bracket as an array or as a single bracket."
					πF.SetLineno(4383)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Get the bracket as an array or as a single bracket.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßgetcontents); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 4392: def getsinglebracket(self):
					πF.SetLineno(4392)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("getsinglebracket", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4393: "Return the bracket as a single sign."
							πF.SetLineno(4393)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp002, πg.NewStr(".").ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 4394: if self.original == '.':
							πF.SetLineno(4394)
						Label1:
							// line 4395: return [TaggedBit().constant('', 'span class="emptydot"')]
							πF.SetLineno(4395)
							πTemp004 = make([]*πg.Object, 1)
							πTemp005 = πF.MakeArgs(2)
							πTemp005[0] = ß.ToObject()
							πTemp005[1] = πg.NewStr("span class=\"emptydot\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßconstant, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp004[0] = πTemp002
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 4396: return [TaggedBit().constant(self.original, 'span class="symbol"')]
							πF.SetLineno(4396)
							πTemp004 = make([]*πg.Object, 1)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							πTemp005[1] = πg.NewStr("span class=\"symbol\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßconstant, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp004[0] = πTemp002
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetsinglebracket.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 4393: "Return the bracket as a single sign."
					πF.SetLineno(4393)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Return the bracket as a single sign.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßgetsinglebracket); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BigBracket").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBigBracket.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4403: class FormulaEquation(CommandBit):
			πF.SetLineno(4403)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaEquation", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4404: "A simple numbered equation."
					πF.SetLineno(4404)
					// line 4404: "A simple numbered equation."
					πF.SetLineno(4404)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A simple numbered equation.").ToObject()); πE != nil {
						continue
					}
					// line 4406: piece = 'equation'
					πF.SetLineno(4406)
					if πE = πClass.SetItem(πF, ßpiece.ToObject(), ßequation.ToObject()); πE != nil {
						continue
					}
					// line 4408: def parsebit(self, pos):
					πF.SetLineno(4408)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4409: "Parse the array"
							πF.SetLineno(4409)
							// line 4410: self.output = ContentsOutput()
							πF.SetLineno(4410)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßContentsOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 4411: self.add(self.factory.parsetype(WholeFormula, pos))
							πF.SetLineno(4411)
							πTemp003 = πF.MakeArgs(1)
							πTemp004 = πF.MakeArgs(2)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßWholeFormula); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp004[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßparsetype, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4409: "Parse the array"
					πF.SetLineno(4409)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the array").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaEquation").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaEquation.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4413: class FormulaCell(FormulaCommand):
			πF.SetLineno(4413)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaCell", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4414: "An array cell inside a row"
					πF.SetLineno(4414)
					// line 4414: "An array cell inside a row"
					πF.SetLineno(4414)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("An array cell inside a row").ToObject()); πE != nil {
						continue
					}
					// line 4416: def setalignment(self, alignment):
					πF.SetLineno(4416)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "alignment", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("setalignment", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µalignment *πg.Object = πArgs[1]
						_ = µalignment
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4417: self.alignment = alignment
							πF.SetLineno(4417)
							if πE = πg.CheckLocal(πF, µalignment, "alignment"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µalignment); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßalignment, πTemp001); πE != nil {
								continue
							}
							// line 4418: self.output = TaggedOutput().settag('span class="arraycell align-' + alignment +'"', True)
							πF.SetLineno(4418)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µalignment, "alignment"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("span class=\"arraycell align-").ToObject(), µalignment); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp002[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 4419: return self
							πF.SetLineno(4419)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetalignment.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4421: def parsebit(self, pos):
					πF.SetLineno(4421)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4422: self.factory.clearskipped(pos)
							πF.SetLineno(4422)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4423: if pos.finished():
							πF.SetLineno(4423)
						Label1:
							// line 4424: return
							πF.SetLineno(4424)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 4425: self.add(self.factory.parsetype(WholeFormula, pos))
							πF.SetLineno(4425)
							πTemp001 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßWholeFormula); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp005[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparsetype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaCell").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaCell.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4427: class FormulaRow(FormulaCommand):
			πF.SetLineno(4427)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaRow", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 []πg.Param
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4428: "An array row inside an array"
					πF.SetLineno(4428)
					// line 4428: "An array row inside an array"
					πF.SetLineno(4428)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("An array row inside an array").ToObject()); πE != nil {
						continue
					}
					// line 4430: cellseparator = FormulaConfig.array['cellseparator']
					πF.SetLineno(4430)
					πTemp001 = ßcellseparator.ToObject()
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßarray, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcellseparator.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4432: def setalignments(self, alignments):
					πF.SetLineno(4432)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "alignments", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("setalignments", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µalignments *πg.Object = πArgs[1]
						_ = µalignments
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4433: self.alignments = alignments
							πF.SetLineno(4433)
							if πE = πg.CheckLocal(πF, µalignments, "alignments"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µalignments); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßalignments, πTemp001); πE != nil {
								continue
							}
							// line 4434: self.output = TaggedOutput().settag('span class="arrayrow"', True)
							πF.SetLineno(4434)
							πTemp002 = πF.MakeArgs(2)
							πTemp002[0] = πg.NewStr("span class=\"arrayrow\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp002[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 4435: return self
							πF.SetLineno(4435)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsetalignments.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4437: def parsebit(self, pos):
					πF.SetLineno(4437)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var µcell *πg.Object = πg.UnboundLocal
						_ = µcell
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 πg.KWArgs
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4438: "Parse a whole row"
							πF.SetLineno(4438)
							// line 4439: index = 0
							πF.SetLineno(4439)
							µindex = πg.NewInt(0).ToObject()
							// line 4440: pos.pushending(self.cellseparator, optional=True)
							πF.SetLineno(4440)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcellseparator, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003 = πg.KWArgs{
								{"optional", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßpushending, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4441: while not pos.finished():
							πF.SetLineno(4441)
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp008).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 4442: cell = self.createcell(index)
							πF.SetLineno(4442)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[0] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcreatecell, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µcell = πTemp004
							// line 4443: cell.parsebit(pos)
							πF.SetLineno(4443)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µcell, "cell"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcell, ßparsebit, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4444: self.add(cell)
							πF.SetLineno(4444)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcell, "cell"); πE != nil {
								continue
							}
							πTemp001[0] = µcell
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4445: index += 1
							πF.SetLineno(4445)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µindex = πTemp002
							// line 4446: pos.checkskip(self.cellseparator)
							πF.SetLineno(4446)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcellseparator, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Eq(πF, πTemp007, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 4447: if len(self.contents) == 0:
							πF.SetLineno(4447)
						Label4:
							// line 4448: self.output = EmptyOutput()
							πF.SetLineno(4448)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßEmptyOutput); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							goto Label5
						Label5:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4438: "Parse a whole row"
					πF.SetLineno(4438)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse a whole row").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4450: def createcell(self, index):
					πF.SetLineno(4450)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "index", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("createcell", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindex *πg.Object = πArgs[1]
						_ = µindex
						var µalignment *πg.Object = πg.UnboundLocal
						_ = µalignment
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4451: "Create the cell that corresponds to the given index."
							πF.SetLineno(4451)
							// line 4452: alignment = self.alignments[index % len(self.alignments)]
							πF.SetLineno(4452)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßalignments, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Mod(πF, µindex, πTemp005); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßalignments, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µalignment = πTemp002
							// line 4453: return self.factory.create(FormulaCell).setalignment(alignment)
							πF.SetLineno(4453)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µalignment, "alignment"); πE != nil {
								continue
							}
							πTemp003[0] = µalignment
							πTemp006 = πF.MakeArgs(1)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaCell); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsetalignment, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcreatecell.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4451: "Create the cell that corresponds to the given index."
					πF.SetLineno(4451)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Create the cell that corresponds to the given index.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßcreatecell); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaRow").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaRow.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4455: class MultiRowFormula(CommandBit):
			πF.SetLineno(4455)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("MultiRowFormula", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4456: "A formula with multiple rows."
					πF.SetLineno(4456)
					// line 4456: "A formula with multiple rows."
					πF.SetLineno(4456)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A formula with multiple rows.").ToObject()); πE != nil {
						continue
					}
					// line 4458: def parserows(self, pos):
					πF.SetLineno(4458)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parserows", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µfirst *πg.Object = πg.UnboundLocal
						_ = µfirst
						var µrow *πg.Object = πg.UnboundLocal
						_ = µrow
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4459: "Parse all rows, finish when no more row ends"
							πF.SetLineno(4459)
							// line 4460: self.rows = []
							πF.SetLineno(4460)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßrows, πTemp003); πE != nil {
								continue
							}
							// line 4461: first = True
							πF.SetLineno(4461)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							µfirst = πTemp002
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßiteraterows, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µrow = πTemp003
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µfirst, "first"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µfirst); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label4
							}
							goto Label5
							// line 4463: if first:
							πF.SetLineno(4463)
						Label4:
							// line 4464: first = False
							πF.SetLineno(4464)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							µfirst = πTemp003
							goto Label6
						Label5:
							// line 4467: self.addempty()
							πF.SetLineno(4467)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßaddempty, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label6
						Label6:
							// line 4468: row.parsebit(pos)
							πF.SetLineno(4468)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µrow, ßparsebit, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4469: self.addrow(row)
							πF.SetLineno(4469)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							πTemp001[0] = µrow
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßaddrow, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 4470: self.size = len(self.rows)
							πF.SetLineno(4470)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßrows, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsize, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparserows.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4459: "Parse all rows, finish when no more row ends"
					πF.SetLineno(4459)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse all rows, finish when no more row ends").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparserows); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4472: def iteraterows(self, pos):
					πF.SetLineno(4472)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("iteraterows", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µrowseparator *πg.Object = πg.UnboundLocal
						_ = µrowseparator
						var µrow *πg.Object = πg.UnboundLocal
						_ = µrow
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1:
									goto Label1
								case 2:
									goto Label2
								case 4:
									goto Label4
								default:
									panic("unexpected function state")
								}
								// line 4473: "Iterate over all rows, end when no more row ends"
								πF.SetLineno(4473)
								// line 4474: rowseparator = FormulaConfig.array['rowseparator']
								πF.SetLineno(4474)
								πTemp001 = ßrowseparator.ToObject()
								if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
									continue
								}
								if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßarray, nil); πE != nil {
									continue
								}
								if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
									continue
								}
								µrowseparator = πTemp002
								// line 4475: while True:
								πF.SetLineno(4475)
								πF.PushCheckpoint(2)
								πTemp005 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp005 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
									continue
								}
								if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
									continue
								}
								if πE != nil || !πTemp006 {
									continue
								}
								πF.PushCheckpoint(1)
								// line 4476: pos.pushending(rowseparator, True)
								πF.SetLineno(4476)
								πTemp007 = πF.MakeArgs(2)
								if πE = πg.CheckLocal(πF, µrowseparator, "rowseparator"); πE != nil {
									continue
								}
								πTemp007[0] = µrowseparator
								if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
									continue
								}
								πTemp007[1] = πTemp001
								if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.GetAttr(πF, µpos, ßpushending, nil); πE != nil {
									continue
								}
								if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp007)
								// line 4477: row = self.factory.create(FormulaRow)
								πF.SetLineno(4477)
								πTemp007 = πF.MakeArgs(1)
								if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaRow); πE != nil {
									continue
								}
								πTemp007[0] = πTemp001
								if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
									continue
								}
								if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcreate, nil); πE != nil {
									continue
								}
								if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp007)
								µrow = πTemp001
								// line 4478: yield row.setalignments(self.alignments)
								πF.SetLineno(4478)
								πTemp007 = πF.MakeArgs(1)
								if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.GetAttr(πF, µself, ßalignments, nil); πE != nil {
									continue
								}
								πTemp007[0] = πTemp001
								if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.GetAttr(πF, µrow, ßsetalignments, nil); πE != nil {
									continue
								}
								if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp007)
								πF.PushCheckpoint(4)
								return πTemp002, nil
							Label4:
								πTemp001 = πSent
								πTemp007 = πF.MakeArgs(1)
								if πE = πg.CheckLocal(πF, µrowseparator, "rowseparator"); πE != nil {
									continue
								}
								πTemp007[0] = µrowseparator
								if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.GetAttr(πF, µpos, ßcheckfor, nil); πE != nil {
									continue
								}
								if πTemp003, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp007)
								if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
									continue
								}
								if πTemp006 {
									goto Label5
								}
								goto Label6
								// line 4479: if pos.checkfor(rowseparator):
								πF.SetLineno(4479)
							Label5:
								// line 4480: self.original += pos.popending(rowseparator)
								πF.SetLineno(4480)
								if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
									continue
								}
								if πTemp001, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
									continue
								}
								πTemp007 = πF.MakeArgs(1)
								if πE = πg.CheckLocal(πF, µrowseparator, "rowseparator"); πE != nil {
									continue
								}
								πTemp007[0] = µrowseparator
								if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
									continue
								}
								if πTemp003, πE = πg.GetAttr(πF, µpos, ßpopending, nil); πE != nil {
									continue
								}
								if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp007)
								if πTemp003, πE = πg.IAdd(πF, πTemp001, πTemp004); πE != nil {
									continue
								}
								if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
									continue
								}
								if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp003); πE != nil {
									continue
								}
								goto Label7
							Label6:
								// line 4482: return
								πF.SetLineno(4482)
								πR = πg.None
								continue
								goto Label7
							Label7:
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßiteraterows.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4473: "Iterate over all rows, end when no more row ends"
					πF.SetLineno(4473)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Iterate over all rows, end when no more row ends").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßiteraterows); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4484: def addempty(self):
					πF.SetLineno(4484)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("addempty", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µrow *πg.Object = πg.UnboundLocal
						_ = µrow
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var µoriginalcell *πg.Object = πg.UnboundLocal
						_ = µoriginalcell
						var µcell *πg.Object = πg.UnboundLocal
						_ = µcell
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4485: "Add an empty row."
							πF.SetLineno(4485)
							// line 4486: row = self.factory.create(FormulaRow).setalignments(self.alignments)
							πF.SetLineno(4486)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßalignments, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							πTemp003 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaRow); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßsetalignments, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrow = πTemp002
							πTemp001 = πF.MakeArgs(1)
							if πTemp005, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp004 = πTemp005
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßrows, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ßcontents, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßenumerate); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp007 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp004); πE != nil {
									continue
								}
								µindex = πTemp005
								µoriginalcell = πTemp006
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 4488: cell = row.createcell(index)
							πF.SetLineno(4488)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[0] = µindex
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µrow, ßcreatecell, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µcell = πTemp005
							// line 4489: cell.add(FormulaConstant(u' '))
							πF.SetLineno(4489)
							πTemp001 = πF.MakeArgs(1)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewUnicode("\xe2\x80\x85").ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp001[0] = πTemp005
							if πE = πg.CheckLocal(πF, µcell, "cell"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µcell, ßadd, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4490: row.add(cell)
							πF.SetLineno(4490)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcell, "cell"); πE != nil {
								continue
							}
							πTemp001[0] = µcell
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µrow, ßadd, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 4491: self.addrow(row)
							πF.SetLineno(4491)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							πTemp001[0] = µrow
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßaddrow, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßaddempty.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4485: "Add an empty row."
					πF.SetLineno(4485)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Add an empty row.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßaddempty); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4493: def addrow(self, row):
					πF.SetLineno(4493)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "row", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("addrow", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µrow *πg.Object = πArgs[1]
						_ = µrow
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4494: "Add a row to the contents and to the list of rows."
							πF.SetLineno(4494)
							// line 4495: self.rows.append(row)
							πF.SetLineno(4495)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							πTemp001[0] = µrow
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßrows, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4496: self.add(row)
							πF.SetLineno(4496)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							πTemp001[0] = µrow
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßaddrow.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4494: "Add a row to the contents and to the list of rows."
					πF.SetLineno(4494)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Add a row to the contents and to the list of rows.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßaddrow); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("MultiRowFormula").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMultiRowFormula.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4498: class FormulaArray(MultiRowFormula):
			πF.SetLineno(4498)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßMultiRowFormula); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaArray", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4499: "An array within a formula"
					πF.SetLineno(4499)
					// line 4499: "An array within a formula"
					πF.SetLineno(4499)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("An array within a formula").ToObject()); πE != nil {
						continue
					}
					// line 4501: piece = 'array'
					πF.SetLineno(4501)
					if πE = πClass.SetItem(πF, ßpiece.ToObject(), ßarray.ToObject()); πE != nil {
						continue
					}
					// line 4503: def parsebit(self, pos):
					πF.SetLineno(4503)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4504: "Parse the array"
							πF.SetLineno(4504)
							// line 4505: self.output = TaggedOutput().settag('span class="array"', False)
							πF.SetLineno(4505)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("span class=\"array\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 4506: self.parsealignments(pos)
							πF.SetLineno(4506)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsealignments, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4507: self.parserows(pos)
							πF.SetLineno(4507)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparserows, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4504: "Parse the array"
					πF.SetLineno(4504)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the array").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4509: def parsealignments(self, pos):
					πF.SetLineno(4509)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsealignments", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µliteral *πg.Object = πg.UnboundLocal
						_ = µliteral
						var µl *πg.Object = πg.UnboundLocal
						_ = µl
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 4510: "Parse the different alignments"
							πF.SetLineno(4510)
							// line 4512: self.valign = 'c'
							πF.SetLineno(4512)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßc.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalign, πTemp001); πE != nil {
								continue
							}
							// line 4513: literal = self.parsesquareliteral(pos)
							πF.SetLineno(4513)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsesquareliteral, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µliteral = πTemp003
							if πE = πg.CheckLocal(πF, µliteral, "literal"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µliteral); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4514: if literal:
							πF.SetLineno(4514)
						Label1:
							// line 4515: self.valign = literal
							πF.SetLineno(4515)
							if πE = πg.CheckLocal(πF, µliteral, "literal"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µliteral); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalign, πTemp001); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 4517: literal = self.parseliteral(pos)
							πF.SetLineno(4517)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparseliteral, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µliteral = πTemp003
							// line 4518: self.alignments = []
							πF.SetLineno(4518)
							πTemp002 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp002...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßalignments, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µliteral, "literal"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µliteral); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp004 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µl = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 4520: self.alignments.append(l)
							πF.SetLineno(4520)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µl, "l"); πE != nil {
								continue
							}
							πTemp002[0] = µl
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßalignments, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp006.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsealignments.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4510: "Parse the different alignments"
					πF.SetLineno(4510)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse the different alignments").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsealignments); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaArray").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaArray.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4522: class FormulaMatrix(MultiRowFormula):
			πF.SetLineno(4522)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßMultiRowFormula); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaMatrix", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4523: "A matrix (array with center alignment)."
					πF.SetLineno(4523)
					// line 4523: "A matrix (array with center alignment)."
					πF.SetLineno(4523)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A matrix (array with center alignment).").ToObject()); πE != nil {
						continue
					}
					// line 4525: piece = 'matrix'
					πF.SetLineno(4525)
					if πE = πClass.SetItem(πF, ßpiece.ToObject(), ßmatrix.ToObject()); πE != nil {
						continue
					}
					// line 4527: def parsebit(self, pos):
					πF.SetLineno(4527)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4528: "Parse the matrix, set alignments to 'c'."
							πF.SetLineno(4528)
							// line 4529: self.output = TaggedOutput().settag('span class="array"', False)
							πF.SetLineno(4529)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("span class=\"array\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 4530: self.valign = 'c'
							πF.SetLineno(4530)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, ßc.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalign, πTemp002); πE != nil {
								continue
							}
							// line 4531: self.alignments = ['c']
							πF.SetLineno(4531)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = ßc.ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßalignments, πTemp003); πE != nil {
								continue
							}
							// line 4532: self.parserows(pos)
							πF.SetLineno(4532)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparserows, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4528: "Parse the matrix, set alignments to 'c'."
					πF.SetLineno(4528)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the matrix, set alignments to 'c'.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaMatrix").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaMatrix.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4534: class FormulaCases(MultiRowFormula):
			πF.SetLineno(4534)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßMultiRowFormula); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaCases", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4535: "A cases statement"
					πF.SetLineno(4535)
					// line 4535: "A cases statement"
					πF.SetLineno(4535)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A cases statement").ToObject()); πE != nil {
						continue
					}
					// line 4537: piece = 'cases'
					πF.SetLineno(4537)
					if πE = πClass.SetItem(πF, ßpiece.ToObject(), ßcases.ToObject()); πE != nil {
						continue
					}
					// line 4539: def parsebit(self, pos):
					πF.SetLineno(4539)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µrow *πg.Object = πg.UnboundLocal
						_ = µrow
						var µcell *πg.Object = πg.UnboundLocal
						_ = µcell
						var µarray *πg.Object = πg.UnboundLocal
						_ = µarray
						var µbrace *πg.Object = πg.UnboundLocal
						_ = µbrace
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							case 4:
								goto Label4
							case 5:
								goto Label5
							default:
								panic("unexpected function state")
							}
							// line 4540: "Parse the cases"
							πF.SetLineno(4540)
							// line 4541: self.output = ContentsOutput()
							πF.SetLineno(4541)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßContentsOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 4542: self.alignments = ['l', 'l']
							πF.SetLineno(4542)
							πTemp003 = make([]*πg.Object, 2)
							πTemp003[0] = ßl.ToObject()
							πTemp003[1] = ßl.ToObject()
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßalignments, πTemp002); πE != nil {
								continue
							}
							// line 4543: self.parserows(pos)
							πF.SetLineno(4543)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp003[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparserows, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µrow = πTemp002
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µrow, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp006); πE != nil {
								continue
							}
							πF.PushCheckpoint(5)
							πTemp005 = false
						Label4:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label6
							}
							if πTemp006, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µcell = πTemp006
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(4)
							// line 4546: cell.output.settag('span class="case align-l"', True)
							πF.SetLineno(4546)
							πTemp003 = πF.MakeArgs(2)
							πTemp003[0] = πg.NewStr("span class=\"case align-l\"").ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003[1] = πTemp006
							if πE = πg.CheckLocal(πF, µcell, "cell"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µcell, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp006, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp008.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 4547: cell.contents.append(FormulaConstant(u' '))
							πF.SetLineno(4547)
							πTemp003 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							πTemp009[0] = πg.NewUnicode("\xe2\x80\x83").ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp006.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp003[0] = πTemp008
							if πE = πg.CheckLocal(πF, µcell, "cell"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µcell, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp006, ßappend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp008.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							continue
						Label5:
							if πE != nil || πR != nil {
								continue
							}
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 4548: array = TaggedBit().complete(self.contents, 'span class="bracketcases"', True)
							πF.SetLineno(4548)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							πTemp003[1] = πg.NewStr("span class=\"bracketcases\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003[2] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µarray = πTemp002
							// line 4549: brace = BigBracket(len(self.contents), '{', 'l')
							πF.SetLineno(4549)
							πTemp003 = πF.MakeArgs(3)
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							πTemp009[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp003[0] = πTemp002
							πTemp003[1] = πg.NewStr("{").ToObject()
							πTemp003[2] = ßl.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßBigBracket); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µbrace = πTemp002
							// line 4550: self.contents = brace.getcontents() + [array]
							πF.SetLineno(4550)
							if πE = πg.CheckLocal(πF, µbrace, "brace"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbrace, ßgetcontents, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µarray, "array"); πE != nil {
								continue
							}
							πTemp003[0] = µarray
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πTemp001, πE = πg.Add(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4540: "Parse the cases"
					πF.SetLineno(4540)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the cases").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaCases").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaCases.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4552: class EquationEnvironment(MultiRowFormula):
			πF.SetLineno(4552)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßMultiRowFormula); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("EquationEnvironment", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4553: "A \\begin{}...\\end equation environment with rows and cells."
					πF.SetLineno(4553)
					// line 4553: "A \\begin{}...\\end equation environment with rows and cells."
					πF.SetLineno(4553)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A \\begin{}...\\end equation environment with rows and cells.").ToObject()); πE != nil {
						continue
					}
					// line 4555: def parsebit(self, pos):
					πF.SetLineno(4555)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µenvironment *πg.Object = πg.UnboundLocal
						_ = µenvironment
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4556: "Parse the whole environment."
							πF.SetLineno(4556)
							// line 4557: self.output = TaggedOutput().settag('span class="environment"', False)
							πF.SetLineno(4557)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("span class=\"environment\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 4558: environment = self.piece.replace('*', '')
							πF.SetLineno(4558)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("*").ToObject()
							πTemp001[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpiece, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µenvironment = πTemp002
							if πE = πg.CheckLocal(πF, µenvironment, "environment"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßenvironments, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, πTemp004, µenvironment); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4559: if environment in FormulaConfig.environments:
							πF.SetLineno(4559)
						Label1:
							// line 4560: self.alignments = FormulaConfig.environments[environment]
							πF.SetLineno(4560)
							if πE = πg.CheckLocal(πF, µenvironment, "environment"); πE != nil {
								continue
							}
							πTemp002 = µenvironment
							if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp004, ßenvironments, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßalignments, πTemp002); πE != nil {
								continue
							}
							goto Label3
						Label2:
							// line 4562: Trace.error('Unknown equation environment ' + self.piece)
							πF.SetLineno(4562)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpiece, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Unknown equation environment ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4563: self.alignments = ['l']
							πF.SetLineno(4563)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = ßl.ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßalignments, πTemp003); πE != nil {
								continue
							}
							goto Label3
						Label3:
							// line 4564: self.parserows(pos)
							πF.SetLineno(4564)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparserows, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4556: "Parse the whole environment."
					πF.SetLineno(4556)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the whole environment.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("EquationEnvironment").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßEquationEnvironment.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4566: class BeginCommand(CommandBit):
			πF.SetLineno(4566)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BeginCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 []*πg.Object
				_ = πTemp006
				var πTemp007 []πg.Param
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4567: "A \\begin{}...\\end command and what it entails (array, cases, aligned)"
					πF.SetLineno(4567)
					// line 4567: "A \\begin{}...\\end command and what it entails (array, cases, aligned)"
					πF.SetLineno(4567)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A \\begin{}...\\end command and what it entails (array, cases, aligned)").ToObject()); πE != nil {
						continue
					}
					// line 4569: commandmap = {FormulaConfig.array['begin']:''}
					πF.SetLineno(4569)
					πTemp001 = πg.NewDict()
					πTemp002 = ßbegin.ToObject()
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßarray, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, πTemp003, ß.ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4571: types = [FormulaEquation, FormulaArray, FormulaCases, FormulaMatrix]
					πF.SetLineno(4571)
					πTemp006 = make([]*πg.Object, 4)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaEquation); πE != nil {
						continue
					}
					πTemp006[0] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaArray); πE != nil {
						continue
					}
					πTemp006[1] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaCases); πE != nil {
						continue
					}
					πTemp006[2] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaMatrix); πE != nil {
						continue
					}
					πTemp006[3] = πTemp002
					πTemp002 = πg.NewList(πTemp006...).ToObject()
					if πE = πClass.SetItem(πF, ßtypes.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4573: def parsebit(self, pos):
					πF.SetLineno(4573)
					πTemp007 = make([]πg.Param, 2)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp007[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µcommand *πg.Object = πg.UnboundLocal
						_ = µcommand
						var µbit *πg.Object = πg.UnboundLocal
						_ = µbit
						var µending *πg.Object = πg.UnboundLocal
						_ = µending
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4574: "Parse the begin command"
							πF.SetLineno(4574)
							// line 4575: command = self.parseliteral(pos)
							πF.SetLineno(4575)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseliteral, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µcommand = πTemp003
							// line 4576: bit = self.findbit(command)
							πF.SetLineno(4576)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							πTemp001[0] = µcommand
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfindbit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbit = πTemp003
							// line 4577: ending = FormulaConfig.array['end'] + '{' + command + '}'
							πF.SetLineno(4577)
							πTemp005 = ßend.ToObject()
							if πTemp007, πE = πg.ResolveGlobal(πF, ßFormulaConfig); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßarray, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, πTemp008, πTemp005); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp006, πg.NewStr("{").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp004, µcommand); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("}").ToObject()); πE != nil {
								continue
							}
							µending = πTemp002
							// line 4578: pos.pushending(ending)
							πF.SetLineno(4578)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp001[0] = µending
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßpushending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4579: bit.parsebit(pos)
							πF.SetLineno(4579)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbit, ßparsebit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4580: self.add(bit)
							πF.SetLineno(4580)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp001[0] = µbit
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4581: self.original += pos.popending(ending)
							πF.SetLineno(4581)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoriginal, nil); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							πTemp001[0] = µending
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßpopending, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.IAdd(πF, πTemp002, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp003); πE != nil {
								continue
							}
							// line 4582: self.size = bit.size
							πF.SetLineno(4582)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbit, ßsize, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsize, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4574: "Parse the begin command"
					πF.SetLineno(4574)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse the begin command").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4584: def findbit(self, piece):
					πF.SetLineno(4584)
					πTemp007 = make([]πg.Param, 2)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp007[1] = πg.Param{Name: "piece", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("findbit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpiece *πg.Object = πArgs[1]
						_ = µpiece
						var µtype *πg.Object = πg.UnboundLocal
						_ = µtype
						var µbit *πg.Object = πg.UnboundLocal
						_ = µbit
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4585: "Find the command bit corresponding to the \\begin{piece}"
							πF.SetLineno(4585)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßBeginCommand); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtypes, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µtype = πTemp002
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp006 = πF.MakeArgs(2)
							πTemp006[0] = πg.NewStr("*").ToObject()
							πTemp006[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µpiece, "piece"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpiece, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µtype, ßpiece, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp007, πTemp003); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 4587: if piece.replace('*', '') == type.piece:
							πF.SetLineno(4587)
						Label4:
							// line 4588: return self.factory.create(type)
							πF.SetLineno(4588)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp006[0] = µtype
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πR = πTemp002
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 4589: bit = self.factory.create(EquationEnvironment)
							πF.SetLineno(4589)
							πTemp006 = πF.MakeArgs(1)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEquationEnvironment); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µbit = πTemp001
							// line 4590: bit.piece = piece
							πF.SetLineno(4590)
							if πE = πg.CheckLocal(πF, µpiece, "piece"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µpiece); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µbit, ßpiece, πTemp001); πE != nil {
								continue
							}
							// line 4591: return bit
							πF.SetLineno(4591)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πR = µbit
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfindbit.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4585: "Find the command bit corresponding to the \\begin{piece}"
					πF.SetLineno(4585)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Find the command bit corresponding to the \\begin{piece}").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßfindbit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BeginCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBeginCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4593: FormulaCommand.types += [BeginCommand]
			πF.SetLineno(4593)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßtypes, nil); πE != nil {
				continue
			}
			πTemp002 = make([]*πg.Object, 1)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßBeginCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp001
			πTemp001 = πg.NewList(πTemp002...).ToObject()
			if πTemp004, πE = πg.IAdd(πF, πTemp003, πTemp001); πE != nil {
				continue
			}
			if πTemp007, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp007, ßtypes, πTemp004); πE != nil {
				continue
			}
			// line 4597: class CombiningFunction(OneParamFunction):
			πF.SetLineno(4597)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßOneParamFunction); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("CombiningFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4599: commandmap = FormulaConfig.combiningfunctions
					πF.SetLineno(4599)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcombiningfunctions, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4601: def parsebit(self, pos):
					πF.SetLineno(4601)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µcombining *πg.Object = πg.UnboundLocal
						_ = µcombining
						var µparameter *πg.Object = πg.UnboundLocal
						_ = µparameter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4602: "Parse a combining function."
							πF.SetLineno(4602)
							// line 4603: self.type = 'alpha'
							πF.SetLineno(4603)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßalpha.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							// line 4604: combining = self.translated
							πF.SetLineno(4604)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							µcombining = πTemp001
							// line 4605: parameter = self.parsesingleparameter(pos)
							πF.SetLineno(4605)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsesingleparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µparameter = πTemp003
							if πE = πg.CheckLocal(πF, µparameter, "parameter"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µparameter); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparameter, "parameter"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µparameter, ßextracttext, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp005
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.NE(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							goto Label3
							// line 4606: if not parameter:
							πF.SetLineno(4606)
						Label1:
							// line 4607: Trace.error('Empty parameter for combining function ' + self.command)
							πF.SetLineno(4607)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcommand, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Empty parameter for combining function ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label3
							// line 4608: elif len(parameter.extracttext()) != 1:
							πF.SetLineno(4608)
						Label2:
							// line 4609: Trace.error('Applying combining function ' + self.command + ' to invalid string "' + parameter.extracttext() + '"')
							πF.SetLineno(4609)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßcommand, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Add(πF, πg.NewStr("Applying combining function ").ToObject(), πTemp007); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πTemp006, πg.NewStr(" to invalid string \"").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparameter, "parameter"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µparameter, ßextracttext, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp005, πTemp007); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewStr("\"").ToObject()); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label3
						Label3:
							// line 4610: self.contents.append(Constant(combining))
							πF.SetLineno(4610)
							πTemp002 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcombining, "combining"); πE != nil {
								continue
							}
							πTemp008[0] = µcombining
							if πTemp001, πE = πg.ResolveGlobal(πF, ßConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßappend, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4602: "Parse a combining function."
					πF.SetLineno(4602)
					// line 4602: "Parse a combining function."
					πF.SetLineno(4602)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Parse a combining function.").ToObject()); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a combining function.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 4612: def parsesingleparameter(self, pos):
					πF.SetLineno(4612)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("parsesingleparameter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µletter *πg.Object = πg.UnboundLocal
						_ = µletter
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4613: "Parse a parameter, or a single letter."
							πF.SetLineno(4613)
							// line 4614: self.factory.clearskipped(pos)
							πF.SetLineno(4614)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4615: if pos.finished():
							πF.SetLineno(4615)
						Label1:
							// line 4616: Trace.error('Error while parsing single parameter at ' + pos.identifier())
							πF.SetLineno(4616)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßidentifier, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Error while parsing single parameter at ").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4617: return None
							πF.SetLineno(4617)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							πTemp001 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßBracket); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp002 = πTemp003
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							πTemp001 = πF.MakeArgs(2)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp002 = πTemp003
						Label3:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 4618: if self.factory.detecttype(Bracket, pos) \
							πF.SetLineno(4618)
						Label4:
							// line 4620: return self.parseparameter(pos)
							πF.SetLineno(4620)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
							goto Label5
						Label5:
							// line 4621: letter = FormulaConstant(pos.skipcurrent())
							πF.SetLineno(4621)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µletter = πTemp003
							// line 4622: self.add(letter)
							πF.SetLineno(4622)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µletter, "letter"); πE != nil {
								continue
							}
							πTemp001[0] = µletter
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4623: return letter
							πF.SetLineno(4623)
							if πE = πg.CheckLocal(πF, µletter, "letter"); πE != nil {
								continue
							}
							πR = µletter
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsesingleparameter.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4613: "Parse a parameter, or a single letter."
					πF.SetLineno(4613)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse a parameter, or a single letter.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsesingleparameter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("CombiningFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßCombiningFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4625: class DecoratingFunction(OneParamFunction):
			πF.SetLineno(4625)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßOneParamFunction); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("DecoratingFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4626: "A function that decorates some bit of text"
					πF.SetLineno(4626)
					// line 4626: "A function that decorates some bit of text"
					πF.SetLineno(4626)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A function that decorates some bit of text").ToObject()); πE != nil {
						continue
					}
					// line 4628: commandmap = FormulaConfig.decoratingfunctions
					πF.SetLineno(4628)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßdecoratingfunctions, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4630: def parsebit(self, pos):
					πF.SetLineno(4630)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µsymbol *πg.Object = πg.UnboundLocal
						_ = µsymbol
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4631: "Parse a decorating function"
							πF.SetLineno(4631)
							// line 4632: self.type = 'alpha'
							πF.SetLineno(4632)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, ßalpha.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßtype, πTemp001); πE != nil {
								continue
							}
							// line 4633: symbol = self.translated
							πF.SetLineno(4633)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							µsymbol = πTemp001
							// line 4634: self.symbol = TaggedBit().constant(symbol, 'span class="symbolover"')
							πF.SetLineno(4634)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsymbol, "symbol"); πE != nil {
								continue
							}
							πTemp002[0] = µsymbol
							πTemp002[1] = πg.NewStr("span class=\"symbolover\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßconstant, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsymbol, πTemp001); πE != nil {
								continue
							}
							// line 4635: self.parameter = self.parseparameter(pos)
							πF.SetLineno(4635)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparseparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparameter, πTemp001); πE != nil {
								continue
							}
							// line 4636: self.output = TaggedOutput().settag('span class="withsymbol"')
							πF.SetLineno(4636)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("span class=\"withsymbol\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 4637: self.contents.insert(0, self.symbol)
							πF.SetLineno(4637)
							πTemp002 = πF.MakeArgs(2)
							πTemp002[0] = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsymbol, nil); πE != nil {
								continue
							}
							πTemp002[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßinsert, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 4638: self.parameter.output = TaggedOutput().settag('span class="undersymbol"')
							πF.SetLineno(4638)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("span class=\"undersymbol\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßparameter, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 4639: self.simplifyifpossible()
							πF.SetLineno(4639)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsimplifyifpossible, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4631: "Parse a decorating function"
					πF.SetLineno(4631)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a decorating function").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("DecoratingFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßDecoratingFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4641: class LimitCommand(EmptyCommand):
			πF.SetLineno(4641)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßEmptyCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LimitCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4642: "A command which accepts limits above and below, in display mode."
					πF.SetLineno(4642)
					// line 4642: "A command which accepts limits above and below, in display mode."
					πF.SetLineno(4642)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A command which accepts limits above and below, in display mode.").ToObject()); πE != nil {
						continue
					}
					// line 4644: commandmap = FormulaConfig.limitcommands
					πF.SetLineno(4644)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßlimitcommands, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4646: def parsebit(self, pos):
					πF.SetLineno(4646)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µpieces *πg.Object = πg.UnboundLocal
						_ = µpieces
						var µpiece *πg.Object = πg.UnboundLocal
						_ = µpiece
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4647: "Parse a limit command."
							πF.SetLineno(4647)
							// line 4648: pieces = BigSymbol(self.translated).getpieces()
							πF.SetLineno(4648)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßBigSymbol); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßgetpieces, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µpieces = πTemp003
							// line 4649: self.output = TaggedOutput().settag('span class="limits"')
							πF.SetLineno(4649)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("span class=\"limits\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpieces, "pieces"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µpieces); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µpiece = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 4651: self.contents.append(TaggedBit().constant(piece, 'span class="limit"'))
							πF.SetLineno(4651)
							πTemp001 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpiece, "piece"); πE != nil {
								continue
							}
							πTemp006[0] = µpiece
							πTemp006[1] = πg.NewStr("span class=\"limit\"").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp007, ßconstant, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp003.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp001[0] = πTemp007
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4647: "Parse a limit command."
					πF.SetLineno(4647)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a limit command.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LimitCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLimitCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4653: class LimitPreviousCommand(LimitCommand):
			πF.SetLineno(4653)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßLimitCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LimitPreviousCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4654: "A command to limit the previous command."
					πF.SetLineno(4654)
					// line 4654: "A command to limit the previous command."
					πF.SetLineno(4654)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A command to limit the previous command.").ToObject()); πE != nil {
						continue
					}
					// line 4656: commandmap = None
					πF.SetLineno(4656)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4658: def parsebit(self, pos):
					πF.SetLineno(4658)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4659: "Do nothing."
							πF.SetLineno(4659)
							// line 4660: self.output = TaggedOutput().settag('span class="limits"')
							πF.SetLineno(4660)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("span class=\"limits\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsettag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp002); πE != nil {
								continue
							}
							// line 4661: self.factory.clearskipped(pos)
							πF.SetLineno(4661)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4659: "Do nothing."
					πF.SetLineno(4659)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Do nothing.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4663: def __unicode__(self):
					πF.SetLineno(4663)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4664: "Return a printable representation."
							πF.SetLineno(4664)
							// line 4665: return 'Limit previous command'
							πF.SetLineno(4665)
							πR = πg.NewStr("Limit previous command").ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4664: "Return a printable representation."
					πF.SetLineno(4664)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp005 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp004, πE = πg.GE(πF, πTemp006, πTemp005); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label1
					}
					goto Label2
					// line 4667: if sys.version_info >= (3, 0):
					πF.SetLineno(4667)
				Label1:
					// line 4668: __str__ = __unicode__
					πF.SetLineno(4668)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp004); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LimitPreviousCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLimitPreviousCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4671: class LimitsProcessor(MathsProcessor):
			πF.SetLineno(4671)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßMathsProcessor); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LimitsProcessor", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4672: "A processor for limits inside an element."
					πF.SetLineno(4672)
					// line 4672: "A processor for limits inside an element."
					πF.SetLineno(4672)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A processor for limits inside an element.").ToObject()); πE != nil {
						continue
					}
					// line 4674: def process(self, contents, index):
					πF.SetLineno(4674)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4675: "Process the limits for an element."
							πF.SetLineno(4675)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsimplemath, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 4676: if Options.simplemath:
							πF.SetLineno(4676)
						Label1:
							// line 4677: return
							πF.SetLineno(4677)
							πR = πg.None
							continue
							goto Label2
						Label2:
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßchecklimits, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 4678: if self.checklimits(contents, index):
							πF.SetLineno(4678)
						Label3:
							// line 4679: self.modifylimits(contents, index)
							πF.SetLineno(4679)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmodifylimits, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label4
						Label4:
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcheckscript, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp001 = πTemp005
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label5
							}
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp004[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcheckscript, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp001 = πTemp005
						Label5:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label6
							}
							goto Label7
							// line 4680: if self.checkscript(contents, index) and self.checkscript(contents, index + 1):
							πF.SetLineno(4680)
						Label6:
							// line 4681: self.modifyscripts(contents, index)
							πF.SetLineno(4681)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmodifyscripts, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label7
						Label7:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4675: "Process the limits for an element."
					πF.SetLineno(4675)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Process the limits for an element.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4683: def checklimits(self, contents, index):
					πF.SetLineno(4683)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("checklimits", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4684: "Check if the current position has a limits command."
							πF.SetLineno(4684)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßDocumentParameters); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßdisplaymode, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4685: if not DocumentParameters.displaymode:
							πF.SetLineno(4685)
						Label1:
							// line 4686: return False
							πF.SetLineno(4686)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							πTemp005 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp005[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp005[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßLimitPreviousCommand); πE != nil {
								continue
							}
							πTemp005[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcheckcommand, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 4687: if self.checkcommand(contents, index + 1, LimitPreviousCommand):
							πF.SetLineno(4687)
						Label3:
							// line 4688: self.limitsahead(contents, index)
							πF.SetLineno(4688)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp005[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp005[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßlimitsahead, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 4689: return False
							πF.SetLineno(4689)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002 = µindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µcontents, πTemp002); πE != nil {
								continue
							}
							πTemp005[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßLimitCommand); πE != nil {
								continue
							}
							πTemp005[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 4690: if not isinstance(contents[index], LimitCommand):
							πF.SetLineno(4690)
						Label5:
							// line 4691: return False
							πF.SetLineno(4691)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label6
						Label6:
							// line 4692: return self.checkscript(contents, index + 1)
							πF.SetLineno(4692)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp005[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcheckscript, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßchecklimits.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4684: "Check if the current position has a limits command."
					πF.SetLineno(4684)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Check if the current position has a limits command.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßchecklimits); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4694: def limitsahead(self, contents, index):
					πF.SetLineno(4694)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("limitsahead", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4695: "Limit the current element based on the next."
							πF.SetLineno(4695)
							// line 4696: contents[index + 1].add(contents[index].clone())
							πF.SetLineno(4696)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002 = µindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µcontents, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßclone, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp003
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µcontents, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßadd, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4697: contents[index].output = EmptyOutput()
							πF.SetLineno(4697)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßEmptyOutput); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004 = µindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µcontents, πTemp004); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßoutput, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßlimitsahead.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4695: "Limit the current element based on the next."
					πF.SetLineno(4695)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Limit the current element based on the next.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßlimitsahead); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4699: def modifylimits(self, contents, index):
					πF.SetLineno(4699)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("modifylimits", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var µlimited *πg.Object = πg.UnboundLocal
						_ = µlimited
						var µsubscript *πg.Object = πg.UnboundLocal
						_ = µsubscript
						var µsuperscript *πg.Object = πg.UnboundLocal
						_ = µsuperscript
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4700: "Modify a limits commands so that the limits appear above and below."
							πF.SetLineno(4700)
							// line 4701: limited = contents[index]
							πF.SetLineno(4701)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001 = µindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcontents, πTemp001); πE != nil {
								continue
							}
							µlimited = πTemp002
							// line 4702: subscript = self.getlimit(contents, index + 1)
							πF.SetLineno(4702)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp003[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetlimit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µsubscript = πTemp002
							// line 4703: limited.contents.append(subscript)
							πF.SetLineno(4703)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsubscript, "subscript"); πE != nil {
								continue
							}
							πTemp003[0] = µsubscript
							if πE = πg.CheckLocal(πF, µlimited, "limited"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlimited, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßappend, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp003[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcheckscript, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4704: if self.checkscript(contents, index + 1):
							πF.SetLineno(4704)
						Label1:
							// line 4705: superscript = self.getlimit(contents, index  + 1)
							πF.SetLineno(4705)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp003[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgetlimit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µsuperscript = πTemp002
							goto Label3
						Label2:
							// line 4707: superscript = TaggedBit().constant(u' ', 'sup class="limit"')
							πF.SetLineno(4707)
							πTemp003 = πF.MakeArgs(2)
							πTemp003[0] = πg.NewUnicode("\xe2\x81\x9f").ToObject()
							πTemp003[1] = πg.NewStr("sup class=\"limit\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßconstant, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µsuperscript = πTemp002
							goto Label3
						Label3:
							// line 4708: limited.contents.insert(0, superscript)
							πF.SetLineno(4708)
							πTemp003 = πF.MakeArgs(2)
							πTemp003[0] = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µsuperscript, "superscript"); πE != nil {
								continue
							}
							πTemp003[1] = µsuperscript
							if πE = πg.CheckLocal(πF, µlimited, "limited"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µlimited, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinsert, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßmodifylimits.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4700: "Modify a limits commands so that the limits appear above and below."
					πF.SetLineno(4700)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Modify a limits commands so that the limits appear above and below.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßmodifylimits); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 4710: def getlimit(self, contents, index):
					πF.SetLineno(4710)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("getlimit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var µlimit *πg.Object = πg.UnboundLocal
						_ = µlimit
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4711: "Get the limit for a limits command."
							πF.SetLineno(4711)
							// line 4712: limit = self.getscript(contents, index)
							πF.SetLineno(4712)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp001[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetscript, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µlimit = πTemp003
							// line 4713: limit.output.tag = limit.output.tag.replace('script', 'limit')
							πF.SetLineno(4713)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = ßscript.ToObject()
							πTemp001[1] = ßlimit.ToObject()
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µlimit, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtag, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µlimit, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßtag, πTemp002); πE != nil {
								continue
							}
							// line 4714: return limit
							πF.SetLineno(4714)
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							πR = µlimit
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetlimit.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 4711: "Get the limit for a limits command."
					πF.SetLineno(4711)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Get the limit for a limits command.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßgetlimit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 4716: def modifyscripts(self, contents, index):
					πF.SetLineno(4716)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("modifyscripts", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var µsubscript *πg.Object = πg.UnboundLocal
						_ = µsubscript
						var µsuperscript *πg.Object = πg.UnboundLocal
						_ = µsuperscript
						var µscripts *πg.Object = πg.UnboundLocal
						_ = µscripts
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4717: "Modify the super- and subscript to appear vertically aligned."
							πF.SetLineno(4717)
							// line 4718: subscript = self.getscript(contents, index)
							πF.SetLineno(4718)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp001[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetscript, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µsubscript = πTemp003
							// line 4720: superscript = self.getscript(contents, index)
							πF.SetLineno(4720)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp001[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetscript, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µsuperscript = πTemp003
							// line 4721: scripts = TaggedBit().complete([superscript, subscript], 'span class="scripts"')
							πF.SetLineno(4721)
							πTemp001 = πF.MakeArgs(2)
							πTemp004 = make([]*πg.Object, 2)
							if πE = πg.CheckLocal(πF, µsuperscript, "superscript"); πE != nil {
								continue
							}
							πTemp004[0] = µsuperscript
							if πE = πg.CheckLocal(πF, µsubscript, "subscript"); πE != nil {
								continue
							}
							πTemp004[1] = µsubscript
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							πTemp001[0] = πTemp002
							πTemp001[1] = πg.NewStr("span class=\"scripts\"").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µscripts = πTemp003
							// line 4722: contents.insert(index, scripts)
							πF.SetLineno(4722)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[0] = µindex
							if πE = πg.CheckLocal(πF, µscripts, "scripts"); πE != nil {
								continue
							}
							πTemp001[1] = µscripts
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontents, ßinsert, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßmodifyscripts.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 4717: "Modify the super- and subscript to appear vertically aligned."
					πF.SetLineno(4717)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Modify the super- and subscript to appear vertically aligned.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßmodifyscripts); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 4724: def checkscript(self, contents, index):
					πF.SetLineno(4724)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("checkscript", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4725: "Check if the current element is a sub- or superscript."
							πF.SetLineno(4725)
							// line 4726: return self.checkcommand(contents, index, SymbolFunction)
							πF.SetLineno(4726)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp001[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[1] = µindex
							if πTemp002, πE = πg.ResolveGlobal(πF, ßSymbolFunction); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcheckcommand, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckscript.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 4725: "Check if the current element is a sub- or superscript."
					πF.SetLineno(4725)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Check if the current element is a sub- or superscript.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßcheckscript); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 4728: def checkcommand(self, contents, index, type):
					πF.SetLineno(4728)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp002[3] = πg.Param{Name: "type", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("checkcommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var µtype *πg.Object = πArgs[3]
						_ = µtype
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4729: "Check for the given type as the current element."
							πF.SetLineno(4729)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp002[0] = µcontents
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.LE(πF, πTemp004, µindex); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4730: if len(contents) <= index:
							πF.SetLineno(4730)
						Label1:
							// line 4731: return False
							πF.SetLineno(4731)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 4732: return isinstance(contents[index], type)
							πF.SetLineno(4732)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001 = µindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µcontents, πTemp001); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µtype, "type"); πE != nil {
								continue
							}
							πTemp002[1] = µtype
							if πTemp001, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckcommand.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 4729: "Check for the given type as the current element."
					πF.SetLineno(4729)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Check for the given type as the current element.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßcheckcommand); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 4734: def getscript(self, contents, index):
					πF.SetLineno(4734)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("getscript", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var µbit *πg.Object = πg.UnboundLocal
						_ = µbit
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4735: "Get the sub- or superscript."
							πF.SetLineno(4735)
							// line 4736: bit = contents[index]
							πF.SetLineno(4736)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001 = µindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcontents, πTemp001); πE != nil {
								continue
							}
							µbit = πTemp002
							// line 4737: bit.output.tag += ' class="script"'
							πF.SetLineno(4737)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µbit, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtag, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, πTemp002, πg.NewStr(" class=\"script\"").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µbit, ßoutput, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßtag, πTemp001); πE != nil {
								continue
							}
							// line 4738: del contents[index]
							πF.SetLineno(4738)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001 = µindex
							if πE = πg.DelItem(πF, µcontents, πTemp001); πE != nil {
								continue
							}
							// line 4739: return bit
							πF.SetLineno(4739)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πR = µbit
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetscript.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 4735: "Get the sub- or superscript."
					πF.SetLineno(4735)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp011}, πg.NewStr("Get the sub- or superscript.").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßgetscript); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp011); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LimitsProcessor").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLimitsProcessor.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4741: class BracketCommand(OneParamFunction):
			πF.SetLineno(4741)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßOneParamFunction); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BracketCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4742: "A command which defines a bracket."
					πF.SetLineno(4742)
					// line 4742: "A command which defines a bracket."
					πF.SetLineno(4742)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A command which defines a bracket.").ToObject()); πE != nil {
						continue
					}
					// line 4744: commandmap = FormulaConfig.bracketcommands
					πF.SetLineno(4744)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßbracketcommands, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4746: def parsebit(self, pos):
					πF.SetLineno(4746)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4747: "Parse the bracket."
							πF.SetLineno(4747)
							// line 4748: OneParamFunction.parsebit(self, pos)
							πF.SetLineno(4748)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOneParamFunction); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparsebit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4747: "Parse the bracket."
					πF.SetLineno(4747)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse the bracket.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 4750: def create(self, direction, character):
					πF.SetLineno(4750)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "direction", Def: nil}
					πTemp003[2] = πg.Param{Name: "character", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("create", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µdirection *πg.Object = πArgs[1]
						_ = µdirection
						var µcharacter *πg.Object = πArgs[2]
						_ = µcharacter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4751: "Create the bracket for the given character."
							πF.SetLineno(4751)
							// line 4752: self.original = character
							πF.SetLineno(4752)
							if πE = πg.CheckLocal(πF, µcharacter, "character"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µcharacter); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp001); πE != nil {
								continue
							}
							// line 4753: self.command = '\\' + direction
							πF.SetLineno(4753)
							if πE = πg.CheckLocal(πF, µdirection, "direction"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("\\").ToObject(), µdirection); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcommand, πTemp002); πE != nil {
								continue
							}
							// line 4754: self.contents = [FormulaConstant(character)]
							πF.SetLineno(4754)
							πTemp003 = make([]*πg.Object, 1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcharacter, "character"); πE != nil {
								continue
							}
							πTemp004[0] = µcharacter
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp002
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp002); πE != nil {
								continue
							}
							// line 4755: return self
							πF.SetLineno(4755)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcreate.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4751: "Create the bracket for the given character."
					πF.SetLineno(4751)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Create the bracket for the given character.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßcreate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BracketCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBracketCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4757: class BracketProcessor(MathsProcessor):
			πF.SetLineno(4757)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßMathsProcessor); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BracketProcessor", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4758: "A processor for bracket commands."
					πF.SetLineno(4758)
					// line 4758: "A processor for bracket commands."
					πF.SetLineno(4758)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A processor for bracket commands.").ToObject()); πE != nil {
						continue
					}
					// line 4760: def process(self, contents, index):
					πF.SetLineno(4760)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("process", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4761: "Convert the bracket using Unicode pieces, if possible."
							πF.SetLineno(4761)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsimplemath, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 4762: if Options.simplemath:
							πF.SetLineno(4762)
						Label1:
							// line 4763: return
							πF.SetLineno(4763)
							πR = πg.None
							continue
							goto Label2
						Label2:
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcheckleft, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 4764: if self.checkleft(contents, index):
							πF.SetLineno(4764)
						Label3:
							// line 4765: return self.processleft(contents, index)
							πF.SetLineno(4765)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßprocessleft, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πR = πTemp002
							continue
							goto Label4
						Label4:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocess.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4761: "Convert the bracket using Unicode pieces, if possible."
					πF.SetLineno(4761)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Convert the bracket using Unicode pieces, if possible.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßprocess); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4767: def processleft(self, contents, index):
					πF.SetLineno(4767)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("processleft", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var µrightindex *πg.Object = πg.UnboundLocal
						_ = µrightindex
						var µsize *πg.Object = πg.UnboundLocal
						_ = µsize
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4768: "Process a left bracket."
							πF.SetLineno(4768)
							// line 4769: rightindex = self.findright(contents, index + 1)
							πF.SetLineno(4769)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp001[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfindright, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrightindex = πTemp003
							if πE = πg.CheckLocal(πF, µrightindex, "rightindex"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µrightindex); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4770: if not rightindex:
							πF.SetLineno(4770)
						Label1:
							// line 4771: return
							πF.SetLineno(4771)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 4772: size = self.findmax(contents, index, rightindex)
							πF.SetLineno(4772)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp001[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[1] = µindex
							if πE = πg.CheckLocal(πF, µrightindex, "rightindex"); πE != nil {
								continue
							}
							πTemp001[2] = µrightindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfindmax, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µsize = πTemp003
							// line 4773: self.resize(contents[index], size)
							πF.SetLineno(4773)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002 = µindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µcontents, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
								continue
							}
							πTemp001[1] = µsize
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßresize, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 4774: self.resize(contents[rightindex], size)
							πF.SetLineno(4774)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrightindex, "rightindex"); πE != nil {
								continue
							}
							πTemp002 = µrightindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µcontents, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
								continue
							}
							πTemp001[1] = µsize
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßresize, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßprocessleft.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4768: "Process a left bracket."
					πF.SetLineno(4768)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Process a left bracket.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßprocessleft); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4776: def checkleft(self, contents, index):
					πF.SetLineno(4776)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("checkleft", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4777: "Check if the command at the given index is left."
							πF.SetLineno(4777)
							// line 4778: return self.checkdirection(contents[index], '\\left')
							πF.SetLineno(4778)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002 = µindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µcontents, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							πTemp001[1] = πg.NewStr("\\left").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcheckdirection, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckleft.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4777: "Check if the command at the given index is left."
					πF.SetLineno(4777)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Check if the command at the given index is left.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßcheckleft); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4780: def checkright(self, contents, index):
					πF.SetLineno(4780)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("checkright", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4781: "Check if the command at the given index is right."
							πF.SetLineno(4781)
							// line 4782: return self.checkdirection(contents[index], '\\right')
							πF.SetLineno(4782)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp002 = µindex
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µcontents, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							πTemp001[1] = πg.NewStr("\\right").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcheckdirection, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckright.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4781: "Check if the command at the given index is right."
					πF.SetLineno(4781)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Check if the command at the given index is right.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßcheckright); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 4784: def checkdirection(self, bit, command):
					πF.SetLineno(4784)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "bit", Def: nil}
					πTemp002[2] = πg.Param{Name: "command", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("checkdirection", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbit *πg.Object = πArgs[1]
						_ = µbit
						var µcommand *πg.Object = πArgs[2]
						_ = µcommand
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4785: "Check if the given bit is the desired bracket command."
							πF.SetLineno(4785)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							πTemp002[0] = µbit
							if πTemp003, πE = πg.ResolveGlobal(πF, ßBracketCommand); πE != nil {
								continue
							}
							πTemp002[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 4786: if not isinstance(bit, BracketCommand):
							πF.SetLineno(4786)
						Label1:
							// line 4787: return False
							πF.SetLineno(4787)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 4788: return bit.command == command
							πF.SetLineno(4788)
							if πE = πg.CheckLocal(πF, µbit, "bit"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µbit, ßcommand, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, µcommand); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheckdirection.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 4785: "Check if the given bit is the desired bracket command."
					πF.SetLineno(4785)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Check if the given bit is the desired bracket command.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßcheckdirection); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 4790: def findright(self, contents, index):
					πF.SetLineno(4790)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "index", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("findright", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µindex *πg.Object = πArgs[2]
						_ = µindex
						var µdepth *πg.Object = πg.UnboundLocal
						_ = µdepth
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4791: "Find the right bracket starting at the given index, or 0."
							πF.SetLineno(4791)
							// line 4792: depth = 1
							πF.SetLineno(4792)
							µdepth = πg.NewInt(1).ToObject()
							// line 4793: while index < len(contents):
							πF.SetLineno(4793)
							πF.PushCheckpoint(2)
							πTemp001 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp001 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp003, πE = πg.LT(πF, µindex, πTemp006); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πE != nil || !πTemp002 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcheckleft, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 4794: if self.checkleft(contents, index):
							πF.SetLineno(4794)
						Label4:
							// line 4795: depth += 1
							πF.SetLineno(4795)
							if πE = πg.CheckLocal(πF, µdepth, "depth"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µdepth, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µdepth = πTemp003
							goto Label5
						Label5:
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp004[0] = µcontents
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004[1] = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcheckright, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label6
							}
							goto Label7
							// line 4796: if self.checkright(contents, index):
							πF.SetLineno(4796)
						Label6:
							// line 4797: depth -= 1
							πF.SetLineno(4797)
							if πE = πg.CheckLocal(πF, µdepth, "depth"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ISub(πF, µdepth, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µdepth = πTemp003
							goto Label7
						Label7:
							if πE = πg.CheckLocal(πF, µdepth, "depth"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, µdepth, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label8
							}
							goto Label9
							// line 4798: if depth == 0:
							πF.SetLineno(4798)
						Label8:
							// line 4799: return index
							πF.SetLineno(4799)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πR = µindex
							continue
							goto Label9
						Label9:
							// line 4800: index += 1
							πF.SetLineno(4800)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µindex = πTemp003
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 4801: return None
							πF.SetLineno(4801)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfindright.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 4791: "Find the right bracket starting at the given index, or 0."
					πF.SetLineno(4791)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Find the right bracket starting at the given index, or 0.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßfindright); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 4803: def findmax(self, contents, leftindex, rightindex):
					πF.SetLineno(4803)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "contents", Def: nil}
					πTemp002[2] = πg.Param{Name: "leftindex", Def: nil}
					πTemp002[3] = πg.Param{Name: "rightindex", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("findmax", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontents *πg.Object = πArgs[1]
						_ = µcontents
						var µleftindex *πg.Object = πArgs[2]
						_ = µleftindex
						var µrightindex *πg.Object = πArgs[3]
						_ = µrightindex
						var µsliced *πg.Object = πg.UnboundLocal
						_ = µsliced
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []πg.Param
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4804: "Find the max size of the contents between the two given indices."
							πF.SetLineno(4804)
							// line 4805: sliced = contents[leftindex:rightindex]
							πF.SetLineno(4805)
							if πE = πg.CheckLocal(πF, µleftindex, "leftindex"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrightindex, "rightindex"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µleftindex, µrightindex, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcontents, πTemp001); πE != nil {
								continue
							}
							µsliced = πTemp002
							// line 4806: return max([element.size for element in sliced])
							πF.SetLineno(4806)
							πTemp003 = πF.MakeArgs(1)
							πTemp004 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µelement *πg.Object = πg.UnboundLocal
								_ = µelement
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µsliced, "sliced"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µsliced); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µelement = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 4806: return max([element.size for element in sliced])
										πF.SetLineno(4806)
										if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GetAttr(πF, µelement, ßsize, nil); πE != nil {
											continue
										}
										πF.PushCheckpoint(4)
										return πTemp004, nil
									Label4:
										πTemp005 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßmax); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πR = πTemp005
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfindmax.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 4804: "Find the max size of the contents between the two given indices."
					πF.SetLineno(4804)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Find the max size of the contents between the two given indices.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßfindmax); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 4808: def resize(self, command, size):
					πF.SetLineno(4808)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "command", Def: nil}
					πTemp002[2] = πg.Param{Name: "size", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("resize", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcommand *πg.Object = πArgs[1]
						_ = µcommand
						var µsize *πg.Object = πArgs[2]
						_ = µsize
						var µcharacter *πg.Object = πg.UnboundLocal
						_ = µcharacter
						var µalignment *πg.Object = πg.UnboundLocal
						_ = µalignment
						var µbracket *πg.Object = πg.UnboundLocal
						_ = µbracket
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4809: "Resize a bracket command to the given size."
							πF.SetLineno(4809)
							// line 4810: character = command.extracttext()
							πF.SetLineno(4810)
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcommand, ßextracttext, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µcharacter = πTemp002
							// line 4811: alignment = command.command.replace('\\', '')
							πF.SetLineno(4811)
							πTemp003 = πF.MakeArgs(2)
							πTemp003[0] = πg.NewStr("\\").ToObject()
							πTemp003[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcommand, ßcommand, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µalignment = πTemp001
							// line 4812: bracket = BigBracket(size, character, alignment)
							πF.SetLineno(4812)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
								continue
							}
							πTemp003[0] = µsize
							if πE = πg.CheckLocal(πF, µcharacter, "character"); πE != nil {
								continue
							}
							πTemp003[1] = µcharacter
							if πE = πg.CheckLocal(πF, µalignment, "alignment"); πE != nil {
								continue
							}
							πTemp003[2] = µalignment
							if πTemp001, πE = πg.ResolveGlobal(πF, ßBigBracket); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µbracket = πTemp002
							// line 4813: command.output = ContentsOutput()
							πF.SetLineno(4813)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßContentsOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µcommand, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 4814: command.contents = bracket.getcontents()
							πF.SetLineno(4814)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µbracket, ßgetcontents, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcommand, "command"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µcommand, ßcontents, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßresize.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 4809: "Resize a bracket command to the given size."
					πF.SetLineno(4809)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Resize a bracket command to the given size.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßresize); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("BracketProcessor").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBracketProcessor.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4816: class TodayCommand(EmptyCommand):
			πF.SetLineno(4816)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßEmptyCommand); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("TodayCommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4817: "Shows today's date."
					πF.SetLineno(4817)
					// line 4817: "Shows today's date."
					πF.SetLineno(4817)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Shows today's date.").ToObject()); πE != nil {
						continue
					}
					// line 4819: commandmap = None
					πF.SetLineno(4819)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4821: def parsebit(self, pos):
					πF.SetLineno(4821)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4822: "Parse a command without parameters"
							πF.SetLineno(4822)
							// line 4823: self.output = FixedOutput()
							πF.SetLineno(4823)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFixedOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 4824: self.html = [datetime.date.today().strftime('%b %d, %Y')]
							πF.SetLineno(4824)
							πTemp003 = make([]*πg.Object, 1)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("%b %d, %Y").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßdatetime); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßdate, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßtoday, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrftime, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp002
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßhtml, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4822: "Parse a command without parameters"
					πF.SetLineno(4822)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse a command without parameters").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("TodayCommand").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßTodayCommand.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4827: FormulaCommand.types += [
			πF.SetLineno(4827)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßtypes, nil); πE != nil {
				continue
			}
			πTemp002 = make([]*πg.Object, 4)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßDecoratingFunction); πE != nil {
				continue
			}
			πTemp002[0] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßCombiningFunction); πE != nil {
				continue
			}
			πTemp002[1] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßLimitCommand); πE != nil {
				continue
			}
			πTemp002[2] = πTemp001
			if πTemp001, πE = πg.ResolveGlobal(πF, ßBracketCommand); πE != nil {
				continue
			}
			πTemp002[3] = πTemp001
			πTemp001 = πg.NewList(πTemp002...).ToObject()
			if πTemp004, πE = πg.IAdd(πF, πTemp003, πTemp001); πE != nil {
				continue
			}
			if πTemp007, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp007, ßtypes, πTemp004); πE != nil {
				continue
			}
			// line 4831: FormulaProcessor.processors += [
			πF.SetLineno(4831)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaProcessor); πE != nil {
				continue
			}
			if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßprocessors, nil); πE != nil {
				continue
			}
			πTemp002 = make([]*πg.Object, 2)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßLimitsProcessor); πE != nil {
				continue
			}
			if πTemp004, πE = πTemp001.Call(πF, nil, nil); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			if πTemp001, πE = πg.ResolveGlobal(πF, ßBracketProcessor); πE != nil {
				continue
			}
			if πTemp004, πE = πTemp001.Call(πF, nil, nil); πE != nil {
				continue
			}
			πTemp002[1] = πTemp004
			πTemp001 = πg.NewList(πTemp002...).ToObject()
			if πTemp004, πE = πg.IAdd(πF, πTemp003, πTemp001); πE != nil {
				continue
			}
			if πTemp007, πE = πg.ResolveGlobal(πF, ßFormulaProcessor); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp007, ßprocessors, πTemp004); πE != nil {
				continue
			}
			// line 4837: class ParameterDefinition(object):
			πF.SetLineno(4837)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ParameterDefinition", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 bool
				_ = πTemp010
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4838: "The definition of a parameter in a hybrid function."
					πF.SetLineno(4838)
					// line 4838: "The definition of a parameter in a hybrid function."
					πF.SetLineno(4838)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("The definition of a parameter in a hybrid function.").ToObject()); πE != nil {
						continue
					}
					// line 4839: "[] parameters are optional, {} parameters are mandatory."
					πF.SetLineno(4839)
					// line 4840: "Each parameter has a one-character name, like {$1} or {$p}."
					πF.SetLineno(4840)
					// line 4841: "A parameter that ends in ! like {$p!} is a literal."
					πF.SetLineno(4841)
					// line 4842: "Example: [$1]{$p!} reads an optional parameter $1 and a literal mandatory parameter p."
					πF.SetLineno(4842)
					// line 4844: parambrackets = [('[', ']'), ('{', '}')]
					πF.SetLineno(4844)
					πTemp001 = make([]*πg.Object, 2)
					πTemp002 = πg.NewTuple2(πg.NewStr("[").ToObject(), πg.NewStr("]").ToObject()).ToObject()
					πTemp001[0] = πTemp002
					πTemp002 = πg.NewTuple2(πg.NewStr("{").ToObject(), πg.NewStr("}").ToObject()).ToObject()
					πTemp001[1] = πTemp002
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πE = πClass.SetItem(πF, ßparambrackets.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4846: def __init__(self):
					πF.SetLineno(4846)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4847: self.name = None
							πF.SetLineno(4847)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßname, πTemp002); πE != nil {
								continue
							}
							// line 4848: self.literal = False
							πF.SetLineno(4848)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßliteral, πTemp002); πE != nil {
								continue
							}
							// line 4849: self.optional = False
							πF.SetLineno(4849)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoptional, πTemp002); πE != nil {
								continue
							}
							// line 4850: self.value = None
							πF.SetLineno(4850)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalue, πTemp002); πE != nil {
								continue
							}
							// line 4851: self.literalvalue = None
							πF.SetLineno(4851)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßliteralvalue, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4853: def parse(self, pos):
					πF.SetLineno(4853)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µopening *πg.Object = πg.UnboundLocal
						_ = µopening
						var µclosing *πg.Object = πg.UnboundLocal
						_ = µclosing
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4854: "Parse a parameter definition: [$0], {$x}, {$1!}..."
							πF.SetLineno(4854)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßParameterDefinition); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparambrackets, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp006}}}, πTemp002); πE != nil {
									continue
								}
								µopening = πTemp003
								µclosing = πTemp006
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µopening, "opening"); πE != nil {
								continue
							}
							πTemp007[0] = µopening
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 4856: if pos.checkskip(opening):
							πF.SetLineno(4856)
						Label4:
							if πE = πg.CheckLocal(πF, µopening, "opening"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µopening, πg.NewStr("[").ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							goto Label7
							// line 4857: if opening == '[':
							πF.SetLineno(4857)
						Label6:
							// line 4858: self.optional = True
							πF.SetLineno(4858)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoptional, πTemp003); πE != nil {
								continue
							}
							goto Label7
						Label7:
							πTemp007 = πF.MakeArgs(1)
							πTemp007[0] = πg.NewStr("$").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp005, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label8
							}
							goto Label9
							// line 4859: if not pos.checkskip('$'):
							πF.SetLineno(4859)
						Label8:
							// line 4860: Trace.error('Wrong parameter name, did you mean $' + pos.current() + '?')
							πF.SetLineno(4860)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Wrong parameter name, did you mean $").ToObject(), πTemp008); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("?").ToObject()); πE != nil {
								continue
							}
							πTemp007[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 4861: return None
							πF.SetLineno(4861)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label9
						Label9:
							// line 4862: self.name = pos.skipcurrent()
							πF.SetLineno(4862)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßname, πTemp002); πE != nil {
								continue
							}
							πTemp007 = πF.MakeArgs(1)
							πTemp007[0] = πg.NewStr("!").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label10
							}
							goto Label11
							// line 4863: if pos.checkskip('!'):
							πF.SetLineno(4863)
						Label10:
							// line 4864: self.literal = True
							πF.SetLineno(4864)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßliteral, πTemp003); πE != nil {
								continue
							}
							goto Label11
						Label11:
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µclosing, "closing"); πE != nil {
								continue
							}
							πTemp007[0] = µclosing
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp005, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label12
							}
							goto Label13
							// line 4865: if not pos.checkskip(closing):
							πF.SetLineno(4865)
						Label12:
							// line 4866: Trace.error('Wrong parameter closing ' + pos.skipcurrent())
							πF.SetLineno(4866)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Wrong parameter closing ").ToObject(), πTemp006); πE != nil {
								continue
							}
							πTemp007[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 4867: return None
							πF.SetLineno(4867)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label13
						Label13:
							// line 4868: return self
							πF.SetLineno(4868)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 4869: Trace.error('Wrong character in parameter template: ' + pos.skipcurrent())
							πF.SetLineno(4869)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Wrong character in parameter template: ").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 4870: return None
							πF.SetLineno(4870)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4854: "Parse a parameter definition: [$0], {$x}, {$1!}..."
					πF.SetLineno(4854)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse a parameter definition: [$0], {$x}, {$1!}...").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4872: def read(self, pos, function):
					πF.SetLineno(4872)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003[2] = πg.Param{Name: "function", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("read", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µfunction *πg.Object = πArgs[2]
						_ = µfunction
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4873: "Read the parameter itself using the definition."
							πF.SetLineno(4873)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßliteral, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoptional, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 4874: if self.literal:
							πF.SetLineno(4874)
						Label1:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoptional, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label5
							}
							goto Label6
							// line 4875: if self.optional:
							πF.SetLineno(4875)
						Label5:
							// line 4876: self.literalvalue = function.parsesquareliteral(pos)
							πF.SetLineno(4876)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp003[0] = µpos
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µfunction, ßparsesquareliteral, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßliteralvalue, πTemp001); πE != nil {
								continue
							}
							goto Label7
						Label6:
							// line 4878: self.literalvalue = function.parseliteral(pos)
							πF.SetLineno(4878)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp003[0] = µpos
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µfunction, ßparseliteral, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßliteralvalue, πTemp001); πE != nil {
								continue
							}
							goto Label7
						Label7:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßliteralvalue, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label8
							}
							goto Label9
							// line 4879: if self.literalvalue:
							πF.SetLineno(4879)
						Label8:
							// line 4880: self.value = FormulaConstant(self.literalvalue)
							πF.SetLineno(4880)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßliteralvalue, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalue, πTemp001); πE != nil {
								continue
							}
							goto Label9
						Label9:
							goto Label4
							// line 4881: elif self.optional:
							πF.SetLineno(4881)
						Label2:
							// line 4882: self.value = function.parsesquare(pos)
							πF.SetLineno(4882)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp003[0] = µpos
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µfunction, ßparsesquare, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalue, πTemp001); πE != nil {
								continue
							}
							goto Label4
						Label3:
							// line 4884: self.value = function.parseparameter(pos)
							πF.SetLineno(4884)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp003[0] = µpos
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µfunction, ßparseparameter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalue, πTemp001); πE != nil {
								continue
							}
							goto Label4
						Label4:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßread.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4873: "Read the parameter itself using the definition."
					πF.SetLineno(4873)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Read the parameter itself using the definition.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßread); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 4886: def __unicode__(self):
					πF.SetLineno(4886)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4887: "Return a printable representation."
							πF.SetLineno(4887)
							// line 4888: result = 'param ' + self.name
							πF.SetLineno(4888)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßname, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("param ").ToObject(), πTemp002); πE != nil {
								continue
							}
							µresult = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 4889: if self.value:
							πF.SetLineno(4889)
						Label1:
							// line 4890: result += ': ' + unicode(self.value)
							πF.SetLineno(4890)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßvalue, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Add(πF, πg.NewStr(": ").ToObject(), πTemp005); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µresult, πTemp001); πE != nil {
								continue
							}
							µresult = πTemp002
							goto Label3
						Label2:
							// line 4892: result += ' (empty)'
							πF.SetLineno(4892)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µresult, πg.NewStr(" (empty)").ToObject()); πE != nil {
								continue
							}
							µresult = πTemp001
							goto Label3
						Label3:
							// line 4893: return result
							πF.SetLineno(4893)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 4887: "Return a printable representation."
					πF.SetLineno(4887)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp009, πE = πg.GetAttr(πF, πTemp008, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp008 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp007, πE = πg.GE(πF, πTemp009, πTemp008); πE != nil {
						continue
					}
					if πTemp010, πE = πg.IsTrue(πF, πTemp007); πE != nil {
						continue
					}
					if πTemp010 {
						goto Label1
					}
					goto Label2
					// line 4895: if sys.version_info >= (3, 0):
					πF.SetLineno(4895)
				Label1:
					// line 4896: __str__ = __unicode__
					πF.SetLineno(4896)
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp007); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ParameterDefinition").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßParameterDefinition.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4899: class ParameterFunction(CommandBit):
			πF.SetLineno(4899)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ParameterFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4900: "A function with a variable number of parameters defined in a template."
					πF.SetLineno(4900)
					// line 4900: "A function with a variable number of parameters defined in a template."
					πF.SetLineno(4900)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A function with a variable number of parameters defined in a template.").ToObject()); πE != nil {
						continue
					}
					// line 4901: "The parameters are defined as a parameter definition."
					πF.SetLineno(4901)
					// line 4903: def readparams(self, readtemplate, pos):
					πF.SetLineno(4903)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "readtemplate", Def: nil}
					πTemp002[2] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("readparams", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreadtemplate *πg.Object = πArgs[1]
						_ = µreadtemplate
						var µpos *πg.Object = πArgs[2]
						_ = µpos
						var µparamdef *πg.Object = πg.UnboundLocal
						_ = µparamdef
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4904: "Read the params according to the template."
							πF.SetLineno(4904)
							// line 4905: self.params = dict()
							πF.SetLineno(4905)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparams, πTemp001); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreadtemplate, "readtemplate"); πE != nil {
								continue
							}
							πTemp003[0] = µreadtemplate
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparamdefs, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µparamdef = πTemp002
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 4907: paramdef.read(pos, self)
							πF.SetLineno(4907)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp003[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[1] = µself
							if πE = πg.CheckLocal(πF, µparamdef, "paramdef"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparamdef, ßread, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 4908: self.params['$' + paramdef.name] = paramdef
							πF.SetLineno(4908)
							if πE = πg.CheckLocal(πF, µparamdef, "paramdef"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µparamdef); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßparams, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparamdef, "paramdef"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, µparamdef, ßname, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Add(πF, πg.NewStr("$").ToObject(), πTemp009); πE != nil {
								continue
							}
							πTemp007 = πTemp008
							if πE = πg.SetItem(πF, πTemp004, πTemp007, πTemp002); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreadparams.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4904: "Read the params according to the template."
					πF.SetLineno(4904)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Read the params according to the template.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßreadparams); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 4910: def paramdefs(self, readtemplate):
					πF.SetLineno(4910)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "readtemplate", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("paramdefs", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreadtemplate *πg.Object = πArgs[1]
						_ = µreadtemplate
						var µpos *πg.Object = πg.UnboundLocal
						_ = µpos
						var µparamdef *πg.Object = πg.UnboundLocal
						_ = µparamdef
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1:
									goto Label1
								case 2:
									goto Label2
								case 6:
									goto Label6
								default:
									panic("unexpected function state")
								}
								// line 4911: "Read each param definition in the template"
								πF.SetLineno(4911)
								// line 4912: pos = TextPosition(readtemplate)
								πF.SetLineno(4912)
								πTemp001 = πF.MakeArgs(1)
								if πE = πg.CheckLocal(πF, µreadtemplate, "readtemplate"); πE != nil {
									continue
								}
								πTemp001[0] = µreadtemplate
								if πTemp002, πE = πg.ResolveGlobal(πF, ßTextPosition); πE != nil {
									continue
								}
								if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp001)
								µpos = πTemp003
								// line 4913: while not pos.finished():
								πF.SetLineno(4913)
								πF.PushCheckpoint(2)
								πTemp004 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp004 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
									continue
								}
								if πTemp003, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
									continue
								}
								if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
									continue
								}
								if πTemp007, πE = πg.IsTrue(πF, πTemp006); πE != nil {
									continue
								}
								πTemp002 = πg.GetBool(!πTemp007).ToObject()
								if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
									continue
								}
								if πE != nil || !πTemp005 {
									continue
								}
								πF.PushCheckpoint(1)
								// line 4914: paramdef = ParameterDefinition().parse(pos)
								πF.SetLineno(4914)
								πTemp001 = πF.MakeArgs(1)
								if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
									continue
								}
								πTemp001[0] = µpos
								if πTemp002, πE = πg.ResolveGlobal(πF, ßParameterDefinition); πE != nil {
									continue
								}
								if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
									continue
								}
								if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßparse, nil); πE != nil {
									continue
								}
								if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
									continue
								}
								πF.FreeArgs(πTemp001)
								µparamdef = πTemp003
								if πE = πg.CheckLocal(πF, µparamdef, "paramdef"); πE != nil {
									continue
								}
								if πTemp005, πE = πg.IsTrue(πF, µparamdef); πE != nil {
									continue
								}
								if πTemp005 {
									goto Label4
								}
								goto Label5
								// line 4915: if paramdef:
								πF.SetLineno(4915)
							Label4:
								// line 4916: yield paramdef
								πF.SetLineno(4916)
								if πE = πg.CheckLocal(πF, µparamdef, "paramdef"); πE != nil {
									continue
								}
								πF.PushCheckpoint(6)
								return µparamdef, nil
							Label6:
								πTemp002 = πSent
								goto Label5
							Label5:
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparamdefs.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 4911: "Read each param definition in the template"
					πF.SetLineno(4911)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Read each param definition in the template").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparamdefs); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4918: def getparam(self, name):
					πF.SetLineno(4918)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "name", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("getparam", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µname *πg.Object = πArgs[1]
						_ = µname
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4919: "Get a parameter as parsed."
							πF.SetLineno(4919)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparams, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp003, µname); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4920: if not name in self.params:
							πF.SetLineno(4920)
						Label1:
							// line 4921: return None
							πF.SetLineno(4921)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 4922: return self.params[name]
							πF.SetLineno(4922)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001 = µname
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparams, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetparam.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4919: "Get a parameter as parsed."
					πF.SetLineno(4919)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Get a parameter as parsed.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßgetparam); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4924: def getvalue(self, name):
					πF.SetLineno(4924)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "name", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("getvalue", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µname *πg.Object = πArgs[1]
						_ = µname
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4925: "Get the value of a parameter."
							πF.SetLineno(4925)
							// line 4926: return self.getparam(name).value
							πF.SetLineno(4926)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[0] = µname
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetparam, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßvalue, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetvalue.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4925: "Get the value of a parameter."
					πF.SetLineno(4925)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Get the value of a parameter.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßgetvalue); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 4928: def getliteralvalue(self, name):
					πF.SetLineno(4928)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "name", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("getliteralvalue", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µname *πg.Object = πArgs[1]
						_ = µname
						var µparam *πg.Object = πg.UnboundLocal
						_ = µparam
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4929: "Get the literal value of a parameter."
							πF.SetLineno(4929)
							// line 4930: param = self.getparam(name)
							πF.SetLineno(4930)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[0] = µname
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgetparam, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µparam = πTemp003
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µparam); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp005).ToObject()
							πTemp002 = πTemp003
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µparam, ßliteralvalue, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp005).ToObject()
							πTemp002 = πTemp003
						Label1:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							goto Label3
							// line 4931: if not param or not param.literalvalue:
							πF.SetLineno(4931)
						Label2:
							// line 4932: return None
							πF.SetLineno(4932)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label3
						Label3:
							// line 4933: return param.literalvalue
							πF.SetLineno(4933)
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparam, ßliteralvalue, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetliteralvalue.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 4929: "Get the literal value of a parameter."
					πF.SetLineno(4929)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Get the literal value of a parameter.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßgetliteralvalue); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ParameterFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßParameterFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 4935: class HybridFunction(ParameterFunction):
			πF.SetLineno(4935)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßParameterFunction); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("HybridFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 4936: """
					πF.SetLineno(4936)
					// line 4936: """
					πF.SetLineno(4936)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n  A parameter function where the output is also defined using a template.\n  The template can use a number of functions; each function has an associated\n  tag.\n  Example: [f0{$1},span class=\"fbox\"] defines a function f0 which corresponds\n  to a span of class fbox, yielding <span class=\"fbox\">$1</span>.\n  Literal parameters can be used in tags definitions:\n    [f0{$1},span style=\"color: $p;\"]\n  yields <span style=\"color: $p;\">$1</span>, where $p is a literal parameter.\n  Sizes can be specified in hybridsizes, e.g. adding parameter sizes. By\n  default the resulting size is the max of all arguments. Sizes are used\n  to generate the right parameters.\n  A function followed by a single / is output as a self-closing XHTML tag:\n    [f0/,hr]\n  will generate <hr/>.\n  ").ToObject()); πE != nil {
						continue
					}
					// line 4953: commandmap = FormulaConfig.hybridfunctions
					πF.SetLineno(4953)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßhybridfunctions, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4955: def parsebit(self, pos):
					πF.SetLineno(4955)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µreadtemplate *πg.Object = πg.UnboundLocal
						_ = µreadtemplate
						var µwritetemplate *πg.Object = πg.UnboundLocal
						_ = µwritetemplate
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4956: "Parse a function with [] and {} parameters"
							πF.SetLineno(4956)
							// line 4957: readtemplate = self.translated[0]
							πF.SetLineno(4957)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µreadtemplate = πTemp002
							// line 4958: writetemplate = self.translated[1]
							πF.SetLineno(4958)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µwritetemplate = πTemp002
							// line 4959: self.readparams(readtemplate, pos)
							πF.SetLineno(4959)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µreadtemplate, "readtemplate"); πE != nil {
								continue
							}
							πTemp004[0] = µreadtemplate
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp004[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreadparams, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 4960: self.contents = self.writeparams(writetemplate)
							πF.SetLineno(4960)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µwritetemplate, "writetemplate"); πE != nil {
								continue
							}
							πTemp004[0] = µwritetemplate
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßwriteparams, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp001); πE != nil {
								continue
							}
							// line 4961: self.computehybridsize()
							πF.SetLineno(4961)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcomputehybridsize, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 4956: "Parse a function with [] and {} parameters"
					πF.SetLineno(4956)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a function with [] and {} parameters").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 4963: def writeparams(self, writetemplate):
					πF.SetLineno(4963)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "writetemplate", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("writeparams", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µwritetemplate *πg.Object = πArgs[1]
						_ = µwritetemplate
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4964: "Write all params according to the template"
							πF.SetLineno(4964)
							// line 4965: return self.writepos(TextPosition(writetemplate))
							πF.SetLineno(4965)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µwritetemplate, "writetemplate"); πE != nil {
								continue
							}
							πTemp002[0] = µwritetemplate
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTextPosition); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßwritepos, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßwriteparams.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 4964: "Write all params according to the template"
					πF.SetLineno(4964)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Write all params according to the template").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßwriteparams); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 4967: def writepos(self, pos):
					πF.SetLineno(4967)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("writepos", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µparam *πg.Object = πg.UnboundLocal
						_ = µparam
						var µfunction *πg.Object = πg.UnboundLocal
						_ = µfunction
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 4968: "Write all params as read in the parse position."
							πF.SetLineno(4968)
							// line 4969: result = []
							πF.SetLineno(4969)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µresult = πTemp002
							// line 4970: while not pos.finished():
							πF.SetLineno(4970)
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp007).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("$").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßf.ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("(").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr(")").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label7
							}
							goto Label8
							// line 4971: if pos.checkskip('$'):
							πF.SetLineno(4971)
						Label4:
							// line 4972: param = self.writeparam(pos)
							πF.SetLineno(4972)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßwriteparam, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µparam = πTemp005
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µparam); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label10
							}
							goto Label11
							// line 4973: if param:
							πF.SetLineno(4973)
						Label10:
							// line 4974: result.append(param)
							πF.SetLineno(4974)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							πTemp001[0] = µparam
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label11
						Label11:
							goto Label9
							// line 4975: elif pos.checkskip('f'):
							πF.SetLineno(4975)
						Label5:
							// line 4976: function = self.writefunction(pos)
							πF.SetLineno(4976)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßwritefunction, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µfunction = πTemp005
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µfunction); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label12
							}
							goto Label13
							// line 4977: if function:
							πF.SetLineno(4977)
						Label12:
							// line 4978: function.type = None
							πF.SetLineno(4978)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µfunction, ßtype, πTemp005); πE != nil {
								continue
							}
							// line 4979: result.append(function)
							πF.SetLineno(4979)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							πTemp001[0] = µfunction
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label13
						Label13:
							goto Label9
							// line 4980: elif pos.checkskip('('):
							πF.SetLineno(4980)
						Label6:
							// line 4981: result.append(self.writebracket('left', '('))
							πF.SetLineno(4981)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(2)
							πTemp008[0] = ßleft.ToObject()
							πTemp008[1] = πg.NewStr("(").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßwritebracket, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[0] = πTemp005
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label9
							// line 4982: elif pos.checkskip(')'):
							πF.SetLineno(4982)
						Label7:
							// line 4983: result.append(self.writebracket('right', ')'))
							πF.SetLineno(4983)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(2)
							πTemp008[0] = ßright.ToObject()
							πTemp008[1] = πg.NewStr(")").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßwritebracket, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[0] = πTemp005
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label9
						Label8:
							// line 4985: result.append(FormulaConstant(pos.skipcurrent()))
							πF.SetLineno(4985)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp005
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[0] = πTemp005
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µresult, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label9
						Label9:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 4986: return result
							πF.SetLineno(4986)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πR = µresult
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßwritepos.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 4968: "Write all params as read in the parse position."
					πF.SetLineno(4968)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Write all params as read in the parse position.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßwritepos); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 4988: def writeparam(self, pos):
					πF.SetLineno(4988)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("writeparam", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 4989: "Write a single param of the form $0, $x..."
							πF.SetLineno(4989)
							// line 4990: name = '$' + pos.skipcurrent()
							πF.SetLineno(4990)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("$").ToObject(), πTemp003); πE != nil {
								continue
							}
							µname = πTemp001
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparams, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πTemp003, µname); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 4991: if not name in self.params:
							πF.SetLineno(4991)
						Label1:
							// line 4992: Trace.error('Unknown parameter ' + name)
							πF.SetLineno(4992)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unknown parameter ").ToObject(), µname); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 4993: return None
							πF.SetLineno(4993)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp002 = µname
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßparams, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 4994: if not self.params[name]:
							πF.SetLineno(4994)
						Label3:
							// line 4995: return None
							πF.SetLineno(4995)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = πg.NewStr(".").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 4996: if pos.checkskip('.'):
							πF.SetLineno(4996)
						Label5:
							// line 4997: self.params[name].value.type = pos.globalpha()
							πF.SetLineno(4997)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßglobalpha, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp003 = µname
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßparams, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, πTemp007, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp006, ßvalue, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp003, ßtype, πTemp001); πE != nil {
								continue
							}
							goto Label6
						Label6:
							// line 4998: return self.params[name].value
							πF.SetLineno(4998)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001 = µname
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparams, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßvalue, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßwriteparam.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 4989: "Write a single param of the form $0, $x..."
					πF.SetLineno(4989)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Write a single param of the form $0, $x...").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßwriteparam); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 5000: def writefunction(self, pos):
					πF.SetLineno(5000)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("writefunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µtag *πg.Object = πg.UnboundLocal
						_ = µtag
						var µcontents *πg.Object = πg.UnboundLocal
						_ = µcontents
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5001: "Write a single function f0,...,fn."
							πF.SetLineno(5001)
							// line 5002: tag = self.readtag(pos)
							πF.SetLineno(5002)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreadtag, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtag = πTemp003
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µtag); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 5003: if not tag:
							πF.SetLineno(5003)
						Label1:
							// line 5004: return None
							πF.SetLineno(5004)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("/").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 5005: if pos.checkskip('/'):
							πF.SetLineno(5005)
						Label3:
							// line 5007: return TaggedBit().selfcomplete(tag)
							πF.SetLineno(5007)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp001[0] = µtag
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßselfcomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
							goto Label4
						Label4:
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("{").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 5008: if not pos.checkskip('{'):
							πF.SetLineno(5008)
						Label5:
							// line 5009: Trace.error('Function should be defined in {}')
							πF.SetLineno(5009)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Function should be defined in {}").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5010: return None
							πF.SetLineno(5010)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label6
						Label6:
							// line 5011: pos.pushending('}')
							πF.SetLineno(5011)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("}").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßpushending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5012: contents = self.writepos(pos)
							πF.SetLineno(5012)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßwritepos, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µcontents = πTemp003
							// line 5013: pos.popending()
							πF.SetLineno(5013)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßpopending, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp001[0] = µcontents
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Eq(πF, πTemp005, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label7
							}
							goto Label8
							// line 5014: if len(contents) == 0:
							πF.SetLineno(5014)
						Label7:
							// line 5015: return None
							πF.SetLineno(5015)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label8
						Label8:
							// line 5016: return TaggedBit().complete(contents, tag)
							πF.SetLineno(5016)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πTemp001[0] = µcontents
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πTemp001[1] = µtag
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßwritefunction.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 5001: "Write a single function f0,...,fn."
					πF.SetLineno(5001)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Write a single function f0,...,fn.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßwritefunction); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 5018: def readtag(self, pos):
					πF.SetLineno(5018)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("readtag", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var µtag *πg.Object = πg.UnboundLocal
						_ = µtag
						var µvariable *πg.Object = πg.UnboundLocal
						_ = µvariable
						var µparam *πg.Object = πg.UnboundLocal
						_ = µparam
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 8:
								goto Label8
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 5019: "Get the tag corresponding to the given index. Does parameter substitution."
							πF.SetLineno(5019)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßisdigit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 5020: if not pos.current().isdigit():
							πF.SetLineno(5020)
						Label1:
							// line 5021: Trace.error('Function should be f0,...,f9: f' + pos.current())
							πF.SetLineno(5021)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Function should be f0,...,f9: f").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 5022: return None
							πF.SetLineno(5022)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 5023: index = int(pos.skipcurrent())
							πF.SetLineno(5023)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µindex = πTemp002
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewInt(2).ToObject(), µindex); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.GT(πF, πTemp002, πTemp006); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 5024: if 2 + index > len(self.translated):
							πF.SetLineno(5024)
						Label3:
							// line 5025: Trace.error('Function f' + unicode(index) + ' is not defined')
							πF.SetLineno(5025)
							πTemp005 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp007[0] = µindex
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Function f").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(" is not defined").ToObject()); πE != nil {
								continue
							}
							πTemp005[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 5026: return None
							πF.SetLineno(5026)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label4
						Label4:
							// line 5027: tag = self.translated[2 + index]
							πF.SetLineno(5027)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewInt(2).ToObject(), µindex); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µtag = πTemp002
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, µtag, πg.NewStr("$").ToObject()); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 5028: if not '$' in tag:
							πF.SetLineno(5028)
						Label5:
							// line 5029: return tag
							πF.SetLineno(5029)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πR = µtag
							continue
							goto Label6
						Label6:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparams, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(8)
							πTemp004 = false
						Label7:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label9
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								µvariable = πTemp002
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(7)
							if πE = πg.CheckLocal(πF, µvariable, "variable"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Contains(πF, µtag, µvariable); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp008).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label10
							}
							goto Label11
							// line 5031: if variable in tag:
							πF.SetLineno(5031)
						Label10:
							// line 5032: param = self.params[variable]
							πF.SetLineno(5032)
							if πE = πg.CheckLocal(πF, µvariable, "variable"); πE != nil {
								continue
							}
							πTemp002 = µvariable
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßparams, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							µparam = πTemp003
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µparam, ßliteral, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp008).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label12
							}
							goto Label13
							// line 5033: if not param.literal:
							πF.SetLineno(5033)
						Label12:
							// line 5034: Trace.error('Parameters in tag ' + tag + ' should be literal: {' + variable + '!}')
							πF.SetLineno(5034)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Add(πF, πg.NewStr("Parameters in tag ").ToObject(), µtag); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Add(πF, πTemp009, πg.NewStr(" should be literal: {").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvariable, "variable"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp006, µvariable); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("!}").ToObject()); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 5035: continue
							πF.SetLineno(5035)
							continue
							goto Label13
						Label13:
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparam, ßliteralvalue, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label14
							}
							goto Label15
							// line 5036: if param.literalvalue:
							πF.SetLineno(5036)
						Label14:
							// line 5037: value = param.literalvalue
							πF.SetLineno(5037)
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparam, ßliteralvalue, nil); πE != nil {
								continue
							}
							µvalue = πTemp002
							goto Label16
						Label15:
							// line 5039: value = ''
							πF.SetLineno(5039)
							µvalue = ß.ToObject()
							goto Label16
						Label16:
							// line 5040: tag = tag.replace(variable, value)
							πF.SetLineno(5040)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µvariable, "variable"); πE != nil {
								continue
							}
							πTemp005[0] = µvariable
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp005[1] = µvalue
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µtag, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µtag = πTemp003
							goto Label11
						Label11:
							continue
						Label8:
							if πE != nil || πR != nil {
								continue
							}
						Label9:
							// line 5041: return tag
							πF.SetLineno(5041)
							if πE = πg.CheckLocal(πF, µtag, "tag"); πE != nil {
								continue
							}
							πR = µtag
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreadtag.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 5019: "Get the tag corresponding to the given index. Does parameter substitution."
					πF.SetLineno(5019)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Get the tag corresponding to the given index. Does parameter substitution.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßreadtag); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 5043: def writebracket(self, direction, character):
					πF.SetLineno(5043)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "direction", Def: nil}
					πTemp003[2] = πg.Param{Name: "character", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("writebracket", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µdirection *πg.Object = πArgs[1]
						_ = µdirection
						var µcharacter *πg.Object = πArgs[2]
						_ = µcharacter
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5044: "Return a new bracket looking at the given direction."
							πF.SetLineno(5044)
							// line 5045: return self.factory.create(BracketCommand).create(direction, character)
							πF.SetLineno(5045)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdirection, "direction"); πE != nil {
								continue
							}
							πTemp001[0] = µdirection
							if πE = πg.CheckLocal(πF, µcharacter, "character"); πE != nil {
								continue
							}
							πTemp001[1] = µcharacter
							πTemp002 = πF.MakeArgs(1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßBracketCommand); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßwritebracket.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 5044: "Return a new bracket looking at the given direction."
					πF.SetLineno(5044)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Return a new bracket looking at the given direction.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßwritebracket); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 5047: def computehybridsize(self):
					πF.SetLineno(5047)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("computehybridsize", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µelement *πg.Object = πg.UnboundLocal
						_ = µelement
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 5048: "Compute the size of the hybrid function."
							πF.SetLineno(5048)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßcommand, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßHybridSize); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßconfigsizes, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Contains(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 5049: if not self.command in HybridSize.configsizes:
							πF.SetLineno(5049)
						Label1:
							// line 5050: self.computesize()
							πF.SetLineno(5050)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcomputesize, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 5051: return
							πF.SetLineno(5051)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 5052: self.size = HybridSize().getsize(self)
							πF.SetLineno(5052)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp007[0] = µself
							if πTemp001, πE = πg.ResolveGlobal(πF, ßHybridSize); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßgetsize, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßsize, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcontents, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp006 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								µelement = πTemp002
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 5055: element.size = self.size
							πF.SetLineno(5055)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsize, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µelement, "element"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µelement, ßsize, πTemp003); πE != nil {
								continue
							}
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcomputehybridsize.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 5048: "Compute the size of the hybrid function."
					πF.SetLineno(5048)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Compute the size of the hybrid function.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßcomputehybridsize); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("HybridFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßHybridFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 5057: class HybridSize(object):
			πF.SetLineno(5057)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("HybridSize", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5058: "The size associated with a hybrid function."
					πF.SetLineno(5058)
					// line 5058: "The size associated with a hybrid function."
					πF.SetLineno(5058)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("The size associated with a hybrid function.").ToObject()); πE != nil {
						continue
					}
					// line 5060: configsizes = FormulaConfig.hybridsizes
					πF.SetLineno(5060)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßFormulaConfig); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßhybridsizes, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßconfigsizes.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 5062: def getsize(self, function):
					πF.SetLineno(5062)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "function", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("getsize", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µfunction *πg.Object = πArgs[1]
						_ = µfunction
						var µsizestring *πg.Object = πg.UnboundLocal
						_ = µsizestring
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var µsize *πg.Object = πg.UnboundLocal
						_ = µsize
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 5063: "Read the size for a function and parse it."
							πF.SetLineno(5063)
							// line 5064: sizestring = self.configsizes[function.command]
							πF.SetLineno(5064)
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µfunction, ßcommand, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßconfigsizes, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							µsizestring = πTemp002
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µfunction, ßparams, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µname = πTemp002
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsizestring, "sizestring"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Contains(πF, µsizestring, µname); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 5066: if name in sizestring:
							πF.SetLineno(5066)
						Label4:
							// line 5067: size = function.params[name].value.computesize()
							πF.SetLineno(5067)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp002 = µname
							if πE = πg.CheckLocal(πF, µfunction, "function"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µfunction, ßparams, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßvalue, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßcomputesize, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µsize = πTemp002
							// line 5068: sizestring = sizestring.replace(name, unicode(size))
							πF.SetLineno(5068)
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp007[0] = µname
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsize, "size"); πE != nil {
								continue
							}
							πTemp008[0] = µsize
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp007[1] = πTemp003
							if πE = πg.CheckLocal(πF, µsizestring, "sizestring"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µsizestring, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							µsizestring = πTemp003
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							if πE = πg.CheckLocal(πF, µsizestring, "sizestring"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, µsizestring, πg.NewStr("$").ToObject()); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 5069: if '$' in sizestring:
							πF.SetLineno(5069)
						Label6:
							// line 5070: Trace.error('Unconverted variable in hybrid size: ' + sizestring)
							πF.SetLineno(5070)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsizestring, "sizestring"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πg.NewStr("Unconverted variable in hybrid size: ").ToObject(), µsizestring); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 5071: return 1
							πF.SetLineno(5071)
							πR = πg.NewInt(1).ToObject()
							continue
							goto Label7
						Label7:
							// line 5072: return eval(sizestring)
							πF.SetLineno(5072)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsizestring, "sizestring"); πE != nil {
								continue
							}
							πTemp007[0] = µsizestring
							if πTemp001, πE = πg.ResolveGlobal(πF, ßeval); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgetsize.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 5063: "Read the size for a function and parse it."
					πF.SetLineno(5063)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Read the size for a function and parse it.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßgetsize); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("HybridSize").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßHybridSize.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 5075: FormulaCommand.types += [HybridFunction]
			πF.SetLineno(5075)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßtypes, nil); πE != nil {
				continue
			}
			πTemp002 = make([]*πg.Object, 1)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßHybridFunction); πE != nil {
				continue
			}
			πTemp002[0] = πTemp001
			πTemp001 = πg.NewList(πTemp002...).ToObject()
			if πTemp004, πE = πg.IAdd(πF, πTemp003, πTemp001); πE != nil {
				continue
			}
			if πTemp007, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp007, ßtypes, πTemp004); πE != nil {
				continue
			}
			// line 5085: class HeaderParser(Parser):
			πF.SetLineno(5085)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("HeaderParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5086: "Parses the LyX header"
					πF.SetLineno(5086)
					// line 5086: "Parses the LyX header"
					πF.SetLineno(5086)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Parses the LyX header").ToObject()); πE != nil {
						continue
					}
					// line 5088: def parse(self, reader):
					πF.SetLineno(5088)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µcontents *πg.Object = πg.UnboundLocal
						_ = µcontents
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5089: "Parse header parameters into a dictionary, return the preamble."
							πF.SetLineno(5089)
							// line 5090: contents = []
							πF.SetLineno(5090)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µcontents = πTemp002
							// line 5091: self.parseending(reader, lambda: self.parseline(reader, contents))
							πF.SetLineno(5091)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 5091: self.parseending(reader, lambda: self.parseline(reader, contents))
									πF.SetLineno(5091)
									πTemp001 = πF.MakeArgs(2)
									if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
										continue
									}
									πTemp001[0] = µreader
									if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
										continue
									}
									πTemp001[1] = µcontents
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ßparseline, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									πR = πTemp003
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseending, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5093: reader.nextline()
							πF.SetLineno(5093)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 5094: return contents
							πF.SetLineno(5094)
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							πR = µcontents
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 5089: "Parse header parameters into a dictionary, return the preamble."
					πF.SetLineno(5089)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Parse header parameters into a dictionary, return the preamble.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 5096: def parseline(self, reader, contents):
					πF.SetLineno(5096)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp002[2] = πg.Param{Name: "contents", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parseline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µcontents *πg.Object = πArgs[2]
						_ = µcontents
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5097: "Parse a single line as a parameter or as a start"
							πF.SetLineno(5097)
							// line 5098: line = reader.currentline()
							πF.SetLineno(5098)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µline = πTemp002
							πTemp003 = πF.MakeArgs(1)
							πTemp001 = ßbranch.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßHeaderConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßparameters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µline, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp001 = ßlstset.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßHeaderConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßparameters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µline, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label2
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp001 = ßbeginpreamble.ToObject()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßHeaderConfig); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßparameters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µline, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label3
							}
							goto Label4
							// line 5099: if line.startswith(HeaderConfig.parameters['branch']):
							πF.SetLineno(5099)
						Label1:
							// line 5100: self.parsebranch(reader)
							πF.SetLineno(5100)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp003[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparsebranch, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 5101: return
							πF.SetLineno(5101)
							πR = πg.None
							continue
							goto Label4
							// line 5102: elif line.startswith(HeaderConfig.parameters['lstset']):
							πF.SetLineno(5102)
						Label2:
							// line 5103: LstParser().parselstset(reader)
							πF.SetLineno(5103)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp003[0] = µreader
							if πTemp001, πE = πg.ResolveGlobal(πF, ßLstParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßparselstset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 5104: return
							πF.SetLineno(5104)
							πR = πg.None
							continue
							goto Label4
							// line 5105: elif line.startswith(HeaderConfig.parameters['beginpreamble']):
							πF.SetLineno(5105)
						Label3:
							// line 5106: contents.append(self.factory.createcontainer(reader))
							πF.SetLineno(5106)
							πTemp003 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp007[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcreatecontainer, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µcontents, "contents"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontents, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 5107: return
							πF.SetLineno(5107)
							πR = πg.None
							continue
							goto Label4
						Label4:
							// line 5109: self.parseparameter(reader)
							πF.SetLineno(5109)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp003[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparseparameter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseline.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 5097: "Parse a single line as a parameter or as a start"
					πF.SetLineno(5097)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse a single line as a parameter or as a start").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparseline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 5111: def parsebranch(self, reader):
					πF.SetLineno(5111)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "reader", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parsebranch", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µbranch *πg.Object = πg.UnboundLocal
						_ = µbranch
						var µsubparser *πg.Object = πg.UnboundLocal
						_ = µsubparser
						var µoptions *πg.Object = πg.UnboundLocal
						_ = µoptions
						var µkey *πg.Object = πg.UnboundLocal
						_ = µkey
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 5112: "Parse all branch definitions."
							πF.SetLineno(5112)
							// line 5113: branch = reader.currentline().split()[1]
							πF.SetLineno(5113)
							πTemp001 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µbranch = πTemp002
							// line 5114: reader.nextline()
							πF.SetLineno(5114)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 5115: subparser = HeaderParser().complete(HeaderConfig.parameters['endbranch'])
							πF.SetLineno(5115)
							πTemp005 = πF.MakeArgs(1)
							πTemp001 = ßendbranch.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßHeaderConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßparameters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßHeaderParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßcomplete, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µsubparser = πTemp002
							// line 5116: subparser.parse(reader)
							πF.SetLineno(5116)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp005[0] = µreader
							if πE = πg.CheckLocal(πF, µsubparser, "subparser"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µsubparser, ßparse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 5117: options = BranchOptions(branch)
							πF.SetLineno(5117)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbranch, "branch"); πE != nil {
								continue
							}
							πTemp005[0] = µbranch
							if πTemp001, πE = πg.ResolveGlobal(πF, ßBranchOptions); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µoptions = πTemp002
							if πE = πg.CheckLocal(πF, µsubparser, "subparser"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µsubparser, ßparameters, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp002); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µkey = πTemp002
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 5119: options.set(key, subparser.parameters[key])
							πF.SetLineno(5119)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp005[0] = µkey
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp002 = µkey
							if πE = πg.CheckLocal(πF, µsubparser, "subparser"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µsubparser, ßparameters, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							πTemp005[1] = πTemp003
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoptions, ßset, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 5120: Options.branches[branch] = options
							πF.SetLineno(5120)
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µoptions); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßbranches, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbranch, "branch"); πE != nil {
								continue
							}
							πTemp002 = µbranch
							if πE = πg.SetItem(πF, πTemp003, πTemp002, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebranch.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 5112: "Parse all branch definitions."
					πF.SetLineno(5112)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse all branch definitions.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparsebranch); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 5122: def complete(self, ending):
					πF.SetLineno(5122)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "ending", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("complete", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µending *πg.Object = πArgs[1]
						_ = µending
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5123: "Complete the parser with the given ending."
							πF.SetLineno(5123)
							// line 5124: self.ending = ending
							πF.SetLineno(5124)
							if πE = πg.CheckLocal(πF, µending, "ending"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µending); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßending, πTemp001); πE != nil {
								continue
							}
							// line 5125: return self
							πF.SetLineno(5125)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πR = µself
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcomplete.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 5123: "Complete the parser with the given ending."
					πF.SetLineno(5123)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Complete the parser with the given ending.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßcomplete); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("HeaderParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßHeaderParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 5127: class PreambleParser(Parser):
			πF.SetLineno(5127)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßParser); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("PreambleParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5128: "A parser for the LyX preamble."
					πF.SetLineno(5128)
					// line 5128: "A parser for the LyX preamble."
					πF.SetLineno(5128)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parser for the LyX preamble.").ToObject()); πE != nil {
						continue
					}
					// line 5130: preamble = []
					πF.SetLineno(5130)
					πTemp001 = make([]*πg.Object, 0)
					πTemp002 = πg.NewList(πTemp001...).ToObject()
					if πE = πClass.SetItem(πF, ßpreamble.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 5132: def parse(self, reader):
					πF.SetLineno(5132)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "reader", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 []πg.Param
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5133: "Parse the full preamble with all statements."
							πF.SetLineno(5133)
							// line 5134: self.ending = HeaderConfig.parameters['endpreamble']
							πF.SetLineno(5134)
							πTemp001 = ßendpreamble.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßHeaderConfig); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßparameters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßending, πTemp001); πE != nil {
								continue
							}
							// line 5135: self.parseending(reader, lambda: self.parsepreambleline(reader))
							πF.SetLineno(5135)
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp005[0] = µreader
							πTemp006 = make([]πg.Param, 0)
							πTemp001 = πg.NewFunction(πg.NewCode("<lambda>", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var πTemp001 []*πg.Object
								_ = πTemp001
								var πTemp002 *πg.Object
								_ = πTemp002
								var πTemp003 *πg.Object
								_ = πTemp003
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								for ; πF.State() >= 0; πF.PopCheckpoint() {
									switch πF.State() {
									case 0:
									default:
										panic("unexpected function state")
									}
									// line 5135: self.parseending(reader, lambda: self.parsepreambleline(reader))
									πF.SetLineno(5135)
									πTemp001 = πF.MakeArgs(1)
									if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
										continue
									}
									πTemp001[0] = µreader
									if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
										continue
									}
									if πTemp002, πE = πg.GetAttr(πF, µself, ßparsepreambleline, nil); πE != nil {
										continue
									}
									if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
										continue
									}
									πF.FreeArgs(πTemp001)
									πR = πTemp003
									continue
								}
								if πE != nil {
									πR = nil
								} else if πR == nil {
									πR = πg.None
								}
								return πR, πE
							}), πF.Globals()).ToObject()
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparseending, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 5136: return []
							πF.SetLineno(5136)
							πTemp005 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 5133: "Parse the full preamble with all statements."
					πF.SetLineno(5133)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse the full preamble with all statements.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 5138: def parsepreambleline(self, reader):
					πF.SetLineno(5138)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "reader", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parsepreambleline", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5139: "Parse a single preamble line."
							πF.SetLineno(5139)
							// line 5140: PreambleParser.preamble.append(reader.currentline())
							πF.SetLineno(5140)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßPreambleParser); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßpreamble, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5141: reader.nextline()
							πF.SetLineno(5141)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsepreambleline.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 5139: "Parse a single preamble line."
					πF.SetLineno(5139)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse a single preamble line.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparsepreambleline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("PreambleParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßPreambleParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 5143: class LstParser(object):
			πF.SetLineno(5143)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LstParser", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5144: "Parse global and local lstparams."
					πF.SetLineno(5144)
					// line 5144: "Parse global and local lstparams."
					πF.SetLineno(5144)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Parse global and local lstparams.").ToObject()); πE != nil {
						continue
					}
					// line 5146: globalparams = dict()
					πF.SetLineno(5146)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßdict); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßglobalparams.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 5148: def parselstset(self, reader):
					πF.SetLineno(5148)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "reader", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parselstset", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µparamtext *πg.Object = πg.UnboundLocal
						_ = µparamtext
						var µlefttext *πg.Object = πg.UnboundLocal
						_ = µlefttext
						var µcroppedtext *πg.Object = πg.UnboundLocal
						_ = µcroppedtext
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5149: "Parse a declaration of lstparams in lstset."
							πF.SetLineno(5149)
							// line 5150: paramtext = self.extractlstset(reader)
							πF.SetLineno(5150)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							πTemp001[0] = µreader
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßextractlstset, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µparamtext = πTemp003
							if πE = πg.CheckLocal(πF, µparamtext, "paramtext"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, µparamtext, πg.NewStr("{").ToObject()); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 5151: if not '{' in paramtext:
							πF.SetLineno(5151)
						Label1:
							// line 5152: Trace.error('Missing opening bracket in lstset: ' + paramtext)
							πF.SetLineno(5152)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparamtext, "paramtext"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Missing opening bracket in lstset: ").ToObject(), µparamtext); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5153: return
							πF.SetLineno(5153)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 5154: lefttext = paramtext.split('{')[1]
							πF.SetLineno(5154)
							πTemp002 = πg.NewInt(1).ToObject()
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("{").ToObject()
							if πE = πg.CheckLocal(πF, µparamtext, "paramtext"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µparamtext, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							µlefttext = πTemp003
							// line 5155: croppedtext = lefttext[:-1]
							πF.SetLineno(5155)
							if πTemp003, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlefttext, "lefttext"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µlefttext, πTemp002); πE != nil {
								continue
							}
							µcroppedtext = πTemp003
							// line 5156: LstParser.globalparams = self.parselstparams(croppedtext)
							πF.SetLineno(5156)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcroppedtext, "croppedtext"); πE != nil {
								continue
							}
							πTemp001[0] = µcroppedtext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparselstparams, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßLstParser); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßglobalparams, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparselstset.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 5149: "Parse a declaration of lstparams in lstset."
					πF.SetLineno(5149)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a declaration of lstparams in lstset.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparselstset); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 5158: def extractlstset(self, reader):
					πF.SetLineno(5158)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "reader", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("extractlstset", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreader *πg.Object = πArgs[1]
						_ = µreader
						var µparamtext *πg.Object = πg.UnboundLocal
						_ = µparamtext
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 5159: "Extract the global lstset parameters."
							πF.SetLineno(5159)
							// line 5160: paramtext = ''
							πF.SetLineno(5160)
							µparamtext = ß.ToObject()
							// line 5161: while not reader.finished():
							πF.SetLineno(5161)
							πF.PushCheckpoint(2)
							πTemp001 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp001 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µreader, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πE != nil || !πTemp002 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 5162: paramtext += reader.currentline()
							πF.SetLineno(5162)
							if πE = πg.CheckLocal(πF, µparamtext, "paramtext"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßcurrentline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µparamtext, πTemp004); πE != nil {
								continue
							}
							µparamtext = πTemp003
							// line 5163: reader.nextline()
							πF.SetLineno(5163)
							if πE = πg.CheckLocal(πF, µreader, "reader"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µreader, ßnextline, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp007 = πF.MakeArgs(1)
							πTemp007[0] = πg.NewStr("}").ToObject()
							if πE = πg.CheckLocal(πF, µparamtext, "paramtext"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µparamtext, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp002, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 5164: if paramtext.endswith('}'):
							πF.SetLineno(5164)
						Label4:
							// line 5165: return paramtext
							πF.SetLineno(5165)
							if πE = πg.CheckLocal(πF, µparamtext, "paramtext"); πE != nil {
								continue
							}
							πR = µparamtext
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 5166: Trace.error('Could not find end of \\lstset settings; aborting')
							πF.SetLineno(5166)
							πTemp007 = πF.MakeArgs(1)
							πTemp007[0] = πg.NewStr("Could not find end of \\lstset settings; aborting").ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßerror, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßextractlstset.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 5159: "Extract the global lstset parameters."
					πF.SetLineno(5159)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Extract the global lstset parameters.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßextractlstset); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 5168: def parsecontainer(self, container):
					πF.SetLineno(5168)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "container", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parsecontainer", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontainer *πg.Object = πArgs[1]
						_ = µcontainer
						var µparamlist *πg.Object = πg.UnboundLocal
						_ = µparamlist
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5169: "Parse some lstparams from elyxer.a container."
							πF.SetLineno(5169)
							// line 5170: container.lstparams = LstParser.globalparams.copy()
							πF.SetLineno(5170)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßLstParser); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßglobalparams, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßcopy, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µcontainer, ßlstparams, πTemp001); πE != nil {
								continue
							}
							// line 5171: paramlist = container.getparameterlist('lstparams')
							πF.SetLineno(5171)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßlstparams.ToObject()
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontainer, ßgetparameterlist, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µparamlist = πTemp002
							// line 5172: container.lstparams.update(self.parselstparams(paramlist))
							πF.SetLineno(5172)
							πTemp003 = πF.MakeArgs(1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparamlist, "paramlist"); πE != nil {
								continue
							}
							πTemp004[0] = µparamlist
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparselstparams, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µcontainer, "container"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontainer, ßlstparams, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßupdate, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsecontainer.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 5169: "Parse some lstparams from elyxer.a container."
					πF.SetLineno(5169)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse some lstparams from elyxer.a container.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparsecontainer); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 5174: def parselstparams(self, paramlist):
					πF.SetLineno(5174)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "paramlist", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("parselstparams", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µparamlist *πg.Object = πArgs[1]
						_ = µparamlist
						var µparamdict *πg.Object = πg.UnboundLocal
						_ = µparamdict
						var µparam *πg.Object = πg.UnboundLocal
						_ = µparam
						var µkey *πg.Object = πg.UnboundLocal
						_ = µkey
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 5175: "Process a number of lstparams from elyxer.a list."
							πF.SetLineno(5175)
							// line 5176: paramdict = dict()
							πF.SetLineno(5176)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßdict); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µparamdict = πTemp002
							if πE = πg.CheckLocal(πF, µparamlist, "paramlist"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µparamlist); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µparam = πTemp002
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, µparam, πg.NewStr("=").ToObject()); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 5178: if not '=' in param:
							πF.SetLineno(5178)
						Label4:
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µparam, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp006[0] = πTemp007
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp005.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.GT(πF, πTemp007, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label7
							}
							goto Label8
							// line 5179: if len(param.strip()) > 0:
							πF.SetLineno(5179)
						Label7:
							// line 5180: Trace.error('Invalid listing parameter ' + param)
							πF.SetLineno(5180)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Invalid listing parameter ").ToObject(), µparam); πE != nil {
								continue
							}
							πTemp006[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp005.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							goto Label8
						Label8:
							goto Label6
						Label5:
							// line 5182: key, value = param.split('=', 1)
							πF.SetLineno(5182)
							πTemp006 = πF.MakeArgs(2)
							πTemp006[0] = πg.NewStr("=").ToObject()
							πTemp006[1] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µparam, "param"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µparam, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp007}}}, πTemp005); πE != nil {
								continue
							}
							µkey = πTemp002
							µvalue = πTemp007
							// line 5183: paramdict[key] = value
							πF.SetLineno(5183)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µvalue); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparamdict, "paramdict"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp005 = µkey
							if πE = πg.SetItem(πF, µparamdict, πTemp005, πTemp002); πE != nil {
								continue
							}
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 5184: return paramdict
							πF.SetLineno(5184)
							if πE = πg.CheckLocal(πF, µparamdict, "paramdict"); πE != nil {
								continue
							}
							πR = µparamdict
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparselstparams.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 5175: "Process a number of lstparams from elyxer.a list."
					πF.SetLineno(5175)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Process a number of lstparams from elyxer.a list.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßparselstparams); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("LstParser").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLstParser.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 5189: class MacroDefinition(CommandBit):
			πF.SetLineno(5189)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("MacroDefinition", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5190: "A function that defines a new command (a macro)."
					πF.SetLineno(5190)
					// line 5190: "A function that defines a new command (a macro)."
					πF.SetLineno(5190)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A function that defines a new command (a macro).").ToObject()); πE != nil {
						continue
					}
					// line 5192: macros = dict()
					πF.SetLineno(5192)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßdict); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßmacros.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 5194: def parsebit(self, pos):
					πF.SetLineno(5194)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5195: "Parse the function that defines the macro."
							πF.SetLineno(5195)
							// line 5196: self.output = EmptyOutput()
							πF.SetLineno(5196)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEmptyOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 5197: self.parameternumber = 0
							πF.SetLineno(5197)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparameternumber, πTemp001); πE != nil {
								continue
							}
							// line 5198: self.defaults = []
							πF.SetLineno(5198)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdefaults, πTemp002); πE != nil {
								continue
							}
							// line 5199: self.factory.defining = True
							πF.SetLineno(5199)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßdefining, πTemp002); πE != nil {
								continue
							}
							// line 5200: self.parseparameters(pos)
							πF.SetLineno(5200)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp003[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparseparameters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 5201: self.factory.defining = False
							πF.SetLineno(5201)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßdefining, πTemp002); πE != nil {
								continue
							}
							// line 5202: Trace.debug('New command ' + self.newcommand + ' (' + \
							πF.SetLineno(5202)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßnewcommand, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πg.NewStr("New command ").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp005, πg.NewStr(" (").ToObject()); πE != nil {
								continue
							}
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßparameternumber, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp002, πE = πg.Add(πF, πTemp004, πTemp006); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewStr(" parameters)").ToObject()); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßdebug, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 5204: self.macros[self.newcommand] = self
							πF.SetLineno(5204)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µself); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßmacros, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßnewcommand, nil); πE != nil {
								continue
							}
							πTemp004 = πTemp005
							if πE = πg.SetItem(πF, πTemp002, πTemp004, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 5195: "Parse the function that defines the macro."
					πF.SetLineno(5195)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse the function that defines the macro.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 5206: def parseparameters(self, pos):
					πF.SetLineno(5206)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("parseparameters", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µliteral *πg.Object = πg.UnboundLocal
						_ = µliteral
						var µbracket *πg.Object = πg.UnboundLocal
						_ = µbracket
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 5207: "Parse all optional parameters (number of parameters, default values)"
							πF.SetLineno(5207)
							// line 5208: "and the mandatory definition."
							πF.SetLineno(5208)
							// line 5209: self.newcommand = self.parsenewcommand(pos)
							πF.SetLineno(5209)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsenewcommand, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßnewcommand, πTemp002); πE != nil {
								continue
							}
							// line 5211: literal = self.parsesquareliteral(pos)
							πF.SetLineno(5211)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsesquareliteral, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µliteral = πTemp003
							if πE = πg.CheckLocal(πF, µliteral, "literal"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µliteral); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 5212: if literal:
							πF.SetLineno(5212)
						Label1:
							// line 5213: self.parameternumber = int(literal)
							πF.SetLineno(5213)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µliteral, "literal"); πE != nil {
								continue
							}
							πTemp001[0] = µliteral
							if πTemp002, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparameternumber, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 5215: bracket = self.parsesquare(pos)
							πF.SetLineno(5215)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsesquare, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbracket = πTemp003
							// line 5216: while bracket:
							πF.SetLineno(5216)
							πF.PushCheckpoint(4)
							πTemp004 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µbracket); πE != nil {
								continue
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 5217: self.defaults.append(bracket)
							πF.SetLineno(5217)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbracket, "bracket"); πE != nil {
								continue
							}
							πTemp001[0] = µbracket
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdefaults, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5218: bracket = self.parsesquare(pos)
							πF.SetLineno(5218)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsesquare, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µbracket = πTemp003
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							// line 5220: self.definition = self.parseparameter(pos)
							πF.SetLineno(5220)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdefinition, πTemp002); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseparameters.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 5207: "Parse all optional parameters (number of parameters, default values)"
					πF.SetLineno(5207)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse all optional parameters (number of parameters, default values)").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparseparameters); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 5222: def parsenewcommand(self, pos):
					πF.SetLineno(5222)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parsenewcommand", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5223: "Parse the name of the new command."
							πF.SetLineno(5223)
							// line 5224: self.factory.clearskipped(pos)
							πF.SetLineno(5224)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßBracket); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 5225: if self.factory.detecttype(Bracket, pos):
							πF.SetLineno(5225)
						Label1:
							// line 5226: return self.parseliteral(pos)
							πF.SetLineno(5226)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseliteral, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
							goto Label2
						Label2:
							πTemp001 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 5227: if self.factory.detecttype(FormulaCommand, pos):
							πF.SetLineno(5227)
						Label3:
							// line 5228: return self.factory.create(FormulaCommand).extractcommand(pos)
							πF.SetLineno(5228)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							πTemp005 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßextractcommand, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp002
							continue
							goto Label4
						Label4:
							// line 5229: Trace.error('Unknown formula bit in defining function at ' + pos.identifier())
							πF.SetLineno(5229)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßidentifier, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("Unknown formula bit in defining function at ").ToObject(), πTemp006); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5230: return 'unknown'
							πF.SetLineno(5230)
							πR = ßunknown.ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsenewcommand.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 5223: "Parse the name of the new command."
					πF.SetLineno(5223)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse the name of the new command.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparsenewcommand); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 5232: def instantiate(self):
					πF.SetLineno(5232)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("instantiate", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5233: "Return an instance of the macro."
							πF.SetLineno(5233)
							// line 5234: return self.definition.clone()
							πF.SetLineno(5234)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdefinition, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßclone, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinstantiate.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 5233: "Return an instance of the macro."
					πF.SetLineno(5233)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Return an instance of the macro.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßinstantiate); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("MacroDefinition").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMacroDefinition.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 5236: class MacroParameter(FormulaBit):
			πF.SetLineno(5236)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormulaBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("MacroParameter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5237: "A parameter from elyxer.a macro."
					πF.SetLineno(5237)
					// line 5237: "A parameter from elyxer.a macro."
					πF.SetLineno(5237)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A parameter from elyxer.a macro.").ToObject()); πE != nil {
						continue
					}
					// line 5239: def detect(self, pos):
					πF.SetLineno(5239)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("detect", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5240: "Find a macro parameter: #n."
							πF.SetLineno(5240)
							// line 5241: return pos.checkfor('#')
							πF.SetLineno(5241)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("#").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßcheckfor, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdetect.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 5240: "Find a macro parameter: #n."
					πF.SetLineno(5240)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Find a macro parameter: #n.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßdetect); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 5243: def parsebit(self, pos):
					πF.SetLineno(5243)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5244: "Parse the parameter: #n."
							πF.SetLineno(5244)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("#").ToObject()
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpos, ßcheckskip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 5245: if not pos.checkskip('#'):
							πF.SetLineno(5245)
						Label1:
							// line 5246: Trace.error('Missing parameter start #.')
							πF.SetLineno(5246)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("Missing parameter start #.").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 5247: return
							πF.SetLineno(5247)
							πR = πg.None
							continue
							goto Label2
						Label2:
							// line 5248: self.number = int(pos.skipcurrent())
							πF.SetLineno(5248)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpos, ßskipcurrent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp001, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßnumber, πTemp001); πE != nil {
								continue
							}
							// line 5249: self.original = '#' + unicode(self.number)
							πF.SetLineno(5249)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßnumber, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Add(πF, πg.NewStr("#").ToObject(), πTemp004); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoriginal, πTemp003); πE != nil {
								continue
							}
							// line 5250: self.contents = [TaggedBit().constant('#' + unicode(self.number), 'span class="unknown"')]
							πF.SetLineno(5250)
							πTemp002 = make([]*πg.Object, 1)
							πTemp006 = πF.MakeArgs(2)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßnumber, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp001, πE = πg.Add(πF, πg.NewStr("#").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							πTemp006[1] = πg.NewStr("span class=\"unknown\"").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTaggedBit); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßconstant, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp002[0] = πTemp003
							πTemp001 = πg.NewList(πTemp002...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 5244: "Parse the parameter: #n."
					πF.SetLineno(5244)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse the parameter: #n.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("MacroParameter").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMacroParameter.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 5252: class MacroFunction(CommandBit):
			πF.SetLineno(5252)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßCommandBit); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("MacroFunction", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5253: "A function that was defined using a macro."
					πF.SetLineno(5253)
					// line 5253: "A function that was defined using a macro."
					πF.SetLineno(5253)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A function that was defined using a macro.").ToObject()); πE != nil {
						continue
					}
					// line 5255: commandmap = MacroDefinition.macros
					πF.SetLineno(5255)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßMacroDefinition); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßmacros, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßcommandmap.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 5257: def parsebit(self, pos):
					πF.SetLineno(5257)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parsebit", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µmacro *πg.Object = πg.UnboundLocal
						_ = µmacro
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5258: "Parse a number of input parameters."
							πF.SetLineno(5258)
							// line 5259: self.output = FilteredOutput()
							πF.SetLineno(5259)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFilteredOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
							// line 5260: self.values = []
							πF.SetLineno(5260)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalues, πTemp002); πE != nil {
								continue
							}
							// line 5261: macro = self.translated
							πF.SetLineno(5261)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßtranslated, nil); πE != nil {
								continue
							}
							µmacro = πTemp001
							// line 5262: self.parseparameters(pos, macro)
							πF.SetLineno(5262)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp003[0] = µpos
							if πE = πg.CheckLocal(πF, µmacro, "macro"); πE != nil {
								continue
							}
							πTemp003[1] = µmacro
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparseparameters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 5263: self.completemacro(macro)
							πF.SetLineno(5263)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmacro, "macro"); πE != nil {
								continue
							}
							πTemp003[0] = µmacro
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßcompletemacro, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsebit.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 5258: "Parse a number of input parameters."
					πF.SetLineno(5258)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Parse a number of input parameters.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparsebit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 5265: def parseparameters(self, pos, macro):
					πF.SetLineno(5265)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003[2] = πg.Param{Name: "macro", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("parseparameters", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µmacro *πg.Object = πArgs[2]
						_ = µmacro
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5266: "Parse as many parameters as are needed."
							πF.SetLineno(5266)
							// line 5267: self.parseoptional(pos, list(macro.defaults))
							πF.SetLineno(5267)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmacro, "macro"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmacro, ßdefaults, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[1] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparseoptional, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5268: self.parsemandatory(pos, macro.parameternumber - len(macro.defaults))
							πF.SetLineno(5268)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µmacro, "macro"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmacro, ßparameternumber, nil); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmacro, "macro"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µmacro, ßdefaults, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.Sub(πF, πTemp004, πTemp006); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparsemandatory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µmacro, "macro"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmacro, ßparameternumber, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.LT(πF, πTemp005, πTemp004); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 5269: if len(self.values) < macro.parameternumber:
							πF.SetLineno(5269)
						Label1:
							// line 5270: Trace.error('Missing parameters in macro ' + unicode(self))
							πF.SetLineno(5270)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp002[0] = µself
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Missing parameters in macro ").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßerror, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseparameters.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 5266: "Parse as many parameters as are needed."
					πF.SetLineno(5266)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Parse as many parameters as are needed.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßparseparameters); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 5272: def parseoptional(self, pos, defaults):
					πF.SetLineno(5272)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003[2] = πg.Param{Name: "defaults", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parseoptional", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µdefaults *πg.Object = πArgs[2]
						_ = µdefaults
						var µoptional *πg.Object = πg.UnboundLocal
						_ = µoptional
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var µdefault *πg.Object = πg.UnboundLocal
						_ = µdefault
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							case 6:
								goto Label6
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 5273: "Parse optional parameters."
							πF.SetLineno(5273)
							// line 5274: optional = []
							πF.SetLineno(5274)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µoptional = πTemp002
							// line 5275: while self.factory.detecttype(SquareBracket, pos):
							πF.SetLineno(5275)
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							πTemp001 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßSquareBracket); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 5276: optional.append(self.parsesquare(pos))
							πF.SetLineno(5276)
							πTemp001 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp006[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsesquare, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp001[0] = πTemp005
							if πE = πg.CheckLocal(πF, µoptional, "optional"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoptional, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoptional, "optional"); πE != nil {
								continue
							}
							πTemp001[0] = µoptional
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdefaults, "defaults"); πE != nil {
								continue
							}
							πTemp001[0] = µdefaults
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GT(πF, πTemp007, πTemp008); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 5277: if len(optional) > len(defaults):
							πF.SetLineno(5277)
						Label4:
							// line 5278: break
							πF.SetLineno(5278)
							πTemp003 = true
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							if πE = πg.CheckLocal(πF, µoptional, "optional"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µoptional); πE != nil {
								continue
							}
							πF.PushCheckpoint(7)
							πTemp003 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πTemp005, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µvalue = πTemp005
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(6)
							// line 5280: default = defaults.pop()
							πF.SetLineno(5280)
							if πE = πg.CheckLocal(πF, µdefaults, "defaults"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µdefaults, ßpop, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							µdefault = πTemp007
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µvalue, ßcontents, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp007
							if πTemp007, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.GT(πF, πTemp008, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label9
							}
							goto Label10
							// line 5281: if len(value.contents) > 0:
							πF.SetLineno(5281)
						Label9:
							// line 5282: self.values.append(value)
							πF.SetLineno(5282)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp001[0] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp005, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label11
						Label10:
							// line 5284: self.values.append(default)
							πF.SetLineno(5284)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdefault, "default"); πE != nil {
								continue
							}
							πTemp001[0] = µdefault
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp005, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label11
						Label11:
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
							// line 5285: self.values += defaults
							πF.SetLineno(5285)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefaults, "defaults"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IAdd(πF, πTemp002, µdefaults); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßvalues, πTemp005); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparseoptional.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 5273: "Parse optional parameters."
					πF.SetLineno(5273)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Parse optional parameters.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparseoptional); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 5287: def parsemandatory(self, pos, number):
					πF.SetLineno(5287)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003[2] = πg.Param{Name: "number", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("parsemandatory", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µnumber *πg.Object = πArgs[2]
						_ = µnumber
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var µparameter *πg.Object = πg.UnboundLocal
						_ = µparameter
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 5288: "Parse a number of mandatory parameters."
							πF.SetLineno(5288)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
								continue
							}
							πTemp002[0] = µnumber
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								µindex = πTemp003
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 5290: parameter = self.parsemacroparameter(pos, number - index)
							πF.SetLineno(5290)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp002[0] = µpos
							if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Sub(πF, µnumber, µindex); πE != nil {
								continue
							}
							πTemp002[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparsemacroparameter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µparameter = πTemp004
							if πE = πg.CheckLocal(πF, µparameter, "parameter"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µparameter); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label4
							}
							goto Label5
							// line 5291: if not parameter:
							πF.SetLineno(5291)
						Label4:
							// line 5292: return
							πF.SetLineno(5292)
							πR = πg.None
							continue
							goto Label5
						Label5:
							// line 5293: self.values.append(parameter)
							πF.SetLineno(5293)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparameter, "parameter"); πE != nil {
								continue
							}
							πTemp002[0] = µparameter
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsemandatory.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 5288: "Parse a number of mandatory parameters."
					πF.SetLineno(5288)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Parse a number of mandatory parameters.").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßparsemandatory); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 5295: def parsemacroparameter(self, pos, remaining):
					πF.SetLineno(5295)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003[2] = πg.Param{Name: "remaining", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("parsemacroparameter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µremaining *πg.Object = πArgs[2]
						_ = µremaining
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5296: "Parse a macro parameter. Could be a bracket or a single letter."
							πF.SetLineno(5296)
							// line 5297: "If there are just two values remaining and there is a running number,"
							πF.SetLineno(5297)
							// line 5298: "parse as two separater numbers."
							πF.SetLineno(5298)
							// line 5299: self.factory.clearskipped(pos)
							πF.SetLineno(5299)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßclearskipped, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µpos, ßfinished, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 5300: if pos.finished():
							πF.SetLineno(5300)
						Label1:
							// line 5301: return None
							πF.SetLineno(5301)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label2
						Label2:
							πTemp001 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaNumber); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßdetecttype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label3
							}
							goto Label4
							// line 5302: if self.factory.detecttype(FormulaNumber, pos):
							πF.SetLineno(5302)
						Label3:
							// line 5303: return self.parsenumbers(pos, remaining)
							πF.SetLineno(5303)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							πTemp001[1] = µremaining
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparsenumbers, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
							goto Label4
						Label4:
							// line 5304: return self.parseparameter(pos)
							πF.SetLineno(5304)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[0] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparseparameter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsemacroparameter.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 5296: "Parse a macro parameter. Could be a bracket or a single letter."
					πF.SetLineno(5296)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("Parse a macro parameter. Could be a bracket or a single letter.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßparsemacroparameter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 5306: def parsenumbers(self, pos, remaining):
					πF.SetLineno(5306)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "pos", Def: nil}
					πTemp003[2] = πg.Param{Name: "remaining", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("parsenumbers", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µpos *πg.Object = πArgs[1]
						_ = µpos
						var µremaining *πg.Object = πArgs[2]
						_ = µremaining
						var µnumber *πg.Object = πg.UnboundLocal
						_ = µnumber
						var µdigit *πg.Object = πg.UnboundLocal
						_ = µdigit
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 5307: "Parse the remaining parameters as a running number."
							πF.SetLineno(5307)
							// line 5308: "For example, 12 would be {1}{2}."
							πF.SetLineno(5308)
							// line 5309: number = self.factory.parsetype(FormulaNumber, pos)
							πF.SetLineno(5309)
							πTemp001 = πF.MakeArgs(2)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFormulaNumber); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpos, "pos"); πE != nil {
								continue
							}
							πTemp001[1] = µpos
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparsetype, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µnumber = πTemp002
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µnumber, ßoriginal, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, πTemp005, µremaining); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 5310: if not len(number.original) == remaining:
							πF.SetLineno(5310)
						Label1:
							// line 5311: return number
							πF.SetLineno(5311)
							if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
								continue
							}
							πR = µnumber
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µnumber, ßoriginal, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp006 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µdigit = πTemp003
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 5313: value = self.factory.create(FormulaNumber)
							πF.SetLineno(5313)
							πTemp001 = πF.MakeArgs(1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaNumber); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßfactory, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßcreate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µvalue = πTemp003
							// line 5314: value.add(FormulaConstant(digit))
							πF.SetLineno(5314)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdigit, "digit"); πE != nil {
								continue
							}
							πTemp008[0] = µdigit
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFormulaConstant); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µvalue, ßadd, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5315: value.type = number
							πF.SetLineno(5315)
							if πE = πg.CheckLocal(πF, µnumber, "number"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µnumber); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µvalue, ßtype, πTemp003); πE != nil {
								continue
							}
							// line 5316: self.values.append(value)
							πF.SetLineno(5316)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp001[0] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							// line 5317: return None
							πF.SetLineno(5317)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparsenumbers.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 5307: "Parse the remaining parameters as a running number."
					πF.SetLineno(5307)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Parse the remaining parameters as a running number.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßparsenumbers); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 5319: def completemacro(self, macro):
					πF.SetLineno(5319)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "macro", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("completemacro", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmacro *πg.Object = πArgs[1]
						_ = µmacro
						var µreplaced *πg.Object = πg.UnboundLocal
						_ = µreplaced
						var µparameter *πg.Object = πg.UnboundLocal
						_ = µparameter
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							case 6:
								goto Label6
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 5320: "Complete the macro with the parameters read."
							πF.SetLineno(5320)
							// line 5321: self.contents = [macro.instantiate()]
							πF.SetLineno(5321)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmacro, "macro"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmacro, ßinstantiate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßcontents, πTemp003); πE != nil {
								continue
							}
							// line 5322: replaced = [False] * len(self.values)
							πF.SetLineno(5322)
							πTemp001 = make([]*πg.Object, 1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Mul(πF, πTemp003, πTemp005); πE != nil {
								continue
							}
							µreplaced = πTemp002
							πTemp001 = πF.MakeArgs(1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßMacroParameter); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßsearchall, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µparameter = πTemp003
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 5324: index = parameter.number - 1
							πF.SetLineno(5324)
							if πE = πg.CheckLocal(πF, µparameter, "parameter"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µparameter, ßnumber, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Sub(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µindex = πTemp003
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.GE(πF, µindex, πTemp005); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 5325: if index >= len(self.values):
							πF.SetLineno(5325)
						Label4:
							// line 5326: Trace.error('Macro parameter index out of bounds: ' + unicode(index))
							πF.SetLineno(5326)
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp008[0] = µindex
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp003, πE = πg.Add(πF, πg.NewStr("Macro parameter index out of bounds: ").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßerror, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 5327: return
							πF.SetLineno(5327)
							πR = πg.None
							continue
							goto Label5
						Label5:
							// line 5328: replaced[index] = True
							πF.SetLineno(5328)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreplaced, "replaced"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp005 = µindex
							if πE = πg.SetItem(πF, µreplaced, πTemp005, πTemp004); πE != nil {
								continue
							}
							// line 5329: parameter.contents = [self.values[index].clone()]
							πF.SetLineno(5329)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp003 = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßclone, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparameter, "parameter"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µparameter, ßcontents, πTemp004); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							πTemp001 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[0] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(7)
							πTemp006 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µindex = πTemp003
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(6)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp004 = µindex
							if πE = πg.CheckLocal(πF, µreplaced, "replaced"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µreplaced, πTemp004); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label9
							}
							goto Label10
							// line 5331: if not replaced[index]:
							πF.SetLineno(5331)
						Label9:
							// line 5332: self.addfilter(index, self.values[index])
							πF.SetLineno(5332)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp001[0] = µindex
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp003 = µindex
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp005, πTemp003); πE != nil {
								continue
							}
							πTemp001[1] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßaddfilter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label10
						Label10:
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcompletemacro.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 5320: "Complete the macro with the parameters read."
					πF.SetLineno(5320)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Complete the macro with the parameters read.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßcompletemacro); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 5334: def addfilter(self, index, value):
					πF.SetLineno(5334)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "index", Def: nil}
					πTemp003[2] = πg.Param{Name: "value", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("addfilter", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindex *πg.Object = πArgs[1]
						_ = µindex
						var µvalue *πg.Object = πArgs[2]
						_ = µvalue
						var µoriginal *πg.Object = πg.UnboundLocal
						_ = µoriginal
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5335: "Add a filter for the given parameter number and parameter value."
							πF.SetLineno(5335)
							// line 5336: original = '#' + unicode(index + 1)
							πF.SetLineno(5336)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunicode); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Add(πF, πg.NewStr("#").ToObject(), πTemp004); πE != nil {
								continue
							}
							µoriginal = πTemp001
							// line 5337: value = ''.join(self.values[0].gethtml())
							πF.SetLineno(5337)
							πTemp002 = πF.MakeArgs(1)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßvalues, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp003, ßgethtml, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp001, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µvalue = πTemp003
							// line 5338: self.output.addfilter(original, value)
							πF.SetLineno(5338)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µoriginal, "original"); πE != nil {
								continue
							}
							πTemp002[0] = µoriginal
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp002[1] = µvalue
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoutput, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßaddfilter, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßaddfilter.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 5335: "Add a filter for the given parameter number and parameter value."
					πF.SetLineno(5335)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Add a filter for the given parameter number and parameter value.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßaddfilter); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("MacroFunction").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMacroFunction.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 5340: class FormulaMacro(Formula):
			πF.SetLineno(5340)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßFormula); πE != nil {
				continue
			}
			πTemp002[0] = πTemp004
			πTemp006 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp006.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FormulaMacro", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp006
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5341: "A math macro defined in an inset."
					πF.SetLineno(5341)
					// line 5341: "A math macro defined in an inset."
					πF.SetLineno(5341)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("A math macro defined in an inset.").ToObject()); πE != nil {
						continue
					}
					// line 5343: def __init__(self):
					πF.SetLineno(5343)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5344: self.parser = MacroParser()
							πF.SetLineno(5344)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßMacroParser); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparser, πTemp001); πE != nil {
								continue
							}
							// line 5345: self.output = EmptyOutput()
							πF.SetLineno(5345)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEmptyOutput); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßoutput, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 5347: def __unicode__(self):
					πF.SetLineno(5347)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("__unicode__", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 5348: "Return a printable representation."
							πF.SetLineno(5348)
							// line 5349: return 'Math macro'
							πF.SetLineno(5349)
							πR = πg.NewStr("Math macro").ToObject()
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__unicode__.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 5348: "Return a printable representation."
					πF.SetLineno(5348)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Return a printable representation.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßsys); πE != nil {
						continue
					}
					if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßversion_info, nil); πE != nil {
						continue
					}
					πTemp005 = πg.NewTuple2(πg.NewInt(3).ToObject(), πg.NewInt(0).ToObject()).ToObject()
					if πTemp004, πE = πg.GE(πF, πTemp006, πTemp005); πE != nil {
						continue
					}
					if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label1
					}
					goto Label2
					// line 5351: if sys.version_info >= (3, 0):
					πF.SetLineno(5351)
				Label1:
					// line 5352: __str__ = __unicode__
					πF.SetLineno(5352)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ß__unicode__); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ß__str__.ToObject(), πTemp004); πE != nil {
						continue
					}
					goto Label2
				Label2:
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp006.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp004, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("FormulaMacro").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp006.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFormulaMacro.ToObject(), πTemp004); πE != nil {
				continue
			}
			// line 5355: FormulaFactory.types += [ MacroParameter ]
			πF.SetLineno(5355)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaFactory); πE != nil {
				continue
			}
			if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßtypes, nil); πE != nil {
				continue
			}
			πTemp002 = make([]*πg.Object, 1)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßMacroParameter); πE != nil {
				continue
			}
			πTemp002[0] = πTemp001
			πTemp001 = πg.NewList(πTemp002...).ToObject()
			if πTemp004, πE = πg.IAdd(πF, πTemp003, πTemp001); πE != nil {
				continue
			}
			if πTemp007, πE = πg.ResolveGlobal(πF, ßFormulaFactory); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp007, ßtypes, πTemp004); πE != nil {
				continue
			}
			// line 5357: FormulaCommand.types += [
			πF.SetLineno(5357)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßtypes, nil); πE != nil {
				continue
			}
			πTemp002 = make([]*πg.Object, 1)
			if πTemp001, πE = πg.ResolveGlobal(πF, ßMacroFunction); πE != nil {
				continue
			}
			πTemp002[0] = πTemp001
			πTemp001 = πg.NewList(πTemp002...).ToObject()
			if πTemp004, πE = πg.IAdd(πF, πTemp003, πTemp001); πE != nil {
				continue
			}
			if πTemp007, πE = πg.ResolveGlobal(πF, ßFormulaCommand); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp007, ßtypes, πTemp004); πE != nil {
				continue
			}
			// line 5363: def math2html(formula):
			πF.SetLineno(5363)
			πTemp008 = make([]πg.Param, 1)
			πTemp008[0] = πg.Param{Name: "formula", Def: nil}
			πTemp001 = πg.NewFunction(πg.NewCode("math2html", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µformula *πg.Object = πArgs[0]
				_ = µformula
				var µfactory *πg.Object = πg.UnboundLocal
				_ = µfactory
				var µwhole *πg.Object = πg.UnboundLocal
				_ = µwhole
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				var πR *πg.Object
				_ = πR
				var πE *πg.BaseException
				_ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5364: "Convert some TeX math to HTML."
					πF.SetLineno(5364)
					// line 5365: factory = FormulaFactory()
					πF.SetLineno(5365)
					if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaFactory); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					µfactory = πTemp002
					// line 5366: whole = factory.parseformula(formula)
					πF.SetLineno(5366)
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µformula, "formula"); πE != nil {
						continue
					}
					πTemp003[0] = µformula
					if πE = πg.CheckLocal(πF, µfactory, "factory"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, µfactory, ßparseformula, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					µwhole = πTemp002
					// line 5367: FormulaProcessor().process(whole)
					πF.SetLineno(5367)
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
						continue
					}
					πTemp003[0] = µwhole
					if πTemp001, πE = πg.ResolveGlobal(πF, ßFormulaProcessor); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßprocess, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					// line 5368: whole.process()
					πF.SetLineno(5368)
					if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, µwhole, ßprocess, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					// line 5369: return ''.join(whole.gethtml())
					πF.SetLineno(5369)
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µwhole, "whole"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, µwhole, ßgethtml, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					πTemp003[0] = πTemp002
					if πTemp001, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					πR = πTemp002
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßmath2html.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 5364: "Convert some TeX math to HTML."
			πF.SetLineno(5364)
			// line 5364: "Convert some TeX math to HTML."
			πF.SetLineno(5364)
			if πE = πF.Globals().SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Convert some TeX math to HTML.").ToObject()); πE != nil {
				continue
			}
			if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Convert some TeX math to HTML.").ToObject()); πE != nil {
				continue
			}
			if πTemp004, πE = πg.ResolveGlobal(πF, ßmath2html); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
				continue
			}
			// line 5371: def main():
			πF.SetLineno(5371)
			πTemp008 = make([]πg.Param, 0)
			πTemp003 = πg.NewFunction(πg.NewCode("main", "/usr/lib/python2.7/site-packages/docutils/utils/math/math2html.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µargs *πg.Object = πg.UnboundLocal
				_ = µargs
				var µresult *πg.Object = πg.UnboundLocal
				_ = µresult
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []*πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 bool
				_ = πTemp005
				var πR *πg.Object
				_ = πR
				var πE *πg.BaseException
				_ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 5372: "Main function, called if invoked from elyxer.the command line"
					πF.SetLineno(5372)
					// line 5373: args = sys.argv
					πF.SetLineno(5373)
					if πTemp001, πE = πg.ResolveGlobal(πF, ßsys); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßargv, nil); πE != nil {
						continue
					}
					µargs = πTemp002
					// line 5374: Options().parseoptions(args)
					πF.SetLineno(5374)
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					πTemp003[0] = µargs
					if πTemp001, πE = πg.ResolveGlobal(πF, ßOptions); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßparseoptions, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					πTemp003[0] = µargs
					if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					if πTemp001, πE = πg.NE(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
						continue
					}
					if πTemp005 {
						goto Label1
					}
					goto Label2
					// line 5375: if len(args) != 1:
					πF.SetLineno(5375)
				Label1:
					// line 5376: Trace.error('Usage: math2html.py escaped_string')
					πF.SetLineno(5376)
					πTemp003 = πF.MakeArgs(1)
					πTemp003[0] = πg.NewStr("Usage: math2html.py escaped_string").ToObject()
					if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					// line 5377: exit()
					πF.SetLineno(5377)
					if πTemp001, πE = πg.ResolveGlobal(πF, ßexit); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					goto Label2
				Label2:
					// line 5378: result = math2html(args[0])
					πF.SetLineno(5378)
					πTemp003 = πF.MakeArgs(1)
					πTemp001 = πg.NewInt(0).ToObject()
					if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetItem(πF, µargs, πTemp001); πE != nil {
						continue
					}
					πTemp003[0] = πTemp002
					if πTemp001, πE = πg.ResolveGlobal(πF, ßmath2html); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
					µresult = πTemp002
					// line 5379: Trace.message(result)
					πF.SetLineno(5379)
					πTemp003 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
						continue
					}
					πTemp003[0] = µresult
					if πTemp001, πE = πg.ResolveGlobal(πF, ßTrace); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßmessage, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp003)
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßmain.ToObject(), πTemp003); πE != nil {
				continue
			}
			// line 5372: "Main function, called if invoked from elyxer.the command line"
			πF.SetLineno(5372)
			if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Main function, called if invoked from elyxer.the command line").ToObject()); πE != nil {
				continue
			}
			if πTemp007, πE = πg.ResolveGlobal(πF, ßmain); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp004); πE != nil {
				continue
			}
			if πTemp007, πE = πg.ResolveGlobal(πF, ß__name__); πE != nil {
				continue
			}
			if πTemp004, πE = πg.Eq(πF, πTemp007, ß__main__.ToObject()); πE != nil {
				continue
			}
			if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
				continue
			}
			if πTemp005 {
				goto Label6
			}
			goto Label7
			// line 5381: if __name__ == '__main__':
			πF.SetLineno(5381)
		Label6:
			// line 5382: main()
			πF.SetLineno(5382)
			if πTemp004, πE = πg.ResolveGlobal(πF, ßmain); πE != nil {
				continue
			}
			if πTemp007, πE = πTemp004.Call(πF, nil, nil); πE != nil {
				continue
			}
			goto Label7
		Label7:
		}
		return nil, πE
	})
	πg.RegisterModule("math2html", Code)
}

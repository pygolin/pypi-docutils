package states

import (
	_ "github.com/pygolin/pypi-docutils"
	πg "github.com/pygolin/runtime"
	_ "github.com/pygolin/stdlib/pkg/re"
	_ "github.com/pygolin/stdlib/pkg/sys"
	_ "github.com/pygolin/stdlib/pkg/types"
)

var Code *πg.Code

func init() {
	Code = πg.NewCode("<module>", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
		var πR *πg.Object
		_ = πR
		var πE *πg.BaseException
		_ = πE
		ß := πg.InternStr("")
		ßA := πg.InternStr("A")
		ßApplicationError := πg.InternStr("ApplicationError")
		ßBody := πg.InternStr("Body")
		ßBulletList := πg.InternStr("BulletList")
		ßDataError := πg.InternStr("DataError")
		ßDefinition := πg.InternStr("Definition")
		ßDefinitionList := πg.InternStr("DefinitionList")
		ßDirectiveError := πg.InternStr("DirectiveError")
		ßEOFError := πg.InternStr("EOFError")
		ßElement := πg.InternStr("Element")
		ßEnumeratedList := πg.InternStr("EnumeratedList")
		ßException := πg.InternStr("Exception")
		ßExplicit := πg.InternStr("Explicit")
		ßExtensionOptionError := πg.InternStr("ExtensionOptionError")
		ßExtensionOptions := πg.InternStr("ExtensionOptions")
		ßFalse := πg.InternStr("False")
		ßFieldList := πg.InternStr("FieldList")
		ßFunctionType := πg.InternStr("FunctionType")
		ßGridTableParser := πg.InternStr("GridTableParser")
		ßI := πg.InternStr("I")
		ßIndexError := πg.InternStr("IndexError")
		ßInline := πg.InternStr("Inline")
		ßInliner := πg.InternStr("Inliner")
		ßInterpretedRoleNotImplementedError := πg.InternStr("InterpretedRoleNotImplementedError")
		ßInvalidRomanNumeralError := πg.InternStr("InvalidRomanNumeralError")
		ßKeyError := πg.InternStr("KeyError")
		ßLine := πg.InternStr("Line")
		ßLineBlock := πg.InternStr("LineBlock")
		ßMarkupError := πg.InternStr("MarkupError")
		ßMarkupMismatch := πg.InternStr("MarkupMismatch")
		ßMethodType := πg.InternStr("MethodType")
		ßNestedStateMachine := πg.InternStr("NestedStateMachine")
		ßNode := πg.InternStr("Node")
		ßNone := πg.InternStr("None")
		ßOptionList := πg.InternStr("OptionList")
		ßPEP := πg.InternStr("PEP")
		ßParserError := πg.InternStr("ParserError")
		ßQuotedLiteralBlock := πg.InternStr("QuotedLiteralBlock")
		ßRFC := πg.InternStr("RFC")
		ßRFC2822Body := πg.InternStr("RFC2822Body")
		ßRFC2822List := πg.InternStr("RFC2822List")
		ßRSTState := πg.InternStr("RSTState")
		ßRSTStateMachine := πg.InternStr("RSTStateMachine")
		ßRomanError := πg.InternStr("RomanError")
		ßSimpleTableParser := πg.InternStr("SimpleTableParser")
		ßSpecializedBody := πg.InternStr("SpecializedBody")
		ßSpecializedText := πg.InternStr("SpecializedText")
		ßStateCorrection := πg.InternStr("StateCorrection")
		ßStateMachineWS := πg.InternStr("StateMachineWS")
		ßStateWS := πg.InternStr("StateWS")
		ßStruct := πg.InternStr("Struct")
		ßSubstitutionDef := πg.InternStr("SubstitutionDef")
		ßTableMarkupError := πg.InternStr("TableMarkupError")
		ßTableParser := πg.InternStr("TableParser")
		ßText := πg.InternStr("Text")
		ßTransitionCorrection := πg.InternStr("TransitionCorrection")
		ßTrue := πg.InternStr("True")
		ßTypeError := πg.InternStr("TypeError")
		ßUNICODE := πg.InternStr("UNICODE")
		ßUnexpectedIndentationError := πg.InternStr("UnexpectedIndentationError")
		ßUnknownInterpretedRoleError := πg.InternStr("UnknownInterpretedRoleError")
		ßVERBOSE := πg.InternStr("VERBOSE")
		ßValueError := πg.InternStr("ValueError")
		ß_ := πg.InternStr("_")
		ß__ := πg.InternStr("__")
		ß__class__ := πg.InternStr("__class__")
		ß__dict__ := πg.InternStr("__dict__")
		ß__doc__ := πg.InternStr("__doc__")
		ß__docformat__ := πg.InternStr("__docformat__")
		ß__init__ := πg.InternStr("__init__")
		ß__metaclass__ := πg.InternStr("__metaclass__")
		ß__module__ := πg.InternStr("__module__")
		ß__name__ := πg.InternStr("__name__")
		ß_fallback_language_module := πg.InternStr("_fallback_language_module")
		ß_loweralpha_to_int := πg.InternStr("_loweralpha_to_int")
		ß_lowerroman_to_int := πg.InternStr("_lowerroman_to_int")
		ß_upperalpha_to_int := πg.InternStr("_upperalpha_to_int")
		ßa := πg.InternStr("a")
		ßabs_line_number := πg.InternStr("abs_line_number")
		ßabs_line_offset := πg.InternStr("abs_line_offset")
		ßadd_backref := πg.InternStr("add_backref")
		ßadd_target := πg.InternStr("add_target")
		ßadd_transition := πg.InternStr("add_transition")
		ßadjust_uri := πg.InternStr("adjust_uri")
		ßalpha := πg.InternStr("alpha")
		ßalphanum := πg.InternStr("alphanum")
		ßalphanumplus := πg.InternStr("alphanumplus")
		ßanonymous := πg.InternStr("anonymous")
		ßanonymous_reference := πg.InternStr("anonymous_reference")
		ßanonymous_target := πg.InternStr("anonymous_target")
		ßappend := πg.InternStr("append")
		ßarabic := πg.InternStr("arabic")
		ßargs := πg.InternStr("args")
		ßastext := πg.InternStr("astext")
		ßat_eof := πg.InternStr("at_eof")
		ßattach_observer := πg.InternStr("attach_observer")
		ßattributes := πg.InternStr("attributes")
		ßattribution := πg.InternStr("attribution")
		ßattribution_pattern := πg.InternStr("attribution_pattern")
		ßauto := πg.InternStr("auto")
		ßbackquote := πg.InternStr("backquote")
		ßblank := πg.InternStr("blank")
		ßblank_finish := πg.InternStr("blank_finish")
		ßblock_quote := πg.InternStr("block_quote")
		ßbof := πg.InternStr("bof")
		ßbuild_regexp := πg.InternStr("build_regexp")
		ßbuild_table := πg.InternStr("build_table")
		ßbuild_table_row := πg.InternStr("build_table_row")
		ßbullet := πg.InternStr("bullet")
		ßbullet_list := πg.InternStr("bullet_list")
		ßcharacter_level_inline_markup := πg.InternStr("character_level_inline_markup")
		ßcheck_attribution := πg.InternStr("check_attribution")
		ßcheck_subsection := πg.InternStr("check_subsection")
		ßchildren := πg.InternStr("children")
		ßchr := πg.InternStr("chr")
		ßcitation := πg.InternStr("citation")
		ßcitation_reference := πg.InternStr("citation_reference")
		ßcitationlabel := πg.InternStr("citationlabel")
		ßclasses := πg.InternStr("classes")
		ßclassifier := πg.InternStr("classifier")
		ßclassifier_delimiter := πg.InternStr("classifier_delimiter")
		ßclosers := πg.InternStr("closers")
		ßclosing_delimiters := πg.InternStr("closing_delimiters")
		ßcolspec := πg.InternStr("colspec")
		ßcolumn_width := πg.InternStr("column_width")
		ßcomment := πg.InternStr("comment")
		ßcompile := πg.InternStr("compile")
		ßconstructs := πg.InternStr("constructs")
		ßconvert_directive_function := πg.InternStr("convert_directive_function")
		ßconverters := πg.InternStr("converters")
		ßcopy := πg.InternStr("copy")
		ßdebug := πg.InternStr("debug")
		ßdefinition := πg.InternStr("definition")
		ßdefinition_list := πg.InternStr("definition_list")
		ßdefinition_list_item := πg.InternStr("definition_list_item")
		ßdelimiters := πg.InternStr("delimiters")
		ßdescription := πg.InternStr("description")
		ßdirective := πg.InternStr("directive")
		ßdirectives := πg.InternStr("directives")
		ßdisallowed_inside_substitution_definitions := πg.InternStr("disallowed_inside_substitution_definitions")
		ßdisconnect := πg.InternStr("disconnect")
		ßdispatch := πg.InternStr("dispatch")
		ßdoctest := πg.InternStr("doctest")
		ßdoctest_block := πg.InternStr("doctest_block")
		ßdocument := πg.InternStr("document")
		ßdocutils := πg.InternStr("docutils")
		ßdouble_width_pad_char := πg.InternStr("double_width_pad_char")
		ßemail := πg.InternStr("email")
		ßemail_pattern := πg.InternStr("email_pattern")
		ßemailc := πg.InternStr("emailc")
		ßembedded_directive := πg.InternStr("embedded_directive")
		ßembedded_link := πg.InternStr("embedded_link")
		ßemphasis := πg.InternStr("emphasis")
		ßend := πg.InternStr("end")
		ßend_string_suffix := πg.InternStr("end_string_suffix")
		ßendswith := πg.InternStr("endswith")
		ßentry := πg.InternStr("entry")
		ßenum := πg.InternStr("enum")
		ßenumerate := πg.InternStr("enumerate")
		ßenumerated_list := πg.InternStr("enumerated_list")
		ßenumerator := πg.InternStr("enumerator")
		ßenumtype := πg.InternStr("enumtype")
		ßeof := πg.InternStr("eof")
		ßeofcheck := πg.InternStr("eofcheck")
		ßerror := πg.InternStr("error")
		ßescape := πg.InternStr("escape")
		ßescape2null := πg.InternStr("escape2null")
		ßexplicit := πg.InternStr("explicit")
		ßexplicit_construct := πg.InternStr("explicit_construct")
		ßexplicit_list := πg.InternStr("explicit_list")
		ßexplicit_markup := πg.InternStr("explicit_markup")
		ßextend := πg.InternStr("extend")
		ßextract_extension_options := πg.InternStr("extract_extension_options")
		ßfield := πg.InternStr("field")
		ßfield_body := πg.InternStr("field_body")
		ßfield_list := πg.InternStr("field_list")
		ßfield_marker := πg.InternStr("field_marker")
		ßfield_name := πg.InternStr("field_name")
		ßfinal_argument_whitespace := πg.InternStr("final_argument_whitespace")
		ßfind := πg.InternStr("find")
		ßfnend := πg.InternStr("fnend")
		ßfootnote := πg.InternStr("footnote")
		ßfootnote_reference := πg.InternStr("footnote_reference")
		ßfootnotelabel := πg.InternStr("footnotelabel")
		ßformat := πg.InternStr("format")
		ßformatinfo := πg.InternStr("formatinfo")
		ßformats := πg.InternStr("formats")
		ßfromRoman := πg.InternStr("fromRoman")
		ßfully_normalize_name := πg.InternStr("fully_normalize_name")
		ßget := πg.InternStr("get")
		ßget_first_known_indented := πg.InternStr("get_first_known_indented")
		ßget_indented := πg.InternStr("get_indented")
		ßget_known_indented := πg.InternStr("get_known_indented")
		ßget_language := πg.InternStr("get_language")
		ßget_source_and_line := πg.InternStr("get_source_and_line")
		ßget_text_block := πg.InternStr("get_text_block")
		ßget_trim_footnote_ref_space := πg.InternStr("get_trim_footnote_ref_space")
		ßgetattr := πg.InternStr("getattr")
		ßgoto_line := πg.InternStr("goto_line")
		ßgrid_table_top := πg.InternStr("grid_table_top")
		ßgrid_table_top_pat := πg.InternStr("grid_table_top_pat")
		ßgroup := πg.InternStr("group")
		ßgroupdict := πg.InternStr("groupdict")
		ßhas_content := πg.InternStr("has_content")
		ßhasattr := πg.InternStr("hasattr")
		ßhyperlink_target := πg.InternStr("hyperlink_target")
		ßi := πg.InternStr("i")
		ßids := πg.InternStr("ids")
		ßimplicit_dispatch := πg.InternStr("implicit_dispatch")
		ßimplicit_inline := πg.InternStr("implicit_inline")
		ßindent := πg.InternStr("indent")
		ßindex := πg.InternStr("index")
		ßindirect_reference_name := πg.InternStr("indirect_reference_name")
		ßinfo := πg.InternStr("info")
		ßinit_customizations := πg.InternStr("init_customizations")
		ßinitial := πg.InternStr("initial")
		ßinitial_inline := πg.InternStr("initial_inline")
		ßinitial_lineno := πg.InternStr("initial_lineno")
		ßinitial_quoted := πg.InternStr("initial_quoted")
		ßinitial_state := πg.InternStr("initial_state")
		ßinitial_transitions := πg.InternStr("initial_transitions")
		ßinline_internal_target := πg.InternStr("inline_internal_target")
		ßinline_obj := πg.InternStr("inline_obj")
		ßinline_text := πg.InternStr("inline_text")
		ßinliner := πg.InternStr("inliner")
		ßinput_lines := πg.InternStr("input_lines")
		ßinsert := πg.InternStr("insert")
		ßint := πg.InternStr("int")
		ßinterpreted := πg.InternStr("interpreted")
		ßinterpreted_or_phrase_ref := πg.InternStr("interpreted_or_phrase_ref")
		ßinvalid_input := πg.InternStr("invalid_input")
		ßis_enumerated_list_item := πg.InternStr("is_enumerated_list_item")
		ßis_next_line_blank := πg.InternStr("is_next_line_blank")
		ßis_reference := πg.InternStr("is_reference")
		ßisinstance := πg.InternStr("isinstance")
		ßisolate_grid_table := πg.InternStr("isolate_grid_table")
		ßisolate_simple_table := πg.InternStr("isolate_simple_table")
		ßitems := πg.InternStr("items")
		ßjoin := πg.InternStr("join")
		ßkeys := πg.InternStr("keys")
		ßlabel := πg.InternStr("label")
		ßlanguage := πg.InternStr("language")
		ßlanguage_code := πg.InternStr("language_code")
		ßlanguages := πg.InternStr("languages")
		ßlastordinal := πg.InternStr("lastordinal")
		ßlen := πg.InternStr("len")
		ßlevel := πg.InternStr("level")
		ßline := πg.InternStr("line")
		ßline_block := πg.InternStr("line_block")
		ßline_block_line := πg.InternStr("line_block_line")
		ßline_offset := πg.InternStr("line_offset")
		ßlist := πg.InternStr("list")
		ßlist_item := πg.InternStr("list_item")
		ßliteral := πg.InternStr("literal")
		ßliteral_block := πg.InternStr("literal_block")
		ßlocals := πg.InternStr("locals")
		ßlongopt := πg.InternStr("longopt")
		ßlower := πg.InternStr("lower")
		ßloweralpha := πg.InternStr("loweralpha")
		ßlowerroman := πg.InternStr("lowerroman")
		ßlstrip := πg.InternStr("lstrip")
		ßmake_enumerator := πg.InternStr("make_enumerator")
		ßmake_target := πg.InternStr("make_target")
		ßmalformed_table := πg.InternStr("malformed_table")
		ßmatch := πg.InternStr("match")
		ßmatch_chars := πg.InternStr("match_chars")
		ßmatch_titles := πg.InternStr("match_titles")
		ßmemo := πg.InternStr("memo")
		ßmessages := πg.InternStr("messages")
		ßmin := πg.InternStr("min")
		ßmorecols := πg.InternStr("morecols")
		ßmorerows := πg.InternStr("morerows")
		ßmsg := πg.InternStr("msg")
		ßname := πg.InternStr("name")
		ßnames := πg.InternStr("names")
		ßnest_line_block_lines := πg.InternStr("nest_line_block_lines")
		ßnest_line_block_segment := πg.InternStr("nest_line_block_segment")
		ßnested_list_parse := πg.InternStr("nested_list_parse")
		ßnested_parse := πg.InternStr("nested_parse")
		ßnested_sm := πg.InternStr("nested_sm")
		ßnested_sm_cache := πg.InternStr("nested_sm_cache")
		ßnested_sm_kwargs := πg.InternStr("nested_sm_kwargs")
		ßnew_subsection := πg.InternStr("new_subsection")
		ßnext_line := πg.InternStr("next_line")
		ßno_match := πg.InternStr("no_match")
		ßnode := πg.InternStr("node")
		ßnodes := πg.InternStr("nodes")
		ßnon_unescaped_whitespace_escape_before := πg.InternStr("non_unescaped_whitespace_escape_before")
		ßnon_whitespace_after := πg.InternStr("non_whitespace_after")
		ßnon_whitespace_before := πg.InternStr("non_whitespace_before")
		ßnon_whitespace_escape_before := πg.InternStr("non_whitespace_escape_before")
		ßnonalphanum7bit := πg.InternStr("nonalphanum7bit")
		ßnormalize_name := πg.InternStr("normalize_name")
		ßnote_anonymous_target := πg.InternStr("note_anonymous_target")
		ßnote_autofootnote := πg.InternStr("note_autofootnote")
		ßnote_autofootnote_ref := πg.InternStr("note_autofootnote_ref")
		ßnote_citation := πg.InternStr("note_citation")
		ßnote_citation_ref := πg.InternStr("note_citation_ref")
		ßnote_explicit_target := πg.InternStr("note_explicit_target")
		ßnote_footnote := πg.InternStr("note_footnote")
		ßnote_footnote_ref := πg.InternStr("note_footnote_ref")
		ßnote_implicit_target := πg.InternStr("note_implicit_target")
		ßnote_indirect_target := πg.InternStr("note_indirect_target")
		ßnote_refname := πg.InternStr("note_refname")
		ßnote_source := πg.InternStr("note_source")
		ßnote_substitution_def := πg.InternStr("note_substitution_def")
		ßnote_substitution_ref := πg.InternStr("note_substitution_ref")
		ßnote_symbol_footnote := πg.InternStr("note_symbol_footnote")
		ßnote_symbol_footnote_ref := πg.InternStr("note_symbol_footnote_ref")
		ßobject := πg.InternStr("object")
		ßoffset := πg.InternStr("offset")
		ßopeners := πg.InternStr("openers")
		ßoptarg := πg.InternStr("optarg")
		ßoption := πg.InternStr("option")
		ßoption_argument := πg.InternStr("option_argument")
		ßoption_group := πg.InternStr("option_group")
		ßoption_list := πg.InternStr("option_list")
		ßoption_list_item := πg.InternStr("option_list_item")
		ßoption_marker := πg.InternStr("option_marker")
		ßoption_spec := πg.InternStr("option_spec")
		ßoption_string := πg.InternStr("option_string")
		ßoptional_arguments := πg.InternStr("optional_arguments")
		ßoptname := πg.InternStr("optname")
		ßord := πg.InternStr("ord")
		ßpad_double_width := πg.InternStr("pad_double_width")
		ßparagraph := πg.InternStr("paragraph")
		ßparens := πg.InternStr("parens")
		ßparent := πg.InternStr("parent")
		ßparse := πg.InternStr("parse")
		ßparse_attribution := πg.InternStr("parse_attribution")
		ßparse_directive_arguments := πg.InternStr("parse_directive_arguments")
		ßparse_directive_block := πg.InternStr("parse_directive_block")
		ßparse_directive_options := πg.InternStr("parse_directive_options")
		ßparse_enumerator := πg.InternStr("parse_enumerator")
		ßparse_extension_options := πg.InternStr("parse_extension_options")
		ßparse_field_body := πg.InternStr("parse_field_body")
		ßparse_field_marker := πg.InternStr("parse_field_marker")
		ßparse_option_marker := πg.InternStr("parse_option_marker")
		ßparse_target := πg.InternStr("parse_target")
		ßparsers := πg.InternStr("parsers")
		ßparts := πg.InternStr("parts")
		ßpats := πg.InternStr("pats")
		ßpatterns := πg.InternStr("patterns")
		ßpep := πg.InternStr("pep")
		ßpep_base_url := πg.InternStr("pep_base_url")
		ßpep_file_url_template := πg.InternStr("pep_file_url_template")
		ßpep_reference := πg.InternStr("pep_reference")
		ßpep_references := πg.InternStr("pep_references")
		ßpepnum1 := πg.InternStr("pepnum1")
		ßpepnum2 := πg.InternStr("pepnum2")
		ßperiod := πg.InternStr("period")
		ßpformat := πg.InternStr("pformat")
		ßphrase := πg.InternStr("phrase")
		ßphrase_ref := πg.InternStr("phrase_ref")
		ßpop := πg.InternStr("pop")
		ßprefix := πg.InternStr("prefix")
		ßprevious_line := πg.InternStr("previous_line")
		ßproblematic := πg.InternStr("problematic")
		ßpunctuation_chars := πg.InternStr("punctuation_chars")
		ßquoted := πg.InternStr("quoted")
		ßquoted_literal_block := πg.InternStr("quoted_literal_block")
		ßquoted_start := πg.InternStr("quoted_start")
		ßrange := πg.InternStr("range")
		ßrawsource := πg.InternStr("rawsource")
		ßre := πg.InternStr("re")
		ßreStructuredText := πg.InternStr("reStructuredText")
		ßrefend := πg.InternStr("refend")
		ßreference := πg.InternStr("reference")
		ßreferenced := πg.InternStr("referenced")
		ßrefname := πg.InternStr("refname")
		ßrefuri := πg.InternStr("refuri")
		ßremove_transition := πg.InternStr("remove_transition")
		ßreplace := πg.InternStr("replace")
		ßreporter := πg.InternStr("reporter")
		ßrequired_arguments := πg.InternStr("required_arguments")
		ßrfc := πg.InternStr("rfc")
		ßrfc2822 := πg.InternStr("rfc2822")
		ßrfc2822_field := πg.InternStr("rfc2822_field")
		ßrfc_base_url := πg.InternStr("rfc_base_url")
		ßrfc_reference := πg.InternStr("rfc_reference")
		ßrfc_references := πg.InternStr("rfc_references")
		ßrfc_url := πg.InternStr("rfc_url")
		ßrfcnum := πg.InternStr("rfcnum")
		ßrfind := πg.InternStr("rfind")
		ßrole := πg.InternStr("role")
		ßroles := πg.InternStr("roles")
		ßroman := πg.InternStr("roman")
		ßrow := πg.InternStr("row")
		ßrparen := πg.InternStr("rparen")
		ßrst := πg.InternStr("rst")
		ßrstrip := πg.InternStr("rstrip")
		ßrun := πg.InternStr("run")
		ßrun_directive := πg.InternStr("run_directive")
		ßruntime_init := πg.InternStr("runtime_init")
		ßscheme := πg.InternStr("scheme")
		ßschemes := πg.InternStr("schemes")
		ßsearch := πg.InternStr("search")
		ßsection := πg.InternStr("section")
		ßsection_bubble_up_kludge := πg.InternStr("section_bubble_up_kludge")
		ßsection_level := πg.InternStr("section_level")
		ßsequence := πg.InternStr("sequence")
		ßsequencepats := πg.InternStr("sequencepats")
		ßsequenceregexps := πg.InternStr("sequenceregexps")
		ßsequences := πg.InternStr("sequences")
		ßset_id := πg.InternStr("set_id")
		ßsetattr := πg.InternStr("setattr")
		ßsettings := πg.InternStr("settings")
		ßsevere := πg.InternStr("severe")
		ßshort_overline := πg.InternStr("short_overline")
		ßshortopt := πg.InternStr("shortopt")
		ßsimple := πg.InternStr("simple")
		ßsimple_table_border_pat := πg.InternStr("simple_table_border_pat")
		ßsimple_table_top := πg.InternStr("simple_table_top")
		ßsimple_table_top_pat := πg.InternStr("simple_table_top_pat")
		ßsimplename := πg.InternStr("simplename")
		ßsource := πg.InternStr("source")
		ßsplit := πg.InternStr("split")
		ßsplit_attribution := πg.InternStr("split_attribution")
		ßsplit_escaped_whitespace := πg.InternStr("split_escaped_whitespace")
		ßstandalone_uri := πg.InternStr("standalone_uri")
		ßstart := πg.InternStr("start")
		ßstart_string_prefix := πg.InternStr("start_string_prefix")
		ßstartswith := πg.InternStr("startswith")
		ßstate_classes := πg.InternStr("state_classes")
		ßstate_correction := πg.InternStr("state_correction")
		ßstate_machine := πg.InternStr("state_machine")
		ßstatemachine := πg.InternStr("statemachine")
		ßstates := πg.InternStr("states")
		ßstr := πg.InternStr("str")
		ßstring := πg.InternStr("string")
		ßstrip := πg.InternStr("strip")
		ßstrong := πg.InternStr("strong")
		ßstub := πg.InternStr("stub")
		ßsubstitution := πg.InternStr("substitution")
		ßsubstitution_def := πg.InternStr("substitution_def")
		ßsubstitution_definition := πg.InternStr("substitution_definition")
		ßsubstitution_ref := πg.InternStr("substitution_ref")
		ßsubstitution_reference := πg.InternStr("substitution_reference")
		ßsuffix := πg.InternStr("suffix")
		ßsys := πg.InternStr("sys")
		ßsystem_message := πg.InternStr("system_message")
		ßtable := πg.InternStr("table")
		ßtable_top := πg.InternStr("table_top")
		ßtableparser := πg.InternStr("tableparser")
		ßtagname := πg.InternStr("tagname")
		ßtarget := πg.InternStr("target")
		ßtbody := πg.InternStr("tbody")
		ßterm := πg.InternStr("term")
		ßtext := πg.InternStr("text")
		ßtgroup := πg.InternStr("tgroup")
		ßthead := πg.InternStr("thead")
		ßtitle := πg.InternStr("title")
		ßtitle_inconsistent := πg.InternStr("title_inconsistent")
		ßtitle_styles := πg.InternStr("title_styles")
		ßtoRoman := πg.InternStr("toRoman")
		ßtransition := πg.InternStr("transition")
		ßtransitions := πg.InternStr("transitions")
		ßtraverse := πg.InternStr("traverse")
		ßtrim_end := πg.InternStr("trim_end")
		ßtrim_left := πg.InternStr("trim_left")
		ßtrim_start := πg.InternStr("trim_start")
		ßtuple := πg.InternStr("tuple")
		ßunderline := πg.InternStr("underline")
		ßunescape := πg.InternStr("unescape")
		ßunindent_warning := πg.InternStr("unindent_warning")
		ßunknown_directive := πg.InternStr("unknown_directive")
		ßunlink := πg.InternStr("unlink")
		ßupdate := πg.InternStr("update")
		ßupper := πg.InternStr("upper")
		ßupperalpha := πg.InternStr("upperalpha")
		ßupperroman := πg.InternStr("upperroman")
		ßuri := πg.InternStr("uri")
		ßuri_end := πg.InternStr("uri_end")
		ßuri_end_delim := πg.InternStr("uri_end_delim")
		ßuric := πg.InternStr("uric")
		ßurilast := πg.InternStr("urilast")
		ßurischemes := πg.InternStr("urischemes")
		ßutils := πg.InternStr("utils")
		ßvars := πg.InternStr("vars")
		ßwarning := πg.InternStr("warning")
		ßwhitespace_normalize_name := πg.InternStr("whitespace_normalize_name")
		ßwhole := πg.InternStr("whole")
		var πTemp001 *πg.Object
		_ = πTemp001
		var πTemp002 []*πg.Object
		_ = πTemp002
		var πTemp003 *πg.Object
		_ = πTemp003
		var πTemp004 *πg.Dict
		_ = πTemp004
		var πTemp005 *πg.Object
		_ = πTemp005
		var πTemp006 []πg.Param
		_ = πTemp006
		var πTemp007 *πg.Object
		_ = πTemp007
		var πTemp008 *πg.Object
		_ = πTemp008
		var πTemp009 *πg.Object
		_ = πTemp009
		var πTemp010 *πg.Object
		_ = πTemp010
		for ; πF.State() >= 0; πF.PopCheckpoint() {
			switch πF.State() {
			case 0:
			default:
				panic("unexpected function state")
			}
			// line 5: """
			πF.SetLineno(5)
			// line 5: """
			πF.SetLineno(5)
			if πE = πF.Globals().SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\nThis is the ``docutils.parsers.rst.states`` module, the core of\nthe reStructuredText parser.  It defines the following:\n\n:Classes:\n    - `RSTStateMachine`: reStructuredText parser's entry point.\n    - `NestedStateMachine`: recursive StateMachine.\n    - `RSTState`: reStructuredText State superclass.\n    - `Inliner`: For parsing inline markup.\n    - `Body`: Generic classifier of the first line of a block.\n    - `SpecializedBody`: Superclass for compound element members.\n    - `BulletList`: Second and subsequent bullet_list list_items\n    - `DefinitionList`: Second+ definition_list_items.\n    - `EnumeratedList`: Second+ enumerated_list list_items.\n    - `FieldList`: Second+ fields.\n    - `OptionList`: Second+ option_list_items.\n    - `RFC2822List`: Second+ RFC2822-style fields.\n    - `ExtensionOptions`: Parses directive option fields.\n    - `Explicit`: Second+ explicit markup constructs.\n    - `SubstitutionDef`: For embedded directives in substitution definitions.\n    - `Text`: Classifier of second line of a text block.\n    - `SpecializedText`: Superclass for continuation lines of Text-variants.\n    - `Definition`: Second line of potential definition_list_item.\n    - `Line`: Second line of overlined section title or transition marker.\n    - `Struct`: An auxiliary collection class.\n\n:Exception classes:\n    - `MarkupError`\n    - `ParserError`\n    - `MarkupMismatch`\n\n:Functions:\n    - `escape2null()`: Return a string, escape-backslashes converted to nulls.\n    - `unescape()`: Return a string, nulls removed or restored to backslashes.\n\n:Attributes:\n    - `state_classes`: set of State classes used with `RSTStateMachine`.\n\nParser Overview\n===============\n\nThe reStructuredText parser is implemented as a recursive state machine,\nexamining its input one line at a time.  To understand how the parser works,\nplease first become familiar with the `docutils.statemachine` module.  In the\ndescription below, references are made to classes defined in this module;\nplease see the individual classes for details.\n\nParsing proceeds as follows:\n\n1. The state machine examines each line of input, checking each of the\n   transition patterns of the state `Body`, in order, looking for a match.\n   The implicit transitions (blank lines and indentation) are checked before\n   any others.  The 'text' transition is a catch-all (matches anything).\n\n2. The method associated with the matched transition pattern is called.\n\n   A. Some transition methods are self-contained, appending elements to the\n      document tree (`Body.doctest` parses a doctest block).  The parser's\n      current line index is advanced to the end of the element, and parsing\n      continues with step 1.\n\n   B. Other transition methods trigger the creation of a nested state machine,\n      whose job is to parse a compound construct ('indent' does a block quote,\n      'bullet' does a bullet list, 'overline' does a section [first checking\n      for a valid section header], etc.).\n\n      - In the case of lists and explicit markup, a one-off state machine is\n        created and run to parse contents of the first item.\n\n      - A new state machine is created and its initial state is set to the\n        appropriate specialized state (`BulletList` in the case of the\n        'bullet' transition; see `SpecializedBody` for more detail).  This\n        state machine is run to parse the compound element (or series of\n        explicit markup elements), and returns as soon as a non-member element\n        is encountered.  For example, the `BulletList` state machine ends as\n        soon as it encounters an element which is not a list item of that\n        bullet list.  The optional omission of inter-element blank lines is\n        enabled by this nested state machine.\n\n      - The current line index is advanced to the end of the elements parsed,\n        and parsing continues with step 1.\n\n   C. The result of the 'text' transition depends on the next line of text.\n      The current state is changed to `Text`, under which the second line is\n      examined.  If the second line is:\n\n      - Indented: The element is a definition list item, and parsing proceeds\n        similarly to step 2.B, using the `DefinitionList` state.\n\n      - A line of uniform punctuation characters: The element is a section\n        header; again, parsing proceeds as in step 2.B, and `Body` is still\n        used.\n\n      - Anything else: The element is a paragraph, which is examined for\n        inline markup and appended to the parent element.  Processing\n        continues with step 1.\n").ToObject()); πE != nil {
				continue
			}
			// line 103: __docformat__ = 'reStructuredText'
			πF.SetLineno(103)
			if πE = πF.Globals().SetItem(πF, ß__docformat__.ToObject(), ßreStructuredText.ToObject()); πE != nil {
				continue
			}
			// line 106: import sys
			πF.SetLineno(106)
			if πTemp002, πE = πg.ImportModule(πF, "sys"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßsys.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 107: import re
			πF.SetLineno(107)
			if πTemp002, πE = πg.ImportModule(πF, "re"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßre.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 108: from types import FunctionType, MethodType
			πF.SetLineno(108)
			if πTemp002, πE = πg.ImportModule(πF, "types"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßFunctionType); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFunctionType.ToObject(), πTemp003); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßMethodType); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMethodType.ToObject(), πTemp003); πE != nil {
				continue
			}
			// line 110: from docutils import nodes, statemachine, utils
			πF.SetLineno(110)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.nodes"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πE = πF.Globals().SetItem(πF, ßnodes.ToObject(), πTemp001); πE != nil {
				continue
			}
			if πTemp002, πE = πg.ImportModule(πF, "docutils.statemachine"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πE = πF.Globals().SetItem(πF, ßstatemachine.ToObject(), πTemp001); πE != nil {
				continue
			}
			if πTemp002, πE = πg.ImportModule(πF, "docutils.utils"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πE = πF.Globals().SetItem(πF, ßutils.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 111: from docutils import ApplicationError, DataError
			πF.SetLineno(111)
			if πTemp002, πE = πg.ImportModule(πF, "docutils"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßApplicationError); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßApplicationError.ToObject(), πTemp003); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßDataError); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßDataError.ToObject(), πTemp003); πE != nil {
				continue
			}
			// line 112: from docutils.statemachine import StateMachineWS, StateWS
			πF.SetLineno(112)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.statemachine"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßStateMachineWS); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStateMachineWS.ToObject(), πTemp003); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßStateWS); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStateWS.ToObject(), πTemp003); πE != nil {
				continue
			}
			// line 113: from docutils.nodes import fully_normalize_name as normalize_name
			πF.SetLineno(113)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.nodes"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßfully_normalize_name); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßnormalize_name.ToObject(), πTemp003); πE != nil {
				continue
			}
			// line 114: from docutils.nodes import whitespace_normalize_name
			πF.SetLineno(114)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.nodes"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßwhitespace_normalize_name); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßwhitespace_normalize_name.ToObject(), πTemp003); πE != nil {
				continue
			}
			// line 115: import docutils.parsers.rst
			πF.SetLineno(115)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.parsers.rst"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[0]
			if πE = πF.Globals().SetItem(πF, ßdocutils.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 116: from docutils.parsers.rst import directives, languages, tableparser, roles
			πF.SetLineno(116)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.parsers.rst.directives"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[3]
			if πE = πF.Globals().SetItem(πF, ßdirectives.ToObject(), πTemp001); πE != nil {
				continue
			}
			if πTemp002, πE = πg.ImportModule(πF, "docutils.parsers.rst.languages"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[3]
			if πE = πF.Globals().SetItem(πF, ßlanguages.ToObject(), πTemp001); πE != nil {
				continue
			}
			if πTemp002, πE = πg.ImportModule(πF, "docutils.parsers.rst.tableparser"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[3]
			if πE = πF.Globals().SetItem(πF, ßtableparser.ToObject(), πTemp001); πE != nil {
				continue
			}
			if πTemp002, πE = πg.ImportModule(πF, "docutils.parsers.rst.roles"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[3]
			if πE = πF.Globals().SetItem(πF, ßroles.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 117: from docutils.parsers.rst.languages import en as _fallback_language_module
			πF.SetLineno(117)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.parsers.rst.languages.en"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[4]
			if πE = πF.Globals().SetItem(πF, ß_fallback_language_module.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 118: from docutils.utils import escape2null, unescape, column_width
			πF.SetLineno(118)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.utils"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßescape2null); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßescape2null.ToObject(), πTemp003); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßunescape); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßunescape.ToObject(), πTemp003); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßcolumn_width); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßcolumn_width.ToObject(), πTemp003); πE != nil {
				continue
			}
			// line 119: from docutils.utils import punctuation_chars, roman, urischemes
			πF.SetLineno(119)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.utils.punctuation_chars"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[2]
			if πE = πF.Globals().SetItem(πF, ßpunctuation_chars.ToObject(), πTemp001); πE != nil {
				continue
			}
			if πTemp002, πE = πg.ImportModule(πF, "docutils.utils.roman"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[2]
			if πE = πF.Globals().SetItem(πF, ßroman.ToObject(), πTemp001); πE != nil {
				continue
			}
			if πTemp002, πE = πg.ImportModule(πF, "docutils.utils.urischemes"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[2]
			if πE = πF.Globals().SetItem(πF, ßurischemes.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 120: from docutils.utils import split_escaped_whitespace
			πF.SetLineno(120)
			if πTemp002, πE = πg.ImportModule(πF, "docutils.utils"); πE != nil {
				continue
			}
			πTemp001 = πTemp002[1]
			if πTemp003, πE = πg.GetAttrImport(πF, πTemp001, ßsplit_escaped_whitespace); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßsplit_escaped_whitespace.ToObject(), πTemp003); πE != nil {
				continue
			}
			// line 122: class MarkupError(DataError): pass
			πF.SetLineno(122)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßDataError); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp004 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("MarkupError", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 122: class MarkupError(DataError): pass
					πF.SetLineno(122)
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("MarkupError").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMarkupError.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 123: class UnknownInterpretedRoleError(DataError): pass
			πF.SetLineno(123)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßDataError); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp004 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("UnknownInterpretedRoleError", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 123: class UnknownInterpretedRoleError(DataError): pass
					πF.SetLineno(123)
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("UnknownInterpretedRoleError").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßUnknownInterpretedRoleError.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 124: class InterpretedRoleNotImplementedError(DataError): pass
			πF.SetLineno(124)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßDataError); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp004 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("InterpretedRoleNotImplementedError", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 124: class InterpretedRoleNotImplementedError(DataError): pass
					πF.SetLineno(124)
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("InterpretedRoleNotImplementedError").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßInterpretedRoleNotImplementedError.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 125: class ParserError(ApplicationError): pass
			πF.SetLineno(125)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßApplicationError); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp004 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ParserError", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 125: class ParserError(ApplicationError): pass
					πF.SetLineno(125)
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("ParserError").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßParserError.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 126: class MarkupMismatch(Exception): pass
			πF.SetLineno(126)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßException); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp004 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("MarkupMismatch", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 126: class MarkupMismatch(Exception): pass
					πF.SetLineno(126)
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("MarkupMismatch").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßMarkupMismatch.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 129: class Struct(object):
			πF.SetLineno(129)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp004 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Struct", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 131: """Stores data attributes for dotted-attribute access."""
					πF.SetLineno(131)
					// line 131: """Stores data attributes for dotted-attribute access."""
					πF.SetLineno(131)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Stores data attributes for dotted-attribute access.").ToObject()); πE != nil {
						continue
					}
					// line 133: def __init__(self, **keywordargs):
					πF.SetLineno(133)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µkeywordargs *πg.Object = πArgs[1]
						_ = µkeywordargs
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 134: self.__dict__.update(keywordargs)
							πF.SetLineno(134)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µkeywordargs, "keywordargs"); πE != nil {
								continue
							}
							πTemp001[0] = µkeywordargs
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß__dict__, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßupdate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("Struct").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßStruct.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 137: class RSTStateMachine(StateMachineWS):
			πF.SetLineno(137)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßStateMachineWS); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp004 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("RSTStateMachine", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 139: """
					πF.SetLineno(139)
					// line 139: """
					πF.SetLineno(139)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    reStructuredText's master StateMachine.\n\n    The entry point to reStructuredText parsing is the `run()` method.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 145: def run(self, input_lines, document, input_offset=0, match_titles=True,
					πF.SetLineno(145)
					πTemp002 = make([]πg.Param, 6)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "input_lines", Def: nil}
					πTemp002[2] = πg.Param{Name: "document", Def: nil}
					πTemp002[3] = πg.Param{Name: "input_offset", Def: πg.NewInt(0).ToObject()}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßTrue); πE != nil {
						continue
					}
					πTemp002[4] = πg.Param{Name: "match_titles", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "inliner", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("run", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µinput_lines *πg.Object = πArgs[1]
						_ = µinput_lines
						var µdocument *πg.Object = πArgs[2]
						_ = µdocument
						var µinput_offset *πg.Object = πArgs[3]
						_ = µinput_offset
						var µmatch_titles *πg.Object = πArgs[4]
						_ = µmatch_titles
						var µinliner *πg.Object = πArgs[5]
						_ = µinliner
						var µresults *πg.Object = πg.UnboundLocal
						_ = µresults
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 πg.KWArgs
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 147: """
							πF.SetLineno(147)
							// line 153: self.language = languages.get_language(
							πF.SetLineno(153)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdocument, "document"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µdocument, ßsettings, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßlanguage_code, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlanguages); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_language, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlanguage, πTemp003); πE != nil {
								continue
							}
							// line 155: self.match_titles = match_titles
							πF.SetLineno(155)
							if πE = πg.CheckLocal(πF, µmatch_titles, "match_titles"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µmatch_titles); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmatch_titles, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinliner, "inliner"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(µinliner == πTemp003).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 156: if inliner is None:
							πF.SetLineno(156)
						Label1:
							// line 157: inliner = Inliner()
							πF.SetLineno(157)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßInliner); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µinliner = πTemp003
							goto Label2
						Label2:
							// line 158: inliner.init_customizations(document.settings)
							πF.SetLineno(158)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdocument, "document"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µdocument, ßsettings, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µinliner, "inliner"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µinliner, ßinit_customizations, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 159: self.memo = Struct(document=document,
							πF.SetLineno(159)
							if πE = πg.CheckLocal(πF, µdocument, "document"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdocument, "document"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µdocument, ßreporter, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßlanguage, nil); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp005 = πg.NewList(πTemp001...).ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinliner, "inliner"); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"document", µdocument},
								{"reporter", πTemp002},
								{"language", πTemp003},
								{"title_styles", πTemp005},
								{"section_level", πg.NewInt(0).ToObject()},
								{"section_bubble_up_kludge", πTemp006},
								{"inliner", µinliner},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßStruct); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, πTemp007); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmemo, πTemp002); πE != nil {
								continue
							}
							// line 166: self.document = document
							πF.SetLineno(166)
							if πE = πg.CheckLocal(πF, µdocument, "document"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µdocument); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdocument, πTemp002); πE != nil {
								continue
							}
							// line 167: self.attach_observer(document.note_source)
							πF.SetLineno(167)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdocument, "document"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µdocument, ßnote_source, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßattach_observer, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 168: self.reporter = self.memo.reporter
							πF.SetLineno(168)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßmemo, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßreporter, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßreporter, πTemp002); πE != nil {
								continue
							}
							// line 169: self.node = document
							πF.SetLineno(169)
							if πE = πg.CheckLocal(πF, µdocument, "document"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µdocument); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßnode, πTemp002); πE != nil {
								continue
							}
							// line 170: results = StateMachineWS.run(self, input_lines, input_offset,
							πF.SetLineno(170)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µinput_lines, "input_lines"); πE != nil {
								continue
							}
							πTemp001[1] = µinput_lines
							if πE = πg.CheckLocal(πF, µinput_offset, "input_offset"); πE != nil {
								continue
							}
							πTemp001[2] = µinput_offset
							πTemp002 = ßsource.ToObject()
							if πE = πg.CheckLocal(πF, µdocument, "document"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µdocument, πTemp002); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"input_source", πTemp003},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßStateMachineWS); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßrun, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µresults = πTemp002
							// line 172: assert results == [], 'RSTStateMachine.run() results should be empty!'
							πF.SetLineno(172)
							if πE = πg.CheckLocal(πF, µresults, "results"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πTemp002, πE = πg.Eq(πF, µresults, πTemp003); πE != nil {
								continue
							}
							if πE = πg.Assert(πF, πTemp002, πg.NewStr("RSTStateMachine.run() results should be empty!").ToObject()); πE != nil {
								continue
							}
							// line 173: self.node = self.memo = None    # remove unneeded references
							πF.SetLineno(173)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßnode, πTemp003); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmemo, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßrun.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 147: """
					πF.SetLineno(147)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("\n        Parse `input_lines` and modify the `document` node in place.\n\n        Extend `StateMachineWS.run()`: set up parse-global data and\n        run the StateMachine.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßrun); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("RSTStateMachine").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßRSTStateMachine.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 176: class NestedStateMachine(StateMachineWS):
			πF.SetLineno(176)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßStateMachineWS); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp004 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("NestedStateMachine", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 178: """
					πF.SetLineno(178)
					// line 178: """
					πF.SetLineno(178)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    StateMachine run from within other StateMachine runs, to parse nested\n    document structures.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 183: def run(self, input_lines, input_offset, memo, node, match_titles=True):
					πF.SetLineno(183)
					πTemp002 = make([]πg.Param, 6)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "input_lines", Def: nil}
					πTemp002[2] = πg.Param{Name: "input_offset", Def: nil}
					πTemp002[3] = πg.Param{Name: "memo", Def: nil}
					πTemp002[4] = πg.Param{Name: "node", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßTrue); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "match_titles", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("run", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µinput_lines *πg.Object = πArgs[1]
						_ = µinput_lines
						var µinput_offset *πg.Object = πArgs[2]
						_ = µinput_offset
						var µmemo *πg.Object = πArgs[3]
						_ = µmemo
						var µnode *πg.Object = πArgs[4]
						_ = µnode
						var µmatch_titles *πg.Object = πArgs[5]
						_ = µmatch_titles
						var µresults *πg.Object = πg.UnboundLocal
						_ = µresults
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 184: """
							πF.SetLineno(184)
							// line 189: self.match_titles = match_titles
							πF.SetLineno(189)
							if πE = πg.CheckLocal(πF, µmatch_titles, "match_titles"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µmatch_titles); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmatch_titles, πTemp001); πE != nil {
								continue
							}
							// line 190: self.memo = memo
							πF.SetLineno(190)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µmemo); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmemo, πTemp001); πE != nil {
								continue
							}
							// line 191: self.document = memo.document
							πF.SetLineno(191)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßdocument, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdocument, πTemp002); πE != nil {
								continue
							}
							// line 192: self.attach_observer(self.document.note_source)
							πF.SetLineno(192)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnote_source, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßattach_observer, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 193: self.reporter = memo.reporter
							πF.SetLineno(193)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßreporter, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßreporter, πTemp002); πE != nil {
								continue
							}
							// line 194: self.language = memo.language
							πF.SetLineno(194)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßlanguage, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlanguage, πTemp002); πE != nil {
								continue
							}
							// line 195: self.node = node
							πF.SetLineno(195)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µnode); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßnode, πTemp001); πE != nil {
								continue
							}
							// line 196: results = StateMachineWS.run(self, input_lines, input_offset)
							πF.SetLineno(196)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[0] = µself
							if πE = πg.CheckLocal(πF, µinput_lines, "input_lines"); πE != nil {
								continue
							}
							πTemp003[1] = µinput_lines
							if πE = πg.CheckLocal(πF, µinput_offset, "input_offset"); πE != nil {
								continue
							}
							πTemp003[2] = µinput_offset
							if πTemp001, πE = πg.ResolveGlobal(πF, ßStateMachineWS); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßrun, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µresults = πTemp001
							// line 197: assert results == [], ('NestedStateMachine.run() results should be '
							πF.SetLineno(197)
							if πE = πg.CheckLocal(πF, µresults, "results"); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πTemp001, πE = πg.Eq(πF, µresults, πTemp002); πE != nil {
								continue
							}
							if πE = πg.Assert(πF, πTemp001, πg.NewStr("NestedStateMachine.run() results should be empty!").ToObject()); πE != nil {
								continue
							}
							// line 199: return results
							πF.SetLineno(199)
							if πE = πg.CheckLocal(πF, µresults, "results"); πE != nil {
								continue
							}
							πR = µresults
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßrun.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 184: """
					πF.SetLineno(184)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("\n        Parse `input_lines` and populate a `docutils.nodes.document` instance.\n\n        Extend `StateMachineWS.run()`: set up document-wide data.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßrun); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("NestedStateMachine").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßNestedStateMachine.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 202: class RSTState(StateWS):
			πF.SetLineno(202)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp005, πE = πg.ResolveGlobal(πF, ßStateWS); πE != nil {
				continue
			}
			πTemp002[0] = πTemp005
			πTemp004 = πg.NewDict()
			if πTemp001, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp001); πE != nil {
				continue
			}
			_, πE = πg.NewCode("RSTState", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Dict
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 204: """
					πF.SetLineno(204)
					// line 204: """
					πF.SetLineno(204)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    reStructuredText State superclass.\n\n    Contains methods used by all State subclasses.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 210: nested_sm = NestedStateMachine
					πF.SetLineno(210)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßNestedStateMachine); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßnested_sm.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 211: nested_sm_cache = []
					πF.SetLineno(211)
					πTemp002 = make([]*πg.Object, 0)
					πTemp001 = πg.NewList(πTemp002...).ToObject()
					if πE = πClass.SetItem(πF, ßnested_sm_cache.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 213: def __init__(self, state_machine, debug=False):
					πF.SetLineno(213)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "state_machine", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp003[2] = πg.Param{Name: "debug", Def: πTemp004}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstate_machine *πg.Object = πArgs[1]
						_ = µstate_machine
						var µdebug *πg.Object = πArgs[2]
						_ = µdebug
						var πTemp001 *πg.Dict
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 214: self.nested_sm_kwargs = {'state_classes': state_classes,
							πF.SetLineno(214)
							πTemp001 = πg.NewDict()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßstate_classes); πE != nil {
								continue
							}
							if πE = πTemp001.SetItem(πF, ßstate_classes.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πE = πTemp001.SetItem(πF, ßinitial_state.ToObject(), ßBody.ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp001.ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßnested_sm_kwargs, πTemp003); πE != nil {
								continue
							}
							// line 216: StateWS.__init__(self, state_machine, debug)
							πF.SetLineno(216)
							πTemp004 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp004[0] = µself
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							πTemp004[1] = µstate_machine
							if πE = πg.CheckLocal(πF, µdebug, "debug"); πE != nil {
								continue
							}
							πTemp004[2] = µdebug
							if πTemp002, πE = πg.ResolveGlobal(πF, ßStateWS); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 218: def runtime_init(self):
					πF.SetLineno(218)
					πTemp003 = make([]πg.Param, 1)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("runtime_init", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmemo *πg.Object = πg.UnboundLocal
						_ = µmemo
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 219: StateWS.runtime_init(self)
							πF.SetLineno(219)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πTemp002, πE = πg.ResolveGlobal(πF, ßStateWS); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßruntime_init, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 220: memo = self.state_machine.memo
							πF.SetLineno(220)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßmemo, nil); πE != nil {
								continue
							}
							µmemo = πTemp003
							// line 221: self.memo = memo
							πF.SetLineno(221)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µmemo); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmemo, πTemp002); πE != nil {
								continue
							}
							// line 222: self.reporter = memo.reporter
							πF.SetLineno(222)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmemo, ßreporter, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßreporter, πTemp003); πE != nil {
								continue
							}
							// line 223: self.inliner = memo.inliner
							πF.SetLineno(223)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmemo, ßinliner, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßinliner, πTemp003); πE != nil {
								continue
							}
							// line 224: self.document = memo.document
							πF.SetLineno(224)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmemo, ßdocument, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdocument, πTemp003); πE != nil {
								continue
							}
							// line 225: self.parent = self.state_machine.node
							πF.SetLineno(225)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnode, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							πTemp001[1] = ßget_source_and_line.ToObject()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßhasattr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 227: if not hasattr(self.reporter, 'get_source_and_line'):
							πF.SetLineno(227)
						Label1:
							// line 228: self.reporter.get_source_and_line = self.state_machine.get_source_and_line
							πF.SetLineno(228)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßget_source_and_line, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßruntime_init.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 231: def goto_line(self, abs_line_offset):
					πF.SetLineno(231)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "abs_line_offset", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("goto_line", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µabs_line_offset *πg.Object = πArgs[1]
						_ = µabs_line_offset
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.BaseException
						_ = πTemp004
						var πTemp005 *πg.Traceback
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 232: """
							πF.SetLineno(232)
							// line 235: try:
							πF.SetLineno(235)
							πF.PushCheckpoint(2)
							// line 236: self.state_machine.goto_line(abs_line_offset)
							πF.SetLineno(236)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µabs_line_offset, "abs_line_offset"); πE != nil {
								continue
							}
							πTemp001[0] = µabs_line_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πF.PopCheckpoint()
							goto Label1
						Label2:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp004, πTemp005 = πF.ExcInfo()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsInstance(πF, πTemp004.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label3
							}
							πE = πF.Raise(πTemp004.ToObject(), nil, πTemp005.ToObject())
							continue
							// line 237: except EOFError:
							πF.SetLineno(237)
						Label3:
							// line 238: pass
							πF.SetLineno(238)
							πF.RestoreExc(nil, nil)
							goto Label1
						Label1:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgoto_line.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 232: """
					πF.SetLineno(232)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("\n        Jump to input line `abs_line_offset`, ignoring jumps past the end.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßgoto_line); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 240: def no_match(self, context, transitions):
					πF.SetLineno(240)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "context", Def: nil}
					πTemp003[2] = πg.Param{Name: "transitions", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("no_match", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontext *πg.Object = πArgs[1]
						_ = µcontext
						var µtransitions *πg.Object = πArgs[2]
						_ = µtransitions
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 241: """
							πF.SetLineno(241)
							// line 246: self.reporter.severe(
							πF.SetLineno(246)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ß__name__, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtransitions, "transitions"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp004, ßline, nil); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple4(πTemp005, µtransitions, µcontext, πTemp006).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("Internal error: no transition pattern match.  State: \"%s\"; transitions: %s; context: %s; current line: %r.").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsevere, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 251: return context, None, []
							πF.SetLineno(251)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(µcontext, πTemp003, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßno_match.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 241: """
					πF.SetLineno(241)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp007}, πg.NewStr("\n        Override `StateWS.no_match` to generate a system message.\n\n        This code should never be run.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßno_match); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp007); πE != nil {
						continue
					}
					// line 253: def bof(self, context):
					πF.SetLineno(253)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "context", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("bof", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontext *πg.Object = πArgs[1]
						_ = µcontext
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 254: """Called at beginning of file."""
							πF.SetLineno(254)
							// line 255: return [], []
							πF.SetLineno(255)
							πTemp002 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp002...).ToObject()
							πTemp002 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp002...).ToObject()
							πTemp001 = πg.NewTuple2(πTemp003, πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßbof.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 254: """Called at beginning of file."""
					πF.SetLineno(254)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Called at beginning of file.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßbof); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 257: def nested_parse(self, block, input_offset, node, match_titles=False,
					πF.SetLineno(257)
					πTemp003 = make([]πg.Param, 7)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "block", Def: nil}
					πTemp003[2] = πg.Param{Name: "input_offset", Def: nil}
					πTemp003[3] = πg.Param{Name: "node", Def: nil}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp003[4] = πg.Param{Name: "match_titles", Def: πTemp009}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp003[5] = πg.Param{Name: "state_machine_class", Def: πTemp009}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp003[6] = πg.Param{Name: "state_machine_kwargs", Def: πTemp009}
					πTemp008 = πg.NewFunction(πg.NewCode("nested_parse", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µblock *πg.Object = πArgs[1]
						_ = µblock
						var µinput_offset *πg.Object = πArgs[2]
						_ = µinput_offset
						var µnode *πg.Object = πArgs[3]
						_ = µnode
						var µmatch_titles *πg.Object = πArgs[4]
						_ = µmatch_titles
						var µstate_machine_class *πg.Object = πArgs[5]
						_ = µstate_machine_class
						var µstate_machine_kwargs *πg.Object = πArgs[6]
						_ = µstate_machine_kwargs
						var µuse_default *πg.Object = πg.UnboundLocal
						_ = µuse_default
						var µblock_length *πg.Object = πg.UnboundLocal
						_ = µblock_length
						var µstate_machine *πg.Object = πg.UnboundLocal
						_ = µstate_machine
						var µnew_offset *πg.Object = πg.UnboundLocal
						_ = µnew_offset
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πTemp007 πg.KWArgs
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 []*πg.Object
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 8:
								goto Label8
							default:
								panic("unexpected function state")
							}
							// line 259: """
							πF.SetLineno(259)
							// line 263: use_default = 0
							πF.SetLineno(263)
							µuse_default = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µstate_machine_class, "state_machine_class"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µstate_machine_class == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 264: if state_machine_class is None:
							πF.SetLineno(264)
						Label1:
							// line 265: state_machine_class = self.nested_sm
							πF.SetLineno(265)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_sm, nil); πE != nil {
								continue
							}
							µstate_machine_class = πTemp001
							// line 266: use_default += 1
							πF.SetLineno(266)
							if πE = πg.CheckLocal(πF, µuse_default, "use_default"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µuse_default, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µuse_default = πTemp001
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µstate_machine_kwargs, "state_machine_kwargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µstate_machine_kwargs == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 267: if state_machine_kwargs is None:
							πF.SetLineno(267)
						Label3:
							// line 268: state_machine_kwargs = self.nested_sm_kwargs
							πF.SetLineno(268)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_sm_kwargs, nil); πE != nil {
								continue
							}
							µstate_machine_kwargs = πTemp001
							// line 269: use_default += 1
							πF.SetLineno(269)
							if πE = πg.CheckLocal(πF, µuse_default, "use_default"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µuse_default, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µuse_default = πTemp001
							goto Label4
						Label4:
							// line 270: block_length = len(block)
							πF.SetLineno(270)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp004[0] = µblock
							if πTemp001, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µblock_length = πTemp002
							// line 272: state_machine = None
							πF.SetLineno(272)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µstate_machine = πTemp001
							if πE = πg.CheckLocal(πF, µuse_default, "use_default"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µuse_default, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							goto Label6
							// line 273: if use_default == 2:
							πF.SetLineno(273)
						Label5:
							// line 274: try:
							πF.SetLineno(274)
							πF.PushCheckpoint(8)
							// line 275: state_machine = self.nested_sm_cache.pop()
							πF.SetLineno(275)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_sm_cache, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßpop, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µstate_machine = πTemp001
							πF.PopCheckpoint()
							goto Label7
						Label8:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßIndexError); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label9
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 276: except IndexError:
							πF.SetLineno(276)
						Label9:
							// line 277: pass
							πF.SetLineno(277)
							πF.RestoreExc(nil, nil)
							goto Label7
						Label7:
							goto Label6
						Label6:
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, µstate_machine); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label10
							}
							goto Label11
							// line 278: if not state_machine:
							πF.SetLineno(278)
						Label10:
							// line 279: state_machine = state_machine_class(debug=self.debug,
							πF.SetLineno(279)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdebug, nil); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"debug", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µstate_machine_kwargs, "state_machine_kwargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstate_machine_class, "state_machine_class"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Invoke(πF, µstate_machine_class, nil, nil, πTemp007, µstate_machine_kwargs); πE != nil {
								continue
							}
							µstate_machine = πTemp001
							goto Label11
						Label11:
							// line 281: state_machine.run(block, input_offset, memo=self.memo,
							πF.SetLineno(281)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp004[0] = µblock
							if πE = πg.CheckLocal(πF, µinput_offset, "input_offset"); πE != nil {
								continue
							}
							πTemp004[1] = µinput_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmemo, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatch_titles, "match_titles"); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"memo", πTemp001},
								{"node", µnode},
								{"match_titles", µmatch_titles},
							}
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µstate_machine, ßrun, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µuse_default, "use_default"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µuse_default, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label12
							}
							goto Label13
							// line 283: if use_default == 2:
							πF.SetLineno(283)
						Label12:
							// line 284: self.nested_sm_cache.append(state_machine)
							πF.SetLineno(284)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							πTemp004[0] = µstate_machine
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_sm_cache, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßappend, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label14
						Label13:
							// line 286: state_machine.unlink()
							πF.SetLineno(286)
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µstate_machine, ßunlink, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label14
						Label14:
							// line 287: new_offset = state_machine.abs_line_offset()
							πF.SetLineno(287)
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µstate_machine, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µnew_offset = πTemp002
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µblock, ßparent, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp003 {
								goto Label15
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp004[0] = µblock
							if πTemp009, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp009.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µblock_length, "block_length"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Sub(πF, πTemp010, µblock_length); πE != nil {
								continue
							}
							if πTemp002, πE = πg.NE(πF, πTemp008, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp002
						Label15:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label16
							}
							goto Label17
							// line 289: if block.parent and (len(block) - block_length) != 0:
							πF.SetLineno(289)
						Label16:
							// line 291: self.state_machine.next_line(len(block) - block_length)
							πF.SetLineno(291)
							πTemp004 = πF.MakeArgs(1)
							πTemp011 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp011[0] = µblock
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp002.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							if πE = πg.CheckLocal(πF, µblock_length, "block_length"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp008, µblock_length); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnext_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label17
						Label17:
							// line 292: return new_offset
							πF.SetLineno(292)
							if πE = πg.CheckLocal(πF, µnew_offset, "new_offset"); πE != nil {
								continue
							}
							πR = µnew_offset
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßnested_parse.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 259: """
					πF.SetLineno(259)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("\n        Create a new StateMachine rooted at `node` and run it over the input\n        `block`.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßnested_parse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 294: def nested_list_parse(self, block, input_offset, node, initial_state,
					πF.SetLineno(294)
					πTemp003 = make([]πg.Param, 11)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "block", Def: nil}
					πTemp003[2] = πg.Param{Name: "input_offset", Def: nil}
					πTemp003[3] = πg.Param{Name: "node", Def: nil}
					πTemp003[4] = πg.Param{Name: "initial_state", Def: nil}
					πTemp003[5] = πg.Param{Name: "blank_finish", Def: nil}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp003[6] = πg.Param{Name: "blank_finish_state", Def: πTemp010}
					πTemp011 = πg.NewDict()
					πTemp010 = πTemp011.ToObject()
					πTemp003[7] = πg.Param{Name: "extra_settings", Def: πTemp010}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp003[8] = πg.Param{Name: "match_titles", Def: πTemp010}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp003[9] = πg.Param{Name: "state_machine_class", Def: πTemp010}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp003[10] = πg.Param{Name: "state_machine_kwargs", Def: πTemp010}
					πTemp009 = πg.NewFunction(πg.NewCode("nested_list_parse", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µblock *πg.Object = πArgs[1]
						_ = µblock
						var µinput_offset *πg.Object = πArgs[2]
						_ = µinput_offset
						var µnode *πg.Object = πArgs[3]
						_ = µnode
						var µinitial_state *πg.Object = πArgs[4]
						_ = µinitial_state
						var µblank_finish *πg.Object = πArgs[5]
						_ = µblank_finish
						var µblank_finish_state *πg.Object = πArgs[6]
						_ = µblank_finish_state
						var µextra_settings *πg.Object = πArgs[7]
						_ = µextra_settings
						var µmatch_titles *πg.Object = πArgs[8]
						_ = µmatch_titles
						var µstate_machine_class *πg.Object = πArgs[9]
						_ = µstate_machine_class
						var µstate_machine_kwargs *πg.Object = πArgs[10]
						_ = µstate_machine_kwargs
						var µstate_machine *πg.Object = πg.UnboundLocal
						_ = µstate_machine
						var µkey *πg.Object = πg.UnboundLocal
						_ = µkey
						var µvalue *πg.Object = πg.UnboundLocal
						_ = µvalue
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 8:
								goto Label8
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 301: """
							πF.SetLineno(301)
							if πE = πg.CheckLocal(πF, µstate_machine_class, "state_machine_class"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µstate_machine_class == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 306: if state_machine_class is None:
							πF.SetLineno(306)
						Label1:
							// line 307: state_machine_class = self.nested_sm
							πF.SetLineno(307)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_sm, nil); πE != nil {
								continue
							}
							µstate_machine_class = πTemp001
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µstate_machine_kwargs, "state_machine_kwargs"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µstate_machine_kwargs == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 308: if state_machine_kwargs is None:
							πF.SetLineno(308)
						Label3:
							// line 309: state_machine_kwargs = self.nested_sm_kwargs.copy()
							πF.SetLineno(309)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_sm_kwargs, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcopy, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µstate_machine_kwargs = πTemp001
							goto Label4
						Label4:
							// line 310: state_machine_kwargs['initial_state'] = initial_state
							πF.SetLineno(310)
							if πE = πg.CheckLocal(πF, µinitial_state, "initial_state"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µinitial_state); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstate_machine_kwargs, "state_machine_kwargs"); πE != nil {
								continue
							}
							πTemp002 = ßinitial_state.ToObject()
							if πE = πg.SetItem(πF, µstate_machine_kwargs, πTemp002, πTemp001); πE != nil {
								continue
							}
							// line 311: state_machine = state_machine_class(debug=self.debug,
							πF.SetLineno(311)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdebug, nil); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"debug", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µstate_machine_kwargs, "state_machine_kwargs"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstate_machine_class, "state_machine_class"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Invoke(πF, µstate_machine_class, nil, nil, πTemp004, µstate_machine_kwargs); πE != nil {
								continue
							}
							µstate_machine = πTemp001
							if πE = πg.CheckLocal(πF, µblank_finish_state, "blank_finish_state"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µblank_finish_state == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							goto Label6
							// line 313: if blank_finish_state is None:
							πF.SetLineno(313)
						Label5:
							// line 314: blank_finish_state = initial_state
							πF.SetLineno(314)
							if πE = πg.CheckLocal(πF, µinitial_state, "initial_state"); πE != nil {
								continue
							}
							µblank_finish_state = µinitial_state
							goto Label6
						Label6:
							// line 315: state_machine.states[blank_finish_state].blank_finish = blank_finish
							πF.SetLineno(315)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish_state, "blank_finish_state"); πE != nil {
								continue
							}
							πTemp002 = µblank_finish_state
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µstate_machine, ßstates, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßblank_finish, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µextra_settings, "extra_settings"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µextra_settings, ßitems, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(8)
							πTemp003 = false
						Label7:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label9
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp002); πE != nil {
									continue
								}
								µkey = πTemp005
								µvalue = πTemp006
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(7)
							// line 317: setattr(state_machine.states[initial_state], key, value)
							πF.SetLineno(317)
							πTemp008 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µinitial_state, "initial_state"); πE != nil {
								continue
							}
							πTemp002 = µinitial_state
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µstate_machine, ßstates, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							πTemp008[0] = πTemp005
							if πE = πg.CheckLocal(πF, µkey, "key"); πE != nil {
								continue
							}
							πTemp008[1] = µkey
							if πE = πg.CheckLocal(πF, µvalue, "value"); πE != nil {
								continue
							}
							πTemp008[2] = µvalue
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsetattr); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							continue
						Label8:
							if πE != nil || πR != nil {
								continue
							}
						Label9:
							// line 318: state_machine.run(block, input_offset, memo=self.memo,
							πF.SetLineno(318)
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp008[0] = µblock
							if πE = πg.CheckLocal(πF, µinput_offset, "input_offset"); πE != nil {
								continue
							}
							πTemp008[1] = µinput_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmemo, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatch_titles, "match_titles"); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"memo", πTemp001},
								{"node", µnode},
								{"match_titles", µmatch_titles},
							}
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µstate_machine, ßrun, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp008, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							// line 320: blank_finish = state_machine.states[blank_finish_state].blank_finish
							πF.SetLineno(320)
							if πE = πg.CheckLocal(πF, µblank_finish_state, "blank_finish_state"); πE != nil {
								continue
							}
							πTemp001 = µblank_finish_state
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µstate_machine, ßstates, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßblank_finish, nil); πE != nil {
								continue
							}
							µblank_finish = πTemp001
							// line 321: state_machine.unlink()
							πF.SetLineno(321)
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µstate_machine, ßunlink, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 322: return state_machine.abs_line_offset(), blank_finish
							πF.SetLineno(322)
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µstate_machine, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp005, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßnested_list_parse.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 301: """
					πF.SetLineno(301)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("\n        Create a new StateMachine rooted at `node` and run it over the input\n        `block`. Also keep track of optional intermediate blank lines and the\n        required final one.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßnested_list_parse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp012, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 324: def section(self, title, source, style, lineno, messages):
					πF.SetLineno(324)
					πTemp003 = make([]πg.Param, 6)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "title", Def: nil}
					πTemp003[2] = πg.Param{Name: "source", Def: nil}
					πTemp003[3] = πg.Param{Name: "style", Def: nil}
					πTemp003[4] = πg.Param{Name: "lineno", Def: nil}
					πTemp003[5] = πg.Param{Name: "messages", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("section", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtitle *πg.Object = πArgs[1]
						_ = µtitle
						var µsource *πg.Object = πArgs[2]
						_ = µsource
						var µstyle *πg.Object = πArgs[3]
						_ = µstyle
						var µlineno *πg.Object = πArgs[4]
						_ = µlineno
						var µmessages *πg.Object = πArgs[5]
						_ = µmessages
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 325: """Check for a valid subsection and create one if it checks out."""
							πF.SetLineno(325)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp001[0] = µsource
							if πE = πg.CheckLocal(πF, µstyle, "style"); πE != nil {
								continue
							}
							πTemp001[1] = µstyle
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[2] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcheck_subsection, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 326: if self.check_subsection(source, style, lineno):
							πF.SetLineno(326)
						Label1:
							// line 327: self.new_subsection(title, lineno, messages)
							πF.SetLineno(327)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							πTemp001[0] = µtitle
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							πTemp001[2] = µmessages
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßnew_subsection, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsection.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 325: """Check for a valid subsection and create one if it checks out."""
					πF.SetLineno(325)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Check for a valid subsection and create one if it checks out.").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßsection); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
					// line 329: def check_subsection(self, source, style, lineno):
					πF.SetLineno(329)
					πTemp003 = make([]πg.Param, 4)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "source", Def: nil}
					πTemp003[2] = πg.Param{Name: "style", Def: nil}
					πTemp003[3] = πg.Param{Name: "lineno", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("check_subsection", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µsource *πg.Object = πArgs[1]
						_ = µsource
						var µstyle *πg.Object = πArgs[2]
						_ = µstyle
						var µlineno *πg.Object = πArgs[3]
						_ = µlineno
						var µmemo *πg.Object = πg.UnboundLocal
						_ = µmemo
						var µtitle_styles *πg.Object = πg.UnboundLocal
						_ = µtitle_styles
						var µmylevel *πg.Object = πg.UnboundLocal
						_ = µmylevel
						var µlevel *πg.Object = πg.UnboundLocal
						_ = µlevel
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 330: """
							πF.SetLineno(330)
							// line 345: memo = self.memo
							πF.SetLineno(345)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmemo, nil); πE != nil {
								continue
							}
							µmemo = πTemp001
							// line 346: title_styles = memo.title_styles
							πF.SetLineno(346)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßtitle_styles, nil); πE != nil {
								continue
							}
							µtitle_styles = πTemp001
							// line 347: mylevel = memo.section_level
							πF.SetLineno(347)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßsection_level, nil); πE != nil {
								continue
							}
							µmylevel = πTemp001
							// line 348: try:                            # check for existing title style
							πF.SetLineno(348)
							πF.PushCheckpoint(2)
							// line 349: level = title_styles.index(style) + 1
							πF.SetLineno(349)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstyle, "style"); πE != nil {
								continue
							}
							πTemp002[0] = µstyle
							if πE = πg.CheckLocal(πF, µtitle_styles, "title_styles"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µtitle_styles, ßindex, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µlevel = πTemp001
							πF.PopCheckpoint()
							goto Label1
						Label2:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label3
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 350: except ValueError:              # new title style
							πF.SetLineno(350)
						Label3:
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtitle_styles, "title_styles"); πE != nil {
								continue
							}
							πTemp002[0] = µtitle_styles
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmemo, ßsection_level, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 351: if len(title_styles) == memo.section_level: # new subsection
							πF.SetLineno(351)
						Label4:
							// line 352: title_styles.append(style)
							πF.SetLineno(352)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstyle, "style"); πE != nil {
								continue
							}
							πTemp002[0] = µstyle
							if πE = πg.CheckLocal(πF, µtitle_styles, "title_styles"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtitle_styles, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 353: return 1
							πF.SetLineno(353)
							πR = πg.NewInt(1).ToObject()
							continue
							goto Label6
						Label5:
							// line 355: self.parent += self.title_inconsistent(source, lineno)
							πF.SetLineno(355)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp002[0] = µsource
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp002[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtitle_inconsistent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.IAdd(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 356: return None
							πF.SetLineno(356)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label6
						Label6:
							πF.RestoreExc(nil, nil)
							goto Label1
						Label1:
							if πE = πg.CheckLocal(πF, µlevel, "level"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmylevel, "mylevel"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.LE(πF, µlevel, µmylevel); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label7
							}
							goto Label8
							// line 357: if level <= mylevel:            # sibling or supersection
							πF.SetLineno(357)
						Label7:
							// line 358: memo.section_level = level   # bubble up to parent section
							πF.SetLineno(358)
							if πE = πg.CheckLocal(πF, µlevel, "level"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µlevel); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µmemo, ßsection_level, πTemp001); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstyle, "style"); πE != nil {
								continue
							}
							πTemp002[0] = µstyle
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label9
							}
							goto Label10
							// line 359: if len(style) == 2:
							πF.SetLineno(359)
						Label9:
							// line 360: memo.section_bubble_up_kludge = True
							πF.SetLineno(360)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µmemo, ßsection_bubble_up_kludge, πTemp003); πE != nil {
								continue
							}
							goto Label10
						Label10:
							// line 362: self.state_machine.previous_line(len(style) + 1)
							πF.SetLineno(362)
							πTemp002 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstyle, "style"); πE != nil {
								continue
							}
							πTemp008[0] = µstyle
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							// line 363: raise EOFError              # let parent section re-evaluate
							πF.SetLineno(363)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
							goto Label8
						Label8:
							if πE = πg.CheckLocal(πF, µlevel, "level"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmylevel, "mylevel"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µmylevel, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µlevel, πTemp003); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label11
							}
							goto Label12
							// line 364: if level == mylevel + 1:        # immediate subsection
							πF.SetLineno(364)
						Label11:
							// line 365: return 1
							πF.SetLineno(365)
							πR = πg.NewInt(1).ToObject()
							continue
							goto Label13
						Label12:
							// line 367: self.parent += self.title_inconsistent(source, lineno)
							πF.SetLineno(367)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp002[0] = µsource
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp002[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßtitle_inconsistent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.IAdd(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 368: return None
							πF.SetLineno(368)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label13
						Label13:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheck_subsection.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 330: """
					πF.SetLineno(330)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp013}, πg.NewStr("\n        Check for a valid subsection header.  Return 1 (true) or None (false).\n\n        When a new section is reached that isn't a subsection of the current\n        section, back up the line count (use ``previous_line(-x)``), then\n        ``raise EOFError``.  The current StateMachine will finish, then the\n        calling StateMachine can re-examine the title.  This will work its way\n        back up the calling chain until the correct section level isreached.\n\n        @@@ Alternative: Evaluate the title, store the title info & level, and\n        back up the chain until that level is reached.  Store in memo? Or\n        return in results?\n\n        :Exception: `EOFError` when a sibling or supersection encountered.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßcheck_subsection); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp014, ß__doc__, πTemp013); πE != nil {
						continue
					}
					// line 370: def title_inconsistent(self, sourcetext, lineno):
					πF.SetLineno(370)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "sourcetext", Def: nil}
					πTemp003[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("title_inconsistent", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µsourcetext *πg.Object = πArgs[1]
						_ = µsourcetext
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µerror *πg.Object = πg.UnboundLocal
						_ = µerror
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 πg.KWArgs
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 371: error = self.reporter.severe(
							πF.SetLineno(371)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("Title level inconsistent:").ToObject()
							πTemp002 = πF.MakeArgs(2)
							πTemp002[0] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µsourcetext, "sourcetext"); πE != nil {
								continue
							}
							πTemp002[1] = µsourcetext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßsevere, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µerror = πTemp003
							// line 374: return error
							πF.SetLineno(374)
							if πE = πg.CheckLocal(πF, µerror, "error"); πE != nil {
								continue
							}
							πR = µerror
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtitle_inconsistent.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 376: def new_subsection(self, title, lineno, messages):
					πF.SetLineno(376)
					πTemp003 = make([]πg.Param, 4)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "title", Def: nil}
					πTemp003[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp003[3] = πg.Param{Name: "messages", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("new_subsection", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtitle *πg.Object = πArgs[1]
						_ = µtitle
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µmessages *πg.Object = πArgs[3]
						_ = µmessages
						var µmemo *πg.Object = πg.UnboundLocal
						_ = µmemo
						var µmylevel *πg.Object = πg.UnboundLocal
						_ = µmylevel
						var µsection_node *πg.Object = πg.UnboundLocal
						_ = µsection_node
						var µtextnodes *πg.Object = πg.UnboundLocal
						_ = µtextnodes
						var µtitle_messages *πg.Object = πg.UnboundLocal
						_ = µtitle_messages
						var µtitlenode *πg.Object = πg.UnboundLocal
						_ = µtitlenode
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µabsoffset *πg.Object = πg.UnboundLocal
						_ = µabsoffset
						var µnewabsoffset *πg.Object = πg.UnboundLocal
						_ = µnewabsoffset
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 377: """Append new subsection to document tree. On return, check level."""
							πF.SetLineno(377)
							// line 378: memo = self.memo
							πF.SetLineno(378)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmemo, nil); πE != nil {
								continue
							}
							µmemo = πTemp001
							// line 379: mylevel = memo.section_level
							πF.SetLineno(379)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßsection_level, nil); πE != nil {
								continue
							}
							µmylevel = πTemp001
							// line 380: memo.section_level += 1
							πF.SetLineno(380)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßsection_level, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µmemo, ßsection_level, πTemp002); πE != nil {
								continue
							}
							// line 381: section_node = nodes.section()
							πF.SetLineno(381)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsection, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µsection_node = πTemp001
							// line 382: self.parent += section_node
							πF.SetLineno(382)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsection_node, "section_node"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µsection_node); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 383: textnodes, title_messages = self.inline_text(title, lineno)
							πF.SetLineno(383)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							πTemp003[0] = µtitle
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßinline_text, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µtextnodes = πTemp001
							µtitle_messages = πTemp004
							// line 384: titlenode = nodes.title(title, '', *textnodes)
							πF.SetLineno(384)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							πTemp003[0] = µtitle
							πTemp003[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µtextnodes, "textnodes"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtitle, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Invoke(πF, πTemp002, πTemp003, µtextnodes, nil, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtitlenode = πTemp001
							// line 385: name = normalize_name(titlenode.astext())
							πF.SetLineno(385)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtitlenode, "titlenode"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtitlenode, ßastext, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µname = πTemp002
							// line 386: section_node['names'].append(name)
							πF.SetLineno(386)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp003[0] = µname
							πTemp001 = ßnames.ToObject()
							if πE = πg.CheckLocal(πF, µsection_node, "section_node"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µsection_node, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 387: section_node += titlenode
							πF.SetLineno(387)
							if πE = πg.CheckLocal(πF, µsection_node, "section_node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitlenode, "titlenode"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µsection_node, µtitlenode); πE != nil {
								continue
							}
							µsection_node = πTemp001
							// line 388: section_node += messages
							πF.SetLineno(388)
							if πE = πg.CheckLocal(πF, µsection_node, "section_node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µsection_node, µmessages); πE != nil {
								continue
							}
							µsection_node = πTemp001
							// line 389: section_node += title_messages
							πF.SetLineno(389)
							if πE = πg.CheckLocal(πF, µsection_node, "section_node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle_messages, "title_messages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µsection_node, µtitle_messages); πE != nil {
								continue
							}
							µsection_node = πTemp001
							// line 390: self.document.note_implicit_target(section_node, section_node)
							πF.SetLineno(390)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsection_node, "section_node"); πE != nil {
								continue
							}
							πTemp003[0] = µsection_node
							if πE = πg.CheckLocal(πF, µsection_node, "section_node"); πE != nil {
								continue
							}
							πTemp003[1] = µsection_node
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnote_implicit_target, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 391: offset = self.state_machine.line_offset + 1
							πF.SetLineno(391)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp001
							// line 392: absoffset = self.state_machine.abs_line_offset() + 1
							πF.SetLineno(392)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µabsoffset = πTemp001
							// line 393: newabsoffset = self.nested_parse(
							πF.SetLineno(393)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µabsoffset, "absoffset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsection_node, "section_node"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"input_offset", µabsoffset},
								{"node", µsection_node},
								{"match_titles", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µnewabsoffset = πTemp002
							// line 396: self.goto_line(newabsoffset)
							πF.SetLineno(396)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnewabsoffset, "newabsoffset"); πE != nil {
								continue
							}
							πTemp003[0] = µnewabsoffset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmemo, ßsection_level, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmylevel, "mylevel"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.LE(πF, πTemp002, µmylevel); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 397: if memo.section_level <= mylevel: # can't handle next section?
							πF.SetLineno(397)
						Label1:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							// line 398: raise EOFError              # bubble up to supersection
							πF.SetLineno(398)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
							goto Label2
						Label2:
							// line 400: memo.section_level = mylevel
							πF.SetLineno(400)
							if πE = πg.CheckLocal(πF, µmylevel, "mylevel"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µmylevel); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µmemo, ßsection_level, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßnew_subsection.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 377: """Append new subsection to document tree. On return, check level."""
					πF.SetLineno(377)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp015}, πg.NewStr("Append new subsection to document tree. On return, check level.").ToObject()); πE != nil {
						continue
					}
					if πTemp016, πE = πg.ResolveClass(πF, πClass, nil, ßnew_subsection); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp016, ß__doc__, πTemp015); πE != nil {
						continue
					}
					// line 402: def paragraph(self, lines, lineno):
					πF.SetLineno(402)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "lines", Def: nil}
					πTemp003[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp015 = πg.NewFunction(πg.NewCode("paragraph", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlines *πg.Object = πArgs[1]
						_ = µlines
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µdata *πg.Object = πg.UnboundLocal
						_ = µdata
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µliteralnext *πg.Object = πg.UnboundLocal
						_ = µliteralnext
						var µtextnodes *πg.Object = πg.UnboundLocal
						_ = µtextnodes
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µp *πg.Object = πg.UnboundLocal
						_ = µp
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 403: """
							πF.SetLineno(403)
							// line 406: data = '\n'.join(lines).rstrip()
							πF.SetLineno(406)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp001[0] = µlines
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µdata = πTemp003
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("(?<!\\\\)(\\\\\\\\)*::$").ToObject()
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp001[1] = µdata
							if πTemp002, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsearch, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 407: if re.search(r'(?<!\\)(\\\\)*::$', data):
							πF.SetLineno(407)
						Label1:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp001[0] = µdata
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Eq(πF, πTemp005, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							if πTemp005, πE = πg.Neg(πF, πg.NewInt(3).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp005
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µdata, πTemp003); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Contains(πF, πg.NewStr(" \n").ToObject(), πTemp005); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 408: if len(data) == 2:
							πF.SetLineno(408)
						Label4:
							// line 409: return [], 1
							πF.SetLineno(409)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple2(πTemp003, πg.NewInt(1).ToObject()).ToObject()
							πR = πTemp002
							continue
							goto Label7
							// line 410: elif data[-3] in ' \n':
							πF.SetLineno(410)
						Label5:
							// line 411: text = data[:-3].rstrip()
							πF.SetLineno(411)
							if πTemp003, πE = πg.Neg(πF, πg.NewInt(3).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µdata, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtext = πTemp003
							goto Label7
						Label6:
							// line 413: text = data[:-1]
							πF.SetLineno(413)
							if πTemp003, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µdata, πTemp002); πE != nil {
								continue
							}
							µtext = πTemp003
							goto Label7
						Label7:
							// line 414: literalnext = 1
							πF.SetLineno(414)
							µliteralnext = πg.NewInt(1).ToObject()
							goto Label3
						Label2:
							// line 416: text = data
							πF.SetLineno(416)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							µtext = µdata
							// line 417: literalnext = 0
							πF.SetLineno(417)
							µliteralnext = πg.NewInt(0).ToObject()
							goto Label3
						Label3:
							// line 418: textnodes, messages = self.inline_text(text, lineno)
							πF.SetLineno(418)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinline_text, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}}}, πTemp003); πE != nil {
								continue
							}
							µtextnodes = πTemp002
							µmessages = πTemp005
							// line 419: p = nodes.paragraph(data, '', *textnodes)
							πF.SetLineno(419)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp001[0] = µdata
							πTemp001[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µtextnodes, "textnodes"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparagraph, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Invoke(πF, πTemp003, πTemp001, µtextnodes, nil, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µp = πTemp002
							// line 420: p.source, p.line = self.state_machine.get_source_and_line(lineno)
							πF.SetLineno(420)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[0] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp005}}}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µp, "p"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µp, ßsource, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µp, "p"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µp, ßline, πTemp005); πE != nil {
								continue
							}
							// line 421: return [p] + messages, literalnext
							πF.SetLineno(421)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µp, "p"); πE != nil {
								continue
							}
							πTemp001[0] = µp
							πTemp005 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp005, µmessages); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µliteralnext, "literalnext"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp003, µliteralnext).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparagraph.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 403: """
					πF.SetLineno(403)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp016}, πg.NewStr("\n        Return a list (paragraph & messages) & a boolean: literal_block next?\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp017, πE = πg.ResolveClass(πF, πClass, nil, ßparagraph); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp017, ß__doc__, πTemp016); πE != nil {
						continue
					}
					// line 423: def inline_text(self, text, lineno):
					πF.SetLineno(423)
					πTemp003 = make([]πg.Param, 3)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "text", Def: nil}
					πTemp003[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp016 = πg.NewFunction(πg.NewCode("inline_text", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µnodes *πg.Object = πg.UnboundLocal
						_ = µnodes
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 424: """
							πF.SetLineno(424)
							// line 427: nodes, messages = self.inliner.parse(text, lineno,
							πF.SetLineno(427)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßmemo, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp001[3] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinliner, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µnodes = πTemp003
							µmessages = πTemp004
							// line 429: return nodes, messages
							πF.SetLineno(429)
							if πE = πg.CheckLocal(πF, µnodes, "nodes"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(µnodes, µmessages).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinline_text.ToObject(), πTemp016); πE != nil {
						continue
					}
					// line 424: """
					πF.SetLineno(424)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp017}, πg.NewStr("\n        Return 2 lists: nodes (text and inline elements), and system_messages.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp018, πE = πg.ResolveClass(πF, πClass, nil, ßinline_text); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp018, ß__doc__, πTemp017); πE != nil {
						continue
					}
					// line 431: def unindent_warning(self, node_name):
					πF.SetLineno(431)
					πTemp003 = make([]πg.Param, 2)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "node_name", Def: nil}
					πTemp017 = πg.NewFunction(πg.NewCode("unindent_warning", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µnode_name *πg.Object = πArgs[1]
						_ = µnode_name
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 πg.KWArgs
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 433: lineno = self.state_machine.abs_line_number()+1
							πF.SetLineno(433)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 434: return self.reporter.warning('%s ends without a blank line; '
							πF.SetLineno(434)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnode_name, "node_name"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("%s ends without a blank line; unexpected unindent.").ToObject(), µnode_name); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßunindent_warning.ToObject(), πTemp017); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp003, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp003 == nil {
				πTemp003 = πg.TypeType.ToObject()
			}
			if πTemp005, πE = πTemp003.Call(πF, []*πg.Object{πg.NewStr("RSTState").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßRSTState.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 439: def build_regexp(definition, compile=True):
			πF.SetLineno(439)
			πTemp006 = make([]πg.Param, 2)
			πTemp006[0] = πg.Param{Name: "definition", Def: nil}
			if πTemp003, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
				continue
			}
			πTemp006[1] = πg.Param{Name: "compile", Def: πTemp003}
			πTemp001 = πg.NewFunction(πg.NewCode("build_regexp", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µdefinition *πg.Object = πArgs[0]
				_ = µdefinition
				var µcompile *πg.Object = πArgs[1]
				_ = µcompile
				var µname *πg.Object = πg.UnboundLocal
				_ = µname
				var µprefix *πg.Object = πg.UnboundLocal
				_ = µprefix
				var µsuffix *πg.Object = πg.UnboundLocal
				_ = µsuffix
				var µparts *πg.Object = πg.UnboundLocal
				_ = µparts
				var µpart_strings *πg.Object = πg.UnboundLocal
				_ = µpart_strings
				var µpart *πg.Object = πg.UnboundLocal
				_ = µpart
				var µor_group *πg.Object = πg.UnboundLocal
				_ = µor_group
				var µregexp *πg.Object = πg.UnboundLocal
				_ = µregexp
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 []*πg.Object
				_ = πTemp005
				var πTemp006 bool
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				var πTemp008 []*πg.Object
				_ = πTemp008
				var πR *πg.Object
				_ = πR
				var πE *πg.BaseException
				_ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 1:
						goto Label1
					case 2:
						goto Label2
					default:
						panic("unexpected function state")
					}
					// line 440: """
					πF.SetLineno(440)
					// line 447: name, prefix, suffix, parts = definition
					πF.SetLineno(447)
					if πE = πg.CheckLocal(πF, µdefinition, "definition"); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, µdefinition); πE != nil {
						continue
					}
					µname = πTemp001
					µprefix = πTemp002
					µsuffix = πTemp003
					µparts = πTemp004
					// line 448: part_strings = []
					πF.SetLineno(448)
					πTemp005 = make([]*πg.Object, 0)
					πTemp001 = πg.NewList(πTemp005...).ToObject()
					µpart_strings = πTemp001
					if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Iter(πF, µparts); πE != nil {
						continue
					}
					πF.PushCheckpoint(2)
					πTemp006 = false
				Label1:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp006 {
						πF.PopCheckpoint()
						goto Label3
					}
					if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp007 = !isStop
					} else {
						πTemp007 = true
						µpart = πTemp002
					}
					if πE != nil || !πTemp007 {
						continue
					}
					πF.PushCheckpoint(1)
					πTemp005 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
						continue
					}
					πTemp005[0] = µpart
					if πTemp002, πE = πg.ResolveGlobal(πF, ßtuple); πE != nil {
						continue
					}
					πTemp005[1] = πTemp002
					if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp005)
					if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
						continue
					}
					if πTemp007 {
						goto Label4
					}
					goto Label5
					// line 450: if isinstance(part, tuple):
					πF.SetLineno(450)
				Label4:
					// line 451: part_strings.append(build_regexp(part, None))
					πF.SetLineno(451)
					πTemp005 = πF.MakeArgs(1)
					πTemp008 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
						continue
					}
					πTemp008[0] = µpart
					if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
						continue
					}
					πTemp008[1] = πTemp002
					if πTemp002, πE = πg.ResolveGlobal(πF, ßbuild_regexp); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp008)
					πTemp005[0] = πTemp003
					if πE = πg.CheckLocal(πF, µpart_strings, "part_strings"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µpart_strings, ßappend, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp005)
					goto Label6
				Label5:
					// line 453: part_strings.append(part)
					πF.SetLineno(453)
					πTemp005 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
						continue
					}
					πTemp005[0] = µpart
					if πE = πg.CheckLocal(πF, µpart_strings, "part_strings"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µpart_strings, ßappend, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp005)
					goto Label6
				Label6:
					continue
				Label2:
					if πE != nil || πR != nil {
						continue
					}
				Label3:
					// line 454: or_group = '|'.join(part_strings)
					πF.SetLineno(454)
					πTemp005 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µpart_strings, "part_strings"); πE != nil {
						continue
					}
					πTemp005[0] = µpart_strings
					if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("|").ToObject(), ßjoin, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp005)
					µor_group = πTemp002
					// line 455: regexp = '%(prefix)s(?P<%(name)s>%(or_group)s)%(suffix)s' % locals()
					πF.SetLineno(455)
					if πTemp002, πE = πg.ResolveGlobal(πF, ßlocals); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("%(prefix)s(?P<%(name)s>%(or_group)s)%(suffix)s").ToObject(), πTemp003); πE != nil {
						continue
					}
					µregexp = πTemp001
					if πE = πg.CheckLocal(πF, µcompile, "compile"); πE != nil {
						continue
					}
					if πTemp006, πE = πg.IsTrue(πF, µcompile); πE != nil {
						continue
					}
					if πTemp006 {
						goto Label7
					}
					goto Label8
					// line 456: if compile:
					πF.SetLineno(456)
				Label7:
					// line 457: return re.compile(regexp, re.UNICODE)
					πF.SetLineno(457)
					πTemp005 = πF.MakeArgs(2)
					if πE = πg.CheckLocal(πF, µregexp, "regexp"); πE != nil {
						continue
					}
					πTemp005[0] = µregexp
					if πTemp001, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßUNICODE, nil); πE != nil {
						continue
					}
					πTemp005[1] = πTemp002
					if πTemp001, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp005)
					πR = πTemp001
					continue
					goto Label9
				Label8:
					// line 459: return regexp
					πF.SetLineno(459)
					if πE = πg.CheckLocal(πF, µregexp, "regexp"); πE != nil {
						continue
					}
					πR = µregexp
					continue
					goto Label9
				Label9:
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ßbuild_regexp.ToObject(), πTemp001); πE != nil {
				continue
			}
			// line 440: """
			πF.SetLineno(440)
			if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("\n    Build, compile and return a regular expression based on `definition`.\n\n    :Parameter: `definition`: a 4-tuple (group name, prefix, suffix, parts),\n        where \"parts\" is a list of regular expressions and/or regular\n        expression definitions to be joined into an or-group.\n    ").ToObject()); πE != nil {
				continue
			}
			if πTemp005, πE = πg.ResolveGlobal(πF, ßbuild_regexp); πE != nil {
				continue
			}
			if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp003); πE != nil {
				continue
			}
			// line 462: class Inliner(object):
			πF.SetLineno(462)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp007, πE = πg.ResolveGlobal(πF, ßobject); πE != nil {
				continue
			}
			πTemp002[0] = πTemp007
			πTemp004 = πg.NewDict()
			if πTemp003, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp003); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Inliner", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 *πg.Object
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				var πTemp019 *πg.Object
				_ = πTemp019
				var πTemp020 *πg.Object
				_ = πTemp020
				var πTemp021 *πg.Object
				_ = πTemp021
				var πTemp022 *πg.Object
				_ = πTemp022
				var πTemp023 *πg.Object
				_ = πTemp023
				var πTemp024 *πg.Object
				_ = πTemp024
				var πTemp025 *πg.Object
				_ = πTemp025
				var πTemp026 *πg.Dict
				_ = πTemp026
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 464: """
					πF.SetLineno(464)
					// line 464: """
					πF.SetLineno(464)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    Parse inline markup; call the `parse()` method.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 468: def __init__(self):
					πF.SetLineno(468)
					πTemp002 = make([]πg.Param, 1)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 469: self.implicit_dispatch = []
							πF.SetLineno(469)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßimplicit_dispatch, πTemp003); πE != nil {
								continue
							}
							// line 470: """List of (pattern, bound method) tuples, used by
							πF.SetLineno(470)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 473: def init_customizations(self, settings):
					πF.SetLineno(473)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "settings", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("init_customizations", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µsettings *πg.Object = πArgs[1]
						_ = µsettings
						var µstart_string_prefix *πg.Object = πg.UnboundLocal
						_ = µstart_string_prefix
						var µend_string_suffix *πg.Object = πg.UnboundLocal
						_ = µend_string_suffix
						var µargs *πg.Object = πg.UnboundLocal
						_ = µargs
						var µparts *πg.Object = πg.UnboundLocal
						_ = µparts
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πTemp011 *πg.Object
						_ = πTemp011
						var πTemp012 *πg.Object
						_ = πTemp012
						var πTemp013 *πg.Object
						_ = πTemp013
						var πTemp014 *πg.Object
						_ = πTemp014
						var πTemp015 *πg.Object
						_ = πTemp015
						var πTemp016 *πg.Object
						_ = πTemp016
						var πTemp017 *πg.Object
						_ = πTemp017
						var πTemp018 *πg.Object
						_ = πTemp018
						var πTemp019 *πg.Object
						_ = πTemp019
						var πTemp020 πg.KWArgs
						_ = πTemp020
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µsettings, "settings"); πE != nil {
								continue
							}
							πTemp001[0] = µsettings
							πTemp001[1] = ßcharacter_level_inline_markup.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 475: if getattr(settings, 'character_level_inline_markup', False):
							πF.SetLineno(475)
						Label1:
							// line 476: start_string_prefix = u'(^|(?<!\x00))'
							πF.SetLineno(476)
							µstart_string_prefix = πg.NewUnicode("(^|(?<!\x00))").ToObject()
							// line 477: end_string_suffix = u''
							πF.SetLineno(477)
							µend_string_suffix = πg.NewUnicode("").ToObject()
							goto Label3
						Label2:
							// line 479: start_string_prefix = (u'(^|(?<=\\s|[%s%s]))' %
							πF.SetLineno(479)
							if πTemp005, πE = πg.ResolveGlobal(πF, ßpunctuation_chars); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßopeners, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßpunctuation_chars); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp005, ßdelimiters, nil); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(πTemp006, πTemp007).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewUnicode("(^|(?<=\\s|[%s%s]))").ToObject(), πTemp003); πE != nil {
								continue
							}
							µstart_string_prefix = πTemp002
							// line 482: end_string_suffix = (u'($|(?=\\s|[\x00%s%s%s]))' %
							πF.SetLineno(482)
							if πTemp005, πE = πg.ResolveGlobal(πF, ßpunctuation_chars); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßclosing_delimiters, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßpunctuation_chars); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp005, ßdelimiters, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßpunctuation_chars); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp005, ßclosers, nil); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple3(πTemp006, πTemp007, πTemp008).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewUnicode("($|(?=\\s|[\x00%s%s%s]))").ToObject(), πTemp003); πE != nil {
								continue
							}
							µend_string_suffix = πTemp002
							goto Label3
						Label3:
							// line 486: args = locals().copy()
							πF.SetLineno(486)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlocals); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßcopy, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µargs = πTemp003
							// line 487: args.update(vars(self.__class__))
							πF.SetLineno(487)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ß__class__, nil); πE != nil {
								continue
							}
							πTemp009[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßvars); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µargs, ßupdate, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 489: parts = ('initial_inline', start_string_prefix, '',
							πF.SetLineno(489)
							if πE = πg.CheckLocal(πF, µstart_string_prefix, "start_string_prefix"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßnon_whitespace_after, nil); πE != nil {
								continue
							}
							πTemp009 = make([]*πg.Object, 5)
							πTemp009[0] = πg.NewStr("\\*\\*").ToObject()
							πTemp009[1] = πg.NewStr("\\*(?!\\*)").ToObject()
							πTemp009[2] = πg.NewStr("``").ToObject()
							πTemp009[3] = πg.NewStr("_`").ToObject()
							πTemp009[4] = πg.NewStr("\\|(?!\\|)").ToObject()
							πTemp006 = πg.NewList(πTemp009...).ToObject()
							πTemp003 = πg.NewTuple4(ßstart.ToObject(), ß.ToObject(), πTemp005, πTemp006).ToObject()
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µend_string_suffix, "end_string_suffix"); πE != nil {
								continue
							}
							πTemp009 = make([]*πg.Object, 2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßsimplename, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Mod(πF, πg.NewStr("(?P<refname>%s)(?P<refend>__?)").ToObject(), πTemp006); πE != nil {
								continue
							}
							πTemp009[0] = πTemp005
							πTemp010 = make([]*πg.Object, 4)
							πTemp010[0] = πg.NewStr("[0-9]+").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßsimplename, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Mod(πF, πg.NewStr("\\#(%s)?").ToObject(), πTemp007); πE != nil {
								continue
							}
							πTemp010[1] = πTemp006
							πTemp010[2] = πg.NewStr("\\*").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßsimplename, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Mod(πF, πg.NewStr("(?P<citationlabel>%s)").ToObject(), πTemp007); πE != nil {
								continue
							}
							πTemp010[3] = πTemp006
							πTemp006 = πg.NewList(πTemp010...).ToObject()
							πTemp005 = πg.NewTuple4(ßfootnotelabel.ToObject(), πg.NewStr("\\[").ToObject(), πg.NewStr("(?P<fnend>\\]_)").ToObject(), πTemp006).ToObject()
							πTemp009[1] = πTemp005
							πTemp005 = πg.NewList(πTemp009...).ToObject()
							πTemp003 = πg.NewTuple4(ßwhole.ToObject(), ß.ToObject(), µend_string_suffix, πTemp005).ToObject()
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßsimplename, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Mod(πF, πg.NewStr("(?P<role>(:%s:)?)").ToObject(), πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßnon_whitespace_after, nil); πE != nil {
								continue
							}
							πTemp009 = make([]*πg.Object, 1)
							πTemp009[0] = πg.NewStr("`(?!`)").ToObject()
							πTemp007 = πg.NewList(πTemp009...).ToObject()
							πTemp003 = πg.NewTuple4(ßbackquote.ToObject(), πTemp005, πTemp006, πTemp007).ToObject()
							πTemp001[2] = πTemp003
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple4(ßinitial_inline.ToObject(), µstart_string_prefix, ß.ToObject(), πTemp003).ToObject()
							µparts = πTemp002
							// line 515: self.start_string_prefix = start_string_prefix
							πF.SetLineno(515)
							if πE = πg.CheckLocal(πF, µstart_string_prefix, "start_string_prefix"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µstart_string_prefix); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßstart_string_prefix, πTemp002); πE != nil {
								continue
							}
							// line 516: self.end_string_suffix = end_string_suffix
							πF.SetLineno(516)
							if πE = πg.CheckLocal(πF, µend_string_suffix, "end_string_suffix"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µend_string_suffix); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßend_string_suffix, πTemp002); πE != nil {
								continue
							}
							// line 517: self.parts = parts
							πF.SetLineno(517)
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µparts); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparts, πTemp002); πE != nil {
								continue
							}
							// line 519: self.patterns = Struct(
							πF.SetLineno(519)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							πTemp001[0] = µparts
							if πTemp002, πE = πg.ResolveGlobal(πF, ßbuild_regexp); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßnon_whitespace_escape_before, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πTemp006, πg.NewStr("(\\*)").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µend_string_suffix, "end_string_suffix"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp005, µend_string_suffix); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßUNICODE, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp005
							if πTemp002, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßnon_whitespace_escape_before, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Add(πF, πTemp007, πg.NewStr("(\\*\\*)").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µend_string_suffix, "end_string_suffix"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, πTemp006, µend_string_suffix); πE != nil {
								continue
							}
							πTemp001[0] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßUNICODE, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp006
							if πTemp005, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Mod(πF, πg.NewStr("\n              %(non_unescaped_whitespace_escape_before)s\n              (\n                `\n                (?P<suffix>\n                  (?P<role>:%(simplename)s:)?\n                  (?P<refend>__?)?\n                )\n              )\n              %(end_string_suffix)s\n              ").ToObject(), µargs); πE != nil {
								continue
							}
							πTemp001[0] = πTemp006
							if πTemp007, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßVERBOSE, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetAttr(πF, πTemp007, ßUNICODE, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Or(πF, πTemp008, πTemp011); πE != nil {
								continue
							}
							πTemp001[1] = πTemp006
							if πTemp006, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Mod(πF, πg.NewStr("\n              (\n                (?:[ \\n]+|^)            # spaces or beginning of line/string\n                <                       # open bracket\n                %(non_whitespace_after)s\n                (([^<>]|\\x00[<>])+)     # anything but unescaped angle brackets\n                %(non_whitespace_escape_before)s\n                >                       # close bracket\n              )\n              $                         # end of string\n              ").ToObject(), µargs); πE != nil {
								continue
							}
							πTemp001[0] = πTemp007
							if πTemp008, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetAttr(πF, πTemp008, ßVERBOSE, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetAttr(πF, πTemp008, ßUNICODE, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Or(πF, πTemp011, πTemp012); πE != nil {
								continue
							}
							πTemp001[1] = πTemp007
							if πTemp007, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp008.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetAttr(πF, µself, ßnon_whitespace_before, nil); πE != nil {
								continue
							}
							if πTemp011, πE = πg.Add(πF, πTemp012, πg.NewStr("(``)").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µend_string_suffix, "end_string_suffix"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Add(πF, πTemp011, µend_string_suffix); πE != nil {
								continue
							}
							πTemp001[0] = πTemp008
							if πTemp008, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetAttr(πF, πTemp008, ßUNICODE, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp011
							if πTemp008, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetAttr(πF, πTemp008, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp011.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, µself, ßnon_whitespace_escape_before, nil); πE != nil {
								continue
							}
							if πTemp012, πE = πg.Add(πF, πTemp013, πg.NewStr("(`)").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µend_string_suffix, "end_string_suffix"); πE != nil {
								continue
							}
							if πTemp011, πE = πg.Add(πF, πTemp012, µend_string_suffix); πE != nil {
								continue
							}
							πTemp001[0] = πTemp011
							if πTemp011, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetAttr(πF, πTemp011, ßUNICODE, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp012
							if πTemp011, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetAttr(πF, πTemp011, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp011, πE = πTemp012.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp014, πE = πg.GetAttr(πF, µself, ßnon_whitespace_escape_before, nil); πE != nil {
								continue
							}
							if πTemp013, πE = πg.Add(πF, πTemp014, πg.NewStr("(\\|_{0,2})").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µend_string_suffix, "end_string_suffix"); πE != nil {
								continue
							}
							if πTemp012, πE = πg.Add(πF, πTemp013, µend_string_suffix); πE != nil {
								continue
							}
							πTemp001[0] = πTemp012
							if πTemp012, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, πTemp012, ßUNICODE, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp013
							if πTemp012, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetAttr(πF, πTemp012, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp012, πE = πTemp013.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp015, πE = πg.GetAttr(πF, µself, ßemail_pattern, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp014, πE = πg.Mod(πF, πTemp015, µargs); πE != nil {
								continue
							}
							if πTemp013, πE = πg.Add(πF, πTemp014, πg.NewStr("$").ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp013
							if πTemp014, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp015, πE = πg.GetAttr(πF, πTemp014, ßVERBOSE, nil); πE != nil {
								continue
							}
							if πTemp014, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp016, πE = πg.GetAttr(πF, πTemp014, ßUNICODE, nil); πE != nil {
								continue
							}
							if πTemp013, πE = πg.Or(πF, πTemp015, πTemp016); πE != nil {
								continue
							}
							πTemp001[1] = πTemp013
							if πTemp013, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp014, πE = πg.GetAttr(πF, πTemp013, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp013, πE = πTemp014.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp017, πE = πg.GetAttr(πF, µself, ßemail_pattern, nil); πE != nil {
								continue
							}
							if πTemp016, πE = πg.Add(πF, πg.NewStr("\n                %(start_string_prefix)s\n                (?P<whole>\n                  (?P<absolute>           # absolute URI\n                    (?P<scheme>             # scheme (http, ftp, mailto)\n                      [a-zA-Z][a-zA-Z0-9.+-]*\n                    )\n                    :\n                    (\n                      (                       # either:\n                        (//?)?                  # hierarchical URI\n                        %(uric)s*               # URI characters\n                        %(uri_end)s             # final URI char\n                      )\n                      (                       # optional query\n                        \\?%(uric)s*\n                        %(uri_end)s\n                      )?\n                      (                       # optional fragment\n                        \\#%(uric)s*\n                        %(uri_end)s\n                      )?\n                    )\n                  )\n                |                       # *OR*\n                  (?P<email>              # email address\n                    ").ToObject(), πTemp017); πE != nil {
								continue
							}
							if πTemp015, πE = πg.Add(πF, πTemp016, πg.NewStr("\n                  )\n                )\n                %(end_string_suffix)s\n                ").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp014, πE = πg.Mod(πF, πTemp015, µargs); πE != nil {
								continue
							}
							πTemp001[0] = πTemp014
							if πTemp015, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp016, πE = πg.GetAttr(πF, πTemp015, ßVERBOSE, nil); πE != nil {
								continue
							}
							if πTemp015, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp017, πE = πg.GetAttr(πF, πTemp015, ßUNICODE, nil); πE != nil {
								continue
							}
							if πTemp014, πE = πg.Or(πF, πTemp016, πTemp017); πE != nil {
								continue
							}
							πTemp001[1] = πTemp014
							if πTemp014, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp015, πE = πg.GetAttr(πF, πTemp014, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp014, πE = πTemp015.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp015, πE = πg.Mod(πF, πg.NewStr("\n                %(start_string_prefix)s\n                (\n                  (pep-(?P<pepnum1>\\d+)(.txt)?) # reference to source file\n                |\n                  (PEP\\s+(?P<pepnum2>\\d+))      # reference by name\n                )\n                %(end_string_suffix)s").ToObject(), µargs); πE != nil {
								continue
							}
							πTemp001[0] = πTemp015
							if πTemp016, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp017, πE = πg.GetAttr(πF, πTemp016, ßVERBOSE, nil); πE != nil {
								continue
							}
							if πTemp016, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp018, πE = πg.GetAttr(πF, πTemp016, ßUNICODE, nil); πE != nil {
								continue
							}
							if πTemp015, πE = πg.Or(πF, πTemp017, πTemp018); πE != nil {
								continue
							}
							πTemp001[1] = πTemp015
							if πTemp015, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp016, πE = πg.GetAttr(πF, πTemp015, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp015, πE = πTemp016.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µargs, "args"); πE != nil {
								continue
							}
							if πTemp016, πE = πg.Mod(πF, πg.NewStr("\n                %(start_string_prefix)s\n                (RFC(-|\\s+)?(?P<rfcnum>\\d+))\n                %(end_string_suffix)s").ToObject(), µargs); πE != nil {
								continue
							}
							πTemp001[0] = πTemp016
							if πTemp017, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp018, πE = πg.GetAttr(πF, πTemp017, ßVERBOSE, nil); πE != nil {
								continue
							}
							if πTemp017, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp019, πE = πg.GetAttr(πF, πTemp017, ßUNICODE, nil); πE != nil {
								continue
							}
							if πTemp016, πE = πg.Or(πF, πTemp018, πTemp019); πE != nil {
								continue
							}
							πTemp001[1] = πTemp016
							if πTemp016, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp017, πE = πg.GetAttr(πF, πTemp016, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp016, πE = πTemp017.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp020 = πg.KWArgs{
								{"initial", πTemp003},
								{"emphasis", πTemp002},
								{"strong", πTemp005},
								{"interpreted_or_phrase_ref", πTemp006},
								{"embedded_link", πTemp007},
								{"literal", πTemp008},
								{"target", πTemp011},
								{"substitution_ref", πTemp012},
								{"email", πTemp013},
								{"uri", πTemp014},
								{"pep", πTemp015},
								{"rfc", πTemp016},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßStruct); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, πTemp020); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßpatterns, πTemp002); πE != nil {
								continue
							}
							// line 605: self.implicit_dispatch.append((self.patterns.uri,
							πF.SetLineno(605)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßuri, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstandalone_uri, nil); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp005, πTemp003).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßimplicit_dispatch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µsettings, "settings"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µsettings, ßpep_references, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 607: if settings.pep_references:
							πF.SetLineno(607)
						Label4:
							// line 608: self.implicit_dispatch.append((self.patterns.pep,
							πF.SetLineno(608)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßpep, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpep_reference, nil); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp005, πTemp003).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßimplicit_dispatch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label5
						Label5:
							if πE = πg.CheckLocal(πF, µsettings, "settings"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µsettings, ßrfc_references, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 610: if settings.rfc_references:
							πF.SetLineno(610)
						Label6:
							// line 611: self.implicit_dispatch.append((self.patterns.rfc,
							πF.SetLineno(611)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßrfc, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßrfc_reference, nil); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp005, πTemp003).ToObject()
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßimplicit_dispatch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label7
						Label7:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinit_customizations.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 614: def parse(self, text, lineno, memo, parent):
					πF.SetLineno(614)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp002[3] = πg.Param{Name: "memo", Def: nil}
					πTemp002[4] = πg.Param{Name: "parent", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("parse", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µmemo *πg.Object = πArgs[3]
						_ = µmemo
						var µparent *πg.Object = πArgs[4]
						_ = µparent
						var µpattern_search *πg.Object = πg.UnboundLocal
						_ = µpattern_search
						var µdispatch *πg.Object = πg.UnboundLocal
						_ = µdispatch
						var µremaining *πg.Object = πg.UnboundLocal
						_ = µremaining
						var µprocessed *πg.Object = πg.UnboundLocal
						_ = µprocessed
						var µunprocessed *πg.Object = πg.UnboundLocal
						_ = µunprocessed
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µmatch *πg.Object = πg.UnboundLocal
						_ = µmatch
						var µgroups *πg.Object = πg.UnboundLocal
						_ = µgroups
						var µmethod *πg.Object = πg.UnboundLocal
						_ = µmethod
						var µbefore *πg.Object = πg.UnboundLocal
						_ = µbefore
						var µinlines *πg.Object = πg.UnboundLocal
						_ = µinlines
						var µsysmessages *πg.Object = πg.UnboundLocal
						_ = µsysmessages
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 617: """
							πF.SetLineno(617)
							// line 630: self.reporter = memo.reporter
							πF.SetLineno(630)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßreporter, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßreporter, πTemp002); πE != nil {
								continue
							}
							// line 631: self.document = memo.document
							πF.SetLineno(631)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßdocument, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßdocument, πTemp002); πE != nil {
								continue
							}
							// line 632: self.language = memo.language
							πF.SetLineno(632)
							if πE = πg.CheckLocal(πF, µmemo, "memo"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmemo, ßlanguage, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlanguage, πTemp002); πE != nil {
								continue
							}
							// line 633: self.parent = parent
							πF.SetLineno(633)
							if πE = πg.CheckLocal(πF, µparent, "parent"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µparent); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp001); πE != nil {
								continue
							}
							// line 634: pattern_search = self.patterns.initial.search
							πF.SetLineno(634)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinitial, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsearch, nil); πE != nil {
								continue
							}
							µpattern_search = πTemp001
							// line 635: dispatch = self.dispatch
							πF.SetLineno(635)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdispatch, nil); πE != nil {
								continue
							}
							µdispatch = πTemp001
							// line 636: remaining = escape2null(text)
							πF.SetLineno(636)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp003[0] = µtext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßescape2null); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µremaining = πTemp002
							// line 637: processed = []
							πF.SetLineno(637)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							µprocessed = πTemp001
							// line 638: unprocessed = []
							πF.SetLineno(638)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							µunprocessed = πTemp001
							// line 639: messages = []
							πF.SetLineno(639)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							µmessages = πTemp001
							// line 640: while remaining:
							πF.SetLineno(640)
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µremaining); πE != nil {
								continue
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 641: match = pattern_search(remaining)
							πF.SetLineno(641)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							πTemp003[0] = µremaining
							if πE = πg.CheckLocal(πF, µpattern_search, "pattern_search"); πE != nil {
								continue
							}
							if πTemp001, πE = µpattern_search.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmatch = πTemp001
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µmatch); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 642: if match:
							πF.SetLineno(642)
						Label4:
							// line 643: groups = match.groupdict()
							πF.SetLineno(643)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßgroupdict, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µgroups = πTemp002
							// line 644: method = dispatch[groups['start'] or groups['backquote']
							πF.SetLineno(644)
							πTemp006 = ßstart.ToObject()
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µgroups, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πTemp007
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							πTemp006 = ßbackquote.ToObject()
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µgroups, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πTemp007
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							πTemp006 = ßrefend.ToObject()
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µgroups, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πTemp007
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label7
							}
							πTemp006 = ßfnend.ToObject()
							if πE = πg.CheckLocal(πF, µgroups, "groups"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µgroups, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πTemp007
						Label7:
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µdispatch, "dispatch"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µdispatch, πTemp001); πE != nil {
								continue
							}
							µmethod = πTemp002
							// line 646: before, inlines, remaining, sysmessages = method(self, match,
							πF.SetLineno(646)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp003[0] = µself
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp003[1] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[2] = µlineno
							if πE = πg.CheckLocal(πF, µmethod, "method"); πE != nil {
								continue
							}
							if πTemp001, πE = µmethod.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}, πg.TieTarget{Target: &πTemp008}}}, πTemp001); πE != nil {
								continue
							}
							µbefore = πTemp002
							µinlines = πTemp006
							µremaining = πTemp007
							µsysmessages = πTemp008
							// line 648: unprocessed.append(before)
							πF.SetLineno(648)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							πTemp003[0] = µbefore
							if πE = πg.CheckLocal(πF, µunprocessed, "unprocessed"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µunprocessed, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 649: messages += sysmessages
							πF.SetLineno(649)
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsysmessages, "sysmessages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µmessages, µsysmessages); πE != nil {
								continue
							}
							µmessages = πTemp001
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µinlines); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label8
							}
							goto Label9
							// line 650: if inlines:
							πF.SetLineno(650)
						Label8:
							// line 651: processed += self.implicit_inline(''.join(unprocessed),
							πF.SetLineno(651)
							if πE = πg.CheckLocal(πF, µprocessed, "processed"); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(2)
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µunprocessed, "unprocessed"); πE != nil {
								continue
							}
							πTemp009[0] = µunprocessed
							if πTemp001, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßimplicit_inline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.IAdd(πF, µprocessed, πTemp002); πE != nil {
								continue
							}
							µprocessed = πTemp001
							// line 653: processed += inlines
							πF.SetLineno(653)
							if πE = πg.CheckLocal(πF, µprocessed, "processed"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µprocessed, µinlines); πE != nil {
								continue
							}
							µprocessed = πTemp001
							// line 654: unprocessed = []
							πF.SetLineno(654)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							µunprocessed = πTemp001
							goto Label9
						Label9:
							goto Label6
						Label5:
							// line 656: break
							πF.SetLineno(656)
							πTemp004 = true
							continue
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 657: remaining = ''.join(unprocessed) + remaining
							πF.SetLineno(657)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µunprocessed, "unprocessed"); πE != nil {
								continue
							}
							πTemp003[0] = µunprocessed
							if πTemp002, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp006, µremaining); πE != nil {
								continue
							}
							µremaining = πTemp001
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µremaining); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label10
							}
							goto Label11
							// line 658: if remaining:
							πF.SetLineno(658)
						Label10:
							// line 659: processed += self.implicit_inline(remaining, lineno)
							πF.SetLineno(659)
							if πE = πg.CheckLocal(πF, µprocessed, "processed"); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							πTemp003[0] = µremaining
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßimplicit_inline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.IAdd(πF, µprocessed, πTemp002); πE != nil {
								continue
							}
							µprocessed = πTemp001
							goto Label11
						Label11:
							// line 660: return processed, messages
							πF.SetLineno(660)
							if πE = πg.CheckLocal(πF, µprocessed, "processed"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µprocessed, µmessages).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 617: """
					πF.SetLineno(617)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("\n        Return 2 lists: nodes (text and inline elements), and system_messages.\n\n        Using `self.patterns.initial`, a pattern which matches start-strings\n        (emphasis, strong, interpreted, phrase reference, literal,\n        substitution reference, and inline target) and complete constructs\n        (simple reference, footnote reference), search for a candidate.  When\n        one is found, check for validity (e.g., not a quoted '*' character).\n        If valid, search for the corresponding end string if applicable, and\n        check it for validity.  If not found or invalid, generate a warning\n        and ignore the start-string.  Implicit inline markup (e.g. standalone\n        URIs) is found last.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßparse); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 665: non_whitespace_before = r'(?<!\s)'
					πF.SetLineno(665)
					if πE = πClass.SetItem(πF, ßnon_whitespace_before.ToObject(), πg.NewStr("(?<!\\s)").ToObject()); πE != nil {
						continue
					}
					// line 666: non_whitespace_escape_before = r'(?<![\s\x00])'
					πF.SetLineno(666)
					if πE = πClass.SetItem(πF, ßnon_whitespace_escape_before.ToObject(), πg.NewStr("(?<![\\s\\x00])").ToObject()); πE != nil {
						continue
					}
					// line 667: non_unescaped_whitespace_escape_before = r'(?<!(?<!\x00)[\s\x00])'
					πF.SetLineno(667)
					if πE = πClass.SetItem(πF, ßnon_unescaped_whitespace_escape_before.ToObject(), πg.NewStr("(?<!(?<!\\x00)[\\s\\x00])").ToObject()); πE != nil {
						continue
					}
					// line 668: non_whitespace_after = r'(?!\s)'
					πF.SetLineno(668)
					if πE = πClass.SetItem(πF, ßnon_whitespace_after.ToObject(), πg.NewStr("(?!\\s)").ToObject()); πE != nil {
						continue
					}
					// line 670: simplename = r'(?:(?!_)\w)+(?:[-._+:](?:(?!_)\w)+)*'
					πF.SetLineno(670)
					if πE = πClass.SetItem(πF, ßsimplename.ToObject(), πg.NewStr("(?:(?!_)\\w)+(?:[-._+:](?:(?!_)\\w)+)*").ToObject()); πE != nil {
						continue
					}
					// line 673: uric = r"""[-_.!~*'()[\];/:@&=+$,%a-zA-Z0-9\x00]"""
					πF.SetLineno(673)
					if πE = πClass.SetItem(πF, ßuric.ToObject(), πg.NewStr("[-_.!~*'()[\\];/:@&=+$,%a-zA-Z0-9\\x00]").ToObject()); πE != nil {
						continue
					}
					// line 675: uri_end_delim = r"""[>]"""
					πF.SetLineno(675)
					if πE = πClass.SetItem(πF, ßuri_end_delim.ToObject(), πg.NewStr("[>]").ToObject()); πE != nil {
						continue
					}
					// line 677: urilast = r"""[_~*/=+a-zA-Z0-9]"""
					πF.SetLineno(677)
					if πE = πClass.SetItem(πF, ßurilast.ToObject(), πg.NewStr("[_~*/=+a-zA-Z0-9]").ToObject()); πE != nil {
						continue
					}
					// line 680: uri_end = r"""(?:%(urilast)s|%(uric)s(?=%(uri_end_delim)s))""" % locals()
					πF.SetLineno(680)
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßlocals); πE != nil {
						continue
					}
					if πTemp007, πE = πTemp006.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πTemp005, πE = πg.Mod(πF, πg.NewStr("(?:%(urilast)s|%(uric)s(?=%(uri_end_delim)s))").ToObject(), πTemp007); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßuri_end.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 681: emailc = r"""[-_!~*'{|}/#?^`&=+$%a-zA-Z0-9\x00]"""
					πF.SetLineno(681)
					if πE = πClass.SetItem(πF, ßemailc.ToObject(), πg.NewStr("[-_!~*'{|}/#?^`&=+$%a-zA-Z0-9\\x00]").ToObject()); πE != nil {
						continue
					}
					// line 682: email_pattern = r"""
					πF.SetLineno(682)
					if πE = πClass.SetItem(πF, ßemail_pattern.ToObject(), πg.NewStr("\n          %(emailc)s+(?:\\.%(emailc)s+)*   # name\n          (?<!\\x00)@                      # at\n          %(emailc)s+(?:\\.%(emailc)s*)*   # host\n          %(uri_end)s                     # final URI char\n          ").ToObject()); πE != nil {
						continue
					}
					// line 689: def quoted_start(self, match):
					πF.SetLineno(689)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("quoted_start", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µstring *πg.Object = πg.UnboundLocal
						_ = µstring
						var µstart *πg.Object = πg.UnboundLocal
						_ = µstart
						var µprestart *πg.Object = πg.UnboundLocal
						_ = µprestart
						var µpoststart *πg.Object = πg.UnboundLocal
						_ = µpoststart
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 690: """Test if inline markup start-string is 'quoted'.
							πF.SetLineno(690)
							// line 696: string = match.string
							πF.SetLineno(696)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							µstring = πTemp001
							// line 697: start = match.start()
							πF.SetLineno(697)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µstart = πTemp002
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µstart, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 698: if start == 0:                  # start-string at beginning of text
							πF.SetLineno(698)
						Label1:
							// line 699: return False
							πF.SetLineno(699)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 700: prestart = string[start - 1]
							πF.SetLineno(700)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Sub(πF, µstart, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							µprestart = πTemp002
							// line 701: try:
							πF.SetLineno(701)
							πF.PushCheckpoint(4)
							// line 702: poststart = string[match.end()]
							πF.SetLineno(702)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							µpoststart = πTemp002
							πF.PopCheckpoint()
							goto Label3
						Label4:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßIndexError); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 703: except IndexError:          # start-string at end of text
							πF.SetLineno(703)
						Label5:
							// line 704: return True  # not "quoted" but no markup start-string either
							πF.SetLineno(704)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							πF.RestoreExc(nil, nil)
							goto Label3
						Label3:
							// line 705: return punctuation_chars.match_chars(prestart, poststart)
							πF.SetLineno(705)
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µprestart, "prestart"); πE != nil {
								continue
							}
							πTemp007[0] = µprestart
							if πE = πg.CheckLocal(πF, µpoststart, "poststart"); πE != nil {
								continue
							}
							πTemp007[1] = µpoststart
							if πTemp001, πE = πg.ResolveGlobal(πF, ßpunctuation_chars); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßmatch_chars, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßquoted_start.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 690: """Test if inline markup start-string is 'quoted'.
					πF.SetLineno(690)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πg.NewStr("Test if inline markup start-string is 'quoted'.\n\n        'Quoted' in this context means the start-string is enclosed in a pair\n        of matching opening/closing delimiters (not necessarily quotes)\n        or at the end of the match.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßquoted_start); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp007, ß__doc__, πTemp006); πE != nil {
						continue
					}
					// line 707: def inline_obj(self, match, lineno, end_pattern, nodeclass,
					πF.SetLineno(707)
					πTemp002 = make([]πg.Param, 6)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp002[3] = πg.Param{Name: "end_pattern", Def: nil}
					πTemp002[4] = πg.Param{Name: "nodeclass", Def: nil}
					if πTemp007, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "restore_backslashes", Def: πTemp007}
					πTemp006 = πg.NewFunction(πg.NewCode("inline_obj", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µend_pattern *πg.Object = πArgs[3]
						_ = µend_pattern
						var µnodeclass *πg.Object = πArgs[4]
						_ = µnodeclass
						var µrestore_backslashes *πg.Object = πArgs[5]
						_ = µrestore_backslashes
						var µstring *πg.Object = πg.UnboundLocal
						_ = µstring
						var µmatchstart *πg.Object = πg.UnboundLocal
						_ = µmatchstart
						var µmatchend *πg.Object = πg.UnboundLocal
						_ = µmatchend
						var µendmatch *πg.Object = πg.UnboundLocal
						_ = µendmatch
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µtextend *πg.Object = πg.UnboundLocal
						_ = µtextend
						var µrawsource *πg.Object = πg.UnboundLocal
						_ = µrawsource
						var µnode *πg.Object = πg.UnboundLocal
						_ = µnode
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var µprb *πg.Object = πg.UnboundLocal
						_ = µprb
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 πg.KWArgs
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 709: string = match.string
							πF.SetLineno(709)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							µstring = πTemp001
							// line 710: matchstart = match.start('start')
							πF.SetLineno(710)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßstart.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µmatchstart = πTemp003
							// line 711: matchend = match.end('start')
							πF.SetLineno(711)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßstart.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µmatchend = πTemp003
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp002[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßquoted_start, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 712: if self.quoted_start(match):
							πF.SetLineno(712)
						Label1:
							// line 713: return (string[:matchend], [], string[matchend:], [], '')
							πF.SetLineno(713)
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µmatchend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µstring, πTemp003); πE != nil {
								continue
							}
							πTemp002 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp002...).ToObject()
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{µmatchend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µstring, πTemp006); πE != nil {
								continue
							}
							πTemp002 = make([]*πg.Object, 0)
							πTemp006 = πg.NewList(πTemp002...).ToObject()
							πTemp001 = πg.NewTuple5(πTemp005, πTemp003, πTemp007, πTemp006, ß.ToObject()).ToObject()
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 714: endmatch = end_pattern.search(string[matchend:])
							πF.SetLineno(714)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µmatchend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µend_pattern, "end_pattern"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µend_pattern, ßsearch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µendmatch = πTemp003
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							πTemp001 = µendmatch
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label3
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µendmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001 = πTemp005
						Label3:
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 715: if endmatch and endmatch.start(1):  # 1 or more chars
							πF.SetLineno(715)
						Label4:
							// line 716: text = endmatch.string[:endmatch.start(1)]
							πF.SetLineno(716)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µendmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp005, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µendmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							µtext = πTemp003
							if πE = πg.CheckLocal(πF, µrestore_backslashes, "restore_backslashes"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µrestore_backslashes); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 717: if restore_backslashes:
							πF.SetLineno(717)
						Label6:
							// line 718: text = unescape(text, True)
							πF.SetLineno(718)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp002[0] = µtext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp002[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µtext = πTemp003
							goto Label7
						Label7:
							// line 719: textend = matchend + endmatch.end(1)
							πF.SetLineno(719)
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µendmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Add(πF, µmatchend, πTemp005); πE != nil {
								continue
							}
							µtextend = πTemp001
							// line 720: rawsource = unescape(string[matchstart:textend], True)
							πF.SetLineno(720)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatchstart, "matchstart"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µmatchstart, µtextend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp002[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µrawsource = πTemp003
							// line 721: node = nodeclass(rawsource, text)
							πF.SetLineno(721)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							πTemp002[0] = µrawsource
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp002[1] = µtext
							if πE = πg.CheckLocal(πF, µnodeclass, "nodeclass"); πE != nil {
								continue
							}
							if πTemp001, πE = µnodeclass.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µnode = πTemp001
							// line 722: return (string[:matchstart], [node],
							πF.SetLineno(722)
							if πE = πg.CheckLocal(πF, µmatchstart, "matchstart"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µmatchstart, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µstring, πTemp003); πE != nil {
								continue
							}
							πTemp002 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp002[0] = µnode
							πTemp003 = πg.NewList(πTemp002...).ToObject()
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{µtextend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µstring, πTemp006); πE != nil {
								continue
							}
							πTemp002 = make([]*πg.Object, 0)
							πTemp006 = πg.NewList(πTemp002...).ToObject()
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µendmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001 = πg.NewTuple5(πTemp005, πTemp003, πTemp007, πTemp006, πTemp009).ToObject()
							πR = πTemp001
							continue
							goto Label5
						Label5:
							// line 724: msg = self.reporter.warning(
							πF.SetLineno(724)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnodeclass, "nodeclass"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µnodeclass, ß__name__, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("Inline %s start-string without end-string.").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp010 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µmsg = πTemp001
							// line 727: text = unescape(string[matchstart:matchend], True)
							πF.SetLineno(727)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatchstart, "matchstart"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µmatchstart, µmatchend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp002[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µtext = πTemp003
							// line 728: prb = self.problematic(text, text, msg)
							πF.SetLineno(728)
							πTemp002 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp002[0] = µtext
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp002[1] = µtext
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp002[2] = µmsg
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßproblematic, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µprb = πTemp003
							// line 729: return string[:matchstart], [prb], string[matchend:], [msg], ''
							πF.SetLineno(729)
							if πE = πg.CheckLocal(πF, µmatchstart, "matchstart"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µmatchstart, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µstring, πTemp003); πE != nil {
								continue
							}
							πTemp002 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µprb, "prb"); πE != nil {
								continue
							}
							πTemp002[0] = µprb
							πTemp003 = πg.NewList(πTemp002...).ToObject()
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{µmatchend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µstring, πTemp006); πE != nil {
								continue
							}
							πTemp002 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp002[0] = µmsg
							πTemp006 = πg.NewList(πTemp002...).ToObject()
							πTemp001 = πg.NewTuple5(πTemp005, πTemp003, πTemp007, πTemp006, ß.ToObject()).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinline_obj.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 731: def problematic(self, text, rawsource, message):
					πF.SetLineno(731)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp002[2] = πg.Param{Name: "rawsource", Def: nil}
					πTemp002[3] = πg.Param{Name: "message", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("problematic", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var µrawsource *πg.Object = πArgs[2]
						_ = µrawsource
						var µmessage *πg.Object = πArgs[3]
						_ = µmessage
						var µmsgid *πg.Object = πg.UnboundLocal
						_ = µmsgid
						var µproblematic *πg.Object = πg.UnboundLocal
						_ = µproblematic
						var µprbid *πg.Object = πg.UnboundLocal
						_ = µprbid
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 732: msgid = self.document.set_id(message, self.parent)
							πF.SetLineno(732)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp001[0] = µmessage
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßset_id, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsgid = πTemp002
							// line 733: problematic = nodes.problematic(rawsource, text, refid=msgid)
							πF.SetLineno(733)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							πTemp001[0] = µrawsource
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[1] = µtext
							if πE = πg.CheckLocal(πF, µmsgid, "msgid"); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"refid", µmsgid},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßproblematic, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µproblematic = πTemp002
							// line 734: prbid = self.document.set_id(problematic)
							πF.SetLineno(734)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µproblematic, "problematic"); πE != nil {
								continue
							}
							πTemp001[0] = µproblematic
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßset_id, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µprbid = πTemp002
							// line 735: message.add_backref(prbid)
							πF.SetLineno(735)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µprbid, "prbid"); πE != nil {
								continue
							}
							πTemp001[0] = µprbid
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmessage, ßadd_backref, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 736: return problematic
							πF.SetLineno(736)
							if πE = πg.CheckLocal(πF, µproblematic, "problematic"); πE != nil {
								continue
							}
							πR = µproblematic
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßproblematic.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 738: def emphasis(self, match, lineno):
					πF.SetLineno(738)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("emphasis", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µbefore *πg.Object = πg.UnboundLocal
						_ = µbefore
						var µinlines *πg.Object = πg.UnboundLocal
						_ = µinlines
						var µremaining *πg.Object = πg.UnboundLocal
						_ = µremaining
						var µsysmessages *πg.Object = πg.UnboundLocal
						_ = µsysmessages
						var µendstring *πg.Object = πg.UnboundLocal
						_ = µendstring
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 739: before, inlines, remaining, sysmessages, endstring = self.inline_obj(
							πF.SetLineno(739)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßemphasis, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßemphasis, nil); πE != nil {
								continue
							}
							πTemp001[3] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinline_obj, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp003); πE != nil {
								continue
							}
							µbefore = πTemp002
							µinlines = πTemp004
							µremaining = πTemp005
							µsysmessages = πTemp006
							µendstring = πTemp007
							// line 741: return before, inlines, remaining, sysmessages
							πF.SetLineno(741)
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsysmessages, "sysmessages"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple4(µbefore, µinlines, µremaining, µsysmessages).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßemphasis.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 743: def strong(self, match, lineno):
					πF.SetLineno(743)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("strong", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µbefore *πg.Object = πg.UnboundLocal
						_ = µbefore
						var µinlines *πg.Object = πg.UnboundLocal
						_ = µinlines
						var µremaining *πg.Object = πg.UnboundLocal
						_ = µremaining
						var µsysmessages *πg.Object = πg.UnboundLocal
						_ = µsysmessages
						var µendstring *πg.Object = πg.UnboundLocal
						_ = µendstring
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 744: before, inlines, remaining, sysmessages, endstring = self.inline_obj(
							πF.SetLineno(744)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstrong, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßstrong, nil); πE != nil {
								continue
							}
							πTemp001[3] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinline_obj, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp003); πE != nil {
								continue
							}
							µbefore = πTemp002
							µinlines = πTemp004
							µremaining = πTemp005
							µsysmessages = πTemp006
							µendstring = πTemp007
							// line 746: return before, inlines, remaining, sysmessages
							πF.SetLineno(746)
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsysmessages, "sysmessages"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple4(µbefore, µinlines, µremaining, µsysmessages).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßstrong.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 748: def interpreted_or_phrase_ref(self, match, lineno):
					πF.SetLineno(748)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("interpreted_or_phrase_ref", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µend_pattern *πg.Object = πg.UnboundLocal
						_ = µend_pattern
						var µstring *πg.Object = πg.UnboundLocal
						_ = µstring
						var µmatchstart *πg.Object = πg.UnboundLocal
						_ = µmatchstart
						var µmatchend *πg.Object = πg.UnboundLocal
						_ = µmatchend
						var µrolestart *πg.Object = πg.UnboundLocal
						_ = µrolestart
						var µrole *πg.Object = πg.UnboundLocal
						_ = µrole
						var µposition *πg.Object = πg.UnboundLocal
						_ = µposition
						var µendmatch *πg.Object = πg.UnboundLocal
						_ = µendmatch
						var µtextend *πg.Object = πg.UnboundLocal
						_ = µtextend
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µprb *πg.Object = πg.UnboundLocal
						_ = µprb
						var µescaped *πg.Object = πg.UnboundLocal
						_ = µescaped
						var µrawsource *πg.Object = πg.UnboundLocal
						_ = µrawsource
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 πg.KWArgs
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 749: end_pattern = self.patterns.interpreted_or_phrase_ref
							πF.SetLineno(749)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinterpreted_or_phrase_ref, nil); πE != nil {
								continue
							}
							µend_pattern = πTemp002
							// line 750: string = match.string
							πF.SetLineno(750)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							µstring = πTemp001
							// line 751: matchstart = match.start('backquote')
							πF.SetLineno(751)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßbackquote.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmatchstart = πTemp002
							// line 752: matchend = match.end('backquote')
							πF.SetLineno(752)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßbackquote.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmatchend = πTemp002
							// line 753: rolestart = match.start('role')
							πF.SetLineno(753)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßrole.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µrolestart = πTemp002
							// line 754: role = match.group('role')
							πF.SetLineno(754)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßrole.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µrole = πTemp002
							// line 755: position = ''
							πF.SetLineno(755)
							µposition = ß.ToObject()
							if πE = πg.CheckLocal(πF, µrole, "role"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µrole); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp003[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßquoted_start, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							goto Label3
							// line 756: if role:
							πF.SetLineno(756)
						Label1:
							// line 757: role = role[1:-1]
							πF.SetLineno(757)
							if πTemp002, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πTemp002, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrole, "role"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µrole, πTemp001); πE != nil {
								continue
							}
							µrole = πTemp002
							// line 758: position = 'prefix'
							πF.SetLineno(758)
							µposition = ßprefix.ToObject()
							goto Label3
							// line 759: elif self.quoted_start(match):
							πF.SetLineno(759)
						Label2:
							// line 760: return (string[:matchend], [], string[matchend:], [])
							πF.SetLineno(760)
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µmatchend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µstring, πTemp002); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{µmatchend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µstring, πTemp006); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp006 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple4(πTemp005, πTemp002, πTemp007, πTemp006).ToObject()
							πR = πTemp001
							continue
							goto Label3
						Label3:
							// line 761: endmatch = end_pattern.search(string[matchend:])
							πF.SetLineno(761)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µmatchend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µend_pattern, "end_pattern"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µend_pattern, ßsearch, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µendmatch = πTemp002
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							πTemp001 = µendmatch
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label4
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µendmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp001 = πTemp005
						Label4:
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label5
							}
							goto Label6
							// line 762: if endmatch and endmatch.start(1):  # 1 or more chars
							πF.SetLineno(762)
						Label5:
							// line 763: textend = matchend + endmatch.end()
							πF.SetLineno(763)
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µendmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µmatchend, πTemp005); πE != nil {
								continue
							}
							µtextend = πTemp001
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßrole.ToObject()
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µendmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label7
							}
							goto Label8
							// line 764: if endmatch.group('role'):
							πF.SetLineno(764)
						Label7:
							if πE = πg.CheckLocal(πF, µrole, "role"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µrole); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label9
							}
							goto Label10
							// line 765: if role:
							πF.SetLineno(765)
						Label9:
							// line 766: msg = self.reporter.warning(
							πF.SetLineno(766)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("Multiple roles in interpreted text (both prefix and suffix present; only one allowed).").ToObject()
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp008 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp008); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmsg = πTemp001
							// line 770: text = unescape(string[rolestart:textend], True)
							πF.SetLineno(770)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrolestart, "rolestart"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µrolestart, µtextend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtext = πTemp002
							// line 771: prb = self.problematic(text, text, msg)
							πF.SetLineno(771)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp003[0] = µtext
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp003[1] = µtext
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp003[2] = µmsg
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßproblematic, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µprb = πTemp002
							// line 772: return string[:rolestart], [prb], string[textend:], [msg]
							πF.SetLineno(772)
							if πE = πg.CheckLocal(πF, µrolestart, "rolestart"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µrolestart, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µstring, πTemp002); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µprb, "prb"); πE != nil {
								continue
							}
							πTemp003[0] = µprb
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{µtextend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µstring, πTemp006); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp003[0] = µmsg
							πTemp006 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple4(πTemp005, πTemp002, πTemp007, πTemp006).ToObject()
							πR = πTemp001
							continue
							goto Label10
						Label10:
							// line 773: role = endmatch.group('suffix')[1:-1]
							πF.SetLineno(773)
							if πTemp002, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πTemp002, πg.None}, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßsuffix.ToObject()
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µendmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.GetItem(πF, πTemp006, πTemp001); πE != nil {
								continue
							}
							µrole = πTemp002
							// line 774: position = 'suffix'
							πF.SetLineno(774)
							µposition = ßsuffix.ToObject()
							goto Label8
						Label8:
							// line 775: escaped = endmatch.string[:endmatch.start(1)]
							πF.SetLineno(775)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µendmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp005, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µendmatch, "endmatch"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µendmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							µescaped = πTemp002
							// line 776: rawsource = unescape(string[matchstart:textend], True)
							πF.SetLineno(776)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatchstart, "matchstart"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µmatchstart, µtextend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µrawsource = πTemp002
							if πTemp005, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πTemp005, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µrawsource, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp005, ß_.ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label11
							}
							goto Label12
							// line 777: if rawsource[-1:] == '_':
							πF.SetLineno(777)
						Label11:
							if πE = πg.CheckLocal(πF, µrole, "role"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µrole); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label14
							}
							goto Label15
							// line 778: if role:
							πF.SetLineno(778)
						Label14:
							// line 779: msg = self.reporter.warning(
							πF.SetLineno(779)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µposition, "position"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("Mismatch: both interpreted text role %s and reference suffix.").ToObject(), µposition); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp008 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp008); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmsg = πTemp001
							// line 782: text = unescape(string[rolestart:textend], True)
							πF.SetLineno(782)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrolestart, "rolestart"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µrolestart, µtextend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtext = πTemp002
							// line 783: prb = self.problematic(text, text, msg)
							πF.SetLineno(783)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp003[0] = µtext
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp003[1] = µtext
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp003[2] = µmsg
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßproblematic, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µprb = πTemp002
							// line 784: return string[:rolestart], [prb], string[textend:], [msg]
							πF.SetLineno(784)
							if πE = πg.CheckLocal(πF, µrolestart, "rolestart"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µrolestart, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µstring, πTemp002); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µprb, "prb"); πE != nil {
								continue
							}
							πTemp003[0] = µprb
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{µtextend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µstring, πTemp006); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp003[0] = µmsg
							πTemp006 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple4(πTemp005, πTemp002, πTemp007, πTemp006).ToObject()
							πR = πTemp001
							continue
							goto Label15
						Label15:
							// line 785: return self.phrase_ref(string[:matchstart], string[textend:],
							πF.SetLineno(785)
							πTemp003 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µmatchstart, "matchstart"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µmatchstart, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µtextend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp003[1] = πTemp002
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							πTemp003[2] = µrawsource
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							πTemp003[3] = µescaped
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßphrase_ref, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πR = πTemp002
							continue
							goto Label13
						Label12:
							// line 788: rawsource = unescape(string[rolestart:textend], True)
							πF.SetLineno(788)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrolestart, "rolestart"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µrolestart, µtextend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µrawsource = πTemp002
							// line 789: nodelist, messages = self.interpreted(rawsource, escaped, role,
							πF.SetLineno(789)
							πTemp003 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							πTemp003[0] = µrawsource
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							πTemp003[1] = µescaped
							if πE = πg.CheckLocal(πF, µrole, "role"); πE != nil {
								continue
							}
							πTemp003[2] = µrole
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[3] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßinterpreted, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp005}}}, πTemp002); πE != nil {
								continue
							}
							µnodelist = πTemp001
							µmessages = πTemp005
							// line 791: return (string[:rolestart], nodelist,
							πF.SetLineno(791)
							if πE = πg.CheckLocal(πF, µrolestart, "rolestart"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µrolestart, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µstring, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtextend, "textend"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µtextend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µstring, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple4(πTemp005, µnodelist, πTemp006, µmessages).ToObject()
							πR = πTemp001
							continue
							goto Label13
						Label13:
							goto Label6
						Label6:
							// line 793: msg = self.reporter.warning(
							πF.SetLineno(793)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("Inline interpreted text or phrase reference start-string without end-string.").ToObject()
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp008 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp008); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmsg = πTemp001
							// line 796: text = unescape(string[matchstart:matchend], True)
							πF.SetLineno(796)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatchstart, "matchstart"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µmatchstart, µmatchend, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µstring, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtext = πTemp002
							// line 797: prb = self.problematic(text, text, msg)
							πF.SetLineno(797)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp003[0] = µtext
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp003[1] = µtext
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp003[2] = µmsg
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßproblematic, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µprb = πTemp002
							// line 798: return string[:matchstart], [prb], string[matchend:], [msg]
							πF.SetLineno(798)
							if πE = πg.CheckLocal(πF, µmatchstart, "matchstart"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µmatchstart, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µstring, πTemp002); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µprb, "prb"); πE != nil {
								continue
							}
							πTemp003[0] = µprb
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{µmatchend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µstring, πTemp006); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp003[0] = µmsg
							πTemp006 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple4(πTemp005, πTemp002, πTemp007, πTemp006).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinterpreted_or_phrase_ref.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 800: def phrase_ref(self, before, after, rawsource, escaped, text=None):
					πF.SetLineno(800)
					πTemp002 = make([]πg.Param, 6)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "before", Def: nil}
					πTemp002[2] = πg.Param{Name: "after", Def: nil}
					πTemp002[3] = πg.Param{Name: "rawsource", Def: nil}
					πTemp002[4] = πg.Param{Name: "escaped", Def: nil}
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[5] = πg.Param{Name: "text", Def: πTemp012}
					πTemp011 = πg.NewFunction(πg.NewCode("phrase_ref", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µbefore *πg.Object = πArgs[1]
						_ = µbefore
						var µafter *πg.Object = πArgs[2]
						_ = µafter
						var µrawsource *πg.Object = πArgs[3]
						_ = µrawsource
						var µescaped *πg.Object = πArgs[4]
						_ = µescaped
						var µtext *πg.Object = πArgs[5]
						_ = µtext
						var µmatch *πg.Object = πg.UnboundLocal
						_ = µmatch
						var µunescaped *πg.Object = πg.UnboundLocal
						_ = µunescaped
						var µrawtext *πg.Object = πg.UnboundLocal
						_ = µrawtext
						var µaliastext *πg.Object = πg.UnboundLocal
						_ = µaliastext
						var µrawaliastext *πg.Object = πg.UnboundLocal
						_ = µrawaliastext
						var µunderscore_escaped *πg.Object = πg.UnboundLocal
						_ = µunderscore_escaped
						var µaliastype *πg.Object = πg.UnboundLocal
						_ = µaliastype
						var µalias *πg.Object = πg.UnboundLocal
						_ = µalias
						var µtarget *πg.Object = πg.UnboundLocal
						_ = µtarget
						var µalias_parts *πg.Object = πg.UnboundLocal
						_ = µalias_parts
						var µrefname *πg.Object = πg.UnboundLocal
						_ = µrefname
						var µreference *πg.Object = πg.UnboundLocal
						_ = µreference
						var µnode_list *πg.Object = πg.UnboundLocal
						_ = µnode_list
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πTemp010 πg.KWArgs
						_ = πTemp010
						var πTemp011 []πg.Param
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 802: match = self.patterns.embedded_link.search(escaped)
							πF.SetLineno(802)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							πTemp001[0] = µescaped
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßembedded_link, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsearch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmatch = πTemp003
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µmatch); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 803: if match: # embedded <URI> or <alias_>
							πF.SetLineno(803)
						Label1:
							// line 804: text = escaped[:match.start(0)]
							πF.SetLineno(804)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp005, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µescaped, πTemp002); πE != nil {
								continue
							}
							µtext = πTemp003
							// line 805: unescaped = unescape(text)
							πF.SetLineno(805)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µunescaped = πTemp003
							// line 806: rawtext = unescape(text, True)
							πF.SetLineno(806)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrawtext = πTemp003
							// line 807: aliastext = match.group(2)
							πF.SetLineno(807)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µaliastext = πTemp003
							// line 808: rawaliastext = unescape(aliastext, True)
							πF.SetLineno(808)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µaliastext, "aliastext"); πE != nil {
								continue
							}
							πTemp001[0] = µaliastext
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrawaliastext = πTemp003
							// line 809: underscore_escaped = rawaliastext.endswith(r'\_')
							πF.SetLineno(809)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\\_").ToObject()
							if πE = πg.CheckLocal(πF, µrawaliastext, "rawaliastext"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µrawaliastext, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µunderscore_escaped = πTemp003
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ß_.ToObject()
							if πE = πg.CheckLocal(πF, µaliastext, "aliastext"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µaliastext, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp002 = πTemp005
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µunderscore_escaped, "underscore_escaped"); πE != nil {
								continue
							}
							πTemp005 = µunderscore_escaped
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label5
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaliastext, "aliastext"); πE != nil {
								continue
							}
							πTemp001[0] = µaliastext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßuri, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp008, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp005 = πTemp008
						Label5:
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp002 = πTemp003
						Label4:
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 810: if aliastext.endswith('_') and not (underscore_escaped
							πF.SetLineno(810)
						Label6:
							// line 812: aliastype = 'name'
							πF.SetLineno(812)
							µaliastype = ßname.ToObject()
							// line 813: alias = normalize_name(unescape(aliastext[:-1]))
							πF.SetLineno(813)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							if πTemp003, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaliastext, "aliastext"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µaliastext, πTemp002); πE != nil {
								continue
							}
							πTemp009[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µalias = πTemp003
							// line 814: target = nodes.target(match.group(1), refname=alias)
							πF.SetLineno(814)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							πTemp009[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							πTemp010 = πg.KWArgs{
								{"refname", µalias},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtarget, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtarget = πTemp002
							// line 815: target.indirect_reference_name = whitespace_normalize_name(
							πF.SetLineno(815)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							if πTemp003, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µaliastext, "aliastext"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µaliastext, πTemp002); πE != nil {
								continue
							}
							πTemp009[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßwhitespace_normalize_name); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µtarget, ßindirect_reference_name, πTemp002); πE != nil {
								continue
							}
							goto Label8
						Label7:
							// line 818: aliastype = 'uri'
							πF.SetLineno(818)
							µaliastype = ßuri.ToObject()
							// line 820: alias_parts = split_escaped_whitespace(match.group(2))
							πF.SetLineno(820)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							πTemp009[0] = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßsplit_escaped_whitespace); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µalias_parts = πTemp003
							// line 821: alias = ' '.join(''.join(part.split())
							πF.SetLineno(821)
							πTemp001 = πF.MakeArgs(1)
							πTemp011 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp011, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µpart *πg.Object = πg.UnboundLocal
								_ = µpart
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µalias_parts, "alias_parts"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µalias_parts); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µpart = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 821: alias = ' '.join(''.join(part.split())
										πF.SetLineno(821)
										πTemp005 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GetAttr(πF, µpart, ßsplit, nil); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, nil, nil); πE != nil {
											continue
										}
										πTemp005[0] = πTemp006
										if πTemp004, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp003, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µalias = πTemp005
							// line 823: alias = self.adjust_uri(unescape(alias))
							πF.SetLineno(823)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							πTemp009[0] = µalias
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp005
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßadjust_uri, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µalias = πTemp005
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("\\_").ToObject()
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µalias, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label9
							}
							goto Label10
							// line 824: if alias.endswith(r'\_'):
							πF.SetLineno(824)
						Label9:
							// line 825: alias = alias[:-2] + '_'
							πF.SetLineno(825)
							if πTemp007, πE = πg.Neg(πF, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp007, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µalias, πTemp005); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp007, ß_.ToObject()); πE != nil {
								continue
							}
							µalias = πTemp003
							goto Label10
						Label10:
							// line 826: target = nodes.target(match.group(1), refuri=alias)
							πF.SetLineno(826)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							πTemp009[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp005
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							πTemp010 = πg.KWArgs{
								{"refuri", µalias},
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßtarget, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtarget = πTemp003
							// line 827: target.referenced = 1
							πF.SetLineno(827)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µtarget, ßreferenced, πTemp003); πE != nil {
								continue
							}
							goto Label8
						Label8:
							if πE = πg.CheckLocal(πF, µaliastext, "aliastext"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µaliastext); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label11
							}
							goto Label12
							// line 828: if not aliastext:
							πF.SetLineno(828)
						Label11:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µaliastext, "aliastext"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Mod(πF, πg.NewStr("problem with embedded link: %r").ToObject(), µaliastext); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßApplicationError); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 829: raise ApplicationError('problem with embedded link: %r'
							πF.SetLineno(829)
							πE = πF.Raise(πTemp005, nil, nil)
							continue
							goto Label12
						Label12:
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µtext); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label13
							}
							goto Label14
							// line 831: if not text:
							πF.SetLineno(831)
						Label13:
							// line 832: text = alias
							πF.SetLineno(832)
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							µtext = µalias
							// line 833: unescaped = unescape(text)
							πF.SetLineno(833)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µunescaped = πTemp005
							// line 834: rawtext = rawaliastext
							πF.SetLineno(834)
							if πE = πg.CheckLocal(πF, µrawaliastext, "rawaliastext"); πE != nil {
								continue
							}
							µrawtext = µrawaliastext
							goto Label14
						Label14:
							goto Label3
						Label2:
							// line 836: text = escaped
							πF.SetLineno(836)
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							µtext = µescaped
							// line 837: unescaped = unescape(text)
							πF.SetLineno(837)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µunescaped = πTemp005
							// line 838: target = None
							πF.SetLineno(838)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µtarget = πTemp003
							// line 839: rawtext = unescape(escaped, True)
							πF.SetLineno(839)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							πTemp001[0] = µescaped
							if πTemp003, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrawtext = πTemp005
							goto Label3
						Label3:
							// line 841: refname = normalize_name(unescaped)
							πF.SetLineno(841)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µunescaped, "unescaped"); πE != nil {
								continue
							}
							πTemp001[0] = µunescaped
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrefname = πTemp005
							// line 842: reference = nodes.reference(rawsource, text,
							πF.SetLineno(842)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							πTemp001[0] = µrawsource
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[1] = µtext
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µunescaped, "unescaped"); πE != nil {
								continue
							}
							πTemp009[0] = µunescaped
							if πTemp003, πE = πg.ResolveGlobal(πF, ßwhitespace_normalize_name); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp010 = πg.KWArgs{
								{"name", πTemp005},
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßreference, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µreference = πTemp003
							// line 844: reference[0].rawsource = rawtext
							πF.SetLineno(844)
							if πE = πg.CheckLocal(πF, µrawtext, "rawtext"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µrawtext); πE != nil {
								continue
							}
							πTemp005 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µreference, πTemp005); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp007, ßrawsource, πTemp003); πE != nil {
								continue
							}
							// line 846: node_list = [reference]
							πF.SetLineno(846)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp001[0] = µreference
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							µnode_list = πTemp003
							if πTemp007, πE = πg.Neg(πF, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.SliceType.Call(πF, πg.Args{πTemp007, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µrawsource, πTemp005); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, πTemp007, ß__.ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label15
							}
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µtarget); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label16
							}
							goto Label17
							// line 848: if rawsource[-2:] == '__':
							πF.SetLineno(848)
						Label15:
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp003 = µtarget
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label19
							}
							if πE = πg.CheckLocal(πF, µaliastype, "aliastype"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Eq(πF, µaliastype, ßname.ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp005
						Label19:
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label20
							}
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp003 = µtarget
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp004 {
								goto Label21
							}
							if πE = πg.CheckLocal(πF, µaliastype, "aliastype"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Eq(πF, µaliastype, ßuri.ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp005
						Label21:
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label22
							}
							goto Label23
							// line 849: if  target and (aliastype == 'name'):
							πF.SetLineno(849)
						Label20:
							// line 850: reference['refname'] = alias
							πF.SetLineno(850)
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µalias); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp005 = ßrefname.ToObject()
							if πE = πg.SetItem(πF, µreference, πTemp005, πTemp003); πE != nil {
								continue
							}
							// line 851: self.document.note_refname(reference)
							πF.SetLineno(851)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp001[0] = µreference
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßnote_refname, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label24
							// line 853: elif target and (aliastype == 'uri'):
							πF.SetLineno(853)
						Label22:
							// line 854: reference['refuri'] = alias
							πF.SetLineno(854)
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µalias); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp005 = ßrefuri.ToObject()
							if πE = πg.SetItem(πF, µreference, πTemp005, πTemp003); πE != nil {
								continue
							}
							goto Label24
						Label23:
							// line 856: reference['anonymous'] = 1
							πF.SetLineno(856)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp005 = ßanonymous.ToObject()
							if πE = πg.SetItem(πF, µreference, πTemp005, πTemp003); πE != nil {
								continue
							}
							goto Label24
						Label24:
							goto Label18
							// line 858: if target:
							πF.SetLineno(858)
						Label16:
							// line 859: target['names'].append(refname)
							πF.SetLineno(859)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							πTemp001[0] = µrefname
							πTemp003 = ßnames.ToObject()
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µtarget, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp005, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µaliastype, "aliastype"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, µaliastype, ßname.ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label25
							}
							goto Label26
							// line 860: if aliastype == 'name':
							πF.SetLineno(860)
						Label25:
							// line 861: reference['refname'] = alias
							πF.SetLineno(861)
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µalias); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp005 = ßrefname.ToObject()
							if πE = πg.SetItem(πF, µreference, πTemp005, πTemp003); πE != nil {
								continue
							}
							// line 862: self.document.note_indirect_target(target)
							πF.SetLineno(862)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp001[0] = µtarget
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßnote_indirect_target, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 863: self.document.note_refname(reference)
							πF.SetLineno(863)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp001[0] = µreference
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßnote_refname, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label27
						Label26:
							// line 865: reference['refuri'] = alias
							πF.SetLineno(865)
							if πE = πg.CheckLocal(πF, µalias, "alias"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µalias); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp005 = ßrefuri.ToObject()
							if πE = πg.SetItem(πF, µreference, πTemp005, πTemp003); πE != nil {
								continue
							}
							// line 866: self.document.note_explicit_target(target, self.parent)
							πF.SetLineno(866)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp001[0] = µtarget
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßnote_explicit_target, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label27
						Label27:
							// line 868: node_list.append(target)
							πF.SetLineno(868)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp001[0] = µtarget
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µnode_list, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label18
						Label17:
							// line 870: reference['refname'] = refname
							πF.SetLineno(870)
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µrefname); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp005 = ßrefname.ToObject()
							if πE = πg.SetItem(πF, µreference, πTemp005, πTemp003); πE != nil {
								continue
							}
							// line 871: self.document.note_refname(reference)
							πF.SetLineno(871)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp001[0] = µreference
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßnote_refname, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label18
						Label18:
							// line 872: return before, node_list, after, []
							πF.SetLineno(872)
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µafter, "after"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp005 = πg.NewList(πTemp001...).ToObject()
							πTemp003 = πg.NewTuple4(µbefore, µnode_list, µafter, πTemp005).ToObject()
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßphrase_ref.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 875: def adjust_uri(self, uri):
					πF.SetLineno(875)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "uri", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("adjust_uri", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µuri *πg.Object = πArgs[1]
						_ = µuri
						var µmatch *πg.Object = πg.UnboundLocal
						_ = µmatch
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 876: match = self.patterns.email.match(uri)
							πF.SetLineno(876)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µuri, "uri"); πE != nil {
								continue
							}
							πTemp001[0] = µuri
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßemail, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmatch = πTemp003
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µmatch); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 877: if match:
							πF.SetLineno(877)
						Label1:
							// line 878: return 'mailto:' + uri
							πF.SetLineno(878)
							if πE = πg.CheckLocal(πF, µuri, "uri"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("mailto:").ToObject(), µuri); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label3
						Label2:
							// line 880: return uri
							πF.SetLineno(880)
							if πE = πg.CheckLocal(πF, µuri, "uri"); πE != nil {
								continue
							}
							πR = µuri
							continue
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadjust_uri.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 882: def interpreted(self, rawsource, text, role, lineno):
					πF.SetLineno(882)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "rawsource", Def: nil}
					πTemp002[2] = πg.Param{Name: "text", Def: nil}
					πTemp002[3] = πg.Param{Name: "role", Def: nil}
					πTemp002[4] = πg.Param{Name: "lineno", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("interpreted", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µrawsource *πg.Object = πArgs[1]
						_ = µrawsource
						var µtext *πg.Object = πArgs[2]
						_ = µtext
						var µrole *πg.Object = πArgs[3]
						_ = µrole
						var µlineno *πg.Object = πArgs[4]
						_ = µlineno
						var µrole_fn *πg.Object = πg.UnboundLocal
						_ = µrole_fn
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µnodes *πg.Object = πg.UnboundLocal
						_ = µnodes
						var µmessages2 *πg.Object = πg.UnboundLocal
						_ = µmessages2
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 883: role_fn, messages = roles.role(role, self.language, lineno,
							πF.SetLineno(883)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µrole, "role"); πE != nil {
								continue
							}
							πTemp001[0] = µrole
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßlanguage, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[2] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							πTemp001[3] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßroles); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßrole, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µrole_fn = πTemp003
							µmessages = πTemp004
							if πE = πg.CheckLocal(πF, µrole_fn, "role_fn"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µrole_fn); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 885: if role_fn:
							πF.SetLineno(885)
						Label1:
							// line 886: nodes, messages2 = role_fn(role, rawsource, text, lineno, self)
							πF.SetLineno(886)
							πTemp001 = πF.MakeArgs(5)
							if πE = πg.CheckLocal(πF, µrole, "role"); πE != nil {
								continue
							}
							πTemp001[0] = µrole
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							πTemp001[1] = µrawsource
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[2] = µtext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[3] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[4] = µself
							if πE = πg.CheckLocal(πF, µrole_fn, "role_fn"); πE != nil {
								continue
							}
							if πTemp002, πE = µrole_fn.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µnodes = πTemp003
							µmessages2 = πTemp004
							// line 887: return nodes, messages + messages2
							πF.SetLineno(887)
							if πE = πg.CheckLocal(πF, µnodes, "nodes"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages2, "messages2"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µmessages, µmessages2); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(µnodes, πTemp003).ToObject()
							πR = πTemp002
							continue
							goto Label3
						Label2:
							// line 889: msg = self.reporter.error(
							πF.SetLineno(889)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrole, "role"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("Unknown interpreted text role \"%s\".").ToObject(), µrole); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp002
							// line 892: return ([self.problematic(rawsource, rawsource, msg)],
							πF.SetLineno(892)
							πTemp001 = make([]*πg.Object, 1)
							πTemp007 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							πTemp007[0] = µrawsource
							if πE = πg.CheckLocal(πF, µrawsource, "rawsource"); πE != nil {
								continue
							}
							πTemp007[1] = µrawsource
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp007[2] = µmsg
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßproblematic, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001[0] = πTemp004
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp001[0] = µmsg
							πTemp008 = πg.NewList(πTemp001...).ToObject()
							if πTemp004, πE = πg.Add(πF, µmessages, πTemp008); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp003, πTemp004).ToObject()
							πR = πTemp002
							continue
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinterpreted.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 895: def literal(self, match, lineno):
					πF.SetLineno(895)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp014 = πg.NewFunction(πg.NewCode("literal", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µbefore *πg.Object = πg.UnboundLocal
						_ = µbefore
						var µinlines *πg.Object = πg.UnboundLocal
						_ = µinlines
						var µremaining *πg.Object = πg.UnboundLocal
						_ = µremaining
						var µsysmessages *πg.Object = πg.UnboundLocal
						_ = µsysmessages
						var µendstring *πg.Object = πg.UnboundLocal
						_ = µendstring
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 896: before, inlines, remaining, sysmessages, endstring = self.inline_obj(
							πF.SetLineno(896)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßliteral, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßliteral, nil); πE != nil {
								continue
							}
							πTemp001[3] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"restore_backslashes", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinline_obj, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}, πg.TieTarget{Target: &πTemp008}}}, πTemp003); πE != nil {
								continue
							}
							µbefore = πTemp002
							µinlines = πTemp005
							µremaining = πTemp006
							µsysmessages = πTemp007
							µendstring = πTemp008
							// line 899: return before, inlines, remaining, sysmessages
							πF.SetLineno(899)
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsysmessages, "sysmessages"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple4(µbefore, µinlines, µremaining, µsysmessages).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßliteral.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 901: def inline_internal_target(self, match, lineno):
					πF.SetLineno(901)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp015 = πg.NewFunction(πg.NewCode("inline_internal_target", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µbefore *πg.Object = πg.UnboundLocal
						_ = µbefore
						var µinlines *πg.Object = πg.UnboundLocal
						_ = µinlines
						var µremaining *πg.Object = πg.UnboundLocal
						_ = µremaining
						var µsysmessages *πg.Object = πg.UnboundLocal
						_ = µsysmessages
						var µendstring *πg.Object = πg.UnboundLocal
						_ = µendstring
						var µtarget *πg.Object = πg.UnboundLocal
						_ = µtarget
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 902: before, inlines, remaining, sysmessages, endstring = self.inline_obj(
							πF.SetLineno(902)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtarget, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtarget, nil); πE != nil {
								continue
							}
							πTemp001[3] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinline_obj, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp003); πE != nil {
								continue
							}
							µbefore = πTemp002
							µinlines = πTemp004
							µremaining = πTemp005
							µsysmessages = πTemp006
							µendstring = πTemp007
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							πTemp002 = µinlines
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp008 {
								goto Label1
							}
							πTemp001 = πF.MakeArgs(2)
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µinlines, πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßtarget, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp002 = πTemp004
						Label1:
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label2
							}
							goto Label3
							// line 904: if inlines and isinstance(inlines[0], nodes.target):
							πF.SetLineno(904)
						Label2:
							// line 905: assert len(inlines) == 1
							πF.SetLineno(905)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							πTemp001[0] = µinlines
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Eq(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.Assert(πF, πTemp002, nil); πE != nil {
								continue
							}
							// line 906: target = inlines[0]
							πF.SetLineno(906)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µinlines, πTemp002); πE != nil {
								continue
							}
							µtarget = πTemp003
							// line 907: name = normalize_name(target.astext())
							πF.SetLineno(907)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µtarget, ßastext, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µname = πTemp003
							// line 908: target['names'].append(name)
							πF.SetLineno(908)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[0] = µname
							πTemp002 = ßnames.ToObject()
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µtarget, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 909: self.document.note_explicit_target(target, self.parent)
							πF.SetLineno(909)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp001[0] = µtarget
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnote_explicit_target, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label3
						Label3:
							// line 910: return before, inlines, remaining, sysmessages
							πF.SetLineno(910)
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsysmessages, "sysmessages"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple4(µbefore, µinlines, µremaining, µsysmessages).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinline_internal_target.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 912: def substitution_reference(self, match, lineno):
					πF.SetLineno(912)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp016 = πg.NewFunction(πg.NewCode("substitution_reference", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µbefore *πg.Object = πg.UnboundLocal
						_ = µbefore
						var µinlines *πg.Object = πg.UnboundLocal
						_ = µinlines
						var µremaining *πg.Object = πg.UnboundLocal
						_ = µremaining
						var µsysmessages *πg.Object = πg.UnboundLocal
						_ = µsysmessages
						var µendstring *πg.Object = πg.UnboundLocal
						_ = µendstring
						var µsubref_node *πg.Object = πg.UnboundLocal
						_ = µsubref_node
						var µsubref_text *πg.Object = πg.UnboundLocal
						_ = µsubref_text
						var µreference_node *πg.Object = πg.UnboundLocal
						_ = µreference_node
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 913: before, inlines, remaining, sysmessages, endstring = self.inline_obj(
							πF.SetLineno(913)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsubstitution_ref, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsubstitution_reference, nil); πE != nil {
								continue
							}
							πTemp001[3] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinline_obj, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp003); πE != nil {
								continue
							}
							µbefore = πTemp002
							µinlines = πTemp004
							µremaining = πTemp005
							µsysmessages = πTemp006
							µendstring = πTemp007
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							πTemp001[0] = µinlines
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Eq(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label1
							}
							goto Label2
							// line 916: if len(inlines) == 1:
							πF.SetLineno(916)
						Label1:
							// line 917: subref_node = inlines[0]
							πF.SetLineno(917)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µinlines, πTemp002); πE != nil {
								continue
							}
							µsubref_node = πTemp003
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsubref_node, "subref_node"); πE != nil {
								continue
							}
							πTemp001[0] = µsubref_node
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsubstitution_reference, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp008, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label3
							}
							goto Label4
							// line 918: if isinstance(subref_node, nodes.substitution_reference):
							πF.SetLineno(918)
						Label3:
							// line 919: subref_text = subref_node.astext()
							πF.SetLineno(919)
							if πE = πg.CheckLocal(πF, µsubref_node, "subref_node"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µsubref_node, ßastext, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µsubref_text = πTemp003
							// line 920: self.document.note_substitution_ref(subref_node, subref_text)
							πF.SetLineno(920)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsubref_node, "subref_node"); πE != nil {
								continue
							}
							πTemp001[0] = µsubref_node
							if πE = πg.CheckLocal(πF, µsubref_text, "subref_text"); πE != nil {
								continue
							}
							πTemp001[1] = µsubref_text
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnote_substitution_ref, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πTemp004, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µendstring, "endstring"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µendstring, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp004, ß_.ToObject()); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label5
							}
							goto Label6
							// line 921: if endstring[-1:] == '_':
							πF.SetLineno(921)
						Label5:
							// line 922: reference_node = nodes.reference(
							πF.SetLineno(922)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsubref_text, "subref_text"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µendstring, "endstring"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(µsubref_text, µendstring).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("|%s%s").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							πTemp001[1] = ß.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßreference, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µreference_node = πTemp002
							if πTemp004, πE = πg.Neg(πF, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πTemp004, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µendstring, "endstring"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µendstring, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp004, ß__.ToObject()); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label7
							}
							goto Label8
							// line 924: if endstring[-2:] == '__':
							πF.SetLineno(924)
						Label7:
							// line 925: reference_node['anonymous'] = 1
							πF.SetLineno(925)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreference_node, "reference_node"); πE != nil {
								continue
							}
							πTemp003 = ßanonymous.ToObject()
							if πE = πg.SetItem(πF, µreference_node, πTemp003, πTemp002); πE != nil {
								continue
							}
							goto Label9
						Label8:
							// line 927: reference_node['refname'] = normalize_name(subref_text)
							πF.SetLineno(927)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsubref_text, "subref_text"); πE != nil {
								continue
							}
							πTemp001[0] = µsubref_text
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreference_node, "reference_node"); πE != nil {
								continue
							}
							πTemp004 = ßrefname.ToObject()
							if πE = πg.SetItem(πF, µreference_node, πTemp004, πTemp002); πE != nil {
								continue
							}
							// line 928: self.document.note_refname(reference_node)
							πF.SetLineno(928)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreference_node, "reference_node"); πE != nil {
								continue
							}
							πTemp001[0] = µreference_node
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnote_refname, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label9
						Label9:
							// line 929: reference_node += subref_node
							πF.SetLineno(929)
							if πE = πg.CheckLocal(πF, µreference_node, "reference_node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsubref_node, "subref_node"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µreference_node, µsubref_node); πE != nil {
								continue
							}
							µreference_node = πTemp002
							// line 930: inlines = [reference_node]
							πF.SetLineno(930)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µreference_node, "reference_node"); πE != nil {
								continue
							}
							πTemp001[0] = µreference_node
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µinlines = πTemp002
							goto Label6
						Label6:
							goto Label4
						Label4:
							goto Label2
						Label2:
							// line 931: return before, inlines, remaining, sysmessages
							πF.SetLineno(931)
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µinlines, "inlines"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsysmessages, "sysmessages"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple4(µbefore, µinlines, µremaining, µsysmessages).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsubstitution_reference.ToObject(), πTemp016); πE != nil {
						continue
					}
					// line 933: def footnote_reference(self, match, lineno):
					πF.SetLineno(933)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp017 = πg.NewFunction(πg.NewCode("footnote_reference", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µlabel *πg.Object = πg.UnboundLocal
						_ = µlabel
						var µrefname *πg.Object = πg.UnboundLocal
						_ = µrefname
						var µstring *πg.Object = πg.UnboundLocal
						_ = µstring
						var µbefore *πg.Object = πg.UnboundLocal
						_ = µbefore
						var µremaining *πg.Object = πg.UnboundLocal
						_ = µremaining
						var µrefnode *πg.Object = πg.UnboundLocal
						_ = µrefnode
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 934: """
							πF.SetLineno(934)
							// line 938: label = match.group('footnotelabel')
							πF.SetLineno(938)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßfootnotelabel.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µlabel = πTemp003
							// line 939: refname = normalize_name(label)
							πF.SetLineno(939)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							πTemp001[0] = µlabel
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrefname = πTemp003
							// line 940: string = match.string
							πF.SetLineno(940)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							µstring = πTemp002
							// line 941: before = string[:match.start('whole')]
							πF.SetLineno(941)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßwhole.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp004, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µstring, πTemp002); πE != nil {
								continue
							}
							µbefore = πTemp003
							// line 942: remaining = string[match.end('whole'):]
							πF.SetLineno(942)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßwhole.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πTemp004, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µstring, πTemp002); πE != nil {
								continue
							}
							µremaining = πTemp003
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßcitationlabel.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 943: if match.group('citationlabel'):
							πF.SetLineno(943)
						Label1:
							// line 944: refnode = nodes.citation_reference('[%s]_' % label,
							πF.SetLineno(944)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("[%s]_").ToObject(), µlabel); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"refname", µrefname},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßcitation_reference, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrefnode = πTemp002
							// line 946: refnode += nodes.Text(label)
							πF.SetLineno(946)
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							πTemp001[0] = µlabel
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßText, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.IAdd(πF, µrefnode, πTemp002); πE != nil {
								continue
							}
							µrefnode = πTemp003
							// line 947: self.document.note_citation_ref(refnode)
							πF.SetLineno(947)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp001[0] = µrefnode
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnote_citation_ref, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label3
						Label2:
							// line 949: refnode = nodes.footnote_reference('[%s]_' % label)
							πF.SetLineno(949)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("[%s]_").ToObject(), µlabel); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßfootnote_reference, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrefnode = πTemp002
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µrefname, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, πTemp004, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µrefname, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							goto Label6
							// line 950: if refname[0] == '#':
							πF.SetLineno(950)
						Label4:
							// line 951: refname = refname[1:]
							πF.SetLineno(951)
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µrefname, πTemp002); πE != nil {
								continue
							}
							µrefname = πTemp003
							// line 952: refnode['auto'] = 1
							πF.SetLineno(952)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp003 = ßauto.ToObject()
							if πE = πg.SetItem(πF, µrefnode, πTemp003, πTemp002); πE != nil {
								continue
							}
							// line 953: self.document.note_autofootnote_ref(refnode)
							πF.SetLineno(953)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp001[0] = µrefnode
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnote_autofootnote_ref, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label7
							// line 954: elif refname == '*':
							πF.SetLineno(954)
						Label5:
							// line 955: refname = ''
							πF.SetLineno(955)
							µrefname = ß.ToObject()
							// line 956: refnode['auto'] = '*'
							πF.SetLineno(956)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp003 = ßauto.ToObject()
							if πE = πg.SetItem(πF, µrefnode, πTemp003, πTemp002); πE != nil {
								continue
							}
							// line 957: self.document.note_symbol_footnote_ref(
							πF.SetLineno(957)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp001[0] = µrefnode
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnote_symbol_footnote_ref, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label7
						Label6:
							// line 960: refnode += nodes.Text(label)
							πF.SetLineno(960)
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							πTemp001[0] = µlabel
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßText, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.IAdd(πF, µrefnode, πTemp002); πE != nil {
								continue
							}
							µrefnode = πTemp003
							goto Label7
						Label7:
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µrefname); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label8
							}
							goto Label9
							// line 961: if refname:
							πF.SetLineno(961)
						Label8:
							// line 962: refnode['refname'] = refname
							πF.SetLineno(962)
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µrefname); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp003 = ßrefname.ToObject()
							if πE = πg.SetItem(πF, µrefnode, πTemp003, πTemp002); πE != nil {
								continue
							}
							// line 963: self.document.note_footnote_ref(refnode)
							πF.SetLineno(963)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp001[0] = µrefnode
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnote_footnote_ref, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label9
						Label9:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsettings, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßutils); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_trim_footnote_ref_space, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label10
							}
							goto Label11
							// line 964: if utils.get_trim_footnote_ref_space(self.document.settings):
							πF.SetLineno(964)
						Label10:
							// line 965: before = before.rstrip()
							πF.SetLineno(965)
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µbefore, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µbefore = πTemp003
							goto Label11
						Label11:
							goto Label3
						Label3:
							// line 966: return (before, [refnode], remaining, [])
							πF.SetLineno(966)
							if πE = πg.CheckLocal(πF, µbefore, "before"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µrefnode, "refnode"); πE != nil {
								continue
							}
							πTemp001[0] = µrefnode
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µremaining, "remaining"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple4(µbefore, πTemp003, µremaining, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfootnote_reference.ToObject(), πTemp017); πE != nil {
						continue
					}
					// line 934: """
					πF.SetLineno(934)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp018}, πg.NewStr("\n        Handles `nodes.footnote_reference` and `nodes.citation_reference`\n        elements.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp019, πE = πg.ResolveClass(πF, πClass, nil, ßfootnote_reference); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp019, ß__doc__, πTemp018); πE != nil {
						continue
					}
					// line 968: def reference(self, match, lineno, anonymous=False):
					πF.SetLineno(968)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					if πTemp019, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "anonymous", Def: πTemp019}
					πTemp018 = πg.NewFunction(πg.NewCode("reference", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µanonymous *πg.Object = πArgs[3]
						_ = µanonymous
						var µreferencename *πg.Object = πg.UnboundLocal
						_ = µreferencename
						var µrefname *πg.Object = πg.UnboundLocal
						_ = µrefname
						var µreferencenode *πg.Object = πg.UnboundLocal
						_ = µreferencenode
						var µstring *πg.Object = πg.UnboundLocal
						_ = µstring
						var µmatchstart *πg.Object = πg.UnboundLocal
						_ = µmatchstart
						var µmatchend *πg.Object = πg.UnboundLocal
						_ = µmatchend
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 969: referencename = match.group('refname')
							πF.SetLineno(969)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßrefname.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µreferencename = πTemp003
							// line 970: refname = normalize_name(referencename)
							πF.SetLineno(970)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreferencename, "referencename"); πE != nil {
								continue
							}
							πTemp001[0] = µreferencename
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrefname = πTemp003
							// line 971: referencenode = nodes.reference(
							πF.SetLineno(971)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µreferencename, "referencename"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = ßrefend.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.Add(πF, µreferencename, πTemp005); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µreferencename, "referencename"); πE != nil {
								continue
							}
							πTemp001[1] = µreferencename
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreferencename, "referencename"); πE != nil {
								continue
							}
							πTemp004[0] = µreferencename
							if πTemp002, πE = πg.ResolveGlobal(πF, ßwhitespace_normalize_name); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp006 = πg.KWArgs{
								{"name", πTemp003},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßreference, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µreferencenode = πTemp002
							// line 974: referencenode[0].rawsource = referencename
							πF.SetLineno(974)
							if πE = πg.CheckLocal(πF, µreferencename, "referencename"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µreferencename); πE != nil {
								continue
							}
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µreferencenode, "referencenode"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µreferencenode, πTemp003); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßrawsource, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µanonymous, "anonymous"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µanonymous); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 975: if anonymous:
							πF.SetLineno(975)
						Label1:
							// line 976: referencenode['anonymous'] = 1
							πF.SetLineno(976)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreferencenode, "referencenode"); πE != nil {
								continue
							}
							πTemp003 = ßanonymous.ToObject()
							if πE = πg.SetItem(πF, µreferencenode, πTemp003, πTemp002); πE != nil {
								continue
							}
							goto Label3
						Label2:
							// line 978: referencenode['refname'] = refname
							πF.SetLineno(978)
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µrefname); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µreferencenode, "referencenode"); πE != nil {
								continue
							}
							πTemp003 = ßrefname.ToObject()
							if πE = πg.SetItem(πF, µreferencenode, πTemp003, πTemp002); πE != nil {
								continue
							}
							// line 979: self.document.note_refname(referencenode)
							πF.SetLineno(979)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreferencenode, "referencenode"); πE != nil {
								continue
							}
							πTemp001[0] = µreferencenode
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnote_refname, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label3
						Label3:
							// line 980: string = match.string
							πF.SetLineno(980)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							µstring = πTemp002
							// line 981: matchstart = match.start('whole')
							πF.SetLineno(981)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßwhole.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmatchstart = πTemp003
							// line 982: matchend = match.end('whole')
							πF.SetLineno(982)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßwhole.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmatchend = πTemp003
							// line 983: return (string[:matchstart], [referencenode], string[matchend:], [])
							πF.SetLineno(983)
							if πE = πg.CheckLocal(πF, µmatchstart, "matchstart"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µmatchstart, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µstring, πTemp003); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µreferencenode, "referencenode"); πE != nil {
								continue
							}
							πTemp001[0] = µreferencenode
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µmatchend, "matchend"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.SliceType.Call(πF, πg.Args{µmatchend, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstring, "string"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetItem(πF, µstring, πTemp008); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp008 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple4(πTemp005, πTemp003, πTemp009, πTemp008).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßreference.ToObject(), πTemp018); πE != nil {
						continue
					}
					// line 985: def anonymous_reference(self, match, lineno):
					πF.SetLineno(985)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp019 = πg.NewFunction(πg.NewCode("anonymous_reference", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 πg.KWArgs
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 986: return self.reference(match, lineno, anonymous=1)
							πF.SetLineno(986)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							πTemp002 = πg.KWArgs{
								{"anonymous", πg.NewInt(1).ToObject()},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreference, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, πTemp002); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßanonymous_reference.ToObject(), πTemp019); πE != nil {
						continue
					}
					// line 988: def standalone_uri(self, match, lineno):
					πF.SetLineno(988)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp020 = πg.NewFunction(πg.NewCode("standalone_uri", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µaddscheme *πg.Object = πg.UnboundLocal
						_ = µaddscheme
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µrefuri *πg.Object = πg.UnboundLocal
						_ = µrefuri
						var µreference *πg.Object = πg.UnboundLocal
						_ = µreference
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πTemp010 πg.KWArgs
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = ßscheme.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp007, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp007).ToObject()
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = ßscheme.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp005, πE = πg.GetAttr(πF, πTemp006, ßlower, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßurischemes); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp005, ßschemes, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Contains(πF, πTemp008, πTemp006); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(πTemp007).ToObject()
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 989: if (not match.group('scheme')
							πF.SetLineno(989)
						Label2:
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = ßemail.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label5
							}
							goto Label6
							// line 991: if match.group('email'):
							πF.SetLineno(991)
						Label5:
							// line 992: addscheme = 'mailto:'
							πF.SetLineno(992)
							µaddscheme = πg.NewStr("mailto:").ToObject()
							goto Label7
						Label6:
							// line 994: addscheme = ''
							πF.SetLineno(994)
							µaddscheme = ß.ToObject()
							goto Label7
						Label7:
							// line 995: text = match.group('whole')
							πF.SetLineno(995)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = ßwhole.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µtext = πTemp003
							// line 996: refuri = addscheme + unescape(text)
							πF.SetLineno(996)
							if πE = πg.CheckLocal(πF, µaddscheme, "addscheme"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp004[0] = µtext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Add(πF, µaddscheme, πTemp005); πE != nil {
								continue
							}
							µrefuri = πTemp001
							// line 997: reference = nodes.reference(unescape(text, True), text,
							πF.SetLineno(997)
							πTemp004 = πF.MakeArgs(2)
							πTemp009 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp009[0] = µtext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp009[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp004[0] = πTemp003
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp004[1] = µtext
							if πE = πg.CheckLocal(πF, µrefuri, "refuri"); πE != nil {
								continue
							}
							πTemp010 = πg.KWArgs{
								{"refuri", µrefuri},
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßreference, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp004, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µreference = πTemp001
							// line 999: return [reference]
							πF.SetLineno(999)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp004[0] = µreference
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							πR = πTemp001
							continue
							goto Label4
						Label3:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßMarkupMismatch); πE != nil {
								continue
							}
							// line 1001: raise MarkupMismatch
							πF.SetLineno(1001)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
							goto Label4
						Label4:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßstandalone_uri.ToObject(), πTemp020); πE != nil {
						continue
					}
					// line 1003: def pep_reference(self, match, lineno):
					πF.SetLineno(1003)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp021 = πg.NewFunction(πg.NewCode("pep_reference", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µpepnum *πg.Object = πg.UnboundLocal
						_ = µpepnum
						var µref *πg.Object = πg.UnboundLocal
						_ = µref
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 πg.KWArgs
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1004: text = match.group(0)
							πF.SetLineno(1004)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtext = πTemp003
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("pep-").ToObject()
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µtext, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßPEP.ToObject()
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µtext, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							goto Label3
							// line 1005: if text.startswith('pep-'):
							πF.SetLineno(1005)
						Label1:
							// line 1006: pepnum = int(unescape(match.group('pepnum1')))
							πF.SetLineno(1006)
							πTemp001 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = ßpepnum1.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µpepnum = πTemp003
							goto Label4
							// line 1007: elif text.startswith('PEP'):
							πF.SetLineno(1007)
						Label2:
							// line 1008: pepnum = int(unescape(match.group('pepnum2')))
							πF.SetLineno(1008)
							πTemp001 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = ßpepnum2.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µpepnum = πTemp003
							goto Label4
						Label3:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßMarkupMismatch); πE != nil {
								continue
							}
							// line 1010: raise MarkupMismatch
							πF.SetLineno(1010)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							goto Label4
						Label4:
							// line 1011: ref = (self.document.settings.pep_base_url
							πF.SetLineno(1011)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßsettings, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp007, ßpep_base_url, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, πTemp008, ßsettings, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp009, ßpep_file_url_template, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µpepnum, "pepnum"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Mod(πF, πTemp008, µpepnum); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							µref = πTemp002
							// line 1013: return [nodes.reference(unescape(text, True), text, refuri=ref)]
							πF.SetLineno(1013)
							πTemp001 = make([]*πg.Object, 1)
							πTemp005 = πF.MakeArgs(2)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp006[0] = µtext
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp006[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[0] = πTemp003
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp005[1] = µtext
							if πE = πg.CheckLocal(πF, µref, "ref"); πE != nil {
								continue
							}
							πTemp010 = πg.KWArgs{
								{"refuri", µref},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßreference, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp005, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001[0] = πTemp002
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßpep_reference.ToObject(), πTemp021); πE != nil {
						continue
					}
					// line 1015: rfc_url = 'rfc%d.html'
					πF.SetLineno(1015)
					if πE = πClass.SetItem(πF, ßrfc_url.ToObject(), πg.NewStr("rfc%d.html").ToObject()); πE != nil {
						continue
					}
					// line 1017: def rfc_reference(self, match, lineno):
					πF.SetLineno(1017)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp022 = πg.NewFunction(πg.NewCode("rfc_reference", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µrfcnum *πg.Object = πg.UnboundLocal
						_ = µrfcnum
						var µref *πg.Object = πg.UnboundLocal
						_ = µref
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1018: text = match.group(0)
							πF.SetLineno(1018)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtext = πTemp003
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßRFC.ToObject()
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µtext, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 1019: if text.startswith('RFC'):
							πF.SetLineno(1019)
						Label1:
							// line 1020: rfcnum = int(unescape(match.group('rfcnum')))
							πF.SetLineno(1020)
							πTemp001 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(1)
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = ßrfcnum.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßint); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µrfcnum = πTemp003
							// line 1021: ref = self.document.settings.rfc_base_url + self.rfc_url % rfcnum
							πF.SetLineno(1021)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßsettings, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp007, ßrfc_base_url, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µself, ßrfc_url, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µrfcnum, "rfcnum"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Mod(πF, πTemp008, µrfcnum); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							µref = πTemp002
							goto Label3
						Label2:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßMarkupMismatch); πE != nil {
								continue
							}
							// line 1023: raise MarkupMismatch
							πF.SetLineno(1023)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							goto Label3
						Label3:
							// line 1024: return [nodes.reference(unescape(text, True), text, refuri=ref)]
							πF.SetLineno(1024)
							πTemp001 = make([]*πg.Object, 1)
							πTemp005 = πF.MakeArgs(2)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp006[0] = µtext
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp006[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp005[0] = πTemp003
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp005[1] = µtext
							if πE = πg.CheckLocal(πF, µref, "ref"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"refuri", µref},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßreference, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp005, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001[0] = πTemp002
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßrfc_reference.ToObject(), πTemp022); πE != nil {
						continue
					}
					// line 1026: def implicit_inline(self, text, lineno):
					πF.SetLineno(1026)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "text", Def: nil}
					πTemp002[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp023 = πg.NewFunction(πg.NewCode("implicit_inline", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtext *πg.Object = πArgs[1]
						_ = µtext
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µpattern *πg.Object = πg.UnboundLocal
						_ = µpattern
						var µmethod *πg.Object = πg.UnboundLocal
						_ = µmethod
						var µmatch *πg.Object = πg.UnboundLocal
						_ = µmatch
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.BaseException
						_ = πTemp010
						var πTemp011 *πg.Traceback
						_ = πTemp011
						var πTemp012 []*πg.Object
						_ = πTemp012
						var πTemp013 []*πg.Object
						_ = πTemp013
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 9:
								goto Label9
							case 3:
								goto Label3
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 1027: """
							πF.SetLineno(1027)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µtext); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp002).ToObject()
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1033: if not text:
							πF.SetLineno(1033)
						Label1:
							// line 1034: return []
							πF.SetLineno(1034)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							πR = πTemp001
							continue
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßimplicit_dispatch, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(4)
							πTemp002 = false
						Label3:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label5
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp004); πE != nil {
									continue
								}
								µpattern = πTemp006
								µmethod = πTemp007
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(3)
							// line 1036: match = pattern.search(text)
							πF.SetLineno(1036)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp003[0] = µtext
							if πE = πg.CheckLocal(πF, µpattern, "pattern"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µpattern, ßsearch, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmatch = πTemp006
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µmatch); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							goto Label7
							// line 1037: if match:
							πF.SetLineno(1037)
						Label6:
							// line 1038: try:
							πF.SetLineno(1038)
							πF.PushCheckpoint(9)
							// line 1041: return (self.implicit_inline(text[:match.start()], lineno)
							πF.SetLineno(1041)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µmatch, ßstart, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp009, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µtext, πTemp007); πE != nil {
								continue
							}
							πTemp003[0] = πTemp008
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßimplicit_inline, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp003[0] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[1] = µlineno
							if πE = πg.CheckLocal(πF, µmethod, "method"); πE != nil {
								continue
							}
							if πTemp007, πE = µmethod.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp006, πE = πg.Add(πF, πTemp008, πTemp007); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.SliceType.Call(πF, πg.Args{πTemp009, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µtext, πTemp007); πE != nil {
								continue
							}
							πTemp003[0] = πTemp008
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßimplicit_inline, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.Add(πF, πTemp006, πTemp008); πE != nil {
								continue
							}
							πR = πTemp004
							continue
							πF.PopCheckpoint()
							goto Label8
						Label9:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp010, πTemp011 = πF.ExcInfo()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßMarkupMismatch); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsInstance(πF, πTemp010.ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label10
							}
							πE = πF.Raise(πTemp010.ToObject(), nil, πTemp011.ToObject())
							continue
							// line 1044: except MarkupMismatch:
							πF.SetLineno(1044)
						Label10:
							// line 1045: pass
							πF.SetLineno(1045)
							πF.RestoreExc(nil, nil)
							goto Label8
						Label8:
							goto Label7
						Label7:
							continue
						Label4:
							if πE != nil || πR != nil {
								continue
							}
						Label5:
							// line 1046: return [nodes.Text(text, unescape(text, True))]
							πF.SetLineno(1046)
							πTemp003 = make([]*πg.Object, 1)
							πTemp012 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp012[0] = µtext
							πTemp013 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp013[0] = µtext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp013[1] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp013, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp013)
							πTemp012[1] = πTemp004
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßText, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, πTemp012, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp012)
							πTemp003[0] = πTemp001
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßimplicit_inline.ToObject(), πTemp023); πE != nil {
						continue
					}
					// line 1027: """
					πF.SetLineno(1027)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp024}, πg.NewStr("\n        Check each of the patterns in `self.implicit_dispatch` for a match,\n        and dispatch to the stored method for the pattern.  Recursively check\n        the text before and after the match.  Return a list of `nodes.Text`\n        and inline element nodes.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp025, πE = πg.ResolveClass(πF, πClass, nil, ßimplicit_inline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp025, ß__doc__, πTemp024); πE != nil {
						continue
					}
					// line 1048: dispatch = {'*': emphasis,
					πF.SetLineno(1048)
					πTemp026 = πg.NewDict()
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßemphasis); πE != nil {
						continue
					}
					if πE = πTemp026.SetItem(πF, πg.NewStr("*").ToObject(), πTemp024); πE != nil {
						continue
					}
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßstrong); πE != nil {
						continue
					}
					if πE = πTemp026.SetItem(πF, πg.NewStr("**").ToObject(), πTemp024); πE != nil {
						continue
					}
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßinterpreted_or_phrase_ref); πE != nil {
						continue
					}
					if πE = πTemp026.SetItem(πF, πg.NewStr("`").ToObject(), πTemp024); πE != nil {
						continue
					}
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßliteral); πE != nil {
						continue
					}
					if πE = πTemp026.SetItem(πF, πg.NewStr("``").ToObject(), πTemp024); πE != nil {
						continue
					}
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßinline_internal_target); πE != nil {
						continue
					}
					if πE = πTemp026.SetItem(πF, πg.NewStr("_`").ToObject(), πTemp024); πE != nil {
						continue
					}
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßfootnote_reference); πE != nil {
						continue
					}
					if πE = πTemp026.SetItem(πF, πg.NewStr("]_").ToObject(), πTemp024); πE != nil {
						continue
					}
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßsubstitution_reference); πE != nil {
						continue
					}
					if πE = πTemp026.SetItem(πF, πg.NewStr("|").ToObject(), πTemp024); πE != nil {
						continue
					}
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßreference); πE != nil {
						continue
					}
					if πE = πTemp026.SetItem(πF, ß_.ToObject(), πTemp024); πE != nil {
						continue
					}
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßanonymous_reference); πE != nil {
						continue
					}
					if πE = πTemp026.SetItem(πF, ß__.ToObject(), πTemp024); πE != nil {
						continue
					}
					πTemp024 = πTemp026.ToObject()
					if πE = πClass.SetItem(πF, ßdispatch.ToObject(), πTemp024); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp005, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp005 == nil {
				πTemp005 = πg.TypeType.ToObject()
			}
			if πTemp007, πE = πTemp005.Call(πF, []*πg.Object{πg.NewStr("Inliner").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßInliner.ToObject(), πTemp007); πE != nil {
				continue
			}
			// line 1059: def _loweralpha_to_int(s, _zero=(ord('a')-1)):
			πF.SetLineno(1059)
			πTemp006 = make([]πg.Param, 2)
			πTemp006[0] = πg.Param{Name: "s", Def: nil}
			πTemp002 = πF.MakeArgs(1)
			πTemp002[0] = ßa.ToObject()
			if πTemp007, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
				continue
			}
			if πTemp008, πE = πTemp007.Call(πF, πTemp002, nil); πE != nil {
				continue
			}
			πF.FreeArgs(πTemp002)
			if πTemp005, πE = πg.Sub(πF, πTemp008, πg.NewInt(1).ToObject()); πE != nil {
				continue
			}
			πTemp006[1] = πg.Param{Name: "_zero", Def: πTemp005}
			πTemp003 = πg.NewFunction(πg.NewCode("_loweralpha_to_int", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µs *πg.Object = πArgs[0]
				_ = µs
				var µ_zero *πg.Object = πArgs[1]
				_ = µ_zero
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πR *πg.Object
				_ = πR
				var πE *πg.BaseException
				_ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1060: return ord(s) - _zero
					πF.SetLineno(1060)
					πTemp002 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µs, "s"); πE != nil {
						continue
					}
					πTemp002[0] = µs
					if πTemp003, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					if πE = πg.CheckLocal(πF, µ_zero, "_zero"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Sub(πF, πTemp004, µ_zero); πE != nil {
						continue
					}
					πR = πTemp001
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ß_loweralpha_to_int.ToObject(), πTemp003); πE != nil {
				continue
			}
			// line 1062: def _upperalpha_to_int(s, _zero=(ord('A')-1)):
			πF.SetLineno(1062)
			πTemp006 = make([]πg.Param, 2)
			πTemp006[0] = πg.Param{Name: "s", Def: nil}
			πTemp002 = πF.MakeArgs(1)
			πTemp002[0] = ßA.ToObject()
			if πTemp008, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
				continue
			}
			if πTemp009, πE = πTemp008.Call(πF, πTemp002, nil); πE != nil {
				continue
			}
			πF.FreeArgs(πTemp002)
			if πTemp007, πE = πg.Sub(πF, πTemp009, πg.NewInt(1).ToObject()); πE != nil {
				continue
			}
			πTemp006[1] = πg.Param{Name: "_zero", Def: πTemp007}
			πTemp005 = πg.NewFunction(πg.NewCode("_upperalpha_to_int", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µs *πg.Object = πArgs[0]
				_ = µs
				var µ_zero *πg.Object = πArgs[1]
				_ = µ_zero
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πR *πg.Object
				_ = πR
				var πE *πg.BaseException
				_ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1063: return ord(s) - _zero
					πF.SetLineno(1063)
					πTemp002 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µs, "s"); πE != nil {
						continue
					}
					πTemp002[0] = µs
					if πTemp003, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
						continue
					}
					if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					if πE = πg.CheckLocal(πF, µ_zero, "_zero"); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Sub(πF, πTemp004, µ_zero); πE != nil {
						continue
					}
					πR = πTemp001
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ß_upperalpha_to_int.ToObject(), πTemp005); πE != nil {
				continue
			}
			// line 1065: def _lowerroman_to_int(s):
			πF.SetLineno(1065)
			πTemp006 = make([]πg.Param, 1)
			πTemp006[0] = πg.Param{Name: "s", Def: nil}
			πTemp007 = πg.NewFunction(πg.NewCode("_lowerroman_to_int", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
				var µs *πg.Object = πArgs[0]
				_ = µs
				var πTemp001 []*πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πR *πg.Object
				_ = πR
				var πE *πg.BaseException
				_ = πE
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 1066: return roman.fromRoman(s.upper())
					πF.SetLineno(1066)
					πTemp001 = πF.MakeArgs(1)
					if πE = πg.CheckLocal(πF, µs, "s"); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, µs, ßupper, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					πTemp001[0] = πTemp003
					if πTemp002, πE = πg.ResolveGlobal(πF, ßroman); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßfromRoman, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp001)
					πR = πTemp002
					continue
				}
				if πE != nil {
					πR = nil
				} else if πR == nil {
					πR = πg.None
				}
				return πR, πE
			}), πF.Globals()).ToObject()
			if πE = πF.Globals().SetItem(πF, ß_lowerroman_to_int.ToObject(), πTemp007); πE != nil {
				continue
			}
			// line 1069: class Body(RSTState):
			πF.SetLineno(1069)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßRSTState); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Body", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Dict
				_ = πTemp003
				var πTemp004 πg.KWArgs
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 []*πg.Object
				_ = πTemp006
				var πTemp007 bool
				_ = πTemp007
				var πTemp008 bool
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				var πTemp015 *πg.Object
				_ = πTemp015
				var πTemp016 []πg.Param
				_ = πTemp016
				var πTemp017 *πg.Object
				_ = πTemp017
				var πTemp018 *πg.Object
				_ = πTemp018
				var πTemp019 *πg.Object
				_ = πTemp019
				var πTemp020 *πg.Object
				_ = πTemp020
				var πTemp021 *πg.Object
				_ = πTemp021
				var πTemp022 *πg.Object
				_ = πTemp022
				var πTemp023 *πg.Object
				_ = πTemp023
				var πTemp024 *πg.Object
				_ = πTemp024
				var πTemp025 *πg.Object
				_ = πTemp025
				var πTemp026 *πg.Object
				_ = πTemp026
				var πTemp027 *πg.Object
				_ = πTemp027
				var πTemp028 *πg.Object
				_ = πTemp028
				var πTemp029 *πg.Object
				_ = πTemp029
				var πTemp030 *πg.Object
				_ = πTemp030
				var πTemp031 *πg.Object
				_ = πTemp031
				var πTemp032 *πg.Object
				_ = πTemp032
				var πTemp033 *πg.Object
				_ = πTemp033
				var πTemp034 *πg.Object
				_ = πTemp034
				var πTemp035 *πg.Object
				_ = πTemp035
				var πTemp036 *πg.Object
				_ = πTemp036
				var πTemp037 *πg.Object
				_ = πTemp037
				var πTemp038 *πg.Object
				_ = πTemp038
				var πTemp039 *πg.Object
				_ = πTemp039
				var πTemp040 *πg.Object
				_ = πTemp040
				var πTemp041 []*πg.Object
				_ = πTemp041
				var πTemp042 *πg.Object
				_ = πTemp042
				var πTemp043 *πg.Object
				_ = πTemp043
				var πTemp044 *πg.Object
				_ = πTemp044
				var πTemp045 *πg.Object
				_ = πTemp045
				var πTemp046 *πg.Object
				_ = πTemp046
				var πTemp047 *πg.Object
				_ = πTemp047
				var πTemp048 *πg.Object
				_ = πTemp048
				var πTemp049 *πg.Object
				_ = πTemp049
				var πTemp050 *πg.Object
				_ = πTemp050
				var πTemp051 *πg.Object
				_ = πTemp051
				var πTemp052 *πg.Object
				_ = πTemp052
				var πTemp053 *πg.Object
				_ = πTemp053
				var πTemp054 *πg.Object
				_ = πTemp054
				var πTemp055 *πg.Object
				_ = πTemp055
				var πTemp056 *πg.Object
				_ = πTemp056
				var πTemp057 *πg.Object
				_ = πTemp057
				var πTemp058 *πg.Object
				_ = πTemp058
				var πTemp059 *πg.Object
				_ = πTemp059
				var πTemp060 *πg.Object
				_ = πTemp060
				var πTemp061 *πg.Object
				_ = πTemp061
				var πTemp062 *πg.Object
				_ = πTemp062
				var πTemp063 *πg.Object
				_ = πTemp063
				var πTemp064 *πg.Object
				_ = πTemp064
				var πTemp065 *πg.Object
				_ = πTemp065
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					case 1:
						goto Label1
					case 2:
						goto Label2
					case 4:
						goto Label4
					case 5:
						goto Label5
					default:
						panic("unexpected function state")
					}
					// line 1071: """
					πF.SetLineno(1071)
					// line 1071: """
					πF.SetLineno(1071)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    Generic classifier of the first line of a block.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 1075: double_width_pad_char = tableparser.TableParser.double_width_pad_char
					πF.SetLineno(1075)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßtableparser); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßTableParser, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßdouble_width_pad_char, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßdouble_width_pad_char.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1076: """Padding character for East Asian double-width text."""
					πF.SetLineno(1076)
					// line 1078: enum = Struct()
					πF.SetLineno(1078)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßStruct); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßenum.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 1079: """Enumerated list parsing information."""
					πF.SetLineno(1079)
					// line 1081: enum.formatinfo = {
					πF.SetLineno(1081)
					πTemp003 = πg.NewDict()
					if πTemp001, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					πTemp004 = πg.KWArgs{
						{"prefix", πg.NewStr("(").ToObject()},
						{"suffix", πg.NewStr(")").ToObject()},
						{"start", πg.NewInt(1).ToObject()},
						{"end", πTemp001},
					}
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßStruct); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, πTemp004); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßparens.ToObject(), πTemp002); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					πTemp004 = πg.KWArgs{
						{"prefix", ß.ToObject()},
						{"suffix", πg.NewStr(")").ToObject()},
						{"start", πg.NewInt(0).ToObject()},
						{"end", πTemp001},
					}
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßStruct); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, πTemp004); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßrparen.ToObject(), πTemp002); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					πTemp004 = πg.KWArgs{
						{"prefix", ß.ToObject()},
						{"suffix", πg.NewStr(".").ToObject()},
						{"start", πg.NewInt(0).ToObject()},
						{"end", πTemp001},
					}
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßStruct); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, πTemp004); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßperiod.ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp001 = πTemp003.ToObject()
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ßformatinfo, πTemp002); πE != nil {
						continue
					}
					// line 1085: enum.formats = enum.formatinfo.keys()
					πF.SetLineno(1085)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßformatinfo, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßkeys, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ßformats, πTemp001); πE != nil {
						continue
					}
					// line 1086: enum.sequences = ['arabic', 'loweralpha', 'upperalpha',
					πF.SetLineno(1086)
					πTemp006 = make([]*πg.Object, 5)
					πTemp006[0] = ßarabic.ToObject()
					πTemp006[1] = ßloweralpha.ToObject()
					πTemp006[2] = ßupperalpha.ToObject()
					πTemp006[3] = ßlowerroman.ToObject()
					πTemp006[4] = ßupperroman.ToObject()
					πTemp001 = πg.NewList(πTemp006...).ToObject()
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ßsequences, πTemp002); πE != nil {
						continue
					}
					// line 1088: enum.sequencepats = {'arabic': '[0-9]+',
					πF.SetLineno(1088)
					πTemp003 = πg.NewDict()
					if πE = πTemp003.SetItem(πF, ßarabic.ToObject(), πg.NewStr("[0-9]+").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßloweralpha.ToObject(), πg.NewStr("[a-z]").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßupperalpha.ToObject(), πg.NewStr("[A-Z]").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßlowerroman.ToObject(), πg.NewStr("[ivxlcdm]+").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßupperroman.ToObject(), πg.NewStr("[IVXLCDM]+").ToObject()); πE != nil {
						continue
					}
					πTemp001 = πTemp003.ToObject()
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ßsequencepats, πTemp002); πE != nil {
						continue
					}
					// line 1093: enum.converters = {'arabic': int,
					πF.SetLineno(1093)
					πTemp003 = πg.NewDict()
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßint); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßarabic.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ß_loweralpha_to_int); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßloweralpha.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ß_upperalpha_to_int); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßupperalpha.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ß_lowerroman_to_int); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßlowerroman.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßroman); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßfromRoman, nil); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßupperroman.ToObject(), πTemp002); πE != nil {
						continue
					}
					πTemp001 = πTemp003.ToObject()
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ßconverters, πTemp002); πE != nil {
						continue
					}
					// line 1099: enum.sequenceregexps = {}
					πF.SetLineno(1099)
					πTemp003 = πg.NewDict()
					πTemp001 = πTemp003.ToObject()
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ßsequenceregexps, πTemp002); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßsequences, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
						continue
					}
					πF.PushCheckpoint(2)
					πTemp007 = false
				Label1:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp007 {
						πF.PopCheckpoint()
						goto Label3
					}
					if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp008 = !isStop
					} else {
						πTemp008 = true
						if πE = πClass.SetItem(πF, ßsequence.ToObject(), πTemp002); πE != nil {
							continue
						}
					}
					if πE != nil || !πTemp008 {
						continue
					}
					πF.PushCheckpoint(1)
					// line 1101: enum.sequenceregexps[sequence] = re.compile(
					πF.SetLineno(1101)
					πTemp006 = πF.MakeArgs(2)
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßsequence); πE != nil {
						continue
					}
					πTemp005 = πTemp009
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πTemp011, πE = πg.GetAttr(πF, πTemp010, ßsequencepats, nil); πE != nil {
						continue
					}
					if πTemp009, πE = πg.GetItem(πF, πTemp011, πTemp005); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Add(πF, πTemp009, πg.NewStr("$").ToObject()); πE != nil {
						continue
					}
					πTemp006[0] = πTemp002
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßUNICODE, nil); πE != nil {
						continue
					}
					πTemp006[1] = πTemp005
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp005.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πTemp002); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πTemp010, πE = πg.GetAttr(πF, πTemp009, ßsequenceregexps, nil); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßsequence); πE != nil {
						continue
					}
					πTemp009 = πTemp011
					if πE = πg.SetItem(πF, πTemp010, πTemp009, πTemp005); πE != nil {
						continue
					}
					continue
				Label2:
					if πE != nil || πR != nil {
						continue
					}
				Label3:
					// line 1104: grid_table_top_pat = re.compile(r'\+-[-+]+-\+ *$')
					πF.SetLineno(1104)
					πTemp006 = πF.MakeArgs(1)
					πTemp006[0] = πg.NewStr("\\+-[-+]+-\\+ *$").ToObject()
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πE = πClass.SetItem(πF, ßgrid_table_top_pat.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1105: """Matches the top (& bottom) of a full table)."""
					πF.SetLineno(1105)
					// line 1107: simple_table_top_pat = re.compile('=+( +=+)+ *$')
					πF.SetLineno(1107)
					πTemp006 = πF.MakeArgs(1)
					πTemp006[0] = πg.NewStr("=+( +=+)+ *$").ToObject()
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πE = πClass.SetItem(πF, ßsimple_table_top_pat.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1108: """Matches the top of a simple table."""
					πF.SetLineno(1108)
					// line 1110: simple_table_border_pat = re.compile('=+[ =]*$')
					πF.SetLineno(1110)
					πTemp006 = πF.MakeArgs(1)
					πTemp006[0] = πg.NewStr("=+[ =]*$").ToObject()
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πE = πClass.SetItem(πF, ßsimple_table_border_pat.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1111: """Matches the bottom & header bottom of a simple table."""
					πF.SetLineno(1111)
					// line 1113: pats = {}
					πF.SetLineno(1113)
					πTemp003 = πg.NewDict()
					πTemp001 = πTemp003.ToObject()
					if πE = πClass.SetItem(πF, ßpats.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1114: """Fragments of patterns used by transitions."""
					πF.SetLineno(1114)
					// line 1116: pats['nonalphanum7bit'] = '[!-/:-@[-`{-~]'
					πF.SetLineno(1116)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewStr("[!-/:-@[-`{-~]").ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp005 = ßnonalphanum7bit.ToObject()
					if πE = πg.SetItem(πF, πTemp002, πTemp005, πTemp001); πE != nil {
						continue
					}
					// line 1117: pats['alpha'] = '[a-zA-Z]'
					πF.SetLineno(1117)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewStr("[a-zA-Z]").ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp005 = ßalpha.ToObject()
					if πE = πg.SetItem(πF, πTemp002, πTemp005, πTemp001); πE != nil {
						continue
					}
					// line 1118: pats['alphanum'] = '[a-zA-Z0-9]'
					πF.SetLineno(1118)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewStr("[a-zA-Z0-9]").ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp005 = ßalphanum.ToObject()
					if πE = πg.SetItem(πF, πTemp002, πTemp005, πTemp001); πE != nil {
						continue
					}
					// line 1119: pats['alphanumplus'] = '[a-zA-Z0-9_-]'
					πF.SetLineno(1119)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewStr("[a-zA-Z0-9_-]").ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp005 = ßalphanumplus.ToObject()
					if πE = πg.SetItem(πF, πTemp002, πTemp005, πTemp001); πE != nil {
						continue
					}
					// line 1120: pats['enum'] = ('(%(arabic)s|%(loweralpha)s|%(upperalpha)s|%(lowerroman)s'
					πF.SetLineno(1120)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßsequencepats, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("(%(arabic)s|%(loweralpha)s|%(upperalpha)s|%(lowerroman)s|%(upperroman)s|#)").ToObject(), πTemp005); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp009 = ßenum.ToObject()
					if πE = πg.SetItem(πF, πTemp005, πTemp009, πTemp002); πE != nil {
						continue
					}
					// line 1122: pats['optname'] = '%(alphanum)s%(alphanumplus)s*' % pats
					πF.SetLineno(1122)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("%(alphanum)s%(alphanumplus)s*").ToObject(), πTemp002); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp009 = ßoptname.ToObject()
					if πE = πg.SetItem(πF, πTemp005, πTemp009, πTemp002); πE != nil {
						continue
					}
					// line 1124: pats['optarg'] = '(%(alpha)s%(alphanumplus)s*|<[^<>]+>)' % pats
					πF.SetLineno(1124)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("(%(alpha)s%(alphanumplus)s*|<[^<>]+>)").ToObject(), πTemp002); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp009 = ßoptarg.ToObject()
					if πE = πg.SetItem(πF, πTemp005, πTemp009, πTemp002); πE != nil {
						continue
					}
					// line 1125: pats['shortopt'] = r'(-|\+)%(alphanum)s( ?%(optarg)s)?' % pats
					πF.SetLineno(1125)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("(-|\\+)%(alphanum)s( ?%(optarg)s)?").ToObject(), πTemp002); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp009 = ßshortopt.ToObject()
					if πE = πg.SetItem(πF, πTemp005, πTemp009, πTemp002); πE != nil {
						continue
					}
					// line 1126: pats['longopt'] = r'(--|/)%(optname)s([ =]%(optarg)s)?' % pats
					πF.SetLineno(1126)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("(--|/)%(optname)s([ =]%(optarg)s)?").ToObject(), πTemp002); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp009 = ßlongopt.ToObject()
					if πE = πg.SetItem(πF, πTemp005, πTemp009, πTemp002); πE != nil {
						continue
					}
					// line 1127: pats['option'] = r'(%(shortopt)s|%(longopt)s)' % pats
					πF.SetLineno(1127)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("(%(shortopt)s|%(longopt)s)").ToObject(), πTemp002); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					πTemp009 = ßoption.ToObject()
					if πE = πg.SetItem(πF, πTemp005, πTemp009, πTemp002); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßformats, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
						continue
					}
					πF.PushCheckpoint(5)
					πTemp007 = false
				Label4:
					if πE != nil || πR != nil {
						continue
					}
					if πTemp007 {
						πF.PopCheckpoint()
						goto Label6
					}
					if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
						isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
						if exc != nil {
							πE = exc
						} else if isStop {
							πE = nil
							πF.RestoreExc(nil, nil)
						}
						πTemp008 = !isStop
					} else {
						πTemp008 = true
						if πE = πClass.SetItem(πF, ßformat.ToObject(), πTemp002); πE != nil {
							continue
						}
					}
					if πE != nil || !πTemp008 {
						continue
					}
					πF.PushCheckpoint(4)
					// line 1130: pats[format] = '(?P<%s>%s%s%s)' % (
					πF.SetLineno(1130)
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßformat); πE != nil {
						continue
					}
					πTemp006 = πF.MakeArgs(1)
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßformat); πE != nil {
						continue
					}
					πTemp010 = πTemp011
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πTemp013, πE = πg.GetAttr(πF, πTemp012, ßformatinfo, nil); πE != nil {
						continue
					}
					if πTemp011, πE = πg.GetItem(πF, πTemp013, πTemp010); πE != nil {
						continue
					}
					if πTemp010, πE = πg.GetAttr(πF, πTemp011, ßprefix, nil); πE != nil {
						continue
					}
					πTemp006[0] = πTemp010
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp011, πE = πg.GetAttr(πF, πTemp010, ßescape, nil); πE != nil {
						continue
					}
					if πTemp010, πE = πTemp011.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					πTemp011 = ßenum.ToObject()
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp012, πE = πg.GetItem(πF, πTemp013, πTemp011); πE != nil {
						continue
					}
					πTemp006 = πF.MakeArgs(1)
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßformat); πE != nil {
						continue
					}
					πTemp011 = πTemp013
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßenum); πE != nil {
						continue
					}
					if πTemp015, πE = πg.GetAttr(πF, πTemp014, ßformatinfo, nil); πE != nil {
						continue
					}
					if πTemp013, πE = πg.GetItem(πF, πTemp015, πTemp011); πE != nil {
						continue
					}
					if πTemp011, πE = πg.GetAttr(πF, πTemp013, ßsuffix, nil); πE != nil {
						continue
					}
					πTemp006[0] = πTemp011
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp013, πE = πg.GetAttr(πF, πTemp011, ßescape, nil); πE != nil {
						continue
					}
					if πTemp011, πE = πTemp013.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					πTemp005 = πg.NewTuple4(πTemp009, πTemp010, πTemp012, πTemp011).ToObject()
					if πTemp002, πE = πg.Mod(πF, πg.NewStr("(?P<%s>%s%s%s)").ToObject(), πTemp005); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πTemp002); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßformat); πE != nil {
						continue
					}
					πTemp010 = πTemp011
					if πE = πg.SetItem(πF, πTemp009, πTemp010, πTemp005); πE != nil {
						continue
					}
					continue
				Label5:
					if πE != nil || πR != nil {
						continue
					}
				Label6:
					// line 1134: patterns = {
					πF.SetLineno(1134)
					πTemp003 = πg.NewDict()
					if πE = πTemp003.SetItem(πF, ßbullet.ToObject(), πg.NewUnicode("[-+*\xe2\x80\xa2\xe2\x80\xa3\xe2\x81\x83]( +|$)").ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("(%(parens)s|%(rparen)s|%(period)s)( +|$)").ToObject(), πTemp002); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßenumerator.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßfield_marker.ToObject(), πg.NewStr(":(?![: ])([^:\\\\]|\\\\.|:(?!([ `]|$)))*(?<! ):( +|$)").ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("%(option)s(, %(option)s)*(  +| ?$)").ToObject(), πTemp002); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßoption_marker.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßdoctest.ToObject(), πg.NewStr(">>>( +|$)").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßline_block.ToObject(), πg.NewStr("\\|( +|$)").ToObject()); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßgrid_table_top_pat); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßgrid_table_top.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßsimple_table_top_pat); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßsimple_table_top.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßexplicit_markup.ToObject(), πg.NewStr("\\.\\.( +|$)").ToObject()); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßanonymous.ToObject(), πg.NewStr("__( +|$)").ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpats); πE != nil {
						continue
					}
					if πTemp001, πE = πg.Mod(πF, πg.NewStr("(%(nonalphanum7bit)s)\\1* *$").ToObject(), πTemp002); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßline.ToObject(), πTemp001); πE != nil {
						continue
					}
					if πE = πTemp003.SetItem(πF, ßtext.ToObject(), ß.ToObject()); πE != nil {
						continue
					}
					πTemp001 = πTemp003.ToObject()
					if πE = πClass.SetItem(πF, ßpatterns.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1147: initial_transitions = (
					πF.SetLineno(1147)
					πTemp006 = make([]*πg.Object, 12)
					πTemp006[0] = ßbullet.ToObject()
					πTemp006[1] = ßenumerator.ToObject()
					πTemp006[2] = ßfield_marker.ToObject()
					πTemp006[3] = ßoption_marker.ToObject()
					πTemp006[4] = ßdoctest.ToObject()
					πTemp006[5] = ßline_block.ToObject()
					πTemp006[6] = ßgrid_table_top.ToObject()
					πTemp006[7] = ßsimple_table_top.ToObject()
					πTemp006[8] = ßexplicit_markup.ToObject()
					πTemp006[9] = ßanonymous.ToObject()
					πTemp006[10] = ßline.ToObject()
					πTemp006[11] = ßtext.ToObject()
					πTemp001 = πg.NewTuple(πTemp006...).ToObject()
					if πE = πClass.SetItem(πF, ßinitial_transitions.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1161: def indent(self, match, context, next_state):
					πF.SetLineno(1161)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("indent", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µline_offset *πg.Object = πg.UnboundLocal
						_ = µline_offset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µelements *πg.Object = πg.UnboundLocal
						_ = µelements
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1162: """Block quote."""
							πF.SetLineno(1162)
							// line 1163: indented, indent, line_offset, blank_finish = \
							πF.SetLineno(1163)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µindent = πTemp003
							µline_offset = πTemp004
							µblank_finish = πTemp005
							// line 1165: elements = self.block_quote(indented, line_offset)
							πF.SetLineno(1165)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp006[0] = µindented
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							πTemp006[1] = µline_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßblock_quote, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µelements = πTemp002
							// line 1166: self.parent += elements
							πF.SetLineno(1166)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µelements, "elements"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µelements); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 1167: if not blank_finish:
							πF.SetLineno(1167)
						Label1:
							// line 1168: self.parent += self.unindent_warning('Block quote')
							πF.SetLineno(1168)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("Block quote").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 1169: return context, next_state, []
							πF.SetLineno(1169)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp006 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp006...).ToObject()
							πTemp001 = πg.NewTuple3(µcontext, µnext_state, πTemp002).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßindent.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 1162: """Block quote."""
					πF.SetLineno(1162)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("Block quote.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßindent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 1171: def block_quote(self, indented, line_offset):
					πF.SetLineno(1171)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "indented", Def: nil}
					πTemp016[2] = πg.Param{Name: "line_offset", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("block_quote", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindented *πg.Object = πArgs[1]
						_ = µindented
						var µline_offset *πg.Object = πArgs[2]
						_ = µline_offset
						var µelements *πg.Object = πg.UnboundLocal
						_ = µelements
						var µblockquote_lines *πg.Object = πg.UnboundLocal
						_ = µblockquote_lines
						var µattribution_lines *πg.Object = πg.UnboundLocal
						_ = µattribution_lines
						var µattribution_offset *πg.Object = πg.UnboundLocal
						_ = µattribution_offset
						var µnew_line_offset *πg.Object = πg.UnboundLocal
						_ = µnew_line_offset
						var µblockquote *πg.Object = πg.UnboundLocal
						_ = µblockquote
						var µattribution *πg.Object = πg.UnboundLocal
						_ = µattribution
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πTemp011 bool
						_ = πTemp011
						var πTemp012 bool
						_ = πTemp012
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							case 6:
								goto Label6
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 1172: elements = []
							πF.SetLineno(1172)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µelements = πTemp002
							// line 1173: while indented:
							πF.SetLineno(1173)
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µindented); πE != nil {
								continue
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1174: (blockquote_lines,
							πF.SetLineno(1174)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001[0] = µindented
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							πTemp001[1] = µline_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßsplit_attribution, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}, πg.TieTarget{Target: &πTemp008}, πg.TieTarget{Target: &πTemp009}}}, πTemp005); πE != nil {
								continue
							}
							µblockquote_lines = πTemp002
							µattribution_lines = πTemp006
							µattribution_offset = πTemp007
							µindented = πTemp008
							µnew_line_offset = πTemp009
							// line 1179: blockquote = nodes.block_quote()
							πF.SetLineno(1179)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßblock_quote, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							µblockquote = πTemp002
							// line 1180: self.nested_parse(blockquote_lines, line_offset, blockquote)
							πF.SetLineno(1180)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µblockquote_lines, "blockquote_lines"); πE != nil {
								continue
							}
							πTemp001[0] = µblockquote_lines
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							πTemp001[1] = µline_offset
							if πE = πg.CheckLocal(πF, µblockquote, "blockquote"); πE != nil {
								continue
							}
							πTemp001[2] = µblockquote
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1181: elements.append(blockquote)
							πF.SetLineno(1181)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblockquote, "blockquote"); πE != nil {
								continue
							}
							πTemp001[0] = µblockquote
							if πE = πg.CheckLocal(πF, µelements, "elements"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µelements, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µattribution_lines, "attribution_lines"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µattribution_lines); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 1182: if attribution_lines:
							πF.SetLineno(1182)
						Label4:
							// line 1183: attribution, messages = self.parse_attribution(
							πF.SetLineno(1183)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µattribution_lines, "attribution_lines"); πE != nil {
								continue
							}
							πTemp001[0] = µattribution_lines
							if πE = πg.CheckLocal(πF, µattribution_offset, "attribution_offset"); πE != nil {
								continue
							}
							πTemp001[1] = µattribution_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparse_attribution, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp006}}}, πTemp005); πE != nil {
								continue
							}
							µattribution = πTemp002
							µmessages = πTemp006
							// line 1185: blockquote += attribution
							πF.SetLineno(1185)
							if πE = πg.CheckLocal(πF, µblockquote, "blockquote"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattribution, "attribution"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µblockquote, µattribution); πE != nil {
								continue
							}
							µblockquote = πTemp002
							// line 1186: elements += messages
							πF.SetLineno(1186)
							if πE = πg.CheckLocal(πF, µelements, "elements"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µelements, µmessages); πE != nil {
								continue
							}
							µelements = πTemp002
							goto Label5
						Label5:
							// line 1187: line_offset = new_line_offset
							πF.SetLineno(1187)
							if πE = πg.CheckLocal(πF, µnew_line_offset, "new_line_offset"); πE != nil {
								continue
							}
							µline_offset = µnew_line_offset
							// line 1188: while indented and not indented[0]:
							πF.SetLineno(1188)
							πF.PushCheckpoint(7)
							πTemp004 = false
						Label6:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp002 = µindented
							if πTemp011, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if !πTemp011 {
								goto Label9
							}
							πTemp006 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µindented, πTemp006); πE != nil {
								continue
							}
							if πTemp012, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp005 = πg.GetBool(!πTemp012).ToObject()
							πTemp002 = πTemp005
						Label9:
							if πTemp010, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πE != nil || !πTemp010 {
								continue
							}
							πF.PushCheckpoint(6)
							// line 1189: indented = indented[1:]
							πF.SetLineno(1189)
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µindented, πTemp002); πE != nil {
								continue
							}
							µindented = πTemp005
							// line 1190: line_offset += 1
							πF.SetLineno(1190)
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µline_offset, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µline_offset = πTemp002
							continue
						Label7:
							if πE != nil || πR != nil {
								continue
							}
						Label8:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1191: return elements
							πF.SetLineno(1191)
							if πE = πg.CheckLocal(πF, µelements, "elements"); πE != nil {
								continue
							}
							πR = µelements
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßblock_quote.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 1194: attribution_pattern = re.compile(u'(---?(?!-)|\u2014) *(?=[^ \\n])',
					πF.SetLineno(1194)
					πTemp006 = πF.MakeArgs(2)
					πTemp006[0] = πg.NewUnicode("(---?(?!-)|\xe2\x80\x94) *(?=[^ \\n])").ToObject()
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp009, πE = πg.GetAttr(πF, πTemp005, ßUNICODE, nil); πE != nil {
						continue
					}
					πTemp006[1] = πTemp009
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp009, πE = πg.GetAttr(πF, πTemp005, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp005, πE = πTemp009.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πE = πClass.SetItem(πF, ßattribution_pattern.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1197: def split_attribution(self, indented, line_offset):
					πF.SetLineno(1197)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "indented", Def: nil}
					πTemp016[2] = πg.Param{Name: "line_offset", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("split_attribution", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindented *πg.Object = πArgs[1]
						_ = µindented
						var µline_offset *πg.Object = πArgs[2]
						_ = µline_offset
						var µblank *πg.Object = πg.UnboundLocal
						_ = µblank
						var µnonblank_seen *πg.Object = πg.UnboundLocal
						_ = µnonblank_seen
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var µmatch *πg.Object = πg.UnboundLocal
						_ = µmatch
						var µattribution_end *πg.Object = πg.UnboundLocal
						_ = µattribution_end
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µa_lines *πg.Object = πg.UnboundLocal
						_ = µa_lines
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 *πg.Object
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1198: """
							πF.SetLineno(1198)
							// line 1209: blank = None
							πF.SetLineno(1209)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µblank = πTemp001
							// line 1210: nonblank_seen = False
							πF.SetLineno(1210)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							µnonblank_seen = πTemp001
							πTemp002 = πF.MakeArgs(1)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp003[0] = µindented
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp002[0] = πTemp005
							if πTemp004, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µi = πTemp004
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1212: line = indented[i].rstrip()
							πF.SetLineno(1212)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp004 = µi
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µindented, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							µline = πTemp005
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µline); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 1213: if line:
							πF.SetLineno(1213)
						Label4:
							if πE = πg.CheckLocal(πF, µnonblank_seen, "nonblank_seen"); πE != nil {
								continue
							}
							πTemp004 = µnonblank_seen
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if !πTemp007 {
								goto Label7
							}
							if πE = πg.CheckLocal(πF, µblank, "blank"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Sub(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Eq(πF, µblank, πTemp008); πE != nil {
								continue
							}
							πTemp004 = πTemp005
						Label7:
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label8
							}
							goto Label9
							// line 1214: if nonblank_seen and blank == i - 1: # last line blank
							πF.SetLineno(1214)
						Label8:
							// line 1215: match = self.attribution_pattern.match(line)
							πF.SetLineno(1215)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp002[0] = µline
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßattribution_pattern, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µmatch = πTemp004
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µmatch); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label10
							}
							goto Label11
							// line 1216: if match:
							πF.SetLineno(1216)
						Label10:
							// line 1217: attribution_end, indent = self.check_attribution(
							πF.SetLineno(1217)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp002[0] = µindented
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp002[1] = µi
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßcheck_attribution, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp008}}}, πTemp005); πE != nil {
								continue
							}
							µattribution_end = πTemp004
							µindent = πTemp008
							if πE = πg.CheckLocal(πF, µattribution_end, "attribution_end"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µattribution_end); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label12
							}
							goto Label13
							// line 1219: if attribution_end:
							πF.SetLineno(1219)
						Label12:
							// line 1220: a_lines = indented[i:attribution_end]
							πF.SetLineno(1220)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattribution_end, "attribution_end"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{µi, µattribution_end, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µindented, πTemp004); πE != nil {
								continue
							}
							µa_lines = πTemp005
							// line 1221: a_lines.trim_left(match.end(), end=1)
							πF.SetLineno(1221)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp005
							πTemp009 = πg.KWArgs{
								{"end", πg.NewInt(1).ToObject()},
							}
							if πE = πg.CheckLocal(πF, µa_lines, "a_lines"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µa_lines, ßtrim_left, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp002, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 1222: a_lines.trim_left(indent, start=1)
							πF.SetLineno(1222)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp002[0] = µindent
							πTemp009 = πg.KWArgs{
								{"start", πg.NewInt(1).ToObject()},
							}
							if πE = πg.CheckLocal(πF, µa_lines, "a_lines"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µa_lines, ßtrim_left, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp002, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 1223: return (indented[:i], a_lines,
							πF.SetLineno(1223)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µi, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µindented, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µa_lines, "a_lines"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattribution_end, "attribution_end"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.SliceType.Call(πF, πg.Args{µattribution_end, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetItem(πF, µindented, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattribution_end, "attribution_end"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Add(πF, µline_offset, µattribution_end); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple5(πTemp008, µa_lines, µi, πTemp010, πTemp005).ToObject()
							πR = πTemp004
							continue
							goto Label13
						Label13:
							goto Label11
						Label11:
							goto Label9
						Label9:
							// line 1226: nonblank_seen = True
							πF.SetLineno(1226)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							µnonblank_seen = πTemp004
							goto Label6
						Label5:
							// line 1228: blank = i
							πF.SetLineno(1228)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							µblank = µi
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
							// line 1230: return (indented, None, None, None, None)
							πF.SetLineno(1230)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πTemp008, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πTemp010, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πTemp011, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple5(µindented, πTemp005, πTemp008, πTemp010, πTemp011).ToObject()
							πR = πTemp004
							continue
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsplit_attribution.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 1198: """
					πF.SetLineno(1198)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("\n        Check for a block quote attribution and split it off:\n\n        * First line after a blank line must begin with a dash (\"--\", \"---\",\n          em-dash; matches `self.attribution_pattern`).\n        * Every line after that must have consistent indentation.\n        * Attributions must be preceded by block quote content.\n\n        Return a tuple of: (block quote content lines, content offset,\n        attribution lines, attribution offset, remaining indented lines).\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßsplit_attribution); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 1232: def check_attribution(self, indented, attribution_start):
					πF.SetLineno(1232)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "indented", Def: nil}
					πTemp016[2] = πg.Param{Name: "attribution_start", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("check_attribution", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindented *πg.Object = πArgs[1]
						_ = µindented
						var µattribution_start *πg.Object = πArgs[2]
						_ = µattribution_start
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1233: """
							πF.SetLineno(1233)
							// line 1237: indent = None
							πF.SetLineno(1237)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µindent = πTemp001
							// line 1238: i = attribution_start + 1
							πF.SetLineno(1238)
							if πE = πg.CheckLocal(πF, µattribution_start, "attribution_start"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µattribution_start, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µi = πTemp001
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µattribution_start, "attribution_start"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µattribution_start, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp004[0] = µindented
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp002[1] = πTemp005
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µi = πTemp003
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1240: line = indented[i].rstrip()
							πF.SetLineno(1240)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp003 = µi
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µindented, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp005, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µline = πTemp005
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µline); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 1241: if not line:
							πF.SetLineno(1241)
						Label4:
							// line 1242: break
							πF.SetLineno(1242)
							πTemp006 = true
							continue
							goto Label5
						Label5:
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(µindent == πTemp005).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label6
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp002[0] = µline
							if πTemp008, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µline, ßlstrip, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp008.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp010
							if πTemp008, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp008.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.Sub(πF, πTemp009, πTemp010); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.NE(πF, πTemp005, µindent); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label7
							}
							goto Label8
							// line 1243: if indent is None:
							πF.SetLineno(1243)
						Label6:
							// line 1244: indent = len(line) - len(line.lstrip())
							πF.SetLineno(1244)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp002[0] = µline
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp005.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µline, ßlstrip, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp009
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp005.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.Sub(πF, πTemp008, πTemp009); πE != nil {
								continue
							}
							µindent = πTemp003
							goto Label8
							// line 1245: elif len(line) - len(line.lstrip()) != indent:
							πF.SetLineno(1245)
						Label7:
							// line 1246: return None, None       # bad shape; not an attribution
							πF.SetLineno(1246)
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πTemp008, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(πTemp005, πTemp008).ToObject()
							πR = πTemp003
							continue
							goto Label8
						Label8:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
							// line 1249: i += 1
							πF.SetLineno(1249)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µi = πTemp003
						Label3:
							// line 1250: return i, (indent or 0)
							πF.SetLineno(1250)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp003 = µindent
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label9
							}
							πTemp003 = πg.NewInt(0).ToObject()
						Label9:
							πTemp001 = πg.NewTuple2(µi, πTemp003).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcheck_attribution.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 1233: """
					πF.SetLineno(1233)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("\n        Check attribution shape.\n        Return the index past the end of the attribution, and the indent.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßcheck_attribution); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 1252: def parse_attribution(self, indented, line_offset):
					πF.SetLineno(1252)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "indented", Def: nil}
					πTemp016[2] = πg.Param{Name: "line_offset", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("parse_attribution", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindented *πg.Object = πArgs[1]
						_ = µindented
						var µline_offset *πg.Object = πArgs[2]
						_ = µline_offset
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µtextnodes *πg.Object = πg.UnboundLocal
						_ = µtextnodes
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µnode *πg.Object = πg.UnboundLocal
						_ = µnode
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1253: text = '\n'.join(indented).rstrip()
							πF.SetLineno(1253)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001[0] = µindented
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtext = πTemp003
							// line 1254: lineno = self.state_machine.abs_line_number() + line_offset
							πF.SetLineno(1254)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, µline_offset); πE != nil {
								continue
							}
							µlineno = πTemp002
							// line 1255: textnodes, messages = self.inline_text(text, lineno)
							πF.SetLineno(1255)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinline_text, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µtextnodes = πTemp002
							µmessages = πTemp004
							// line 1256: node = nodes.attribution(text, '', *textnodes)
							πF.SetLineno(1256)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							πTemp001[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µtextnodes, "textnodes"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßattribution, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Invoke(πF, πTemp003, πTemp001, µtextnodes, nil, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µnode = πTemp002
							// line 1257: node.source, node.line = self.state_machine.get_source_and_line(lineno)
							πF.SetLineno(1257)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[0] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µnode, ßsource, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µnode, ßline, πTemp004); πE != nil {
								continue
							}
							// line 1258: return node, messages
							πF.SetLineno(1258)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(µnode, µmessages).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_attribution.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 1260: def bullet(self, match, context, next_state):
					πF.SetLineno(1260)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("bullet", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µbulletlist *πg.Object = πg.UnboundLocal
						_ = µbulletlist
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µnew_line_offset *πg.Object = πg.UnboundLocal
						_ = µnew_line_offset
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1261: """Bullet list item."""
							πF.SetLineno(1261)
							// line 1262: bulletlist = nodes.bullet_list()
							πF.SetLineno(1262)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßbullet_list, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µbulletlist = πTemp001
							// line 1263: (bulletlist.source,
							πF.SetLineno(1263)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbulletlist, "bulletlist"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µbulletlist, ßsource, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbulletlist, "bulletlist"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µbulletlist, ßline, πTemp003); πE != nil {
								continue
							}
							// line 1265: self.parent += bulletlist
							πF.SetLineno(1265)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbulletlist, "bulletlist"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µbulletlist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 1266: bulletlist['bullet'] = match.string[0]
							πF.SetLineno(1266)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbulletlist, "bulletlist"); πE != nil {
								continue
							}
							πTemp003 = ßbullet.ToObject()
							if πE = πg.SetItem(πF, µbulletlist, πTemp003, πTemp001); πE != nil {
								continue
							}
							// line 1267: i, blank_finish = self.list_item(match.end())
							πF.SetLineno(1267)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßlist_item, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µi = πTemp001
							µblank_finish = πTemp003
							// line 1268: bulletlist += i
							πF.SetLineno(1268)
							if πE = πg.CheckLocal(πF, µbulletlist, "bulletlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µbulletlist, µi); πE != nil {
								continue
							}
							µbulletlist = πTemp001
							// line 1269: offset = self.state_machine.line_offset + 1   # next line
							πF.SetLineno(1269)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp001
							// line 1270: new_line_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(1270)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µbulletlist, "bulletlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"input_offset", πTemp001},
								{"node", µbulletlist},
								{"initial_state", ßBulletList.ToObject()},
								{"blank_finish", µblank_finish},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µnew_line_offset = πTemp001
							µblank_finish = πTemp003
							// line 1275: self.goto_line(new_line_offset)
							πF.SetLineno(1275)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnew_line_offset, "new_line_offset"); πE != nil {
								continue
							}
							πTemp004[0] = µnew_line_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 1276: if not blank_finish:
							πF.SetLineno(1276)
						Label1:
							// line 1277: self.parent += self.unindent_warning('Bullet list')
							πF.SetLineno(1277)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("Bullet list").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 1278: return [], next_state, []
							πF.SetLineno(1278)
							πTemp004 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp004 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp004...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp003).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßbullet.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 1261: """Bullet list item."""
					πF.SetLineno(1261)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp012}, πg.NewStr("Bullet list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp013, πE = πg.ResolveClass(πF, πClass, nil, ßbullet); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp013, ß__doc__, πTemp012); πE != nil {
						continue
					}
					// line 1280: def list_item(self, indent):
					πF.SetLineno(1280)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "indent", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("list_item", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindent *πg.Object = πArgs[1]
						_ = µindent
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µline_offset *πg.Object = πg.UnboundLocal
						_ = µline_offset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µlistitem *πg.Object = πg.UnboundLocal
						_ = µlistitem
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µindent, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1281: if self.state_machine.line[indent:]:
							πF.SetLineno(1281)
						Label1:
							// line 1282: indented, line_offset, blank_finish = (
							πF.SetLineno(1282)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp006[0] = µindent
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µline_offset = πTemp003
							µblank_finish = πTemp004
							goto Label3
						Label2:
							// line 1285: indented, indent, line_offset, blank_finish = (
							πF.SetLineno(1285)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindent, "indent"); πE != nil {
								continue
							}
							πTemp006[0] = µindent
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp007}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µindent = πTemp003
							µline_offset = πTemp004
							µblank_finish = πTemp007
							goto Label3
						Label3:
							// line 1287: listitem = nodes.list_item('\n'.join(indented))
							πF.SetLineno(1287)
							πTemp006 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp008[0] = µindented
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp006[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßlist_item, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µlistitem = πTemp001
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µindented); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 1288: if indented:
							πF.SetLineno(1288)
						Label4:
							// line 1289: self.nested_parse(indented, input_offset=line_offset,
							πF.SetLineno(1289)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp006[0] = µindented
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlistitem, "listitem"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"input_offset", µline_offset},
								{"node", µlistitem},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							goto Label5
						Label5:
							// line 1291: return listitem, blank_finish
							πF.SetLineno(1291)
							if πE = πg.CheckLocal(πF, µlistitem, "listitem"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µlistitem, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßlist_item.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 1293: def enumerator(self, match, context, next_state):
					πF.SetLineno(1293)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp013 = πg.NewFunction(πg.NewCode("enumerator", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µformat *πg.Object = πg.UnboundLocal
						_ = µformat
						var µsequence *πg.Object = πg.UnboundLocal
						_ = µsequence
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µordinal *πg.Object = πg.UnboundLocal
						_ = µordinal
						var µenumlist *πg.Object = πg.UnboundLocal
						_ = µenumlist
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var µlistitem *πg.Object = πg.UnboundLocal
						_ = µlistitem
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µnewline_offset *πg.Object = πg.UnboundLocal
						_ = µnewline_offset
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Dict
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1294: """Enumerated List Item"""
							πF.SetLineno(1294)
							// line 1295: format, sequence, text, ordinal = self.parse_enumerator(match)
							πF.SetLineno(1295)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparse_enumerator, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp003); πE != nil {
								continue
							}
							µformat = πTemp002
							µsequence = πTemp004
							µtext = πTemp005
							µordinal = πTemp006
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							πTemp001[0] = µordinal
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							πTemp001[1] = µsequence
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp001[2] = µformat
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßis_enumerated_list_item, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 1296: if not self.is_enumerated_list_item(ordinal, sequence, format):
							πF.SetLineno(1296)
						Label1:
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßtext.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßstatemachine); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßTransitionCorrection, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1297: raise statemachine.TransitionCorrection('text')
							πF.SetLineno(1297)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							goto Label2
						Label2:
							// line 1298: enumlist = nodes.enumerated_list()
							πF.SetLineno(1298)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßenumerated_list, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µenumlist = πTemp002
							// line 1299: self.parent += enumlist
							πF.SetLineno(1299)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µenumlist, "enumlist"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µenumlist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µsequence, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label3
							}
							goto Label4
							// line 1300: if sequence == '#':
							πF.SetLineno(1300)
						Label3:
							// line 1301: enumlist['enumtype'] = 'arabic'
							πF.SetLineno(1301)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, ßarabic.ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µenumlist, "enumlist"); πE != nil {
								continue
							}
							πTemp003 = ßenumtype.ToObject()
							if πE = πg.SetItem(πF, µenumlist, πTemp003, πTemp002); πE != nil {
								continue
							}
							goto Label5
						Label4:
							// line 1303: enumlist['enumtype'] = sequence
							πF.SetLineno(1303)
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µsequence); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µenumlist, "enumlist"); πE != nil {
								continue
							}
							πTemp003 = ßenumtype.ToObject()
							if πE = πg.SetItem(πF, µenumlist, πTemp003, πTemp002); πE != nil {
								continue
							}
							goto Label5
						Label5:
							// line 1304: enumlist['prefix'] = self.enum.formatinfo[format].prefix
							πF.SetLineno(1304)
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp002 = µformat
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßformatinfo, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßprefix, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µenumlist, "enumlist"); πE != nil {
								continue
							}
							πTemp004 = ßprefix.ToObject()
							if πE = πg.SetItem(πF, µenumlist, πTemp004, πTemp003); πE != nil {
								continue
							}
							// line 1305: enumlist['suffix'] = self.enum.formatinfo[format].suffix
							πF.SetLineno(1305)
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp002 = µformat
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßformatinfo, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsuffix, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µenumlist, "enumlist"); πE != nil {
								continue
							}
							πTemp004 = ßsuffix.ToObject()
							if πE = πg.SetItem(πF, µenumlist, πTemp004, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.NE(πF, µordinal, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label6
							}
							goto Label7
							// line 1306: if ordinal != 1:
							πF.SetLineno(1306)
						Label6:
							// line 1307: enumlist['start'] = ordinal
							πF.SetLineno(1307)
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µordinal); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µenumlist, "enumlist"); πE != nil {
								continue
							}
							πTemp003 = ßstart.ToObject()
							if πE = πg.SetItem(πF, µenumlist, πTemp003, πTemp002); πE != nil {
								continue
							}
							// line 1308: msg = self.reporter.info(
							πF.SetLineno(1308)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							πTemp003 = πg.NewTuple2(µtext, µordinal).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("Enumerated list start value not ordinal-1: \"%s\" (ordinal %s)").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßinfo, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp002
							// line 1311: self.parent += msg
							πF.SetLineno(1311)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							goto Label7
						Label7:
							// line 1312: listitem, blank_finish = self.list_item(match.end())
							πF.SetLineno(1312)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßlist_item, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µlistitem = πTemp002
							µblank_finish = πTemp004
							// line 1313: enumlist += listitem
							πF.SetLineno(1313)
							if πE = πg.CheckLocal(πF, µenumlist, "enumlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlistitem, "listitem"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µenumlist, µlistitem); πE != nil {
								continue
							}
							µenumlist = πTemp002
							// line 1314: offset = self.state_machine.line_offset + 1   # next line
							πF.SetLineno(1314)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp002
							// line 1315: newline_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(1315)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µenumlist, "enumlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp008 = πg.NewDict()
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							if πE = πTemp008.SetItem(πF, ßlastordinal.ToObject(), µordinal); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							if πE = πTemp008.SetItem(πF, ßformat.ToObject(), µformat); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, µsequence, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							if πE = πTemp008.SetItem(πF, ßauto.ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp003 = πTemp008.ToObject()
							πTemp009 = πg.KWArgs{
								{"input_offset", πTemp002},
								{"node", µenumlist},
								{"initial_state", ßEnumeratedList.ToObject()},
								{"blank_finish", µblank_finish},
								{"extra_settings", πTemp003},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µnewline_offset = πTemp002
							µblank_finish = πTemp004
							// line 1323: self.goto_line(newline_offset)
							πF.SetLineno(1323)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnewline_offset, "newline_offset"); πE != nil {
								continue
							}
							πTemp001[0] = µnewline_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label8
							}
							goto Label9
							// line 1324: if not blank_finish:
							πF.SetLineno(1324)
						Label8:
							// line 1325: self.parent += self.unindent_warning('Enumerated list')
							πF.SetLineno(1325)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Enumerated list").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.IAdd(πF, πTemp002, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							goto Label9
						Label9:
							// line 1326: return [], next_state, []
							πF.SetLineno(1326)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßenumerator.ToObject(), πTemp013); πE != nil {
						continue
					}
					// line 1294: """Enumerated List Item"""
					πF.SetLineno(1294)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp014}, πg.NewStr("Enumerated List Item").ToObject()); πE != nil {
						continue
					}
					if πTemp015, πE = πg.ResolveClass(πF, πClass, nil, ßenumerator); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp015, ß__doc__, πTemp014); πE != nil {
						continue
					}
					// line 1328: def parse_enumerator(self, match, expected_sequence=None):
					πF.SetLineno(1328)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					if πTemp015, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp016[2] = πg.Param{Name: "expected_sequence", Def: πTemp015}
					πTemp014 = πg.NewFunction(πg.NewCode("parse_enumerator", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µexpected_sequence *πg.Object = πArgs[2]
						_ = µexpected_sequence
						var µgroupdict *πg.Object = πg.UnboundLocal
						_ = µgroupdict
						var µsequence *πg.Object = πg.UnboundLocal
						_ = µsequence
						var µformat *πg.Object = πg.UnboundLocal
						_ = µformat
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µordinal *πg.Object = πg.UnboundLocal
						_ = µordinal
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.BaseException
						_ = πTemp010
						var πTemp011 *πg.Traceback
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							case 12:
								goto Label12
							case 18:
								goto Label18
							case 19:
								goto Label19
							case 27:
								goto Label27
							default:
								panic("unexpected function state")
							}
							// line 1329: """
							πF.SetLineno(1329)
							// line 1346: groupdict = match.groupdict()
							πF.SetLineno(1346)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßgroupdict, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µgroupdict = πTemp002
							// line 1347: sequence = ''
							πF.SetLineno(1347)
							µsequence = ß.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßformats, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µformat = πTemp002
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp002 = µformat
							if πE = πg.CheckLocal(πF, µgroupdict, "groupdict"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µgroupdict, πTemp002); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 1349: if groupdict[format]:       # was this the format matched?
							πF.SetLineno(1349)
						Label4:
							// line 1350: break                   # yes; keep `format`
							πF.SetLineno(1350)
							πTemp004 = true
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("enumerator format not matched").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßParserError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 1352: raise ParserError('enumerator format not matched')
							πF.SetLineno(1352)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
						Label3:
							// line 1353: text = groupdict[format][self.enum.formatinfo[format].start
							πF.SetLineno(1353)
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp002 = µformat
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßformatinfo, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp008, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßstart, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp003 = µformat
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetAttr(πF, πTemp008, ßformatinfo, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, πTemp009, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp007, ßend, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp002, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp003 = µformat
							if πE = πg.CheckLocal(πF, µgroupdict, "groupdict"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µgroupdict, πTemp003); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp007, πTemp001); πE != nil {
								continue
							}
							µtext = πTemp002
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µtext, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							if πE = πg.CheckLocal(πF, µexpected_sequence, "expected_sequence"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µexpected_sequence); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label7
							}
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µtext, ßi.ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µtext, ßI.ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label9
							}
							goto Label10
							// line 1355: if text == '#':
							πF.SetLineno(1355)
						Label6:
							// line 1356: sequence = '#'
							πF.SetLineno(1356)
							µsequence = πg.NewStr("#").ToObject()
							goto Label10
							// line 1357: elif expected_sequence:
							πF.SetLineno(1357)
						Label7:
							// line 1358: try:
							πF.SetLineno(1358)
							πF.PushCheckpoint(12)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp006[0] = µtext
							if πE = πg.CheckLocal(πF, µexpected_sequence, "expected_sequence"); πE != nil {
								continue
							}
							πTemp001 = µexpected_sequence
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßsequenceregexps, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp007, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label13
							}
							goto Label14
							// line 1359: if self.enum.sequenceregexps[expected_sequence].match(text):
							πF.SetLineno(1359)
						Label13:
							// line 1360: sequence = expected_sequence
							πF.SetLineno(1360)
							if πE = πg.CheckLocal(πF, µexpected_sequence, "expected_sequence"); πE != nil {
								continue
							}
							µsequence = µexpected_sequence
							goto Label14
						Label14:
							πF.PopCheckpoint()
							goto Label11
						Label12:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp010, πTemp011 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßKeyError); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsInstance(πF, πTemp010.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label15
							}
							πE = πF.Raise(πTemp010.ToObject(), nil, πTemp011.ToObject())
							continue
							// line 1361: except KeyError:            # shouldn't happen
							πF.SetLineno(1361)
						Label15:
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("unknown enumerator sequence: %s").ToObject(), µsequence); πE != nil {
								continue
							}
							πTemp006[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßParserError); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 1362: raise ParserError('unknown enumerator sequence: %s'
							πF.SetLineno(1362)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							πF.RestoreExc(nil, nil)
							goto Label11
						Label11:
							goto Label10
							// line 1364: elif text == 'i':
							πF.SetLineno(1364)
						Label8:
							// line 1365: sequence = 'lowerroman'
							πF.SetLineno(1365)
							µsequence = ßlowerroman.ToObject()
							goto Label10
							// line 1366: elif text == 'I':
							πF.SetLineno(1366)
						Label9:
							// line 1367: sequence = 'upperroman'
							πF.SetLineno(1367)
							µsequence = ßupperroman.ToObject()
							goto Label10
						Label10:
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µsequence); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label16
							}
							goto Label17
							// line 1368: if not sequence:
							πF.SetLineno(1368)
						Label16:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsequences, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(19)
							πTemp004 = false
						Label18:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label20
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µsequence = πTemp002
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(18)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp006[0] = µtext
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							πTemp002 = µsequence
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßsequenceregexps, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp008, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label21
							}
							goto Label22
							// line 1370: if self.enum.sequenceregexps[sequence].match(text):
							πF.SetLineno(1370)
						Label21:
							// line 1371: break
							πF.SetLineno(1371)
							πTemp004 = true
							continue
							goto Label22
						Label22:
							continue
						Label19:
							if πE != nil || πR != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("enumerator sequence not matched").ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßParserError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 1373: raise ParserError('enumerator sequence not matched')
							πF.SetLineno(1373)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
						Label20:
							goto Label17
						Label17:
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µsequence, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label23
							}
							goto Label24
							// line 1374: if sequence == '#':
							πF.SetLineno(1374)
						Label23:
							// line 1375: ordinal = 1
							πF.SetLineno(1375)
							µordinal = πg.NewInt(1).ToObject()
							goto Label25
						Label24:
							// line 1377: try:
							πF.SetLineno(1377)
							πF.PushCheckpoint(27)
							// line 1378: ordinal = self.enum.converters[sequence](text)
							πF.SetLineno(1378)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp006[0] = µtext
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							πTemp001 = µsequence
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp003, ßconverters, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp007, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µordinal = πTemp001
							πF.PopCheckpoint()
							goto Label26
						Label27:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp010, πTemp011 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßroman); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßInvalidRomanNumeralError, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsInstance(πF, πTemp010.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label28
							}
							πE = πF.Raise(πTemp010.ToObject(), nil, πTemp011.ToObject())
							continue
							// line 1379: except roman.InvalidRomanNumeralError:
							πF.SetLineno(1379)
						Label28:
							// line 1380: ordinal = None
							πF.SetLineno(1380)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µordinal = πTemp001
							πF.RestoreExc(nil, nil)
							goto Label26
						Label26:
							goto Label25
						Label25:
							// line 1381: return format, sequence, text, ordinal
							πF.SetLineno(1381)
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple4(µformat, µsequence, µtext, µordinal).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_enumerator.ToObject(), πTemp014); πE != nil {
						continue
					}
					// line 1329: """
					πF.SetLineno(1329)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp015}, πg.NewStr("\n        Analyze an enumerator and return the results.\n\n        :Return:\n            - the enumerator format ('period', 'parens', or 'rparen'),\n            - the sequence used ('arabic', 'loweralpha', 'upperroman', etc.),\n            - the text of the enumerator, stripped of formatting, and\n            - the ordinal value of the enumerator ('a' -> 1, 'ii' -> 2, etc.;\n              ``None`` is returned for invalid enumerator text).\n\n        The enumerator format has already been determined by the regular\n        expression match. If `expected_sequence` is given, that sequence is\n        tried first. If not, we check for Roman numeral 1. This way,\n        single-character Roman numerals (which are also alphabetical) can be\n        matched. If no sequence has been matched, all sequences are checked in\n        order.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp017, πE = πg.ResolveClass(πF, πClass, nil, ßparse_enumerator); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp017, ß__doc__, πTemp015); πE != nil {
						continue
					}
					// line 1383: def is_enumerated_list_item(self, ordinal, sequence, format):
					πF.SetLineno(1383)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "ordinal", Def: nil}
					πTemp016[2] = πg.Param{Name: "sequence", Def: nil}
					πTemp016[3] = πg.Param{Name: "format", Def: nil}
					πTemp015 = πg.NewFunction(πg.NewCode("is_enumerated_list_item", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µordinal *πg.Object = πArgs[1]
						_ = µordinal
						var µsequence *πg.Object = πArgs[2]
						_ = µsequence
						var µformat *πg.Object = πArgs[3]
						_ = µformat
						var µnext_line *πg.Object = πg.UnboundLocal
						_ = µnext_line
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µnext_enumerator *πg.Object = πg.UnboundLocal
						_ = µnext_enumerator
						var µauto_enumerator *πg.Object = πg.UnboundLocal
						_ = µauto_enumerator
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.BaseException
						_ = πTemp004
						var πTemp005 *πg.Traceback
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 11:
								goto Label11
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 1384: """
							πF.SetLineno(1384)
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(µordinal == πTemp002).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							goto Label2
							// line 1390: if ordinal is None:
							πF.SetLineno(1390)
						Label1:
							// line 1391: return None
							πF.SetLineno(1391)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 1392: try:
							πF.SetLineno(1392)
							πF.PushCheckpoint(4)
							// line 1393: next_line = self.state_machine.next_line()
							πF.SetLineno(1393)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnext_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µnext_line = πTemp001
							πF.PopCheckpoint()
							// line 1398: self.state_machine.previous_line()
							πF.SetLineno(1398)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label3
						Label4:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp004, πTemp005 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsInstance(πF, πTemp004.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label5
							}
							πE = πF.Raise(πTemp004.ToObject(), nil, πTemp005.ToObject())
							continue
							// line 1394: except EOFError:              # end of input lines
							πF.SetLineno(1394)
						Label5:
							// line 1395: self.state_machine.previous_line()
							πF.SetLineno(1395)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 1396: return 1
							πF.SetLineno(1396)
							πR = πg.NewInt(1).ToObject()
							continue
							πF.RestoreExc(nil, nil)
							goto Label3
						Label3:
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.NewInt(1).ToObject(), πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnext_line, "next_line"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µnext_line, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp006, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp003).ToObject()
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label6
							}
							goto Label7
							// line 1399: if not next_line[:1].strip():   # blank or indented
							πF.SetLineno(1399)
						Label6:
							// line 1400: return 1
							πF.SetLineno(1400)
							πR = πg.NewInt(1).ToObject()
							continue
							goto Label7
						Label7:
							// line 1401: result = self.make_enumerator(ordinal + 1, sequence, format)
							πF.SetLineno(1401)
							πTemp007 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µordinal, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							πTemp007[1] = µsequence
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp007[2] = µformat
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmake_enumerator, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							µresult = πTemp002
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, µresult); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label8
							}
							goto Label9
							// line 1402: if result:
							πF.SetLineno(1402)
						Label8:
							// line 1403: next_enumerator, auto_enumerator = result
							πF.SetLineno(1403)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp002}}}, µresult); πE != nil {
								continue
							}
							µnext_enumerator = πTemp001
							µauto_enumerator = πTemp002
							// line 1404: try:
							πF.SetLineno(1404)
							πF.PushCheckpoint(11)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnext_enumerator, "next_enumerator"); πE != nil {
								continue
							}
							πTemp007[0] = µnext_enumerator
							if πE = πg.CheckLocal(πF, µnext_line, "next_line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µnext_line, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001 = πTemp006
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label12
							}
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µauto_enumerator, "auto_enumerator"); πE != nil {
								continue
							}
							πTemp007[0] = µauto_enumerator
							if πE = πg.CheckLocal(πF, µnext_line, "next_line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µnext_line, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001 = πTemp006
						Label12:
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label13
							}
							goto Label14
							// line 1405: if ( next_line.startswith(next_enumerator) or
							πF.SetLineno(1405)
						Label13:
							// line 1407: return 1
							πF.SetLineno(1407)
							πR = πg.NewInt(1).ToObject()
							continue
							goto Label14
						Label14:
							πF.PopCheckpoint()
							goto Label10
						Label11:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp004, πTemp005 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTypeError); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsInstance(πF, πTemp004.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label15
							}
							πE = πF.Raise(πTemp004.ToObject(), nil, πTemp005.ToObject())
							continue
							// line 1408: except TypeError:
							πF.SetLineno(1408)
						Label15:
							// line 1409: pass
							πF.SetLineno(1409)
							πF.RestoreExc(nil, nil)
							goto Label10
						Label10:
							goto Label9
						Label9:
							// line 1410: return None
							πF.SetLineno(1410)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßis_enumerated_list_item.ToObject(), πTemp015); πE != nil {
						continue
					}
					// line 1384: """
					πF.SetLineno(1384)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp017}, πg.NewStr("\n        Check validity based on the ordinal value and the second line.\n\n        Return true if the ordinal is valid and the second line is blank,\n        indented, or starts with the next enumerator or an auto-enumerator.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp018, πE = πg.ResolveClass(πF, πClass, nil, ßis_enumerated_list_item); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp018, ß__doc__, πTemp017); πE != nil {
						continue
					}
					// line 1412: def make_enumerator(self, ordinal, sequence, format):
					πF.SetLineno(1412)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "ordinal", Def: nil}
					πTemp016[2] = πg.Param{Name: "sequence", Def: nil}
					πTemp016[3] = πg.Param{Name: "format", Def: nil}
					πTemp017 = πg.NewFunction(πg.NewCode("make_enumerator", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µordinal *πg.Object = πArgs[1]
						_ = µordinal
						var µsequence *πg.Object = πArgs[2]
						_ = µsequence
						var µformat *πg.Object = πArgs[3]
						_ = µformat
						var µenumerator *πg.Object = πg.UnboundLocal
						_ = µenumerator
						var µformatinfo *πg.Object = πg.UnboundLocal
						_ = µformatinfo
						var µnext_enumerator *πg.Object = πg.UnboundLocal
						_ = µnext_enumerator
						var µauto_enumerator *πg.Object = πg.UnboundLocal
						_ = µauto_enumerator
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.BaseException
						_ = πTemp008
						var πTemp009 *πg.Traceback
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 12:
								goto Label12
							default:
								panic("unexpected function state")
							}
							// line 1413: """
							πF.SetLineno(1413)
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µsequence, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µsequence, ßarabic.ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 1419: if sequence == '#':
							πF.SetLineno(1419)
						Label1:
							// line 1420: enumerator = '#'
							πF.SetLineno(1420)
							µenumerator = πg.NewStr("#").ToObject()
							goto Label4
							// line 1421: elif sequence == 'arabic':
							πF.SetLineno(1421)
						Label2:
							// line 1422: enumerator = str(ordinal)
							πF.SetLineno(1422)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							πTemp003[0] = µordinal
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µenumerator = πTemp004
							goto Label4
						Label3:
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßalpha.ToObject()
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µsequence, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label5
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßroman.ToObject()
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µsequence, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label6
							}
							goto Label7
							// line 1424: if sequence.endswith('alpha'):
							πF.SetLineno(1424)
						Label5:
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GT(πF, µordinal, πg.NewInt(26).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label9
							}
							goto Label10
							// line 1425: if ordinal > 26:
							πF.SetLineno(1425)
						Label9:
							// line 1426: return None
							πF.SetLineno(1426)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label10
						Label10:
							// line 1427: enumerator = chr(ordinal + ord('a') - 1)
							πF.SetLineno(1427)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = ßa.ToObject()
							if πTemp006, πE = πg.ResolveGlobal(πF, ßord); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp004, πE = πg.Add(πF, µordinal, πTemp007); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßchr); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µenumerator = πTemp004
							goto Label8
							// line 1428: elif sequence.endswith('roman'):
							πF.SetLineno(1428)
						Label6:
							// line 1429: try:
							πF.SetLineno(1429)
							πF.PushCheckpoint(12)
							// line 1430: enumerator = roman.toRoman(ordinal)
							πF.SetLineno(1430)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							πTemp003[0] = µordinal
							if πTemp001, πE = πg.ResolveGlobal(πF, ßroman); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßtoRoman, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µenumerator = πTemp001
							πF.PopCheckpoint()
							goto Label11
						Label12:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp008, πTemp009 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßroman); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßRomanError, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsInstance(πF, πTemp008.ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label13
							}
							πE = πF.Raise(πTemp008.ToObject(), nil, πTemp009.ToObject())
							continue
							// line 1431: except roman.RomanError:
							πF.SetLineno(1431)
						Label13:
							// line 1432: return None
							πF.SetLineno(1432)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							πF.RestoreExc(nil, nil)
							goto Label11
						Label11:
							goto Label8
						Label7:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("unknown enumerator sequence: \"%s\"").ToObject(), µsequence); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßParserError); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1434: raise ParserError('unknown enumerator sequence: "%s"'
							πF.SetLineno(1434)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
							goto Label8
						Label8:
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßlower.ToObject()
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µsequence, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label14
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßupper.ToObject()
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µsequence, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label15
							}
							goto Label16
							// line 1436: if sequence.startswith('lower'):
							πF.SetLineno(1436)
						Label14:
							// line 1437: enumerator = enumerator.lower()
							πF.SetLineno(1437)
							if πE = πg.CheckLocal(πF, µenumerator, "enumerator"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µenumerator, ßlower, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µenumerator = πTemp004
							goto Label17
							// line 1438: elif sequence.startswith('upper'):
							πF.SetLineno(1438)
						Label15:
							// line 1439: enumerator = enumerator.upper()
							πF.SetLineno(1439)
							if πE = πg.CheckLocal(πF, µenumerator, "enumerator"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µenumerator, ßupper, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µenumerator = πTemp004
							goto Label17
						Label16:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("unknown enumerator sequence: \"%s\"").ToObject(), µsequence); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßParserError); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1441: raise ParserError('unknown enumerator sequence: "%s"'
							πF.SetLineno(1441)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
							goto Label17
						Label17:
							goto Label4
						Label4:
							// line 1443: formatinfo = self.enum.formatinfo[format]
							πF.SetLineno(1443)
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp001 = µformat
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßenum, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßformatinfo, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp007, πTemp001); πE != nil {
								continue
							}
							µformatinfo = πTemp004
							// line 1444: next_enumerator = (formatinfo.prefix + enumerator + formatinfo.suffix
							πF.SetLineno(1444)
							if πE = πg.CheckLocal(πF, µformatinfo, "formatinfo"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µformatinfo, ßprefix, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µenumerator, "enumerator"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Add(πF, πTemp007, µenumerator); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µformatinfo, "formatinfo"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µformatinfo, ßsuffix, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp006, πTemp007); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewStr(" ").ToObject()); πE != nil {
								continue
							}
							µnext_enumerator = πTemp001
							// line 1446: auto_enumerator = formatinfo.prefix + '#' + formatinfo.suffix + ' '
							πF.SetLineno(1446)
							if πE = πg.CheckLocal(πF, µformatinfo, "formatinfo"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µformatinfo, ßprefix, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Add(πF, πTemp007, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µformatinfo, "formatinfo"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µformatinfo, ßsuffix, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp006, πTemp007); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewStr(" ").ToObject()); πE != nil {
								continue
							}
							µauto_enumerator = πTemp001
							// line 1447: return next_enumerator, auto_enumerator
							πF.SetLineno(1447)
							if πE = πg.CheckLocal(πF, µnext_enumerator, "next_enumerator"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µauto_enumerator, "auto_enumerator"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µnext_enumerator, µauto_enumerator).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßmake_enumerator.ToObject(), πTemp017); πE != nil {
						continue
					}
					// line 1413: """
					πF.SetLineno(1413)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp018}, πg.NewStr("\n        Construct and return the next enumerated list item marker, and an\n        auto-enumerator (\"#\" instead of the regular enumerator).\n\n        Return ``None`` for invalid (out of range) ordinals.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp019, πE = πg.ResolveClass(πF, πClass, nil, ßmake_enumerator); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp019, ß__doc__, πTemp018); πE != nil {
						continue
					}
					// line 1449: def field_marker(self, match, context, next_state):
					πF.SetLineno(1449)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp018 = πg.NewFunction(πg.NewCode("field_marker", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µfield_list *πg.Object = πg.UnboundLocal
						_ = µfield_list
						var µfield *πg.Object = πg.UnboundLocal
						_ = µfield
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µnewline_offset *πg.Object = πg.UnboundLocal
						_ = µnewline_offset
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1450: """Field list item."""
							πF.SetLineno(1450)
							// line 1451: field_list = nodes.field_list()
							πF.SetLineno(1451)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßfield_list, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µfield_list = πTemp001
							// line 1452: self.parent += field_list
							πF.SetLineno(1452)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield_list, "field_list"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µfield_list); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 1453: field, blank_finish = self.field(match)
							πF.SetLineno(1453)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp003[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßfield, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µfield = πTemp001
							µblank_finish = πTemp004
							// line 1454: field_list += field
							πF.SetLineno(1454)
							if πE = πg.CheckLocal(πF, µfield_list, "field_list"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield, "field"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µfield_list, µfield); πE != nil {
								continue
							}
							µfield_list = πTemp001
							// line 1455: offset = self.state_machine.line_offset + 1   # next line
							πF.SetLineno(1455)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp001
							// line 1456: newline_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(1456)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield_list, "field_list"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"input_offset", πTemp001},
								{"node", µfield_list},
								{"initial_state", ßFieldList.ToObject()},
								{"blank_finish", µblank_finish},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µnewline_offset = πTemp001
							µblank_finish = πTemp004
							// line 1461: self.goto_line(newline_offset)
							πF.SetLineno(1461)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnewline_offset, "newline_offset"); πE != nil {
								continue
							}
							πTemp003[0] = µnewline_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 1462: if not blank_finish:
							πF.SetLineno(1462)
						Label1:
							// line 1463: self.parent += self.unindent_warning('Field list')
							πF.SetLineno(1463)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("Field list").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 1464: return [], next_state, []
							πF.SetLineno(1464)
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfield_marker.ToObject(), πTemp018); πE != nil {
						continue
					}
					// line 1450: """Field list item."""
					πF.SetLineno(1450)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp019}, πg.NewStr("Field list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp020, πE = πg.ResolveClass(πF, πClass, nil, ßfield_marker); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp020, ß__doc__, πTemp019); πE != nil {
						continue
					}
					// line 1466: def field(self, match):
					πF.SetLineno(1466)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp019 = πg.NewFunction(πg.NewCode("field", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var µsrc *πg.Object = πg.UnboundLocal
						_ = µsrc
						var µsrcline *πg.Object = πg.UnboundLocal
						_ = µsrcline
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µline_offset *πg.Object = πg.UnboundLocal
						_ = µline_offset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µfield_node *πg.Object = πg.UnboundLocal
						_ = µfield_node
						var µname_nodes *πg.Object = πg.UnboundLocal
						_ = µname_nodes
						var µname_messages *πg.Object = πg.UnboundLocal
						_ = µname_messages
						var µfield_body *πg.Object = πg.UnboundLocal
						_ = µfield_body
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1467: name = self.parse_field_marker(match)
							πF.SetLineno(1467)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparse_field_marker, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µname = πTemp003
							// line 1468: src, srcline = self.state_machine.get_source_and_line()
							πF.SetLineno(1468)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µsrc = πTemp003
							µsrcline = πTemp004
							// line 1469: lineno = self.state_machine.abs_line_number()
							πF.SetLineno(1469)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlineno = πTemp002
							// line 1470: indented, indent, line_offset, blank_finish = \
							πF.SetLineno(1470)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp002); πE != nil {
								continue
							}
							µindented = πTemp003
							µindent = πTemp004
							µline_offset = πTemp005
							µblank_finish = πTemp006
							// line 1472: field_node = nodes.field()
							πF.SetLineno(1472)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßfield, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µfield_node = πTemp002
							// line 1473: field_node.source = src
							πF.SetLineno(1473)
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µsrc); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield_node, "field_node"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µfield_node, ßsource, πTemp002); πE != nil {
								continue
							}
							// line 1474: field_node.line = srcline
							πF.SetLineno(1474)
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µsrcline); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield_node, "field_node"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µfield_node, ßline, πTemp002); πE != nil {
								continue
							}
							// line 1475: name_nodes, name_messages = self.inline_text(name, lineno)
							πF.SetLineno(1475)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[0] = µname
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinline_text, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µname_nodes = πTemp002
							µname_messages = πTemp004
							// line 1476: field_node += nodes.field_name(name, '', *name_nodes)
							πF.SetLineno(1476)
							if πE = πg.CheckLocal(πF, µfield_node, "field_node"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp001[0] = µname
							πTemp001[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µname_nodes, "name_nodes"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßfield_name, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Invoke(πF, πTemp003, πTemp001, µname_nodes, nil, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.IAdd(πF, µfield_node, πTemp002); πE != nil {
								continue
							}
							µfield_node = πTemp003
							// line 1477: field_body = nodes.field_body('\n'.join(indented), *name_messages)
							πF.SetLineno(1477)
							πTemp001 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp007[0] = µindented
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µname_messages, "name_messages"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßfield_body, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Invoke(πF, πTemp003, πTemp001, µname_messages, nil, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µfield_body = πTemp002
							// line 1478: field_node += field_body
							πF.SetLineno(1478)
							if πE = πg.CheckLocal(πF, µfield_node, "field_node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield_body, "field_body"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µfield_node, µfield_body); πE != nil {
								continue
							}
							µfield_node = πTemp002
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, µindented); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label1
							}
							goto Label2
							// line 1479: if indented:
							πF.SetLineno(1479)
						Label1:
							// line 1480: self.parse_field_body(indented, line_offset, field_body)
							πF.SetLineno(1480)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001[0] = µindented
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							πTemp001[1] = µline_offset
							if πE = πg.CheckLocal(πF, µfield_body, "field_body"); πE != nil {
								continue
							}
							πTemp001[2] = µfield_body
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparse_field_body, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label2
						Label2:
							// line 1481: return field_node, blank_finish
							πF.SetLineno(1481)
							if πE = πg.CheckLocal(πF, µfield_node, "field_node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(µfield_node, µblank_finish).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfield.ToObject(), πTemp019); πE != nil {
						continue
					}
					// line 1483: def parse_field_marker(self, match):
					πF.SetLineno(1483)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp020 = πg.NewFunction(πg.NewCode("parse_field_marker", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µfield *πg.Object = πg.UnboundLocal
						_ = µfield
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1484: """Extract & return field name from a field marker match."""
							πF.SetLineno(1484)
							// line 1485: field = match.group()[1:]        # strip off leading ':'
							πF.SetLineno(1485)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µfield = πTemp002
							// line 1486: field = field[:field.rfind(':')] # strip off trailing ':' etc.
							πF.SetLineno(1486)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = πg.NewStr(":").ToObject()
							if πE = πg.CheckLocal(πF, µfield, "field"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µfield, ßrfind, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield, "field"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µfield, πTemp001); πE != nil {
								continue
							}
							µfield = πTemp002
							// line 1487: return field
							πF.SetLineno(1487)
							if πE = πg.CheckLocal(πF, µfield, "field"); πE != nil {
								continue
							}
							πR = µfield
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_field_marker.ToObject(), πTemp020); πE != nil {
						continue
					}
					// line 1484: """Extract & return field name from a field marker match."""
					πF.SetLineno(1484)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp021}, πg.NewStr("Extract & return field name from a field marker match.").ToObject()); πE != nil {
						continue
					}
					if πTemp022, πE = πg.ResolveClass(πF, πClass, nil, ßparse_field_marker); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp022, ß__doc__, πTemp021); πE != nil {
						continue
					}
					// line 1489: def parse_field_body(self, indented, offset, node):
					πF.SetLineno(1489)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "indented", Def: nil}
					πTemp016[2] = πg.Param{Name: "offset", Def: nil}
					πTemp016[3] = πg.Param{Name: "node", Def: nil}
					πTemp021 = πg.NewFunction(πg.NewCode("parse_field_body", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindented *πg.Object = πArgs[1]
						_ = µindented
						var µoffset *πg.Object = πArgs[2]
						_ = µoffset
						var µnode *πg.Object = πArgs[3]
						_ = µnode
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 πg.KWArgs
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1490: self.nested_parse(indented, input_offset=offset, node=node)
							πF.SetLineno(1490)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001[0] = µindented
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp002 = πg.KWArgs{
								{"input_offset", µoffset},
								{"node", µnode},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, πTemp002); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_field_body.ToObject(), πTemp021); πE != nil {
						continue
					}
					// line 1492: def option_marker(self, match, context, next_state):
					πF.SetLineno(1492)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp022 = πg.NewFunction(πg.NewCode("option_marker", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µoptionlist *πg.Object = πg.UnboundLocal
						_ = µoptionlist
						var µlistitem *πg.Object = πg.UnboundLocal
						_ = µlistitem
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µerror *πg.Object = πg.UnboundLocal
						_ = µerror
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µline_offset *πg.Object = πg.UnboundLocal
						_ = µline_offset
						var µelements *πg.Object = πg.UnboundLocal
						_ = µelements
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µnewline_offset *πg.Object = πg.UnboundLocal
						_ = µnewline_offset
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 πg.KWArgs
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1493: """Option list item."""
							πF.SetLineno(1493)
							// line 1494: optionlist = nodes.option_list()
							πF.SetLineno(1494)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßoption_list, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µoptionlist = πTemp001
							// line 1495: (optionlist.source, optionlist.line) = self.state_machine.get_source_and_line()
							πF.SetLineno(1495)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoptionlist, "optionlist"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µoptionlist, ßsource, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoptionlist, "optionlist"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µoptionlist, ßline, πTemp003); πE != nil {
								continue
							}
							// line 1496: try:
							πF.SetLineno(1496)
							πF.PushCheckpoint(2)
							// line 1497: listitem, blank_finish = self.option_list_item(match)
							πF.SetLineno(1497)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp004[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßoption_list_item, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µlistitem = πTemp001
							µblank_finish = πTemp003
							πF.PopCheckpoint()
							goto Label1
						Label2:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label3
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 1498: except MarkupError as error:
							πF.SetLineno(1498)
						Label3:
							µerror = πTemp005.ToObject()
							// line 1500: msg = self.reporter.error(u'Invalid option list marker: %s' %
							πF.SetLineno(1500)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µerror, "error"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewUnicode("Invalid option list marker: %s").ToObject(), µerror); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µmsg = πTemp001
							// line 1502: self.parent += msg
							πF.SetLineno(1502)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 1503: indented, indent, line_offset, blank_finish = \
							πF.SetLineno(1503)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp008}, πg.TieTarget{Target: &πTemp009}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µindent = πTemp003
							µline_offset = πTemp008
							µblank_finish = πTemp009
							// line 1505: elements = self.block_quote(indented, line_offset)
							πF.SetLineno(1505)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp004[0] = µindented
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							πTemp004[1] = µline_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßblock_quote, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µelements = πTemp002
							// line 1506: self.parent += elements
							πF.SetLineno(1506)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µelements, "elements"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µelements); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 1507: if not blank_finish:
							πF.SetLineno(1507)
						Label4:
							// line 1508: self.parent += self.unindent_warning('Option list')
							πF.SetLineno(1508)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("Option list").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label5
						Label5:
							// line 1509: return [], next_state, []
							πF.SetLineno(1509)
							πTemp004 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp004 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp004...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp003).ToObject()
							πR = πTemp001
							continue
							πF.RestoreExc(nil, nil)
							goto Label1
						Label1:
							// line 1510: self.parent += optionlist
							πF.SetLineno(1510)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoptionlist, "optionlist"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µoptionlist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 1511: optionlist += listitem
							πF.SetLineno(1511)
							if πE = πg.CheckLocal(πF, µoptionlist, "optionlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlistitem, "listitem"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µoptionlist, µlistitem); πE != nil {
								continue
							}
							µoptionlist = πTemp001
							// line 1512: offset = self.state_machine.line_offset + 1   # next line
							πF.SetLineno(1512)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp001
							// line 1513: newline_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(1513)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp003, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp008, πTemp001); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoptionlist, "optionlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp010 = πg.KWArgs{
								{"input_offset", πTemp001},
								{"node", µoptionlist},
								{"initial_state", ßOptionList.ToObject()},
								{"blank_finish", µblank_finish},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µnewline_offset = πTemp001
							µblank_finish = πTemp003
							// line 1518: self.goto_line(newline_offset)
							πF.SetLineno(1518)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnewline_offset, "newline_offset"); πE != nil {
								continue
							}
							πTemp004[0] = µnewline_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label6
							}
							goto Label7
							// line 1519: if not blank_finish:
							πF.SetLineno(1519)
						Label6:
							// line 1520: self.parent += self.unindent_warning('Option list')
							πF.SetLineno(1520)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("Option list").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label7
						Label7:
							// line 1521: return [], next_state, []
							πF.SetLineno(1521)
							πTemp004 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp004 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp004...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp003).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßoption_marker.ToObject(), πTemp022); πE != nil {
						continue
					}
					// line 1493: """Option list item."""
					πF.SetLineno(1493)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp023}, πg.NewStr("Option list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp024, πE = πg.ResolveClass(πF, πClass, nil, ßoption_marker); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp024, ß__doc__, πTemp023); πE != nil {
						continue
					}
					// line 1523: def option_list_item(self, match):
					πF.SetLineno(1523)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp023 = πg.NewFunction(πg.NewCode("option_list_item", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µoptions *πg.Object = πg.UnboundLocal
						_ = µoptions
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µline_offset *πg.Object = πg.UnboundLocal
						_ = µline_offset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µoption_group *πg.Object = πg.UnboundLocal
						_ = µoption_group
						var µdescription *πg.Object = πg.UnboundLocal
						_ = µdescription
						var µoption_list_item *πg.Object = πg.UnboundLocal
						_ = µoption_list_item
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1524: offset = self.state_machine.abs_line_offset()
							πF.SetLineno(1524)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µoffset = πTemp001
							// line 1525: options = self.parse_option_marker(match)
							πF.SetLineno(1525)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp003[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparse_option_marker, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µoptions = πTemp002
							// line 1526: indented, indent, line_offset, blank_finish = \
							πF.SetLineno(1526)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µindent = πTemp004
							µline_offset = πTemp005
							µblank_finish = πTemp006
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µindented); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 1528: if not indented:                # not an option list item
							πF.SetLineno(1528)
						Label1:
							// line 1529: self.goto_line(offset)
							πF.SetLineno(1529)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							πTemp003[0] = µoffset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßtext.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstatemachine); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßTransitionCorrection, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1530: raise statemachine.TransitionCorrection('text')
							πF.SetLineno(1530)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
							goto Label2
						Label2:
							// line 1531: option_group = nodes.option_group('', *options)
							πF.SetLineno(1531)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßoption_group, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Invoke(πF, πTemp002, πTemp003, µoptions, nil, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µoption_group = πTemp001
							// line 1532: description = nodes.description('\n'.join(indented))
							πF.SetLineno(1532)
							πTemp003 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp008[0] = µindented
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßdescription, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µdescription = πTemp001
							// line 1533: option_list_item = nodes.option_list_item('', option_group,
							πF.SetLineno(1533)
							πTemp003 = πF.MakeArgs(3)
							πTemp003[0] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µoption_group, "option_group"); πE != nil {
								continue
							}
							πTemp003[1] = µoption_group
							if πE = πg.CheckLocal(πF, µdescription, "description"); πE != nil {
								continue
							}
							πTemp003[2] = µdescription
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßoption_list_item, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µoption_list_item = πTemp001
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µindented); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label3
							}
							goto Label4
							// line 1535: if indented:
							πF.SetLineno(1535)
						Label3:
							// line 1536: self.nested_parse(indented, input_offset=line_offset,
							πF.SetLineno(1536)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp003[0] = µindented
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdescription, "description"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"input_offset", µline_offset},
								{"node", µdescription},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label4
						Label4:
							// line 1538: return option_list_item, blank_finish
							πF.SetLineno(1538)
							if πE = πg.CheckLocal(πF, µoption_list_item, "option_list_item"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µoption_list_item, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßoption_list_item.ToObject(), πTemp023); πE != nil {
						continue
					}
					// line 1540: def parse_option_marker(self, match):
					πF.SetLineno(1540)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp024 = πg.NewFunction(πg.NewCode("parse_option_marker", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µoptlist *πg.Object = πg.UnboundLocal
						_ = µoptlist
						var µoptionstrings *πg.Object = πg.UnboundLocal
						_ = µoptionstrings
						var µoptionstring *πg.Object = πg.UnboundLocal
						_ = µoptionstring
						var µtokens *πg.Object = πg.UnboundLocal
						_ = µtokens
						var µdelimiter *πg.Object = πg.UnboundLocal
						_ = µdelimiter
						var µfirstopt *πg.Object = πg.UnboundLocal
						_ = µfirstopt
						var µoption *πg.Object = πg.UnboundLocal
						_ = µoption
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πTemp011 *πg.Object
						_ = πTemp011
						var πTemp012 *πg.Object
						_ = πTemp012
						var πTemp013 bool
						_ = πTemp013
						var πTemp014 []*πg.Object
						_ = πTemp014
						var πTemp015 πg.KWArgs
						_ = πTemp015
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1541: """
							πF.SetLineno(1541)
							// line 1547: optlist = []
							πF.SetLineno(1547)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µoptlist = πTemp002
							// line 1548: optionstrings = match.group().rstrip().split(', ')
							πF.SetLineno(1548)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr(", ").ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µoptionstrings = πTemp003
							if πE = πg.CheckLocal(πF, µoptionstrings, "optionstrings"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, µoptionstrings); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp004 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp005 = !isStop
							} else {
								πTemp005 = true
								µoptionstring = πTemp003
							}
							if πE != nil || !πTemp005 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1550: tokens = optionstring.split()
							πF.SetLineno(1550)
							if πE = πg.CheckLocal(πF, µoptionstring, "optionstring"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µoptionstring, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtokens = πTemp006
							// line 1551: delimiter = ' '
							πF.SetLineno(1551)
							µdelimiter = πg.NewStr(" ").ToObject()
							// line 1552: firstopt = tokens[0].split('=', 1)
							πF.SetLineno(1552)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = πg.NewStr("=").ToObject()
							πTemp001[1] = πg.NewInt(1).ToObject()
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µtokens, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp006, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µfirstopt = πTemp006
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfirstopt, "firstopt"); πE != nil {
								continue
							}
							πTemp001[0] = µfirstopt
							if πTemp006, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.GT(πF, πTemp007, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp007 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µtokens, πTemp007); πE != nil {
								continue
							}
							πTemp001[0] = πTemp008
							if πTemp007, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp006, πE = πg.GT(πF, πTemp008, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp006
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label5
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("-").ToObject()
							πTemp008 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetItem(πF, µtokens, πTemp008); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp011, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp011, πE = πTemp008.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp007 = πTemp011
							if πTemp010, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							if !πTemp010 {
								goto Label7
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("--").ToObject()
							πTemp011 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetItem(πF, µtokens, πTemp011); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetAttr(πF, πTemp012, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp012, πE = πTemp011.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp013, πE = πg.IsTrue(πF, πTemp012); πE != nil {
								continue
							}
							πTemp008 = πg.GetBool(!πTemp013).ToObject()
							πTemp007 = πTemp008
						Label7:
							πTemp006 = πTemp007
							if πTemp009, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label6
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("+").ToObject()
							πTemp007 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µtokens, πTemp007); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp008, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp006 = πTemp008
						Label6:
							πTemp003 = πTemp006
						Label5:
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label8
							}
							goto Label9
							// line 1553: if len(firstopt) > 1:
							πF.SetLineno(1553)
						Label4:
							// line 1555: tokens[:1] = firstopt
							πF.SetLineno(1555)
							if πE = πg.CheckLocal(πF, µfirstopt, "firstopt"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µfirstopt); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.NewInt(1).ToObject(), πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.SetItem(πF, µtokens, πTemp006, πTemp003); πE != nil {
								continue
							}
							// line 1556: delimiter = '='
							πF.SetLineno(1556)
							µdelimiter = πg.NewStr("=").ToObject()
							goto Label9
							// line 1557: elif (len(tokens[0]) > 2
							πF.SetLineno(1557)
						Label8:
							// line 1562: tokens[:1] = [tokens[0][:2], tokens[0][2:]]
							πF.SetLineno(1562)
							πTemp001 = make([]*πg.Object, 2)
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.NewInt(2).ToObject(), πg.None}, nil); πE != nil {
								continue
							}
							πTemp007 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µtokens, πTemp007); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, πTemp008, πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp006
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(2).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							πTemp007 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µtokens, πTemp007); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, πTemp008, πTemp003); πE != nil {
								continue
							}
							πTemp001[1] = πTemp006
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.NewInt(1).ToObject(), πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.SetItem(πF, µtokens, πTemp007, πTemp006); πE != nil {
								continue
							}
							// line 1563: delimiter = ''
							πF.SetLineno(1563)
							µdelimiter = ß.ToObject()
							goto Label9
						Label9:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							πTemp001[0] = µtokens
							if πTemp007, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp006, πE = πg.GT(πF, πTemp008, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp006
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label10
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("<").ToObject()
							πTemp007 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µtokens, πTemp007); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp008, ßstartswith, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp006 = πTemp008
							if πTemp009, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							if !πTemp009 {
								goto Label11
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr(">").ToObject()
							if πTemp008, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp007 = πTemp008
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µtokens, πTemp007); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp008, ßendswith, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp006 = πTemp008
						Label11:
							πTemp003 = πTemp006
						Label10:
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label12
							}
							goto Label13
							// line 1564: if len(tokens) > 1 and (tokens[1].startswith('<')
							πF.SetLineno(1564)
						Label12:
							// line 1567: tokens[1:] = [' '.join(tokens[1:])]
							πF.SetLineno(1567)
							πTemp001 = make([]*πg.Object, 1)
							πTemp014 = πF.MakeArgs(1)
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µtokens, πTemp003); πE != nil {
								continue
							}
							πTemp014[0] = πTemp006
							if πTemp003, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp014, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp014)
							πTemp001[0] = πTemp006
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp006}, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.SetItem(πF, µtokens, πTemp007, πTemp006); πE != nil {
								continue
							}
							goto Label13
						Label13:
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							πTemp001[0] = µtokens
							if πTemp006, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.LT(πF, πg.NewInt(0).ToObject(), πTemp007); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label14
							}
							if πTemp003, πE = πg.LE(πF, πTemp007, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
						Label14:
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label15
							}
							goto Label16
							// line 1568: if 0 < len(tokens) <= 2:
							πF.SetLineno(1568)
						Label15:
							// line 1569: option = nodes.option(optionstring)
							πF.SetLineno(1569)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoptionstring, "optionstring"); πE != nil {
								continue
							}
							πTemp001[0] = µoptionstring
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßoption, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µoption = πTemp003
							// line 1570: option += nodes.option_string(tokens[0], tokens[0])
							πF.SetLineno(1570)
							if πE = πg.CheckLocal(πF, µoption, "option"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µtokens, πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp006
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µtokens, πTemp003); πE != nil {
								continue
							}
							πTemp001[1] = πTemp006
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßoption_string, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp006, πE = πg.IAdd(πF, µoption, πTemp003); πE != nil {
								continue
							}
							µoption = πTemp006
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							πTemp001[0] = µtokens
							if πTemp006, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.GT(πF, πTemp007, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label18
							}
							goto Label19
							// line 1571: if len(tokens) > 1:
							πF.SetLineno(1571)
						Label18:
							// line 1572: option += nodes.option_argument(tokens[1], tokens[1],
							πF.SetLineno(1572)
							if πE = πg.CheckLocal(πF, µoption, "option"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							πTemp003 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µtokens, πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp006
							πTemp003 = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µtokens, πTemp003); πE != nil {
								continue
							}
							πTemp001[1] = πTemp006
							if πE = πg.CheckLocal(πF, µdelimiter, "delimiter"); πE != nil {
								continue
							}
							πTemp015 = πg.KWArgs{
								{"delimiter", µdelimiter},
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp003, ßoption_argument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp006.Call(πF, πTemp001, πTemp015); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp006, πE = πg.IAdd(πF, µoption, πTemp003); πE != nil {
								continue
							}
							µoption = πTemp006
							goto Label19
						Label19:
							// line 1574: optlist.append(option)
							πF.SetLineno(1574)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoption, "option"); πE != nil {
								continue
							}
							πTemp001[0] = µoption
							if πE = πg.CheckLocal(πF, µoptlist, "optlist"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µoptlist, ßappend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label17
						Label16:
							πTemp001 = πF.MakeArgs(1)
							πTemp014 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtokens, "tokens"); πE != nil {
								continue
							}
							πTemp014[0] = µtokens
							if πTemp007, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp014, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp014)
							if πE = πg.CheckLocal(πF, µoptionstring, "optionstring"); πE != nil {
								continue
							}
							πTemp006 = πg.NewTuple2(πTemp008, µoptionstring).ToObject()
							if πTemp003, πE = πg.Mod(πF, πg.NewStr("wrong number of option tokens (=%s), should be 1 or 2: \"%s\"").ToObject(), πTemp006); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1576: raise MarkupError(
							πF.SetLineno(1576)
							πE = πF.Raise(πTemp006, nil, nil)
							continue
							goto Label17
						Label17:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1579: return optlist
							πF.SetLineno(1579)
							if πE = πg.CheckLocal(πF, µoptlist, "optlist"); πE != nil {
								continue
							}
							πR = µoptlist
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_option_marker.ToObject(), πTemp024); πE != nil {
						continue
					}
					// line 1541: """
					πF.SetLineno(1541)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp025}, πg.NewStr("\n        Return a list of `node.option` and `node.option_argument` objects,\n        parsed from an option marker match.\n\n        :Exception: `MarkupError` for invalid option markers.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp026, πE = πg.ResolveClass(πF, πClass, nil, ßparse_option_marker); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp026, ß__doc__, πTemp025); πE != nil {
						continue
					}
					// line 1581: def doctest(self, match, context, next_state):
					πF.SetLineno(1581)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp025 = πg.NewFunction(πg.NewCode("doctest", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µdata *πg.Object = πg.UnboundLocal
						_ = µdata
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1582: data = '\n'.join(self.state_machine.get_text_block())
							πF.SetLineno(1582)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_text_block, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µdata = πTemp003
							// line 1586: self.parent += nodes.doctest_block(data, data)
							πF.SetLineno(1586)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp001[0] = µdata
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp001[1] = µdata
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßdoctest_block, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IAdd(πF, πTemp002, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp004); πE != nil {
								continue
							}
							// line 1587: return [], next_state, []
							πF.SetLineno(1587)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdoctest.ToObject(), πTemp025); πE != nil {
						continue
					}
					// line 1589: def line_block(self, match, context, next_state):
					πF.SetLineno(1589)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp026 = πg.NewFunction(πg.NewCode("line_block", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µblock *πg.Object = πg.UnboundLocal
						_ = µblock
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µnew_line_offset *πg.Object = πg.UnboundLocal
						_ = µnew_line_offset
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 πg.KWArgs
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1590: """First line of a line block."""
							πF.SetLineno(1590)
							// line 1591: block = nodes.line_block()
							πF.SetLineno(1591)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßline_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µblock = πTemp001
							// line 1592: self.parent += block
							πF.SetLineno(1592)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µblock); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 1593: lineno = self.state_machine.abs_line_number()
							πF.SetLineno(1593)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 1594: line, messages, blank_finish = self.line_block_line(match, lineno)
							πF.SetLineno(1594)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp003[0] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßline_block_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp002); πE != nil {
								continue
							}
							µline = πTemp001
							µmessages = πTemp004
							µblank_finish = πTemp005
							// line 1595: block += line
							πF.SetLineno(1595)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µblock, µline); πE != nil {
								continue
							}
							µblock = πTemp001
							// line 1596: self.parent += messages
							πF.SetLineno(1596)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmessages); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 1597: if not blank_finish:
							πF.SetLineno(1597)
						Label1:
							// line 1598: offset = self.state_machine.line_offset + 1   # next line
							πF.SetLineno(1598)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp001
							// line 1599: new_line_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(1599)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"input_offset", πTemp001},
								{"node", µblock},
								{"initial_state", ßLineBlock.ToObject()},
								{"blank_finish", πg.NewInt(0).ToObject()},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µnew_line_offset = πTemp001
							µblank_finish = πTemp004
							// line 1604: self.goto_line(new_line_offset)
							πF.SetLineno(1604)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnew_line_offset, "new_line_offset"); πE != nil {
								continue
							}
							πTemp003[0] = µnew_line_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label3
							}
							goto Label4
							// line 1605: if not blank_finish:
							πF.SetLineno(1605)
						Label3:
							// line 1606: self.parent += self.reporter.warning(
							πF.SetLineno(1606)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("Line block ends without a blank line.").ToObject()
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µlineno, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"line", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp004, πE = πg.IAdd(πF, πTemp001, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp004); πE != nil {
								continue
							}
							goto Label4
						Label4:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003[0] = µblock
							if πTemp001, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label5
							}
							goto Label6
							// line 1609: if len(block):
							πF.SetLineno(1609)
						Label5:
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µblock, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp004, ßindent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(πTemp002 == πTemp004).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label7
							}
							goto Label8
							// line 1610: if block[0].indent is None:
							πF.SetLineno(1610)
						Label7:
							// line 1611: block[0].indent = 0
							πF.SetLineno(1611)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µblock, πTemp002); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßindent, πTemp001); πE != nil {
								continue
							}
							goto Label8
						Label8:
							// line 1612: self.nest_line_block_lines(block)
							πF.SetLineno(1612)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003[0] = µblock
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnest_line_block_lines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label6
						Label6:
							// line 1613: return [], next_state, []
							πF.SetLineno(1613)
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßline_block.ToObject(), πTemp026); πE != nil {
						continue
					}
					// line 1590: """First line of a line block."""
					πF.SetLineno(1590)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp027}, πg.NewStr("First line of a line block.").ToObject()); πE != nil {
						continue
					}
					if πTemp028, πE = πg.ResolveClass(πF, πClass, nil, ßline_block); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp028, ß__doc__, πTemp027); πE != nil {
						continue
					}
					// line 1615: def line_block_line(self, match, lineno):
					πF.SetLineno(1615)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp027 = πg.NewFunction(πg.NewCode("line_block_line", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µline_offset *πg.Object = πg.UnboundLocal
						_ = µline_offset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µtext_nodes *πg.Object = πg.UnboundLocal
						_ = µtext_nodes
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1616: """Return one line element of a line_block."""
							πF.SetLineno(1616)
							// line 1617: indented, indent, line_offset, blank_finish = \
							πF.SetLineno(1617)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"until_blank", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp002); πE != nil {
								continue
							}
							µindented = πTemp003
							µindent = πTemp005
							µline_offset = πTemp006
							µblank_finish = πTemp007
							// line 1620: text = u'\n'.join(indented)
							πF.SetLineno(1620)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001[0] = µindented
							if πTemp002, πE = πg.GetAttr(πF, πg.NewUnicode("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtext = πTemp003
							// line 1621: text_nodes, messages = self.inline_text(text, lineno)
							πF.SetLineno(1621)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinline_text, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}}}, πTemp003); πE != nil {
								continue
							}
							µtext_nodes = πTemp002
							µmessages = πTemp005
							// line 1622: line = nodes.line(text, '', *text_nodes)
							πF.SetLineno(1622)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							πTemp001[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µtext_nodes, "text_nodes"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Invoke(πF, πTemp003, πTemp001, µtext_nodes, nil, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µline = πTemp002
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.NE(πF, πTemp003, πg.NewStr("|").ToObject()); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label1
							}
							goto Label2
							// line 1623: if match.string.rstrip() != '|': # not empty
							πF.SetLineno(1623)
						Label1:
							// line 1624: line.indent = len(match.group(1)) - 1
							πF.SetLineno(1624)
							πTemp001 = πF.MakeArgs(1)
							πTemp009 = πF.MakeArgs(1)
							πTemp009[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							πTemp001[0] = πTemp005
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Sub(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µline, ßindent, πTemp003); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 1625: return line, messages, blank_finish
							πF.SetLineno(1625)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple3(µline, µmessages, µblank_finish).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßline_block_line.ToObject(), πTemp027); πE != nil {
						continue
					}
					// line 1616: """Return one line element of a line_block."""
					πF.SetLineno(1616)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp028}, πg.NewStr("Return one line element of a line_block.").ToObject()); πE != nil {
						continue
					}
					if πTemp029, πE = πg.ResolveClass(πF, πClass, nil, ßline_block_line); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp029, ß__doc__, πTemp028); πE != nil {
						continue
					}
					// line 1627: def nest_line_block_lines(self, block):
					πF.SetLineno(1627)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "block", Def: nil}
					πTemp028 = πg.NewFunction(πg.NewCode("nest_line_block_lines", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µblock *πg.Object = πArgs[1]
						_ = µblock
						var µindex *πg.Object = πg.UnboundLocal
						_ = µindex
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							πTemp002 = πF.MakeArgs(2)
							πTemp002[0] = πg.NewInt(1).ToObject()
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003[0] = µblock
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp002[1] = πTemp005
							if πTemp004, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp005); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µindex = πTemp004
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp002 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp005 = µindex
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µblock, πTemp005); πE != nil {
								continue
							}
							πTemp002[0] = πTemp008
							πTemp002[1] = ßindent.ToObject()
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002[2] = πTemp005
							if πTemp005, πE = πg.ResolveGlobal(πF, ßgetattr); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp005.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(πTemp008 == πTemp005).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 1629: if getattr(block[index], 'indent', None) is None:
							πF.SetLineno(1629)
						Label4:
							// line 1630: block[index].indent = block[index - 1].indent
							πF.SetLineno(1630)
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Sub(πF, µindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp004 = πTemp005
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µblock, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ßindent, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindex, "index"); πE != nil {
								continue
							}
							πTemp008 = µindex
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetItem(πF, µblock, πTemp008); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp009, ßindent, πTemp005); πE != nil {
								continue
							}
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1631: self.nest_line_block_segment(block)
							πF.SetLineno(1631)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp002[0] = µblock
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnest_line_block_segment, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßnest_line_block_lines.ToObject(), πTemp028); πE != nil {
						continue
					}
					// line 1633: def nest_line_block_segment(self, block):
					πF.SetLineno(1633)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "block", Def: nil}
					πTemp029 = πg.NewFunction(πg.NewCode("nest_line_block_segment", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µblock *πg.Object = πArgs[1]
						_ = µblock
						var µindents *πg.Object = πg.UnboundLocal
						_ = µindents
						var µleast *πg.Object = πg.UnboundLocal
						_ = µleast
						var µnew_items *πg.Object = πg.UnboundLocal
						_ = µnew_items
						var µnew_block *πg.Object = πg.UnboundLocal
						_ = µnew_block
						var µitem *πg.Object = πg.UnboundLocal
						_ = µitem
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []πg.Param
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1634: indents = [item.indent for item in block]
							πF.SetLineno(1634)
							πTemp003 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µitem *πg.Object = πg.UnboundLocal
								_ = µitem
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µblock); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µitem = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 1634: indents = [item.indent for item in block]
										πF.SetLineno(1634)
										if πE = πg.CheckLocal(πF, µitem, "item"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GetAttr(πF, µitem, ßindent, nil); πE != nil {
											continue
										}
										πF.PushCheckpoint(4)
										return πTemp004, nil
									Label4:
										πTemp005 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
								continue
							}
							µindents = πTemp001
							// line 1635: least = min(indents)
							πF.SetLineno(1635)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindents, "indents"); πE != nil {
								continue
							}
							πTemp005[0] = µindents
							if πTemp001, πE = πg.ResolveGlobal(πF, ßmin); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µleast = πTemp004
							// line 1636: new_items = []
							πF.SetLineno(1636)
							πTemp005 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							µnew_items = πTemp001
							// line 1637: new_block = nodes.line_block()
							πF.SetLineno(1637)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp001, ßline_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							µnew_block = πTemp001
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µblock); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µitem = πTemp004
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µitem, "item"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, µitem, ßindent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µleast, "least"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GT(πF, πTemp008, µleast); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 1639: if item.indent > least:
							πF.SetLineno(1639)
						Label4:
							// line 1640: new_block.append(item)
							πF.SetLineno(1640)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µitem, "item"); πE != nil {
								continue
							}
							πTemp005[0] = µitem
							if πE = πg.CheckLocal(πF, µnew_block, "new_block"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µnew_block, ßappend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label6
						Label5:
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnew_block, "new_block"); πE != nil {
								continue
							}
							πTemp005[0] = µnew_block
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp007, πE = πg.IsTrue(πF, πTemp008); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label7
							}
							goto Label8
							// line 1642: if len(new_block):
							πF.SetLineno(1642)
						Label7:
							// line 1643: self.nest_line_block_segment(new_block)
							πF.SetLineno(1643)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnew_block, "new_block"); πE != nil {
								continue
							}
							πTemp005[0] = µnew_block
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßnest_line_block_segment, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 1644: new_items.append(new_block)
							πF.SetLineno(1644)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnew_block, "new_block"); πE != nil {
								continue
							}
							πTemp005[0] = µnew_block
							if πE = πg.CheckLocal(πF, µnew_items, "new_items"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µnew_items, ßappend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 1645: new_block = nodes.line_block()
							πF.SetLineno(1645)
							if πTemp004, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp004, ßline_block, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp008.Call(πF, nil, nil); πE != nil {
								continue
							}
							µnew_block = πTemp004
							goto Label8
						Label8:
							// line 1646: new_items.append(item)
							πF.SetLineno(1646)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µitem, "item"); πE != nil {
								continue
							}
							πTemp005[0] = µitem
							if πE = πg.CheckLocal(πF, µnew_items, "new_items"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µnew_items, ßappend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnew_block, "new_block"); πE != nil {
								continue
							}
							πTemp005[0] = µnew_block
							if πTemp001, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp006, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label9
							}
							goto Label10
							// line 1647: if len(new_block):
							πF.SetLineno(1647)
						Label9:
							// line 1648: self.nest_line_block_segment(new_block)
							πF.SetLineno(1648)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnew_block, "new_block"); πE != nil {
								continue
							}
							πTemp005[0] = µnew_block
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnest_line_block_segment, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 1649: new_items.append(new_block)
							πF.SetLineno(1649)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnew_block, "new_block"); πE != nil {
								continue
							}
							πTemp005[0] = µnew_block
							if πE = πg.CheckLocal(πF, µnew_items, "new_items"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µnew_items, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label10
						Label10:
							// line 1650: block[:] = new_items
							πF.SetLineno(1650)
							if πE = πg.CheckLocal(πF, µnew_items, "new_items"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µnew_items); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.SetItem(πF, µblock, πTemp004, πTemp001); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßnest_line_block_segment.ToObject(), πTemp029); πE != nil {
						continue
					}
					// line 1652: def grid_table_top(self, match, context, next_state):
					πF.SetLineno(1652)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp030 = πg.NewFunction(πg.NewCode("grid_table_top", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1653: """Top border of a full table."""
							πF.SetLineno(1653)
							// line 1654: return self.table_top(match, context, next_state,
							πF.SetLineno(1654)
							πTemp001 = πF.MakeArgs(5)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp001[1] = µcontext
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001[2] = µnext_state
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßisolate_grid_table, nil); πE != nil {
								continue
							}
							πTemp001[3] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßtableparser); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßGridTableParser, nil); πE != nil {
								continue
							}
							πTemp001[4] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtable_top, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßgrid_table_top.ToObject(), πTemp030); πE != nil {
						continue
					}
					// line 1653: """Top border of a full table."""
					πF.SetLineno(1653)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp031}, πg.NewStr("Top border of a full table.").ToObject()); πE != nil {
						continue
					}
					if πTemp032, πE = πg.ResolveClass(πF, πClass, nil, ßgrid_table_top); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp032, ß__doc__, πTemp031); πE != nil {
						continue
					}
					// line 1658: def simple_table_top(self, match, context, next_state):
					πF.SetLineno(1658)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp031 = πg.NewFunction(πg.NewCode("simple_table_top", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1659: """Top border of a simple table."""
							πF.SetLineno(1659)
							// line 1660: return self.table_top(match, context, next_state,
							πF.SetLineno(1660)
							πTemp001 = πF.MakeArgs(5)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp001[1] = µcontext
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001[2] = µnext_state
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßisolate_simple_table, nil); πE != nil {
								continue
							}
							πTemp001[3] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßtableparser); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßSimpleTableParser, nil); πE != nil {
								continue
							}
							πTemp001[4] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtable_top, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsimple_table_top.ToObject(), πTemp031); πE != nil {
						continue
					}
					// line 1659: """Top border of a simple table."""
					πF.SetLineno(1659)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp032}, πg.NewStr("Top border of a simple table.").ToObject()); πE != nil {
						continue
					}
					if πTemp033, πE = πg.ResolveClass(πF, πClass, nil, ßsimple_table_top); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp033, ß__doc__, πTemp032); πE != nil {
						continue
					}
					// line 1664: def table_top(self, match, context, next_state,
					πF.SetLineno(1664)
					πTemp016 = make([]πg.Param, 6)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp016[4] = πg.Param{Name: "isolate_function", Def: nil}
					πTemp016[5] = πg.Param{Name: "parser_class", Def: nil}
					πTemp032 = πg.NewFunction(πg.NewCode("table_top", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µisolate_function *πg.Object = πArgs[4]
						_ = µisolate_function
						var µparser_class *πg.Object = πArgs[5]
						_ = µparser_class
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1666: """Top border of a generic table."""
							πF.SetLineno(1666)
							// line 1667: nodelist, blank_finish = self.table(isolate_function, parser_class)
							πF.SetLineno(1667)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µisolate_function, "isolate_function"); πE != nil {
								continue
							}
							πTemp001[0] = µisolate_function
							if πE = πg.CheckLocal(πF, µparser_class, "parser_class"); πE != nil {
								continue
							}
							πTemp001[1] = µparser_class
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßtable, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µnodelist = πTemp002
							µblank_finish = πTemp004
							// line 1668: self.parent += nodelist
							πF.SetLineno(1668)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µnodelist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1669: if not blank_finish:
							πF.SetLineno(1669)
						Label1:
							// line 1670: msg = self.reporter.warning(
							πF.SetLineno(1670)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Blank line required after table.").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"line", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp002
							// line 1673: self.parent += msg
							πF.SetLineno(1673)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 1674: return [], next_state, []
							πF.SetLineno(1674)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtable_top.ToObject(), πTemp032); πE != nil {
						continue
					}
					// line 1666: """Top border of a generic table."""
					πF.SetLineno(1666)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp033}, πg.NewStr("Top border of a generic table.").ToObject()); πE != nil {
						continue
					}
					if πTemp034, πE = πg.ResolveClass(πF, πClass, nil, ßtable_top); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp034, ß__doc__, πTemp033); πE != nil {
						continue
					}
					// line 1676: def table(self, isolate_function, parser_class):
					πF.SetLineno(1676)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "isolate_function", Def: nil}
					πTemp016[2] = πg.Param{Name: "parser_class", Def: nil}
					πTemp033 = πg.NewFunction(πg.NewCode("table", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µisolate_function *πg.Object = πArgs[1]
						_ = µisolate_function
						var µparser_class *πg.Object = πArgs[2]
						_ = µparser_class
						var µblock *πg.Object = πg.UnboundLocal
						_ = µblock
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µparser *πg.Object = πg.UnboundLocal
						_ = µparser
						var µtabledata *πg.Object = πg.UnboundLocal
						_ = µtabledata
						var µtableline *πg.Object = πg.UnboundLocal
						_ = µtableline
						var µtable *πg.Object = πg.UnboundLocal
						_ = µtable
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var µerr *πg.Object = πg.UnboundLocal
						_ = µerr
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.BaseException
						_ = πTemp008
						var πTemp009 *πg.Traceback
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πTemp011 πg.KWArgs
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 5:
								goto Label5
							default:
								panic("unexpected function state")
							}
							// line 1677: """Parse a table."""
							πF.SetLineno(1677)
							// line 1678: block, messages, blank_finish = isolate_function()
							πF.SetLineno(1678)
							if πE = πg.CheckLocal(πF, µisolate_function, "isolate_function"); πE != nil {
								continue
							}
							if πTemp001, πE = µisolate_function.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, πTemp001); πE != nil {
								continue
							}
							µblock = πTemp002
							µmessages = πTemp003
							µblank_finish = πTemp004
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µblock); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1679: if block:
							πF.SetLineno(1679)
						Label1:
							// line 1680: try:
							πF.SetLineno(1680)
							πF.PushCheckpoint(5)
							// line 1681: parser = parser_class()
							πF.SetLineno(1681)
							if πE = πg.CheckLocal(πF, µparser_class, "parser_class"); πE != nil {
								continue
							}
							if πTemp001, πE = µparser_class.Call(πF, nil, nil); πE != nil {
								continue
							}
							µparser = πTemp001
							// line 1682: tabledata = parser.parse(block)
							πF.SetLineno(1682)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp006[0] = µblock
							if πE = πg.CheckLocal(πF, µparser, "parser"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µparser, ßparse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µtabledata = πTemp002
							// line 1683: tableline = (self.state_machine.abs_line_number() - len(block)
							πF.SetLineno(1683)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp006[0] = µblock
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.Sub(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µtableline = πTemp001
							// line 1685: table = self.build_table(tabledata, tableline)
							πF.SetLineno(1685)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtabledata, "tabledata"); πE != nil {
								continue
							}
							πTemp006[0] = µtabledata
							if πE = πg.CheckLocal(πF, µtableline, "tableline"); πE != nil {
								continue
							}
							πTemp006[1] = µtableline
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßbuild_table, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µtable = πTemp002
							// line 1686: nodelist = [table] + messages
							πF.SetLineno(1686)
							πTemp006 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µtable, "table"); πE != nil {
								continue
							}
							πTemp006[0] = µtable
							πTemp002 = πg.NewList(πTemp006...).ToObject()
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µmessages); πE != nil {
								continue
							}
							µnodelist = πTemp001
							πF.PopCheckpoint()
							goto Label4
						Label5:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp008, πTemp009 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßtableparser); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßTableMarkupError, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsInstance(πF, πTemp008.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							πE = πF.Raise(πTemp008.ToObject(), nil, πTemp009.ToObject())
							continue
							// line 1687: except tableparser.TableMarkupError as err:
							πF.SetLineno(1687)
						Label6:
							µerr = πTemp008.ToObject()
							// line 1688: nodelist = self.malformed_table(block, ' '.join(err.args),
							πF.SetLineno(1688)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp006[0] = µblock
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µerr, "err"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µerr, ßargs, nil); πE != nil {
								continue
							}
							πTemp010[0] = πTemp002
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp006[1] = πTemp003
							if πE = πg.CheckLocal(πF, µerr, "err"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µerr, ßoffset, nil); πE != nil {
								continue
							}
							πTemp011 = πg.KWArgs{
								{"offset", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßmalformed_table, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, πTemp011); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, µmessages); πE != nil {
								continue
							}
							µnodelist = πTemp001
							πF.RestoreExc(nil, nil)
							goto Label4
						Label4:
							goto Label3
						Label2:
							// line 1691: nodelist = messages
							πF.SetLineno(1691)
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							µnodelist = µmessages
							goto Label3
						Label3:
							// line 1692: return nodelist, blank_finish
							πF.SetLineno(1692)
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µnodelist, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtable.ToObject(), πTemp033); πE != nil {
						continue
					}
					// line 1677: """Parse a table."""
					πF.SetLineno(1677)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp034}, πg.NewStr("Parse a table.").ToObject()); πE != nil {
						continue
					}
					if πTemp035, πE = πg.ResolveClass(πF, πClass, nil, ßtable); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp035, ß__doc__, πTemp034); πE != nil {
						continue
					}
					// line 1694: def isolate_grid_table(self):
					πF.SetLineno(1694)
					πTemp016 = make([]πg.Param, 1)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp034 = πg.NewFunction(πg.NewCode("isolate_grid_table", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µblock *πg.Object = πg.UnboundLocal
						_ = µblock
						var µerr *πg.Object = πg.UnboundLocal
						_ = µerr
						var µsrc *πg.Object = πg.UnboundLocal
						_ = µsrc
						var µsrcline *πg.Object = πg.UnboundLocal
						_ = µsrcline
						var µwidth *πg.Object = πg.UnboundLocal
						_ = µwidth
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 πg.KWArgs
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πTemp011 bool
						_ = πTemp011
						var πTemp012 *πg.Object
						_ = πTemp012
						var πTemp013 *πg.Object
						_ = πTemp013
						var πTemp014 *πg.Object
						_ = πTemp014
						var πTemp015 bool
						_ = πTemp015
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 2:
								goto Label2
							case 4:
								goto Label4
							case 5:
								goto Label5
							case 11:
								goto Label11
							case 12:
								goto Label12
							case 16:
								goto Label16
							case 17:
								goto Label17
							default:
								panic("unexpected function state")
							}
							// line 1695: messages = []
							πF.SetLineno(1695)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µmessages = πTemp002
							// line 1696: blank_finish = 1
							πF.SetLineno(1696)
							µblank_finish = πg.NewInt(1).ToObject()
							// line 1697: try:
							πF.SetLineno(1697)
							πF.PushCheckpoint(2)
							// line 1698: block = self.state_machine.get_text_block(flush_left=True)
							πF.SetLineno(1698)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp003 = πg.KWArgs{
								{"flush_left", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßget_text_block, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, nil, πTemp003); πE != nil {
								continue
							}
							µblock = πTemp002
							πF.PopCheckpoint()
							goto Label1
						Label2:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßstatemachine); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßUnexpectedIndentationError, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label3
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 1699: except statemachine.UnexpectedIndentationError as err:
							πF.SetLineno(1699)
						Label3:
							µerr = πTemp005.ToObject()
							// line 1700: block, src, srcline = err.args
							πF.SetLineno(1700)
							if πE = πg.CheckLocal(πF, µerr, "err"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µerr, ßargs, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp008}, πg.TieTarget{Target: &πTemp009}}}, πTemp002); πE != nil {
								continue
							}
							µblock = πTemp004
							µsrc = πTemp008
							µsrcline = πTemp009
							// line 1701: messages.append(self.reporter.error('Unexpected indentation.',
							πF.SetLineno(1701)
							πTemp001 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							πTemp010[0] = πg.NewStr("Unexpected indentation.").ToObject()
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							πTemp003 = πg.KWArgs{
								{"source", µsrc},
								{"line", µsrcline},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, πTemp010, πTemp003); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmessages, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1703: blank_finish = 0
							πF.SetLineno(1703)
							µblank_finish = πg.NewInt(0).ToObject()
							πF.RestoreExc(nil, nil)
							goto Label1
						Label1:
							// line 1704: block.disconnect()
							πF.SetLineno(1704)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µblock, ßdisconnect, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 1706: block.pad_double_width(self.double_width_pad_char)
							πF.SetLineno(1706)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdouble_width_pad_char, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µblock, ßpad_double_width, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1707: width = len(block[0].strip())
							πF.SetLineno(1707)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µblock, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp004, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µwidth = πTemp004
							πTemp001 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp010[0] = µblock
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp001[0] = πTemp008
							if πTemp004, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp008); πE != nil {
								continue
							}
							πF.PushCheckpoint(5)
							πTemp007 = false
						Label4:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label6
							}
							if πTemp004, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp011 = !isStop
							} else {
								πTemp011 = true
								µi = πTemp004
							}
							if πE != nil || !πTemp011 {
								continue
							}
							πF.PushCheckpoint(4)
							// line 1709: block[i] = block[i].strip()
							πF.SetLineno(1709)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp004 = µi
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µblock, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp008, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πTemp008); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp009 = µi
							if πE = πg.SetItem(πF, µblock, πTemp009, πTemp004); πE != nil {
								continue
							}
							πTemp008 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp012 = µi
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetItem(πF, µblock, πTemp012); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetItem(πF, πTemp013, πTemp008); πE != nil {
								continue
							}
							if πTemp011, πE = πg.Contains(πF, πg.NewStr("+|").ToObject(), πTemp009); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp011).ToObject()
							if πTemp011, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp011 {
								goto Label7
							}
							goto Label8
							// line 1710: if block[i][0] not in '+|': # check left edge
							πF.SetLineno(1710)
						Label7:
							// line 1711: blank_finish = 0
							πF.SetLineno(1711)
							µblank_finish = πg.NewInt(0).ToObject()
							// line 1712: self.state_machine.previous_line(len(block) - i)
							πF.SetLineno(1712)
							πTemp001 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp010[0] = µblock
							if πTemp008, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Sub(πF, πTemp009, µi); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp004, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp008.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1713: del block[i:]
							πF.SetLineno(1713)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{µi, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.DelItem(πF, µblock, πTemp004); πE != nil {
								continue
							}
							// line 1714: break
							πF.SetLineno(1714)
							πTemp007 = true
							continue
							goto Label8
						Label8:
							continue
						Label5:
							if πE != nil || πR != nil {
								continue
							}
						Label6:
							πTemp001 = πF.MakeArgs(1)
							if πTemp008, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp004 = πTemp008
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µblock, πTemp004); πE != nil {
								continue
							}
							πTemp001[0] = πTemp008
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßgrid_table_top_pat, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp004, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp008.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label9
							}
							goto Label10
							// line 1715: if not self.grid_table_top_pat.match(block[-1]): # find bottom
							πF.SetLineno(1715)
						Label9:
							// line 1716: blank_finish = 0
							πF.SetLineno(1716)
							µblank_finish = πg.NewInt(0).ToObject()
							πTemp001 = πF.MakeArgs(3)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp010[0] = µblock
							if πTemp008, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							if πTemp004, πE = πg.Sub(πF, πTemp009, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							πTemp001[1] = πg.NewInt(1).ToObject()
							if πTemp004, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001[2] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp008); πE != nil {
								continue
							}
							πF.PushCheckpoint(12)
							πTemp007 = false
						Label11:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label13
							}
							if πTemp004, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp011 = !isStop
							} else {
								πTemp011 = true
								µi = πTemp004
							}
							if πE != nil || !πTemp011 {
								continue
							}
							πF.PushCheckpoint(11)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp004 = µi
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µblock, πTemp004); πE != nil {
								continue
							}
							πTemp001[0] = πTemp008
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßgrid_table_top_pat, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp004, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp008.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp011, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp011 {
								goto Label14
							}
							goto Label15
							// line 1719: if self.grid_table_top_pat.match(block[i]):
							πF.SetLineno(1719)
						Label14:
							// line 1720: self.state_machine.previous_line(len(block) - i + 1)
							πF.SetLineno(1720)
							πTemp001 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp010[0] = µblock
							if πTemp009, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp012, πE = πTemp009.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Sub(πF, πTemp012, µi); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, πTemp008, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp004, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp008.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1721: del block[i+1:]
							πF.SetLineno(1721)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.Add(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πTemp008, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.DelItem(πF, µblock, πTemp004); πE != nil {
								continue
							}
							// line 1722: break
							πF.SetLineno(1722)
							πTemp007 = true
							continue
							goto Label15
						Label15:
							continue
						Label12:
							if πE != nil || πR != nil {
								continue
							}
							// line 1724: messages.extend(self.malformed_table(block))
							πF.SetLineno(1724)
							πTemp001 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp010[0] = µblock
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßmalformed_table, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp001[0] = πTemp008
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmessages, ßextend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1725: return [], messages, blank_finish
							πF.SetLineno(1725)
							πTemp001 = make([]*πg.Object, 0)
							πTemp008 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple3(πTemp008, µmessages, µblank_finish).ToObject()
							πR = πTemp004
							continue
						Label13:
							goto Label10
						Label10:
							πTemp001 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp010[0] = µblock
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp001[0] = πTemp008
							if πTemp004, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp008); πE != nil {
								continue
							}
							πF.PushCheckpoint(17)
							πTemp007 = false
						Label16:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label18
							}
							if πTemp004, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp011 = !isStop
							} else {
								πTemp011 = true
								µi = πTemp004
							}
							if πE != nil || !πTemp011 {
								continue
							}
							πF.PushCheckpoint(16)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp009 = µi
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetItem(πF, µblock, πTemp009); πE != nil {
								continue
							}
							πTemp001[0] = πTemp012
							if πTemp009, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp012, πE = πTemp009.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µwidth, "width"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.NE(πF, πTemp012, µwidth); πE != nil {
								continue
							}
							πTemp004 = πTemp008
							if πTemp011, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp011 {
								goto Label19
							}
							if πTemp012, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp009 = πTemp012
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp013 = µi
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp014, πE = πg.GetItem(πF, µblock, πTemp013); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetItem(πF, πTemp014, πTemp009); πE != nil {
								continue
							}
							if πTemp015, πE = πg.Contains(πF, πg.NewStr("+|").ToObject(), πTemp012); πE != nil {
								continue
							}
							πTemp008 = πg.GetBool(!πTemp015).ToObject()
							πTemp004 = πTemp008
						Label19:
							if πTemp011, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp011 {
								goto Label20
							}
							goto Label21
							// line 1727: if len(block[i]) != width or block[i][-1] not in '+|':
							πF.SetLineno(1727)
						Label20:
							// line 1728: messages.extend(self.malformed_table(block))
							πF.SetLineno(1728)
							πTemp001 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp010[0] = µblock
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßmalformed_table, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp001[0] = πTemp008
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmessages, ßextend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1729: return [], messages, blank_finish
							πF.SetLineno(1729)
							πTemp001 = make([]*πg.Object, 0)
							πTemp008 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple3(πTemp008, µmessages, µblank_finish).ToObject()
							πR = πTemp004
							continue
							goto Label21
						Label21:
							continue
						Label17:
							if πE != nil || πR != nil {
								continue
							}
						Label18:
							// line 1730: return block, messages, blank_finish
							πF.SetLineno(1730)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple3(µblock, µmessages, µblank_finish).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisolate_grid_table.ToObject(), πTemp034); πE != nil {
						continue
					}
					// line 1732: def isolate_simple_table(self):
					πF.SetLineno(1732)
					πTemp016 = make([]πg.Param, 1)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp035 = πg.NewFunction(πg.NewCode("isolate_simple_table", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstart *πg.Object = πg.UnboundLocal
						_ = µstart
						var µlines *πg.Object = πg.UnboundLocal
						_ = µlines
						var µlimit *πg.Object = πg.UnboundLocal
						_ = µlimit
						var µtoplen *πg.Object = πg.UnboundLocal
						_ = µtoplen
						var µpattern_match *πg.Object = πg.UnboundLocal
						_ = µpattern_match
						var µfound *πg.Object = πg.UnboundLocal
						_ = µfound
						var µfound_at *πg.Object = πg.UnboundLocal
						_ = µfound_at
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var µmatch *πg.Object = πg.UnboundLocal
						_ = µmatch
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µend *πg.Object = πg.UnboundLocal
						_ = µend
						var µextra *πg.Object = πg.UnboundLocal
						_ = µextra
						var µblock *πg.Object = πg.UnboundLocal
						_ = µblock
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1733: start = self.state_machine.line_offset
							πF.SetLineno(1733)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßline_offset, nil); πE != nil {
								continue
							}
							µstart = πTemp002
							// line 1734: lines = self.state_machine.input_lines
							πF.SetLineno(1734)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinput_lines, nil); πE != nil {
								continue
							}
							µlines = πTemp002
							// line 1735: limit = len(lines) - 1
							πF.SetLineno(1735)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp003[0] = µlines
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Sub(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µlimit = πTemp001
							// line 1736: toplen = len(lines[start].strip())
							πF.SetLineno(1736)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							πTemp001 = µstart
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µlines, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtoplen = πTemp002
							// line 1737: pattern_match = self.simple_table_border_pat.match
							πF.SetLineno(1737)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsimple_table_border_pat, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßmatch, nil); πE != nil {
								continue
							}
							µpattern_match = πTemp002
							// line 1738: found = 0
							πF.SetLineno(1738)
							µfound = πg.NewInt(0).ToObject()
							// line 1739: found_at = None
							πF.SetLineno(1739)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µfound_at = πTemp001
							// line 1740: i = start + 1
							πF.SetLineno(1740)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µstart, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µi = πTemp001
							// line 1741: while i <= limit:
							πF.SetLineno(1741)
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.LE(πF, µi, µlimit); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1742: line = lines[i]
							πF.SetLineno(1742)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp001 = µi
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µlines, πTemp001); πE != nil {
								continue
							}
							µline = πTemp002
							// line 1743: match = pattern_match(line)
							πF.SetLineno(1743)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp003[0] = µline
							if πE = πg.CheckLocal(πF, µpattern_match, "pattern_match"); πE != nil {
								continue
							}
							if πTemp001, πE = µpattern_match.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmatch = πTemp001
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µmatch); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label4
							}
							goto Label5
							// line 1744: if match:
							πF.SetLineno(1744)
						Label4:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µline, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.CheckLocal(πF, µtoplen, "toplen"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.NE(πF, πTemp004, µtoplen); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label6
							}
							goto Label7
							// line 1745: if len(line.strip()) != toplen:
							πF.SetLineno(1745)
						Label6:
							// line 1746: self.state_machine.next_line(i - start)
							πF.SetLineno(1746)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, µi, µstart); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnext_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1747: messages = self.malformed_table(
							πF.SetLineno(1747)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µstart, πTemp002, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µlines, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							πTemp003[1] = πg.NewStr("Bottom/header table border does not match top border.").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmalformed_table, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmessages = πTemp002
							// line 1750: return [], messages, i == limit or not lines[i+1].strip()
							πF.SetLineno(1750)
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Eq(πF, µi, µlimit); πE != nil {
								continue
							}
							πTemp004 = πTemp007
							if πTemp006, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Add(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp008 = πTemp009
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetItem(πF, µlines, πTemp008); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp009, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.IsTrue(πF, πTemp009); πE != nil {
								continue
							}
							πTemp007 = πg.GetBool(!πTemp010).ToObject()
							πTemp004 = πTemp007
						Label8:
							πTemp001 = πg.NewTuple3(πTemp002, µmessages, πTemp004).ToObject()
							πR = πTemp001
							continue
							goto Label7
						Label7:
							// line 1751: found += 1
							πF.SetLineno(1751)
							if πE = πg.CheckLocal(πF, µfound, "found"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µfound, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µfound = πTemp001
							// line 1752: found_at = i
							πF.SetLineno(1752)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							µfound_at = µi
							if πE = πg.CheckLocal(πF, µfound, "found"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µfound, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label9
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µi, µlimit); πE != nil {
								continue
							}
							πTemp001 = πTemp002
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label9
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Add(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp004 = πTemp007
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µlines, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp007, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.IsTrue(πF, πTemp007); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp010).ToObject()
							πTemp001 = πTemp002
						Label9:
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label10
							}
							goto Label11
							// line 1753: if found == 2 or i == limit or not lines[i+1].strip():
							πF.SetLineno(1753)
						Label10:
							// line 1754: end = i
							πF.SetLineno(1754)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							µend = µi
							// line 1755: break
							πF.SetLineno(1755)
							πTemp005 = true
							continue
							goto Label11
						Label11:
							goto Label5
						Label5:
							// line 1756: i += 1
							πF.SetLineno(1756)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µi = πTemp001
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfound, "found"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µfound); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label12
							}
							goto Label13
							// line 1758: if found:
							πF.SetLineno(1758)
						Label12:
							// line 1759: extra = ' or no blank line after table bottom'
							πF.SetLineno(1759)
							µextra = πg.NewStr(" or no blank line after table bottom").ToObject()
							// line 1760: self.state_machine.next_line(found_at - start)
							πF.SetLineno(1760)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfound_at, "found_at"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, µfound_at, µstart); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnext_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1761: block = lines[start:found_at+1]
							πF.SetLineno(1761)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfound_at, "found_at"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µfound_at, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µstart, πTemp002, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µlines, πTemp001); πE != nil {
								continue
							}
							µblock = πTemp002
							goto Label14
						Label13:
							// line 1763: extra = ''
							πF.SetLineno(1763)
							µextra = ß.ToObject()
							// line 1764: self.state_machine.next_line(i - start - 1)
							πF.SetLineno(1764)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Sub(πF, µi, µstart); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnext_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1765: block = lines[start:]
							πF.SetLineno(1765)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µstart, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µlines, πTemp001); πE != nil {
								continue
							}
							µblock = πTemp002
							goto Label14
						Label14:
							// line 1766: messages = self.malformed_table(
							πF.SetLineno(1766)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003[0] = µblock
							if πE = πg.CheckLocal(πF, µextra, "extra"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("No bottom table border found%s.").ToObject(), µextra); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmalformed_table, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmessages = πTemp002
							// line 1768: return [], messages, not extra
							πF.SetLineno(1768)
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µextra, "extra"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µextra); πE != nil {
								continue
							}
							πTemp004 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µmessages, πTemp004).ToObject()
							πR = πTemp001
							continue
						Label3:
							// line 1769: self.state_machine.next_line(end - start)
							πF.SetLineno(1769)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µend, "end"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, µend, µstart); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnext_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1770: block = lines[start:end+1]
							πF.SetLineno(1770)
							if πE = πg.CheckLocal(πF, µstart, "start"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µend, "end"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µend, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µstart, πTemp002, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µlines, πTemp001); πE != nil {
								continue
							}
							µblock = πTemp002
							// line 1772: block.pad_double_width(self.double_width_pad_char)
							πF.SetLineno(1772)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdouble_width_pad_char, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µblock, ßpad_double_width, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1773: return block, [], end == limit or not lines[end+1].strip()
							πF.SetLineno(1773)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µend, "end"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlimit, "limit"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Eq(πF, µend, µlimit); πE != nil {
								continue
							}
							πTemp004 = πTemp007
							if πTemp005, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label15
							}
							if πE = πg.CheckLocal(πF, µend, "end"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Add(πF, µend, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp008 = πTemp009
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetItem(πF, µlines, πTemp008); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp009, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp008.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp009); πE != nil {
								continue
							}
							πTemp007 = πg.GetBool(!πTemp006).ToObject()
							πTemp004 = πTemp007
						Label15:
							πTemp001 = πg.NewTuple3(µblock, πTemp002, πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßisolate_simple_table.ToObject(), πTemp035); πE != nil {
						continue
					}
					// line 1775: def malformed_table(self, block, detail='', offset=0):
					πF.SetLineno(1775)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "block", Def: nil}
					πTemp016[2] = πg.Param{Name: "detail", Def: ß.ToObject()}
					πTemp016[3] = πg.Param{Name: "offset", Def: πg.NewInt(0).ToObject()}
					πTemp036 = πg.NewFunction(πg.NewCode("malformed_table", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µblock *πg.Object = πArgs[1]
						_ = µblock
						var µdetail *πg.Object = πArgs[2]
						_ = µdetail
						var µoffset *πg.Object = πArgs[3]
						_ = µoffset
						var µdata *πg.Object = πg.UnboundLocal
						_ = µdata
						var µmessage *πg.Object = πg.UnboundLocal
						_ = µmessage
						var µstartline *πg.Object = πg.UnboundLocal
						_ = µstartline
						var µerror *πg.Object = πg.UnboundLocal
						_ = µerror
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1776: block.replace(self.double_width_pad_char, '')
							πF.SetLineno(1776)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdouble_width_pad_char, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							πTemp001[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µblock, ßreplace, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1777: data = '\n'.join(block)
							πF.SetLineno(1777)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp001[0] = µblock
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µdata = πTemp003
							// line 1778: message = 'Malformed table.'
							πF.SetLineno(1778)
							µmessage = πg.NewStr("Malformed table.").ToObject()
							// line 1779: startline = self.state_machine.abs_line_number() - len(block) + 1
							πF.SetLineno(1779)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp001[0] = µblock
							if πTemp005, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.Sub(πF, πTemp004, πTemp006); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µstartline = πTemp002
							if πE = πg.CheckLocal(πF, µdetail, "detail"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µdetail); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 1780: if detail:
							πF.SetLineno(1780)
						Label1:
							// line 1781: message += '\n' + detail
							πF.SetLineno(1781)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdetail, "detail"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πg.NewStr("\n").ToObject(), µdetail); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µmessage, πTemp002); πE != nil {
								continue
							}
							µmessage = πTemp003
							goto Label2
						Label2:
							// line 1782: error = self.reporter.error(message, nodes.literal_block(data, data),
							πF.SetLineno(1782)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp001[0] = µmessage
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp008[0] = µdata
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp008[1] = µdata
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µstartline, "startline"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µstartline, µoffset); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"line", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µerror = πTemp002
							// line 1784: return [error]
							πF.SetLineno(1784)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µerror, "error"); πE != nil {
								continue
							}
							πTemp001[0] = µerror
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßmalformed_table.ToObject(), πTemp036); πE != nil {
						continue
					}
					// line 1786: def build_table(self, tabledata, tableline, stub_columns=0, widths=None):
					πF.SetLineno(1786)
					πTemp016 = make([]πg.Param, 5)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "tabledata", Def: nil}
					πTemp016[2] = πg.Param{Name: "tableline", Def: nil}
					πTemp016[3] = πg.Param{Name: "stub_columns", Def: πg.NewInt(0).ToObject()}
					if πTemp038, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp016[4] = πg.Param{Name: "widths", Def: πTemp038}
					πTemp037 = πg.NewFunction(πg.NewCode("build_table", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtabledata *πg.Object = πArgs[1]
						_ = µtabledata
						var µtableline *πg.Object = πArgs[2]
						_ = µtableline
						var µstub_columns *πg.Object = πArgs[3]
						_ = µstub_columns
						var µwidths *πg.Object = πArgs[4]
						_ = µwidths
						var µcolwidths *πg.Object = πg.UnboundLocal
						_ = µcolwidths
						var µheadrows *πg.Object = πg.UnboundLocal
						_ = µheadrows
						var µbodyrows *πg.Object = πg.UnboundLocal
						_ = µbodyrows
						var µtable *πg.Object = πg.UnboundLocal
						_ = µtable
						var µtgroup *πg.Object = πg.UnboundLocal
						_ = µtgroup
						var µcolwidth *πg.Object = πg.UnboundLocal
						_ = µcolwidth
						var µcolspec *πg.Object = πg.UnboundLocal
						_ = µcolspec
						var µthead *πg.Object = πg.UnboundLocal
						_ = µthead
						var µrow *πg.Object = πg.UnboundLocal
						_ = µrow
						var µtbody *πg.Object = πg.UnboundLocal
						_ = µtbody
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 πg.KWArgs
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 4:
								goto Label4
							case 5:
								goto Label5
							case 11:
								goto Label11
							case 12:
								goto Label12
							case 14:
								goto Label14
							case 15:
								goto Label15
							default:
								panic("unexpected function state")
							}
							// line 1787: colwidths, headrows, bodyrows = tabledata
							πF.SetLineno(1787)
							if πE = πg.CheckLocal(πF, µtabledata, "tabledata"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, µtabledata); πE != nil {
								continue
							}
							µcolwidths = πTemp001
							µheadrows = πTemp002
							µbodyrows = πTemp003
							// line 1788: table = nodes.table()
							πF.SetLineno(1788)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtable, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtable = πTemp001
							if πE = πg.CheckLocal(πF, µwidths, "widths"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µwidths, ßauto.ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µwidths, "widths"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µwidths); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label2
							}
							goto Label3
							// line 1789: if widths == 'auto':
							πF.SetLineno(1789)
						Label1:
							// line 1790: table['classes'] += ['colwidths-auto']
							πF.SetLineno(1790)
							πTemp001 = ßclasses.ToObject()
							if πE = πg.CheckLocal(πF, µtable, "table"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µtable, πTemp001); πE != nil {
								continue
							}
							πTemp005 = make([]*πg.Object, 1)
							πTemp005[0] = πg.NewStr("colwidths-auto").ToObject()
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							if πTemp003, πE = πg.IAdd(πF, πTemp002, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtable, "table"); πE != nil {
								continue
							}
							πTemp006 = ßclasses.ToObject()
							if πE = πg.SetItem(πF, µtable, πTemp006, πTemp003); πE != nil {
								continue
							}
							goto Label3
							// line 1791: elif widths: # "grid" or list of integers
							πF.SetLineno(1791)
						Label2:
							// line 1792: table['classes'] += ['colwidths-given']
							πF.SetLineno(1792)
							πTemp001 = ßclasses.ToObject()
							if πE = πg.CheckLocal(πF, µtable, "table"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µtable, πTemp001); πE != nil {
								continue
							}
							πTemp005 = make([]*πg.Object, 1)
							πTemp005[0] = πg.NewStr("colwidths-given").ToObject()
							πTemp001 = πg.NewList(πTemp005...).ToObject()
							if πTemp003, πE = πg.IAdd(πF, πTemp002, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtable, "table"); πE != nil {
								continue
							}
							πTemp006 = ßclasses.ToObject()
							if πE = πg.SetItem(πF, µtable, πTemp006, πTemp003); πE != nil {
								continue
							}
							goto Label3
						Label3:
							// line 1793: tgroup = nodes.tgroup(cols=len(colwidths))
							πF.SetLineno(1793)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcolwidths, "colwidths"); πE != nil {
								continue
							}
							πTemp005[0] = µcolwidths
							if πTemp001, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp007 = πg.KWArgs{
								{"cols", πTemp002},
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtgroup, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, πTemp007); πE != nil {
								continue
							}
							µtgroup = πTemp001
							// line 1794: table += tgroup
							πF.SetLineno(1794)
							if πE = πg.CheckLocal(πF, µtable, "table"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtgroup, "tgroup"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µtable, µtgroup); πE != nil {
								continue
							}
							µtable = πTemp001
							if πE = πg.CheckLocal(πF, µcolwidths, "colwidths"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µcolwidths); πE != nil {
								continue
							}
							πF.PushCheckpoint(5)
							πTemp004 = false
						Label4:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label6
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								µcolwidth = πTemp002
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(4)
							// line 1796: colspec = nodes.colspec(colwidth=colwidth)
							πF.SetLineno(1796)
							if πE = πg.CheckLocal(πF, µcolwidth, "colwidth"); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"colwidth", µcolwidth},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßcolspec, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, πTemp007); πE != nil {
								continue
							}
							µcolspec = πTemp002
							if πE = πg.CheckLocal(πF, µstub_columns, "stub_columns"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, µstub_columns); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label7
							}
							goto Label8
							// line 1797: if stub_columns:
							πF.SetLineno(1797)
						Label7:
							// line 1798: colspec.attributes['stub'] = 1
							πF.SetLineno(1798)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcolspec, "colspec"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µcolspec, ßattributes, nil); πE != nil {
								continue
							}
							πTemp006 = ßstub.ToObject()
							if πE = πg.SetItem(πF, πTemp003, πTemp006, πTemp002); πE != nil {
								continue
							}
							// line 1799: stub_columns -= 1
							πF.SetLineno(1799)
							if πE = πg.CheckLocal(πF, µstub_columns, "stub_columns"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ISub(πF, µstub_columns, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µstub_columns = πTemp002
							goto Label8
						Label8:
							// line 1800: tgroup += colspec
							πF.SetLineno(1800)
							if πE = πg.CheckLocal(πF, µtgroup, "tgroup"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcolspec, "colspec"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µtgroup, µcolspec); πE != nil {
								continue
							}
							µtgroup = πTemp002
							continue
						Label5:
							if πE != nil || πR != nil {
								continue
							}
						Label6:
							if πE = πg.CheckLocal(πF, µheadrows, "headrows"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µheadrows); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label9
							}
							goto Label10
							// line 1801: if headrows:
							πF.SetLineno(1801)
						Label9:
							// line 1802: thead = nodes.thead()
							πF.SetLineno(1802)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßthead, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µthead = πTemp001
							// line 1803: tgroup += thead
							πF.SetLineno(1803)
							if πE = πg.CheckLocal(πF, µtgroup, "tgroup"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µthead, "thead"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µtgroup, µthead); πE != nil {
								continue
							}
							µtgroup = πTemp001
							if πE = πg.CheckLocal(πF, µheadrows, "headrows"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µheadrows); πE != nil {
								continue
							}
							πF.PushCheckpoint(12)
							πTemp004 = false
						Label11:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label13
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								µrow = πTemp002
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(11)
							// line 1805: thead += self.build_table_row(row, tableline)
							πF.SetLineno(1805)
							if πE = πg.CheckLocal(πF, µthead, "thead"); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							πTemp005[0] = µrow
							if πE = πg.CheckLocal(πF, µtableline, "tableline"); πE != nil {
								continue
							}
							πTemp005[1] = µtableline
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßbuild_table_row, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp002, πE = πg.IAdd(πF, µthead, πTemp003); πE != nil {
								continue
							}
							µthead = πTemp002
							continue
						Label12:
							if πE != nil || πR != nil {
								continue
							}
						Label13:
							goto Label10
						Label10:
							// line 1806: tbody = nodes.tbody()
							πF.SetLineno(1806)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtbody, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtbody = πTemp001
							// line 1807: tgroup += tbody
							πF.SetLineno(1807)
							if πE = πg.CheckLocal(πF, µtgroup, "tgroup"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtbody, "tbody"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µtgroup, µtbody); πE != nil {
								continue
							}
							µtgroup = πTemp001
							if πE = πg.CheckLocal(πF, µbodyrows, "bodyrows"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µbodyrows); πE != nil {
								continue
							}
							πF.PushCheckpoint(15)
							πTemp004 = false
						Label14:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp004 {
								πF.PopCheckpoint()
								goto Label16
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp008 = !isStop
							} else {
								πTemp008 = true
								µrow = πTemp002
							}
							if πE != nil || !πTemp008 {
								continue
							}
							πF.PushCheckpoint(14)
							// line 1809: tbody += self.build_table_row(row, tableline)
							πF.SetLineno(1809)
							if πE = πg.CheckLocal(πF, µtbody, "tbody"); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							πTemp005[0] = µrow
							if πE = πg.CheckLocal(πF, µtableline, "tableline"); πE != nil {
								continue
							}
							πTemp005[1] = µtableline
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßbuild_table_row, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp002, πE = πg.IAdd(πF, µtbody, πTemp003); πE != nil {
								continue
							}
							µtbody = πTemp002
							continue
						Label15:
							if πE != nil || πR != nil {
								continue
							}
						Label16:
							// line 1810: return table
							πF.SetLineno(1810)
							if πE = πg.CheckLocal(πF, µtable, "table"); πE != nil {
								continue
							}
							πR = µtable
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßbuild_table.ToObject(), πTemp037); πE != nil {
						continue
					}
					// line 1812: def build_table_row(self, rowdata, tableline):
					πF.SetLineno(1812)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "rowdata", Def: nil}
					πTemp016[2] = πg.Param{Name: "tableline", Def: nil}
					πTemp038 = πg.NewFunction(πg.NewCode("build_table_row", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µrowdata *πg.Object = πArgs[1]
						_ = µrowdata
						var µtableline *πg.Object = πArgs[2]
						_ = µtableline
						var µrow *πg.Object = πg.UnboundLocal
						_ = µrow
						var µcell *πg.Object = πg.UnboundLocal
						_ = µcell
						var µmorerows *πg.Object = πg.UnboundLocal
						_ = µmorerows
						var µmorecols *πg.Object = πg.UnboundLocal
						_ = µmorecols
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µcellblock *πg.Object = πg.UnboundLocal
						_ = µcellblock
						var µattributes *πg.Object = πg.UnboundLocal
						_ = µattributes
						var µentry *πg.Object = πg.UnboundLocal
						_ = µentry
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Dict
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πTemp010 πg.KWArgs
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 1813: row = nodes.row()
							πF.SetLineno(1813)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßrow, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µrow = πTemp001
							if πE = πg.CheckLocal(πF, µrowdata, "rowdata"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, µrowdata); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp003 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp003 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp004 = !isStop
							} else {
								πTemp004 = true
								µcell = πTemp002
							}
							if πE != nil || !πTemp004 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µcell, "cell"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(µcell == πTemp005).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label4
							}
							goto Label5
							// line 1815: if cell is None:
							πF.SetLineno(1815)
						Label4:
							// line 1816: continue
							πF.SetLineno(1816)
							continue
							goto Label5
						Label5:
							// line 1817: morerows, morecols, offset, cellblock = cell
							πF.SetLineno(1817)
							if πE = πg.CheckLocal(πF, µcell, "cell"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, µcell); πE != nil {
								continue
							}
							µmorerows = πTemp002
							µmorecols = πTemp005
							µoffset = πTemp006
							µcellblock = πTemp007
							// line 1818: attributes = {}
							πF.SetLineno(1818)
							πTemp008 = πg.NewDict()
							πTemp002 = πTemp008.ToObject()
							µattributes = πTemp002
							if πE = πg.CheckLocal(πF, µmorerows, "morerows"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µmorerows); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label6
							}
							goto Label7
							// line 1819: if morerows:
							πF.SetLineno(1819)
						Label6:
							// line 1820: attributes['morerows'] = morerows
							πF.SetLineno(1820)
							if πE = πg.CheckLocal(πF, µmorerows, "morerows"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µmorerows); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattributes, "attributes"); πE != nil {
								continue
							}
							πTemp005 = ßmorerows.ToObject()
							if πE = πg.SetItem(πF, µattributes, πTemp005, πTemp002); πE != nil {
								continue
							}
							goto Label7
						Label7:
							if πE = πg.CheckLocal(πF, µmorecols, "morecols"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, µmorecols); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label8
							}
							goto Label9
							// line 1821: if morecols:
							πF.SetLineno(1821)
						Label8:
							// line 1822: attributes['morecols'] = morecols
							πF.SetLineno(1822)
							if πE = πg.CheckLocal(πF, µmorecols, "morecols"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µmorecols); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µattributes, "attributes"); πE != nil {
								continue
							}
							πTemp005 = ßmorecols.ToObject()
							if πE = πg.SetItem(πF, µattributes, πTemp005, πTemp002); πE != nil {
								continue
							}
							goto Label9
						Label9:
							// line 1823: entry = nodes.entry(**attributes)
							πF.SetLineno(1823)
							if πE = πg.CheckLocal(πF, µattributes, "attributes"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßentry, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Invoke(πF, πTemp005, nil, nil, nil, µattributes); πE != nil {
								continue
							}
							µentry = πTemp002
							// line 1824: row += entry
							πF.SetLineno(1824)
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µentry, "entry"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µrow, µentry); πE != nil {
								continue
							}
							µrow = πTemp002
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcellblock, "cellblock"); πE != nil {
								continue
							}
							πTemp009[0] = µcellblock
							if πTemp002, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							if πTemp004, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label10
							}
							goto Label11
							// line 1825: if ''.join(cellblock):
							πF.SetLineno(1825)
						Label10:
							// line 1826: self.nested_parse(cellblock, input_offset=tableline+offset,
							πF.SetLineno(1826)
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcellblock, "cellblock"); πE != nil {
								continue
							}
							πTemp009[0] = µcellblock
							if πE = πg.CheckLocal(πF, µtableline, "tableline"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µtableline, µoffset); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µentry, "entry"); πE != nil {
								continue
							}
							πTemp010 = πg.KWArgs{
								{"input_offset", πTemp002},
								{"node", µentry},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp009, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							goto Label11
						Label11:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1828: return row
							πF.SetLineno(1828)
							if πE = πg.CheckLocal(πF, µrow, "row"); πE != nil {
								continue
							}
							πR = µrow
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßbuild_table_row.ToObject(), πTemp038); πE != nil {
						continue
					}
					// line 1831: explicit = Struct()
					πF.SetLineno(1831)
					if πTemp039, πE = πg.ResolveClass(πF, πClass, nil, ßStruct); πE != nil {
						continue
					}
					if πTemp040, πE = πTemp039.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßexplicit.ToObject(), πTemp040); πE != nil {
						continue
					}
					// line 1832: """Patterns and constants used for explicit markup recognition."""
					πF.SetLineno(1832)
					// line 1834: explicit.patterns = Struct(
					πF.SetLineno(1834)
					πTemp006 = πF.MakeArgs(2)
					πTemp041 = πF.MakeArgs(1)
					if πTemp040, πE = πg.ResolveClass(πF, πClass, nil, ßInliner); πE != nil {
						continue
					}
					πTemp041[0] = πTemp040
					if πTemp040, πE = πg.ResolveClass(πF, πClass, nil, ßvars); πE != nil {
						continue
					}
					if πTemp042, πE = πTemp040.Call(πF, πTemp041, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp041)
					if πTemp039, πE = πg.Mod(πF, πg.NewStr("\n                            (\n                              _               # anonymous target\n                            |               # *OR*\n                              (?!_)           # no underscore at the beginning\n                              (?P<quote>`?)   # optional open quote\n                              (?![ `])        # first char. not space or\n                                              # backquote\n                              (?P<name>       # reference name\n                                .+?\n                              )\n                              %(non_whitespace_escape_before)s\n                              (?P=quote)      # close quote if open quote used\n                            )\n                            (?<!(?<!\\x00):) # no unescaped colon at end\n                            %(non_whitespace_escape_before)s\n                            [ ]?            # optional space\n                            :               # end of reference name\n                            ([ ]+|$)        # followed by whitespace\n                            ").ToObject(), πTemp042); πE != nil {
						continue
					}
					πTemp006[0] = πTemp039
					if πTemp040, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp042, πE = πg.GetAttr(πF, πTemp040, ßVERBOSE, nil); πE != nil {
						continue
					}
					if πTemp040, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp043, πE = πg.GetAttr(πF, πTemp040, ßUNICODE, nil); πE != nil {
						continue
					}
					if πTemp039, πE = πg.Or(πF, πTemp042, πTemp043); πE != nil {
						continue
					}
					πTemp006[1] = πTemp039
					if πTemp039, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp040, πE = πg.GetAttr(πF, πTemp039, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp039, πE = πTemp040.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					πTemp006 = πF.MakeArgs(2)
					πTemp041 = πF.MakeArgs(1)
					if πTemp042, πE = πg.ResolveClass(πF, πClass, nil, ßInliner); πE != nil {
						continue
					}
					πTemp041[0] = πTemp042
					if πTemp042, πE = πg.ResolveClass(πF, πClass, nil, ßvars); πE != nil {
						continue
					}
					if πTemp043, πE = πTemp042.Call(πF, πTemp041, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp041)
					if πTemp040, πE = πg.Mod(πF, πg.NewStr("\n                               (\n                                 (?P<simple>%(simplename)s)_\n                               |                  # *OR*\n                                 `                  # open backquote\n                                 (?![ ])            # not space\n                                 (?P<phrase>.+?)    # hyperlink phrase\n                                 %(non_whitespace_escape_before)s\n                                 `_                 # close backquote,\n                                                    # reference mark\n                               )\n                               $                  # end of string\n                               ").ToObject(), πTemp043); πE != nil {
						continue
					}
					πTemp006[0] = πTemp040
					if πTemp042, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp043, πE = πg.GetAttr(πF, πTemp042, ßVERBOSE, nil); πE != nil {
						continue
					}
					if πTemp042, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp044, πE = πg.GetAttr(πF, πTemp042, ßUNICODE, nil); πE != nil {
						continue
					}
					if πTemp040, πE = πg.Or(πF, πTemp043, πTemp044); πE != nil {
						continue
					}
					πTemp006[1] = πTemp040
					if πTemp040, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp042, πE = πg.GetAttr(πF, πTemp040, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp040, πE = πTemp042.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					πTemp006 = πF.MakeArgs(2)
					πTemp041 = πF.MakeArgs(1)
					if πTemp043, πE = πg.ResolveClass(πF, πClass, nil, ßInliner); πE != nil {
						continue
					}
					πTemp041[0] = πTemp043
					if πTemp043, πE = πg.ResolveClass(πF, πClass, nil, ßvars); πE != nil {
						continue
					}
					if πTemp044, πE = πTemp043.Call(πF, πTemp041, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp041)
					if πTemp042, πE = πg.Mod(πF, πg.NewStr("\n                                  (\n                                    (?![ ])          # first char. not space\n                                    (?P<name>.+?)    # substitution text\n                                    %(non_whitespace_escape_before)s\n                                    \\|               # close delimiter\n                                  )\n                                  ([ ]+|$)           # followed by whitespace\n                                  ").ToObject(), πTemp044); πE != nil {
						continue
					}
					πTemp006[0] = πTemp042
					if πTemp043, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp044, πE = πg.GetAttr(πF, πTemp043, ßVERBOSE, nil); πE != nil {
						continue
					}
					if πTemp043, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp045, πE = πg.GetAttr(πF, πTemp043, ßUNICODE, nil); πE != nil {
						continue
					}
					if πTemp042, πE = πg.Or(πF, πTemp044, πTemp045); πE != nil {
						continue
					}
					πTemp006[1] = πTemp042
					if πTemp042, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp043, πE = πg.GetAttr(πF, πTemp042, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp042, πE = πTemp043.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					πTemp004 = πg.KWArgs{
						{"target", πTemp039},
						{"reference", πTemp040},
						{"substitution", πTemp042},
					}
					if πTemp039, πE = πg.ResolveClass(πF, πClass, nil, ßStruct); πE != nil {
						continue
					}
					if πTemp040, πE = πTemp039.Call(πF, nil, πTemp004); πE != nil {
						continue
					}
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp039}, πTemp040); πE != nil {
						continue
					}
					if πTemp042, πE = πg.ResolveClass(πF, πClass, nil, ßexplicit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp042, ßpatterns, πTemp039); πE != nil {
						continue
					}
					// line 1879: def footnote(self, match):
					πF.SetLineno(1879)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp039 = πg.NewFunction(πg.NewCode("footnote", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µsrc *πg.Object = πg.UnboundLocal
						_ = µsrc
						var µsrcline *πg.Object = πg.UnboundLocal
						_ = µsrcline
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µlabel *πg.Object = πg.UnboundLocal
						_ = µlabel
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var µfootnote *πg.Object = πg.UnboundLocal
						_ = µfootnote
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1880: src, srcline = self.state_machine.get_source_and_line()
							πF.SetLineno(1880)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, πTemp001); πE != nil {
								continue
							}
							µsrc = πTemp002
							µsrcline = πTemp003
							// line 1881: indented, indent, offset, blank_finish = \
							πF.SetLineno(1881)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µindent = πTemp003
							µoffset = πTemp005
							µblank_finish = πTemp006
							// line 1883: label = match.group(1)
							πF.SetLineno(1883)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µlabel = πTemp002
							// line 1884: name = normalize_name(label)
							πF.SetLineno(1884)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							πTemp004[0] = µlabel
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µname = πTemp002
							// line 1885: footnote = nodes.footnote('\n'.join(indented))
							πF.SetLineno(1885)
							πTemp004 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp007[0] = µindented
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp004[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßfootnote, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µfootnote = πTemp001
							// line 1886: footnote.source = src
							πF.SetLineno(1886)
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsrc); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µfootnote, ßsource, πTemp001); πE != nil {
								continue
							}
							// line 1887: footnote.line = srcline
							πF.SetLineno(1887)
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsrcline); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µfootnote, ßline, πTemp001); πE != nil {
								continue
							}
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µname, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, µname, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label2
							}
							goto Label3
							// line 1888: if name[0] == '#':              # auto-numbered
							πF.SetLineno(1888)
						Label1:
							// line 1889: name = name[1:]             # autonumber label
							πF.SetLineno(1889)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µname, πTemp001); πE != nil {
								continue
							}
							µname = πTemp002
							// line 1890: footnote['auto'] = 1
							πF.SetLineno(1890)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp002 = ßauto.ToObject()
							if πE = πg.SetItem(πF, µfootnote, πTemp002, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, µname); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label5
							}
							goto Label6
							// line 1891: if name:
							πF.SetLineno(1891)
						Label5:
							// line 1892: footnote['names'].append(name)
							πF.SetLineno(1892)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp004[0] = µname
							πTemp001 = ßnames.ToObject()
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µfootnote, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label6
						Label6:
							// line 1893: self.document.note_autofootnote(footnote)
							πF.SetLineno(1893)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp004[0] = µfootnote
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnote_autofootnote, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label4
							// line 1894: elif name == '*':               # auto-symbol
							πF.SetLineno(1894)
						Label2:
							// line 1895: name = ''
							πF.SetLineno(1895)
							µname = ß.ToObject()
							// line 1896: footnote['auto'] = '*'
							πF.SetLineno(1896)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewStr("*").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp002 = ßauto.ToObject()
							if πE = πg.SetItem(πF, µfootnote, πTemp002, πTemp001); πE != nil {
								continue
							}
							// line 1897: self.document.note_symbol_footnote(footnote)
							πF.SetLineno(1897)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp004[0] = µfootnote
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnote_symbol_footnote, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label4
						Label3:
							// line 1899: footnote += nodes.label('', label)
							πF.SetLineno(1899)
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(2)
							πTemp004[0] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							πTemp004[1] = µlabel
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßlabel, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.IAdd(πF, µfootnote, πTemp001); πE != nil {
								continue
							}
							µfootnote = πTemp002
							// line 1900: footnote['names'].append(name)
							πF.SetLineno(1900)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp004[0] = µname
							πTemp001 = ßnames.ToObject()
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µfootnote, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1901: self.document.note_footnote(footnote)
							πF.SetLineno(1901)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp004[0] = µfootnote
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnote_footnote, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label4
						Label4:
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, µname); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label7
							}
							goto Label8
							// line 1902: if name:
							πF.SetLineno(1902)
						Label7:
							// line 1903: self.document.note_explicit_target(footnote, footnote)
							πF.SetLineno(1903)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp004[0] = µfootnote
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp004[1] = µfootnote
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnote_explicit_target, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label9
						Label8:
							// line 1905: self.document.set_id(footnote, footnote)
							πF.SetLineno(1905)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp004[0] = µfootnote
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp004[1] = µfootnote
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßset_id, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label9
						Label9:
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, µindented); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label10
							}
							goto Label11
							// line 1906: if indented:
							πF.SetLineno(1906)
						Label10:
							// line 1907: self.nested_parse(indented, input_offset=offset, node=footnote)
							πF.SetLineno(1907)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp004[0] = µindented
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"input_offset", µoffset},
								{"node", µfootnote},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label11
						Label11:
							// line 1908: return [footnote], blank_finish
							πF.SetLineno(1908)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µfootnote, "footnote"); πE != nil {
								continue
							}
							πTemp004[0] = µfootnote
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfootnote.ToObject(), πTemp039); πE != nil {
						continue
					}
					// line 1910: def citation(self, match):
					πF.SetLineno(1910)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp040 = πg.NewFunction(πg.NewCode("citation", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µsrc *πg.Object = πg.UnboundLocal
						_ = µsrc
						var µsrcline *πg.Object = πg.UnboundLocal
						_ = µsrcline
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µlabel *πg.Object = πg.UnboundLocal
						_ = µlabel
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var µcitation *πg.Object = πg.UnboundLocal
						_ = µcitation
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1911: src, srcline = self.state_machine.get_source_and_line()
							πF.SetLineno(1911)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, πTemp001); πE != nil {
								continue
							}
							µsrc = πTemp002
							µsrcline = πTemp003
							// line 1912: indented, indent, offset, blank_finish = \
							πF.SetLineno(1912)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µindent = πTemp003
							µoffset = πTemp005
							µblank_finish = πTemp006
							// line 1914: label = match.group(1)
							πF.SetLineno(1914)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µlabel = πTemp002
							// line 1915: name = normalize_name(label)
							πF.SetLineno(1915)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							πTemp004[0] = µlabel
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µname = πTemp002
							// line 1916: citation = nodes.citation('\n'.join(indented))
							πF.SetLineno(1916)
							πTemp004 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp007[0] = µindented
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp004[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßcitation, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µcitation = πTemp001
							// line 1917: citation.source = src
							πF.SetLineno(1917)
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsrc); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcitation, "citation"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µcitation, ßsource, πTemp001); πE != nil {
								continue
							}
							// line 1918: citation.line = srcline
							πF.SetLineno(1918)
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsrcline); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcitation, "citation"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µcitation, ßline, πTemp001); πE != nil {
								continue
							}
							// line 1919: citation += nodes.label('', label)
							πF.SetLineno(1919)
							if πE = πg.CheckLocal(πF, µcitation, "citation"); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(2)
							πTemp004[0] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µlabel, "label"); πE != nil {
								continue
							}
							πTemp004[1] = µlabel
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßlabel, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.IAdd(πF, µcitation, πTemp001); πE != nil {
								continue
							}
							µcitation = πTemp002
							// line 1920: citation['names'].append(name)
							πF.SetLineno(1920)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp004[0] = µname
							πTemp001 = ßnames.ToObject()
							if πE = πg.CheckLocal(πF, µcitation, "citation"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcitation, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1921: self.document.note_citation(citation)
							πF.SetLineno(1921)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcitation, "citation"); πE != nil {
								continue
							}
							πTemp004[0] = µcitation
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnote_citation, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 1922: self.document.note_explicit_target(citation, citation)
							πF.SetLineno(1922)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcitation, "citation"); πE != nil {
								continue
							}
							πTemp004[0] = µcitation
							if πE = πg.CheckLocal(πF, µcitation, "citation"); πE != nil {
								continue
							}
							πTemp004[1] = µcitation
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnote_explicit_target, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, µindented); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label1
							}
							goto Label2
							// line 1923: if indented:
							πF.SetLineno(1923)
						Label1:
							// line 1924: self.nested_parse(indented, input_offset=offset, node=citation)
							πF.SetLineno(1924)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp004[0] = µindented
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcitation, "citation"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"input_offset", µoffset},
								{"node", µcitation},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label2
						Label2:
							// line 1925: return [citation], blank_finish
							πF.SetLineno(1925)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µcitation, "citation"); πE != nil {
								continue
							}
							πTemp004[0] = µcitation
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcitation.ToObject(), πTemp040); πE != nil {
						continue
					}
					// line 1927: def hyperlink_target(self, match):
					πF.SetLineno(1927)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp042 = πg.NewFunction(πg.NewCode("hyperlink_target", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µpattern *πg.Object = πg.UnboundLocal
						_ = µpattern
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µblock *πg.Object = πg.UnboundLocal
						_ = µblock
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µblocktext *πg.Object = πg.UnboundLocal
						_ = µblocktext
						var µescaped *πg.Object = πg.UnboundLocal
						_ = µescaped
						var µblockindex *πg.Object = πg.UnboundLocal
						_ = µblockindex
						var µtargetmatch *πg.Object = πg.UnboundLocal
						_ = µtargetmatch
						var µtarget *πg.Object = πg.UnboundLocal
						_ = µtarget
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []πg.Param
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πTemp011 *πg.BaseException
						_ = πTemp011
						var πTemp012 *πg.Traceback
						_ = πTemp012
						var πTemp013 *πg.Object
						_ = πTemp013
						var πTemp014 *πg.Object
						_ = πTemp014
						var πTemp015 []*πg.Object
						_ = πTemp015
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 1928: pattern = self.explicit.patterns.target
							πF.SetLineno(1928)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßexplicit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßtarget, nil); πE != nil {
								continue
							}
							µpattern = πTemp001
							// line 1929: lineno = self.state_machine.abs_line_number()
							πF.SetLineno(1929)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 1930: block, indent, offset, blank_finish = \
							πF.SetLineno(1930)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"until_blank", πTemp001},
								{"strip_indent", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp001); πE != nil {
								continue
							}
							µblock = πTemp002
							µindent = πTemp005
							µoffset = πTemp006
							µblank_finish = πTemp007
							// line 1933: blocktext = match.string[:match.end()] + '\n'.join(block)
							πF.SetLineno(1933)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp006, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003[0] = µblock
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Add(πF, πTemp005, πTemp006); πE != nil {
								continue
							}
							µblocktext = πTemp001
							// line 1934: block = [escape2null(line) for line in block]
							πF.SetLineno(1934)
							πTemp008 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µline *πg.Object = πg.UnboundLocal
								_ = µline
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µblock); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µline = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 1934: block = [escape2null(line) for line in block]
										πF.SetLineno(1934)
										πTemp005 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
											continue
										}
										πTemp005[0] = µline
										if πTemp004, πE = πg.ResolveGlobal(πF, ßescape2null); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							µblock = πTemp001
							// line 1935: escaped = block[0]
							πF.SetLineno(1935)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µblock, πTemp001); πE != nil {
								continue
							}
							µescaped = πTemp005
							// line 1936: blockindex = 0
							πF.SetLineno(1936)
							µblockindex = πg.NewInt(0).ToObject()
							// line 1937: while True:
							πF.SetLineno(1937)
							πF.PushCheckpoint(2)
							πTemp009 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp009 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πTemp010, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp010 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 1938: targetmatch = pattern.match(escaped)
							πF.SetLineno(1938)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							πTemp003[0] = µescaped
							if πE = πg.CheckLocal(πF, µpattern, "pattern"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpattern, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtargetmatch = πTemp005
							if πE = πg.CheckLocal(πF, µtargetmatch, "targetmatch"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.IsTrue(πF, µtargetmatch); πE != nil {
								continue
							}
							if πTemp010 {
								goto Label4
							}
							goto Label5
							// line 1939: if targetmatch:
							πF.SetLineno(1939)
						Label4:
							// line 1940: break
							πF.SetLineno(1940)
							πTemp009 = true
							continue
							goto Label5
						Label5:
							// line 1941: blockindex += 1
							πF.SetLineno(1941)
							if πE = πg.CheckLocal(πF, µblockindex, "blockindex"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µblockindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µblockindex = πTemp001
							// line 1942: try:
							πF.SetLineno(1942)
							πF.PushCheckpoint(7)
							// line 1943: escaped += block[blockindex]
							πF.SetLineno(1943)
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblockindex, "blockindex"); πE != nil {
								continue
							}
							πTemp001 = µblockindex
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µblock, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µescaped, πTemp005); πE != nil {
								continue
							}
							µescaped = πTemp001
							πF.PopCheckpoint()
							goto Label6
						Label7:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp011, πTemp012 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßIndexError); πE != nil {
								continue
							}
							if πTemp010, πE = πg.IsInstance(πF, πTemp011.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp010 {
								goto Label8
							}
							πE = πF.Raise(πTemp011.ToObject(), nil, πTemp012.ToObject())
							continue
							// line 1944: except IndexError:
							πF.SetLineno(1944)
						Label8:
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("malformed hyperlink target.").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 1945: raise MarkupError('malformed hyperlink target.')
							πF.SetLineno(1945)
							πE = πF.Raise(πTemp005, nil, nil)
							continue
							πF.RestoreExc(nil, nil)
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 1946: del block[:blockindex]
							πF.SetLineno(1946)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblockindex, "blockindex"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µblockindex, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.DelItem(πF, µblock, πTemp001); πE != nil {
								continue
							}
							// line 1947: block[0] = (block[0] + ' ')[targetmatch.end()-len(escaped)-1:].strip()
							πF.SetLineno(1947)
							if πE = πg.CheckLocal(πF, µtargetmatch, "targetmatch"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, µtargetmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp013, πE = πTemp007.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							πTemp003[0] = µescaped
							if πTemp007, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp014, πE = πTemp007.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp006, πE = πg.Sub(πF, πTemp013, πTemp014); πE != nil {
								continue
							}
							if πTemp005, πE = πg.Sub(πF, πTemp006, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp005, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							πTemp007 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp013, πE = πg.GetItem(πF, µblock, πTemp007); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Add(πF, πTemp013, πg.NewStr(" ").ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp005, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp006 = πg.NewInt(0).ToObject()
							if πE = πg.SetItem(πF, µblock, πTemp006, πTemp001); πE != nil {
								continue
							}
							// line 1948: target = self.make_target(block, blocktext, lineno,
							πF.SetLineno(1948)
							πTemp003 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003[0] = µblock
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp003[1] = µblocktext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[2] = µlineno
							πTemp015 = πF.MakeArgs(1)
							πTemp015[0] = ßname.ToObject()
							if πE = πg.CheckLocal(πF, µtargetmatch, "targetmatch"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtargetmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp015, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp015)
							πTemp003[3] = πTemp005
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmake_target, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtarget = πTemp005
							// line 1950: return [target], blank_finish
							πF.SetLineno(1950)
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp003[0] = µtarget
							πTemp005 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp005, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßhyperlink_target.ToObject(), πTemp042); πE != nil {
						continue
					}
					// line 1952: def make_target(self, block, block_text, lineno, target_name):
					πF.SetLineno(1952)
					πTemp016 = make([]πg.Param, 5)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "block", Def: nil}
					πTemp016[2] = πg.Param{Name: "block_text", Def: nil}
					πTemp016[3] = πg.Param{Name: "lineno", Def: nil}
					πTemp016[4] = πg.Param{Name: "target_name", Def: nil}
					πTemp043 = πg.NewFunction(πg.NewCode("make_target", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µblock *πg.Object = πArgs[1]
						_ = µblock
						var µblock_text *πg.Object = πArgs[2]
						_ = µblock_text
						var µlineno *πg.Object = πArgs[3]
						_ = µlineno
						var µtarget_name *πg.Object = πArgs[4]
						_ = µtarget_name
						var µtarget_type *πg.Object = πg.UnboundLocal
						_ = µtarget_type
						var µdata *πg.Object = πg.UnboundLocal
						_ = µdata
						var µtarget *πg.Object = πg.UnboundLocal
						_ = µtarget
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 πg.KWArgs
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1953: target_type, data = self.parse_target(block, block_text, lineno)
							πF.SetLineno(1953)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp001[0] = µblock
							if πE = πg.CheckLocal(πF, µblock_text, "block_text"); πE != nil {
								continue
							}
							πTemp001[1] = µblock_text
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[2] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparse_target, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µtarget_type = πTemp002
							µdata = πTemp004
							if πE = πg.CheckLocal(πF, µtarget_type, "target_type"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µtarget_type, ßrefname.ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µtarget_type, "target_type"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µtarget_type, ßrefuri.ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label2
							}
							goto Label3
							// line 1954: if target_type == 'refname':
							πF.SetLineno(1954)
						Label1:
							// line 1955: target = nodes.target(block_text, '', refname=normalize_name(data))
							πF.SetLineno(1955)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblock_text, "block_text"); πE != nil {
								continue
							}
							πTemp001[0] = µblock_text
							πTemp001[1] = ß.ToObject()
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp006[0] = µdata
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp007 = πg.KWArgs{
								{"refname", πTemp003},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtarget, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtarget = πTemp002
							// line 1956: target.indirect_reference_name = data
							πF.SetLineno(1956)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µdata); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µtarget, ßindirect_reference_name, πTemp002); πE != nil {
								continue
							}
							// line 1957: self.add_target(target_name, '', target, lineno)
							πF.SetLineno(1957)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µtarget_name, "target_name"); πE != nil {
								continue
							}
							πTemp001[0] = µtarget_name
							πTemp001[1] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp001[2] = µtarget
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[3] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd_target, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1958: self.document.note_indirect_target(target)
							πF.SetLineno(1958)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp001[0] = µtarget
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßnote_indirect_target, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1959: return target
							πF.SetLineno(1959)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πR = µtarget
							continue
							goto Label4
							// line 1960: elif target_type == 'refuri':
							πF.SetLineno(1960)
						Label2:
							// line 1961: target = nodes.target(block_text, '')
							πF.SetLineno(1961)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblock_text, "block_text"); πE != nil {
								continue
							}
							πTemp001[0] = µblock_text
							πTemp001[1] = ß.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßtarget, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtarget = πTemp002
							// line 1962: self.add_target(target_name, data, target, lineno)
							πF.SetLineno(1962)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µtarget_name, "target_name"); πE != nil {
								continue
							}
							πTemp001[0] = µtarget_name
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp001[1] = µdata
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp001[2] = µtarget
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[3] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd_target, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 1963: return target
							πF.SetLineno(1963)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πR = µtarget
							continue
							goto Label4
						Label3:
							// line 1965: return data
							πF.SetLineno(1965)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πR = µdata
							continue
							goto Label4
						Label4:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßmake_target.ToObject(), πTemp043); πE != nil {
						continue
					}
					// line 1967: def parse_target(self, block, block_text, lineno):
					πF.SetLineno(1967)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "block", Def: nil}
					πTemp016[2] = πg.Param{Name: "block_text", Def: nil}
					πTemp016[3] = πg.Param{Name: "lineno", Def: nil}
					πTemp044 = πg.NewFunction(πg.NewCode("parse_target", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µblock *πg.Object = πArgs[1]
						_ = µblock
						var µblock_text *πg.Object = πArgs[2]
						_ = µblock_text
						var µlineno *πg.Object = πArgs[3]
						_ = µlineno
						var µreference *πg.Object = πg.UnboundLocal
						_ = µreference
						var µrefname *πg.Object = πg.UnboundLocal
						_ = µrefname
						var µref_parts *πg.Object = πg.UnboundLocal
						_ = µref_parts
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 []πg.Param
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1968: """
							πF.SetLineno(1968)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp001 = µblock
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							if πTemp005, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πTemp005, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp006 = πTemp007
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µblock, πTemp006); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp007, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp007, πTemp004); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Eq(πF, πTemp005, ß_.ToObject()); πE != nil {
								continue
							}
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 1977: if block and block[-1].strip()[-1:] == '_': # possible indirect target
							πF.SetLineno(1977)
						Label2:
							// line 1978: reference = ' '.join([line.strip() for line in block])
							πF.SetLineno(1978)
							πTemp008 = πF.MakeArgs(1)
							πTemp009 = make([]πg.Param, 0)
							πTemp003 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp009, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µline *πg.Object = πg.UnboundLocal
								_ = µline
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 *πg.Object
								_ = πTemp005
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µblock); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µline = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 1978: reference = ' '.join([line.strip() for line in block])
										πF.SetLineno(1978)
										if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
											continue
										}
										if πTemp004, πE = πg.GetAttr(πF, µline, ßstrip, nil); πE != nil {
											continue
										}
										if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
											continue
										}
										πF.PushCheckpoint(4)
										return πTemp005, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp004}, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp001
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							µreference = πTemp004
							// line 1979: refname = self.is_reference(reference)
							πF.SetLineno(1979)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp008[0] = µreference
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßis_reference, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							µrefname = πTemp004
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µrefname); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 1980: if refname:
							πF.SetLineno(1980)
						Label4:
							// line 1981: return 'refname', refname
							πF.SetLineno(1981)
							if πE = πg.CheckLocal(πF, µrefname, "refname"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(ßrefname.ToObject(), µrefname).ToObject()
							πR = πTemp001
							continue
							goto Label5
						Label5:
							goto Label3
						Label3:
							// line 1982: ref_parts = split_escaped_whitespace(' '.join(block))
							πF.SetLineno(1982)
							πTemp008 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp010[0] = µblock
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp008[0] = πTemp004
							if πTemp001, πE = πg.ResolveGlobal(πF, ßsplit_escaped_whitespace); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							µref_parts = πTemp004
							// line 1983: reference = ' '.join(''.join(unescape(part).split())
							πF.SetLineno(1983)
							πTemp008 = πF.MakeArgs(1)
							πTemp009 = make([]πg.Param, 0)
							πTemp001 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp009, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µpart *πg.Object = πg.UnboundLocal
								_ = µpart
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 []*πg.Object
								_ = πTemp006
								var πTemp007 *πg.Object
								_ = πTemp007
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µref_parts, "ref_parts"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µref_parts); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µpart = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 1983: reference = ' '.join(''.join(unescape(part).split())
										πF.SetLineno(1983)
										πTemp005 = πF.MakeArgs(1)
										πTemp006 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
											continue
										}
										πTemp006[0] = µpart
										if πTemp004, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
											continue
										}
										if πTemp007, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp006)
										if πTemp004, πE = πg.GetAttr(πF, πTemp007, ßsplit, nil); πE != nil {
											continue
										}
										if πTemp007, πE = πTemp004.Call(πF, nil, nil); πE != nil {
											continue
										}
										πTemp005[0] = πTemp007
										if πTemp004, πE = πg.GetAttr(πF, ß.ToObject(), ßjoin, nil); πE != nil {
											continue
										}
										if πTemp007, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp007, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp004, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp004
							if πTemp004, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							µreference = πTemp005
							// line 1985: return 'refuri', reference
							πF.SetLineno(1985)
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple2(ßrefuri.ToObject(), µreference).ToObject()
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_target.ToObject(), πTemp044); πE != nil {
						continue
					}
					// line 1968: """
					πF.SetLineno(1968)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp045}, πg.NewStr("\n        Determine the type of reference of a target.\n\n        :Return: A 2-tuple, one of:\n\n            - 'refname' and the indirect reference name\n            - 'refuri' and the URI\n            - 'malformed' and a system_message node\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp046, πE = πg.ResolveClass(πF, πClass, nil, ßparse_target); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp046, ß__doc__, πTemp045); πE != nil {
						continue
					}
					// line 1987: def is_reference(self, reference):
					πF.SetLineno(1987)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "reference", Def: nil}
					πTemp045 = πg.NewFunction(πg.NewCode("is_reference", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µreference *πg.Object = πArgs[1]
						_ = µreference
						var µmatch *πg.Object = πg.UnboundLocal
						_ = µmatch
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1988: match = self.explicit.patterns.reference.match(
							πF.SetLineno(1988)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µreference, "reference"); πE != nil {
								continue
							}
							πTemp002[0] = µreference
							if πTemp003, πE = πg.ResolveGlobal(πF, ßwhitespace_normalize_name); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßexplicit, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßreference, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmatch = πTemp003
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µmatch); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp005).ToObject()
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 1990: if not match:
							πF.SetLineno(1990)
						Label1:
							// line 1991: return None
							πF.SetLineno(1991)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πR = πTemp003
							continue
							goto Label2
						Label2:
							// line 1992: return unescape(match.group('simple') or match.group('phrase'))
							πF.SetLineno(1992)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßsimple.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp003 = πTemp006
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label3
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = ßphrase.ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp003 = πTemp006
						Label3:
							πTemp001[0] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp004
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßis_reference.ToObject(), πTemp045); πE != nil {
						continue
					}
					// line 1994: def add_target(self, targetname, refuri, target, lineno):
					πF.SetLineno(1994)
					πTemp016 = make([]πg.Param, 5)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "targetname", Def: nil}
					πTemp016[2] = πg.Param{Name: "refuri", Def: nil}
					πTemp016[3] = πg.Param{Name: "target", Def: nil}
					πTemp016[4] = πg.Param{Name: "lineno", Def: nil}
					πTemp046 = πg.NewFunction(πg.NewCode("add_target", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtargetname *πg.Object = πArgs[1]
						_ = µtargetname
						var µrefuri *πg.Object = πArgs[2]
						_ = µrefuri
						var µtarget *πg.Object = πArgs[3]
						_ = µtarget
						var µlineno *πg.Object = πArgs[4]
						_ = µlineno
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var µuri *πg.Object = πg.UnboundLocal
						_ = µuri
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 1995: target.line = lineno
							πF.SetLineno(1995)
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µlineno); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µtarget, ßline, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtargetname, "targetname"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µtargetname); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							goto Label2
							// line 1996: if targetname:
							πF.SetLineno(1996)
						Label1:
							// line 1997: name = normalize_name(unescape(targetname))
							πF.SetLineno(1997)
							πTemp003 = πF.MakeArgs(1)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtargetname, "targetname"); πE != nil {
								continue
							}
							πTemp004[0] = µtargetname
							if πTemp001, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003[0] = πTemp005
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnormalize_name); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µname = πTemp005
							// line 1998: target['names'].append(name)
							πF.SetLineno(1998)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp003[0] = µname
							πTemp001 = ßnames.ToObject()
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µtarget, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp005, ßappend, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.CheckLocal(πF, µrefuri, "refuri"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µrefuri); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 1999: if refuri:
							πF.SetLineno(1999)
						Label4:
							// line 2000: uri = self.inliner.adjust_uri(refuri)
							πF.SetLineno(2000)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrefuri, "refuri"); πE != nil {
								continue
							}
							πTemp003[0] = µrefuri
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßinliner, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp001, ßadjust_uri, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µuri = πTemp001
							if πE = πg.CheckLocal(πF, µuri, "uri"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µuri); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label6
							}
							goto Label7
							// line 2001: if uri:
							πF.SetLineno(2001)
						Label6:
							// line 2002: target['refuri'] = uri
							πF.SetLineno(2002)
							if πE = πg.CheckLocal(πF, µuri, "uri"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µuri); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp005 = ßrefuri.ToObject()
							if πE = πg.SetItem(πF, µtarget, πTemp005, πTemp001); πE != nil {
								continue
							}
							goto Label8
						Label7:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrefuri, "refuri"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("problem with URI: %r").ToObject(), µrefuri); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßApplicationError); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2004: raise ApplicationError('problem with URI: %r' % refuri)
							πF.SetLineno(2004)
							πE = πF.Raise(πTemp005, nil, nil)
							continue
							goto Label8
						Label8:
							goto Label5
						Label5:
							// line 2005: self.document.note_explicit_target(target, self.parent)
							πF.SetLineno(2005)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp003[0] = µtarget
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp001, ßnote_explicit_target, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label3
						Label2:
							if πE = πg.CheckLocal(πF, µrefuri, "refuri"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µrefuri); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label9
							}
							goto Label10
							// line 2007: if refuri:
							πF.SetLineno(2007)
						Label9:
							// line 2008: target['refuri'] = refuri
							πF.SetLineno(2008)
							if πE = πg.CheckLocal(πF, µrefuri, "refuri"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µrefuri); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp005 = ßrefuri.ToObject()
							if πE = πg.SetItem(πF, µtarget, πTemp005, πTemp001); πE != nil {
								continue
							}
							goto Label10
						Label10:
							// line 2009: target['anonymous'] = 1
							πF.SetLineno(2009)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp005 = ßanonymous.ToObject()
							if πE = πg.SetItem(πF, µtarget, πTemp005, πTemp001); πE != nil {
								continue
							}
							// line 2010: self.document.note_anonymous_target(target)
							πF.SetLineno(2010)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp003[0] = µtarget
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp001, ßnote_anonymous_target, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßadd_target.ToObject(), πTemp046); πE != nil {
						continue
					}
					// line 2012: def substitution_def(self, match):
					πF.SetLineno(2012)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp047 = πg.NewFunction(πg.NewCode("substitution_def", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µpattern *πg.Object = πg.UnboundLocal
						_ = µpattern
						var µsrc *πg.Object = πg.UnboundLocal
						_ = µsrc
						var µsrcline *πg.Object = πg.UnboundLocal
						_ = µsrcline
						var µblock *πg.Object = πg.UnboundLocal
						_ = µblock
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µblocktext *πg.Object = πg.UnboundLocal
						_ = µblocktext
						var µescaped *πg.Object = πg.UnboundLocal
						_ = µescaped
						var µblockindex *πg.Object = πg.UnboundLocal
						_ = µblockindex
						var µsubdefmatch *πg.Object = πg.UnboundLocal
						_ = µsubdefmatch
						var µsubname *πg.Object = πg.UnboundLocal
						_ = µsubname
						var µsubstitution_node *πg.Object = πg.UnboundLocal
						_ = µsubstitution_node
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var µnew_abs_offset *πg.Object = πg.UnboundLocal
						_ = µnew_abs_offset
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var µnode *πg.Object = πg.UnboundLocal
						_ = µnode
						var µpformat *πg.Object = πg.UnboundLocal
						_ = µpformat
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 πg.KWArgs
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 *πg.BaseException
						_ = πTemp010
						var πTemp011 *πg.Traceback
						_ = πTemp011
						var πTemp012 *πg.Object
						_ = πTemp012
						var πTemp013 bool
						_ = πTemp013
						var πTemp014 bool
						_ = πTemp014
						var πTemp015 []*πg.Object
						_ = πTemp015
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							case 7:
								goto Label7
							case 11:
								goto Label11
							case 12:
								goto Label12
							case 17:
								goto Label17
							case 18:
								goto Label18
							case 24:
								goto Label24
							case 25:
								goto Label25
							default:
								panic("unexpected function state")
							}
							// line 2013: pattern = self.explicit.patterns.substitution
							πF.SetLineno(2013)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßexplicit, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßsubstitution, nil); πE != nil {
								continue
							}
							µpattern = πTemp001
							// line 2014: src, srcline = self.state_machine.get_source_and_line()
							πF.SetLineno(2014)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, πTemp001); πE != nil {
								continue
							}
							µsrc = πTemp002
							µsrcline = πTemp003
							// line 2015: block, indent, offset, blank_finish = \
							πF.SetLineno(2015)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"strip_indent", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp001); πE != nil {
								continue
							}
							µblock = πTemp002
							µindent = πTemp003
							µoffset = πTemp006
							µblank_finish = πTemp007
							// line 2018: blocktext = (match.string[:match.end()] + '\n'.join(block))
							πF.SetLineno(2018)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp006, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp004[0] = µblock
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Add(πF, πTemp003, πTemp006); πE != nil {
								continue
							}
							µblocktext = πTemp001
							// line 2019: block.disconnect()
							πF.SetLineno(2019)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µblock, ßdisconnect, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2020: escaped = escape2null(block[0].rstrip())
							πF.SetLineno(2020)
							πTemp004 = πF.MakeArgs(1)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µblock, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßescape2null); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µescaped = πTemp002
							// line 2021: blockindex = 0
							πF.SetLineno(2021)
							µblockindex = πg.NewInt(0).ToObject()
							// line 2022: while True:
							πF.SetLineno(2022)
							πF.PushCheckpoint(2)
							πTemp008 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp008 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2023: subdefmatch = pattern.match(escaped)
							πF.SetLineno(2023)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							πTemp004[0] = µescaped
							if πE = πg.CheckLocal(πF, µpattern, "pattern"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µpattern, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µsubdefmatch = πTemp002
							if πE = πg.CheckLocal(πF, µsubdefmatch, "subdefmatch"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, µsubdefmatch); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label4
							}
							goto Label5
							// line 2024: if subdefmatch:
							πF.SetLineno(2024)
						Label4:
							// line 2025: break
							πF.SetLineno(2025)
							πTemp008 = true
							continue
							goto Label5
						Label5:
							// line 2026: blockindex += 1
							πF.SetLineno(2026)
							if πE = πg.CheckLocal(πF, µblockindex, "blockindex"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µblockindex, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µblockindex = πTemp001
							// line 2027: try:
							πF.SetLineno(2027)
							πF.PushCheckpoint(7)
							// line 2028: escaped = escaped + ' ' + escape2null(block[blockindex].strip())
							πF.SetLineno(2028)
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µescaped, πg.NewStr(" ").ToObject()); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblockindex, "blockindex"); πE != nil {
								continue
							}
							πTemp003 = µblockindex
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µblock, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp006, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp006
							if πTemp003, πE = πg.ResolveGlobal(πF, ßescape2null); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp006); πE != nil {
								continue
							}
							µescaped = πTemp001
							πF.PopCheckpoint()
							goto Label6
						Label7:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp010, πTemp011 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßIndexError); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsInstance(πF, πTemp010.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label8
							}
							πE = πF.Raise(πTemp010.ToObject(), nil, πTemp011.ToObject())
							continue
							// line 2029: except IndexError:
							πF.SetLineno(2029)
						Label8:
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("malformed substitution definition.").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 2030: raise MarkupError('malformed substitution definition.')
							πF.SetLineno(2030)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							πF.RestoreExc(nil, nil)
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2031: del block[:blockindex]          # strip out the substitution marker
							πF.SetLineno(2031)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblockindex, "blockindex"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µblockindex, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.DelItem(πF, µblock, πTemp001); πE != nil {
								continue
							}
							// line 2032: block[0] = (block[0].strip() + ' ')[subdefmatch.end()-len(escaped)-1:-1]
							πF.SetLineno(2032)
							if πE = πg.CheckLocal(πF, µsubdefmatch, "subdefmatch"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µsubdefmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µescaped, "escaped"); πE != nil {
								continue
							}
							πTemp004[0] = µescaped
							if πTemp006, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp012, πE = πTemp006.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp003, πE = πg.Sub(πF, πTemp007, πTemp012); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Sub(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp002, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							πTemp006 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µblock, πTemp006); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp007, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp007, πg.NewStr(" ").ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp003, πTemp001); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.SetItem(πF, µblock, πTemp003, πTemp001); πE != nil {
								continue
							}
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µblock, πTemp002); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp008).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label9
							}
							goto Label10
							// line 2033: if not block[0]:
							πF.SetLineno(2033)
						Label9:
							// line 2034: del block[0]
							πF.SetLineno(2034)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.DelItem(πF, µblock, πTemp001); πE != nil {
								continue
							}
							// line 2035: offset += 1
							πF.SetLineno(2035)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µoffset, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp001
							goto Label10
						Label10:
							// line 2036: while block and not block[-1].strip():
							πF.SetLineno(2036)
							πF.PushCheckpoint(12)
							πTemp008 = false
						Label11:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp008 {
								πF.PopCheckpoint()
								goto Label13
							}
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp001 = µblock
							if πTemp013, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp013 {
								goto Label14
							}
							if πTemp006, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp006
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µblock, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp006, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp014, πE = πg.IsTrue(πF, πTemp006); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp014).ToObject()
							πTemp001 = πTemp002
						Label14:
							if πTemp009, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(11)
							// line 2037: block.pop()
							πF.SetLineno(2037)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µblock, ßpop, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label12:
							if πE != nil || πR != nil {
								continue
							}
						Label13:
							// line 2038: subname = subdefmatch.group('name')
							πF.SetLineno(2038)
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = ßname.ToObject()
							if πE = πg.CheckLocal(πF, µsubdefmatch, "subdefmatch"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µsubdefmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µsubname = πTemp002
							// line 2039: substitution_node = nodes.substitution_definition(blocktext)
							πF.SetLineno(2039)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp004[0] = µblocktext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsubstitution_definition, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µsubstitution_node = πTemp001
							// line 2040: substitution_node.source = src
							πF.SetLineno(2040)
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsrc); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µsubstitution_node, ßsource, πTemp001); πE != nil {
								continue
							}
							// line 2041: substitution_node.line = srcline
							πF.SetLineno(2041)
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsrcline); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µsubstitution_node, ßline, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, µblock); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp008).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label15
							}
							goto Label16
							// line 2042: if not block:
							πF.SetLineno(2042)
						Label15:
							// line 2043: msg = self.reporter.warning(
							πF.SetLineno(2043)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsubname, "subname"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("Substitution definition \"%s\" missing contents.").ToObject(), µsubname); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							πTemp015 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp015[0] = µblocktext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp015[1] = µblocktext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp015, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp015)
							πTemp004[1] = πTemp001
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"source", µsrc},
								{"line", µsrcline},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µmsg = πTemp001
							// line 2047: return [msg], blank_finish
							πF.SetLineno(2047)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp004[0] = µmsg
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, µblank_finish).ToObject()
							πR = πTemp001
							continue
							goto Label16
						Label16:
							// line 2048: block[0] = block[0].strip()
							πF.SetLineno(2048)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µblock, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.SetItem(πF, µblock, πTemp003, πTemp001); πE != nil {
								continue
							}
							// line 2049: substitution_node['names'].append(
							πF.SetLineno(2049)
							πTemp004 = πF.MakeArgs(1)
							πTemp015 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsubname, "subname"); πE != nil {
								continue
							}
							πTemp015[0] = µsubname
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwhitespace_normalize_name, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp015, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp015)
							πTemp004[0] = πTemp001
							πTemp001 = ßnames.ToObject()
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µsubstitution_node, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 2051: new_abs_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(2051)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp004[0] = µblock
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"input_offset", µoffset},
								{"node", µsubstitution_node},
								{"initial_state", ßSubstitutionDef.ToObject()},
								{"blank_finish", µblank_finish},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µnew_abs_offset = πTemp001
							µblank_finish = πTemp003
							// line 2054: i = 0
							πF.SetLineno(2054)
							µi = πg.NewInt(0).ToObject()
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µsubstitution_node, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(18)
							πTemp008 = false
						Label17:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp008 {
								πF.PopCheckpoint()
								goto Label19
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp009 = !isStop
							} else {
								πTemp009 = true
								µnode = πTemp002
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(17)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp004[0] = µnode
							if πTemp006, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßInline, nil); πE != nil {
								continue
							}
							πTemp004[1] = πTemp007
							if πTemp006, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003 = πTemp007
							if πTemp009, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label20
							}
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp004[0] = µnode
							if πTemp006, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp006, ßText, nil); πE != nil {
								continue
							}
							πTemp004[1] = πTemp007
							if πTemp006, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp006.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							πTemp003 = πTemp007
						Label20:
							if πTemp009, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp009).ToObject()
							if πTemp009, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label21
							}
							goto Label22
							// line 2056: if not (isinstance(node, nodes.Inline) or
							πF.SetLineno(2056)
						Label21:
							// line 2058: self.parent += substitution_node[i]
							πF.SetLineno(2058)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp003 = µi
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetItem(πF, µsubstitution_node, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, πTemp006); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2059: del substitution_node[i]
							πF.SetLineno(2059)
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp002 = µi
							if πE = πg.DelItem(πF, µsubstitution_node, πTemp002); πE != nil {
								continue
							}
							goto Label23
						Label22:
							// line 2061: i += 1
							πF.SetLineno(2061)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µi = πTemp002
							goto Label23
						Label23:
							continue
						Label18:
							if πE != nil || πR != nil {
								continue
							}
						Label19:
							πTemp004 = πF.MakeArgs(1)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßElement, nil); πE != nil {
								continue
							}
							πTemp004[0] = πTemp003
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µsubstitution_node, ßtraverse, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(25)
							πTemp008 = false
						Label24:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp008 {
								πF.PopCheckpoint()
								goto Label26
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp009 = !isStop
							} else {
								πTemp009 = true
								µnode = πTemp002
							}
							if πE != nil || !πTemp009 {
								continue
							}
							πF.PushCheckpoint(24)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp004[0] = µnode
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdisallowed_inside_substitution_definitions, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp009, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label27
							}
							goto Label28
							// line 2063: if self.disallowed_inside_substitution_definitions(node):
							πF.SetLineno(2063)
						Label27:
							// line 2064: pformat = nodes.literal_block('', node.pformat().rstrip())
							πF.SetLineno(2064)
							πTemp004 = πF.MakeArgs(2)
							πTemp004[0] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µnode, ßpformat, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp004[1] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µpformat = πTemp002
							// line 2065: msg = self.reporter.error(
							πF.SetLineno(2065)
							πTemp004 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µnode, ßtagname, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("Substitution definition contains illegal element <%s>:").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µpformat, "pformat"); πE != nil {
								continue
							}
							πTemp004[1] = µpformat
							πTemp015 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp015[0] = µblocktext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp015[1] = µblocktext
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp015, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp015)
							πTemp004[2] = πTemp002
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"source", µsrc},
								{"line", µsrcline},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µmsg = πTemp002
							// line 2070: return [msg], blank_finish
							πF.SetLineno(2070)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp004[0] = µmsg
							πTemp003 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp003, µblank_finish).ToObject()
							πR = πTemp002
							continue
							goto Label28
						Label28:
							continue
						Label25:
							if πE != nil || πR != nil {
								continue
							}
						Label26:
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							πTemp004[0] = µsubstitution_node
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.Eq(πF, πTemp003, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label29
							}
							goto Label30
							// line 2071: if len(substitution_node) == 0:
							πF.SetLineno(2071)
						Label29:
							// line 2072: msg = self.reporter.warning(
							πF.SetLineno(2072)
							πTemp004 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsubname, "subname"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("Substitution definition \"%s\" empty or invalid.").ToObject(), µsubname); πE != nil {
								continue
							}
							πTemp004[0] = πTemp001
							πTemp015 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp015[0] = µblocktext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp015[1] = µblocktext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp015, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp015)
							πTemp004[1] = πTemp001
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"source", µsrc},
								{"line", µsrcline},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							µmsg = πTemp001
							// line 2076: return [msg], blank_finish
							πF.SetLineno(2076)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp004[0] = µmsg
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, µblank_finish).ToObject()
							πR = πTemp001
							continue
							goto Label30
						Label30:
							// line 2077: self.document.note_substitution_def(
							πF.SetLineno(2077)
							πTemp004 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							πTemp004[0] = µsubstitution_node
							if πE = πg.CheckLocal(πF, µsubname, "subname"); πE != nil {
								continue
							}
							πTemp004[1] = µsubname
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp004[2] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnote_substitution_def, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							// line 2079: return [substitution_node], blank_finish
							πF.SetLineno(2079)
							πTemp004 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µsubstitution_node, "substitution_node"); πE != nil {
								continue
							}
							πTemp004[0] = µsubstitution_node
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßsubstitution_def.ToObject(), πTemp047); πE != nil {
						continue
					}
					// line 2081: def disallowed_inside_substitution_definitions(self, node):
					πF.SetLineno(2081)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "node", Def: nil}
					πTemp048 = πg.NewFunction(πg.NewCode("disallowed_inside_substitution_definitions", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µnode *πg.Object = πArgs[1]
						_ = µnode
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							πTemp003 = ßids.ToObject()
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µnode, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πTemp004
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp006[0] = µnode
							if πTemp004, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp004, ßreference, nil); πE != nil {
								continue
							}
							πTemp006[1] = πTemp007
							if πTemp004, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp003 = πTemp007
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label2
							}
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = ßanonymous.ToObject()
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µnode, ßget, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp003 = πTemp007
						Label2:
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label1
							}
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp006[0] = µnode
							if πTemp004, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp004, ßfootnote_reference, nil); πE != nil {
								continue
							}
							πTemp006[1] = πTemp007
							if πTemp004, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp003 = πTemp007
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp005 {
								goto Label3
							}
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = ßauto.ToObject()
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µnode, ßget, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp003 = πTemp007
						Label3:
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label4
							}
							goto Label5
							// line 2082: if (node['ids'] or
							πF.SetLineno(2082)
						Label4:
							// line 2085: return True
							πF.SetLineno(2085)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label6
						Label5:
							// line 2087: return False
							πF.SetLineno(2087)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πR = πTemp001
							continue
							goto Label6
						Label6:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdisallowed_inside_substitution_definitions.ToObject(), πTemp048); πE != nil {
						continue
					}
					// line 2089: def directive(self, match, **option_presets):
					πF.SetLineno(2089)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp049 = πg.NewFunction(πg.NewCode("directive", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, πg.CodeFlagKWArg, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µoption_presets *πg.Object = πArgs[2]
						_ = µoption_presets
						var µtype_name *πg.Object = πg.UnboundLocal
						_ = µtype_name
						var µdirective_class *πg.Object = πg.UnboundLocal
						_ = µdirective_class
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2090: """Returns a 2-tuple: list of nodes, and a "blank finish" boolean."""
							πF.SetLineno(2090)
							// line 2091: type_name = match.group(1)
							πF.SetLineno(2091)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßgroup, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtype_name = πTemp003
							// line 2092: directive_class, messages = directives.directive(
							πF.SetLineno(2092)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µtype_name, "type_name"); πE != nil {
								continue
							}
							πTemp001[0] = µtype_name
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßmemo, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßlanguage, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdocument, nil); πE != nil {
								continue
							}
							πTemp001[2] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßdirectives); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßdirective, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µdirective_class = πTemp003
							µmessages = πTemp004
							// line 2094: self.parent += messages
							πF.SetLineno(2094)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µmessages); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdirective_class, "directive_class"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µdirective_class); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2095: if directive_class:
							πF.SetLineno(2095)
						Label1:
							// line 2096: return self.run_directive(
							πF.SetLineno(2096)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µdirective_class, "directive_class"); πE != nil {
								continue
							}
							πTemp001[0] = µdirective_class
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[1] = µmatch
							if πE = πg.CheckLocal(πF, µtype_name, "type_name"); πE != nil {
								continue
							}
							πTemp001[2] = µtype_name
							if πE = πg.CheckLocal(πF, µoption_presets, "option_presets"); πE != nil {
								continue
							}
							πTemp001[3] = µoption_presets
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßrun_directive, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
							goto Label3
						Label2:
							// line 2099: return self.unknown_directive(type_name)
							πF.SetLineno(2099)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtype_name, "type_name"); πE != nil {
								continue
							}
							πTemp001[0] = µtype_name
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßunknown_directive, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdirective.ToObject(), πTemp049); πE != nil {
						continue
					}
					// line 2090: """Returns a 2-tuple: list of nodes, and a "blank finish" boolean."""
					πF.SetLineno(2090)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp050}, πg.NewStr("Returns a 2-tuple: list of nodes, and a \"blank finish\" boolean.").ToObject()); πE != nil {
						continue
					}
					if πTemp051, πE = πg.ResolveClass(πF, πClass, nil, ßdirective); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp051, ß__doc__, πTemp050); πE != nil {
						continue
					}
					// line 2101: def run_directive(self, directive, match, type_name, option_presets):
					πF.SetLineno(2101)
					πTemp016 = make([]πg.Param, 5)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "directive", Def: nil}
					πTemp016[2] = πg.Param{Name: "match", Def: nil}
					πTemp016[3] = πg.Param{Name: "type_name", Def: nil}
					πTemp016[4] = πg.Param{Name: "option_presets", Def: nil}
					πTemp050 = πg.NewFunction(πg.NewCode("run_directive", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µdirective *πg.Object = πArgs[1]
						_ = µdirective
						var µmatch *πg.Object = πArgs[2]
						_ = µmatch
						var µtype_name *πg.Object = πArgs[3]
						_ = µtype_name
						var µoption_presets *πg.Object = πArgs[4]
						_ = µoption_presets
						var µconvert_directive_function *πg.Object = πg.UnboundLocal
						_ = µconvert_directive_function
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µinitial_line_offset *πg.Object = πg.UnboundLocal
						_ = µinitial_line_offset
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µline_offset *πg.Object = πg.UnboundLocal
						_ = µline_offset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µblock_text *πg.Object = πg.UnboundLocal
						_ = µblock_text
						var µarguments *πg.Object = πg.UnboundLocal
						_ = µarguments
						var µoptions *πg.Object = πg.UnboundLocal
						_ = µoptions
						var µcontent *πg.Object = πg.UnboundLocal
						_ = µcontent
						var µcontent_offset *πg.Object = πg.UnboundLocal
						_ = µcontent_offset
						var µdetail *πg.Object = πg.UnboundLocal
						_ = µdetail
						var µerror *πg.Object = πg.UnboundLocal
						_ = µerror
						var µdirective_instance *πg.Object = πg.UnboundLocal
						_ = µdirective_instance
						var µresult *πg.Object = πg.UnboundLocal
						_ = µresult
						var µmsg_node *πg.Object = πg.UnboundLocal
						_ = µmsg_node
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.BaseException
						_ = πTemp009
						var πTemp010 *πg.Traceback
						_ = πTemp010
						var πTemp011 []*πg.Object
						_ = πTemp011
						var πTemp012 bool
						_ = πTemp012
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 9:
								goto Label9
							case 10:
								goto Label10
							case 4:
								goto Label4
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 2102: """
							πF.SetLineno(2102)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							πTemp001[0] = µdirective
							if πTemp003, πE = πg.ResolveGlobal(πF, ßFunctionType); πE != nil {
								continue
							}
							if πTemp004, πE = πg.ResolveGlobal(πF, ßMethodType); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp003, πTemp004).ToObject()
							πTemp001[1] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2122: if isinstance(directive, (FunctionType, MethodType)):
							πF.SetLineno(2122)
						Label1:
							// line 2123: from docutils.parsers.rst import convert_directive_function
							πF.SetLineno(2123)
							if πTemp001, πE = πg.ImportModule(πF, "docutils.parsers.rst"); πE != nil {
								continue
							}
							πTemp002 = πTemp001[2]
							if πTemp003, πE = πg.GetAttrImport(πF, πTemp002, ßconvert_directive_function); πE != nil {
								continue
							}
							µconvert_directive_function = πTemp003
							// line 2124: directive = convert_directive_function(directive)
							πF.SetLineno(2124)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							πTemp001[0] = µdirective
							if πE = πg.CheckLocal(πF, µconvert_directive_function, "convert_directive_function"); πE != nil {
								continue
							}
							if πTemp002, πE = µconvert_directive_function.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µdirective = πTemp002
							goto Label2
						Label2:
							// line 2125: lineno = self.state_machine.abs_line_number()
							πF.SetLineno(2125)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlineno = πTemp002
							// line 2126: initial_line_offset = self.state_machine.line_offset
							πF.SetLineno(2126)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßline_offset, nil); πE != nil {
								continue
							}
							µinitial_line_offset = πTemp003
							// line 2127: indented, indent, line_offset, blank_finish \
							πF.SetLineno(2127)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							πTemp006 = πg.KWArgs{
								{"strip_top", πg.NewInt(0).ToObject()},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp007}, πg.TieTarget{Target: &πTemp008}}}, πTemp002); πE != nil {
								continue
							}
							µindented = πTemp003
							µindent = πTemp004
							µline_offset = πTemp007
							µblank_finish = πTemp008
							// line 2130: block_text = '\n'.join(self.state_machine.input_lines[
							πF.SetLineno(2130)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µinitial_line_offset, "initial_line_offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp004, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp007, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µinitial_line_offset, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp004, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp007, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µblock_text = πTemp003
							// line 2132: try:
							πF.SetLineno(2132)
							πF.PushCheckpoint(4)
							// line 2133: arguments, options, content, content_offset = (
							πF.SetLineno(2133)
							πTemp001 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001[0] = µindented
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							πTemp001[1] = µline_offset
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							πTemp001[2] = µdirective
							if πE = πg.CheckLocal(πF, µoption_presets, "option_presets"); πE != nil {
								continue
							}
							πTemp001[3] = µoption_presets
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparse_directive_block, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp007}, πg.TieTarget{Target: &πTemp008}}}, πTemp003); πE != nil {
								continue
							}
							µarguments = πTemp002
							µoptions = πTemp004
							µcontent = πTemp007
							µcontent_offset = πTemp008
							πF.PopCheckpoint()
							goto Label3
						Label4:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp009, πTemp010 = πF.ExcInfo()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsInstance(πF, πTemp009.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label5
							}
							πE = πF.Raise(πTemp009.ToObject(), nil, πTemp010.ToObject())
							continue
							// line 2136: except MarkupError as detail:
							πF.SetLineno(2136)
						Label5:
							µdetail = πTemp009.ToObject()
							// line 2137: error = self.reporter.error(
							πF.SetLineno(2137)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtype_name, "type_name"); πE != nil {
								continue
							}
							πTemp011 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdetail, "detail"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µdetail, ßargs, nil); πE != nil {
								continue
							}
							πTemp011[0] = πTemp004
							if πTemp004, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp003 = πg.NewTuple2(µtype_name, πTemp007).ToObject()
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("Error in \"%s\" directive:\n%s.").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							πTemp011 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblock_text, "block_text"); πE != nil {
								continue
							}
							πTemp011[0] = µblock_text
							if πE = πg.CheckLocal(πF, µblock_text, "block_text"); πE != nil {
								continue
							}
							πTemp011[1] = µblock_text
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßerror, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µerror = πTemp002
							// line 2141: return [error], blank_finish
							πF.SetLineno(2141)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µerror, "error"); πE != nil {
								continue
							}
							πTemp001[0] = µerror
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp003, µblank_finish).ToObject()
							πR = πTemp002
							continue
							πF.RestoreExc(nil, nil)
							goto Label3
						Label3:
							// line 2142: directive_instance = directive(
							πF.SetLineno(2142)
							πTemp001 = πF.MakeArgs(9)
							if πE = πg.CheckLocal(πF, µtype_name, "type_name"); πE != nil {
								continue
							}
							πTemp001[0] = µtype_name
							if πE = πg.CheckLocal(πF, µarguments, "arguments"); πE != nil {
								continue
							}
							πTemp001[1] = µarguments
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							πTemp001[2] = µoptions
							if πE = πg.CheckLocal(πF, µcontent, "content"); πE != nil {
								continue
							}
							πTemp001[3] = µcontent
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp001[4] = µlineno
							if πE = πg.CheckLocal(πF, µcontent_offset, "content_offset"); πE != nil {
								continue
							}
							πTemp001[5] = µcontent_offset
							if πE = πg.CheckLocal(πF, µblock_text, "block_text"); πE != nil {
								continue
							}
							πTemp001[6] = µblock_text
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[7] = µself
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							πTemp001[8] = πTemp002
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp002, πE = µdirective.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µdirective_instance = πTemp002
							// line 2145: try:
							πF.SetLineno(2145)
							πF.PushCheckpoint(7)
							// line 2146: result = directive_instance.run()
							πF.SetLineno(2146)
							if πE = πg.CheckLocal(πF, µdirective_instance, "directive_instance"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µdirective_instance, ßrun, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µresult = πTemp003
							πF.PopCheckpoint()
							goto Label6
						Label7:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp009, πTemp010 = πF.ExcInfo()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßdocutils); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßparsers, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßrst, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßDirectiveError, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsInstance(πF, πTemp009.ToObject(), πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label8
							}
							πE = πF.Raise(πTemp009.ToObject(), nil, πTemp010.ToObject())
							continue
							// line 2147: except docutils.parsers.rst.DirectiveError as error:
							πF.SetLineno(2147)
						Label8:
							µerror = πTemp009.ToObject()
							// line 2148: msg_node = self.reporter.system_message(error.level, error.msg,
							πF.SetLineno(2148)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µerror, "error"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µerror, ßlevel, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µerror, "error"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µerror, ßmsg, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßsystem_message, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg_node = πTemp002
							// line 2150: msg_node += nodes.literal_block(block_text, block_text)
							πF.SetLineno(2150)
							if πE = πg.CheckLocal(πF, µmsg_node, "msg_node"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblock_text, "block_text"); πE != nil {
								continue
							}
							πTemp001[0] = µblock_text
							if πE = πg.CheckLocal(πF, µblock_text, "block_text"); πE != nil {
								continue
							}
							πTemp001[1] = µblock_text
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp003, πE = πg.IAdd(πF, µmsg_node, πTemp002); πE != nil {
								continue
							}
							µmsg_node = πTemp003
							// line 2151: result = [msg_node]
							πF.SetLineno(2151)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmsg_node, "msg_node"); πE != nil {
								continue
							}
							πTemp001[0] = µmsg_node
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µresult = πTemp002
							πF.RestoreExc(nil, nil)
							goto Label6
						Label6:
							// line 2152: assert isinstance(result, list), \
							πF.SetLineno(2152)
							if πE = πg.CheckLocal(πF, µtype_name, "type_name"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("Directive \"%s\" must return a list of nodes.").ToObject(), µtype_name); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πTemp001[0] = µresult
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Assert(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp011 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							πTemp011[0] = µresult
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp001[0] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(10)
							πTemp005 = false
						Label9:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label11
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp012 = !isStop
							} else {
								πTemp012 = true
								µi = πTemp003
							}
							if πE != nil || !πTemp012 {
								continue
							}
							πF.PushCheckpoint(9)
							// line 2155: assert isinstance(result[i], nodes.Node), \
							πF.SetLineno(2155)
							if πE = πg.CheckLocal(πF, µtype_name, "type_name"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp007 = µi
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µresult, πTemp007); πE != nil {
								continue
							}
							πTemp004 = πg.NewTuple3(µtype_name, µi, πTemp008).ToObject()
							if πTemp003, πE = πg.Mod(πF, πg.NewStr("Directive \"%s\" returned non-Node object (index %s): %r").ToObject(), πTemp004); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp004 = µi
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetItem(πF, µresult, πTemp004); πE != nil {
								continue
							}
							πTemp001[0] = πTemp007
							if πTemp004, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp004, ßNode, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp007
							if πTemp004, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Assert(πF, πTemp007, πTemp003); πE != nil {
								continue
							}
							continue
						Label10:
							if πE != nil || πR != nil {
								continue
							}
						Label11:
							// line 2158: return (result,
							πF.SetLineno(2158)
							if πE = πg.CheckLocal(πF, µresult, "result"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp003 = µblank_finish
							if πTemp005, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label12
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.GetAttr(πF, πTemp004, ßis_next_line_blank, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp007.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003 = πTemp004
						Label12:
							πTemp002 = πg.NewTuple2(µresult, πTemp003).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßrun_directive.ToObject(), πTemp050); πE != nil {
						continue
					}
					// line 2102: """
					πF.SetLineno(2102)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp051}, πg.NewStr("\n        Parse a directive then run its directive function.\n\n        Parameters:\n\n        - `directive`: The class implementing the directive.  Must be\n          a subclass of `rst.Directive`.\n\n        - `match`: A regular expression match object which matched the first\n          line of the directive.\n\n        - `type_name`: The directive name, as used in the source text.\n\n        - `option_presets`: A dictionary of preset options, defaults for the\n          directive options.  Currently, only an \"alt\" option is passed by\n          substitution definitions (value: the substitution name), which may\n          be used by an embedded image directive.\n\n        Returns a 2-tuple: list of nodes, and a \"blank finish\" boolean.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp052, πE = πg.ResolveClass(πF, πClass, nil, ßrun_directive); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp052, ß__doc__, πTemp051); πE != nil {
						continue
					}
					// line 2161: def parse_directive_block(self, indented, line_offset, directive,
					πF.SetLineno(2161)
					πTemp016 = make([]πg.Param, 5)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "indented", Def: nil}
					πTemp016[2] = πg.Param{Name: "line_offset", Def: nil}
					πTemp016[3] = πg.Param{Name: "directive", Def: nil}
					πTemp016[4] = πg.Param{Name: "option_presets", Def: nil}
					πTemp051 = πg.NewFunction(πg.NewCode("parse_directive_block", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindented *πg.Object = πArgs[1]
						_ = µindented
						var µline_offset *πg.Object = πArgs[2]
						_ = µline_offset
						var µdirective *πg.Object = πArgs[3]
						_ = µdirective
						var µoption_presets *πg.Object = πArgs[4]
						_ = µoption_presets
						var µoption_spec *πg.Object = πg.UnboundLocal
						_ = µoption_spec
						var µhas_content *πg.Object = πg.UnboundLocal
						_ = µhas_content
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var µarg_block *πg.Object = πg.UnboundLocal
						_ = µarg_block
						var µcontent *πg.Object = πg.UnboundLocal
						_ = µcontent
						var µcontent_offset *πg.Object = πg.UnboundLocal
						_ = µcontent_offset
						var µoptions *πg.Object = πg.UnboundLocal
						_ = µoptions
						var µarguments *πg.Object = πg.UnboundLocal
						_ = µarguments
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πTemp010 *πg.Dict
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 4:
								goto Label4
							case 5:
								goto Label5
							case 13:
								goto Label13
							case 14:
								goto Label14
							case 25:
								goto Label25
							case 26:
								goto Label26
							default:
								panic("unexpected function state")
							}
							// line 2163: option_spec = directive.option_spec
							πF.SetLineno(2163)
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µdirective, ßoption_spec, nil); πE != nil {
								continue
							}
							µoption_spec = πTemp001
							// line 2164: has_content = directive.has_content
							πF.SetLineno(2164)
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µdirective, ßhas_content, nil); πE != nil {
								continue
							}
							µhas_content = πTemp001
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001 = µindented
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							πTemp004 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µindented, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 2165: if indented and not indented[0].strip():
							πF.SetLineno(2165)
						Label2:
							// line 2166: indented.trim_start()
							πF.SetLineno(2166)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µindented, ßtrim_start, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2167: line_offset += 1
							πF.SetLineno(2167)
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µline_offset, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µline_offset = πTemp001
							goto Label3
						Label3:
							// line 2168: while indented and not indented[-1].strip():
							πF.SetLineno(2168)
							πF.PushCheckpoint(5)
							πTemp002 = false
						Label4:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label6
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001 = µindented
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp007 {
								goto Label7
							}
							if πTemp005, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp004 = πTemp005
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µindented, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp008).ToObject()
							πTemp001 = πTemp003
						Label7:
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(4)
							// line 2169: indented.trim_end()
							πF.SetLineno(2169)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µindented, ßtrim_end, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label5:
							if πE != nil || πR != nil {
								continue
							}
						Label6:
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001 = µindented
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label8
							}
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µdirective, ßrequired_arguments, nil); πE != nil {
								continue
							}
							πTemp003 = πTemp004
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label9
							}
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µdirective, ßoptional_arguments, nil); πE != nil {
								continue
							}
							πTemp003 = πTemp004
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label9
							}
							if πE = πg.CheckLocal(πF, µoption_spec, "option_spec"); πE != nil {
								continue
							}
							πTemp003 = µoption_spec
						Label9:
							πTemp001 = πTemp003
						Label8:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label10
							}
							goto Label11
							// line 2170: if indented and (directive.required_arguments
							πF.SetLineno(2170)
						Label10:
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp009[0] = µindented
							if πTemp003, πE = πg.ResolveGlobal(πF, ßenumerate); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(14)
							πTemp002 = false
						Label13:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label15
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp003); πE != nil {
									continue
								}
								µi = πTemp004
								µline = πTemp005
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(13)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µline, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label16
							}
							goto Label17
							// line 2174: if not line.strip():
							πF.SetLineno(2174)
						Label16:
							// line 2175: break
							πF.SetLineno(2175)
							πTemp002 = true
							continue
							goto Label17
						Label17:
							continue
						Label14:
							if πE != nil || πR != nil {
								continue
							}
							// line 2177: i += 1
							πF.SetLineno(2177)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µi = πTemp003
						Label15:
							// line 2178: arg_block = indented[:i]
							πF.SetLineno(2178)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µi, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µindented, πTemp001); πE != nil {
								continue
							}
							µarg_block = πTemp003
							// line 2179: content = indented[i+1:]
							πF.SetLineno(2179)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µi, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πTemp003, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µindented, πTemp001); πE != nil {
								continue
							}
							µcontent = πTemp003
							// line 2180: content_offset = line_offset + i + 1
							πF.SetLineno(2180)
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µline_offset, µi); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µcontent_offset = πTemp001
							goto Label12
						Label11:
							// line 2182: content = indented
							πF.SetLineno(2182)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							µcontent = µindented
							// line 2183: content_offset = line_offset
							πF.SetLineno(2183)
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							µcontent_offset = µline_offset
							// line 2184: arg_block = []
							πF.SetLineno(2184)
							πTemp009 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp009...).ToObject()
							µarg_block = πTemp001
							goto Label12
						Label12:
							if πE = πg.CheckLocal(πF, µoption_spec, "option_spec"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IsTrue(πF, µoption_spec); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label18
							}
							goto Label19
							// line 2185: if option_spec:
							πF.SetLineno(2185)
						Label18:
							// line 2186: options, arg_block = self.parse_directive_options(
							πF.SetLineno(2186)
							πTemp009 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µoption_presets, "option_presets"); πE != nil {
								continue
							}
							πTemp009[0] = µoption_presets
							if πE = πg.CheckLocal(πF, µoption_spec, "option_spec"); πE != nil {
								continue
							}
							πTemp009[1] = µoption_spec
							if πE = πg.CheckLocal(πF, µarg_block, "arg_block"); πE != nil {
								continue
							}
							πTemp009[2] = µarg_block
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparse_directive_options, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µoptions = πTemp001
							µarg_block = πTemp004
							goto Label20
						Label19:
							// line 2189: options = {}
							πF.SetLineno(2189)
							πTemp010 = πg.NewDict()
							πTemp001 = πTemp010.ToObject()
							µoptions = πTemp001
							goto Label20
						Label20:
							if πE = πg.CheckLocal(πF, µarg_block, "arg_block"); πE != nil {
								continue
							}
							πTemp001 = µarg_block
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label21
							}
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µdirective, ßrequired_arguments, nil); πE != nil {
								continue
							}
							πTemp004 = πTemp005
							if πTemp006, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label22
							}
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µdirective, ßoptional_arguments, nil); πE != nil {
								continue
							}
							πTemp004 = πTemp005
						Label22:
							if πTemp006, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp003
						Label21:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label23
							}
							goto Label24
							// line 2190: if arg_block and not (directive.required_arguments
							πF.SetLineno(2190)
						Label23:
							// line 2192: content = arg_block + indented[i:]
							πF.SetLineno(2192)
							if πE = πg.CheckLocal(πF, µarg_block, "arg_block"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.SliceType.Call(πF, πg.Args{µi, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µindented, πTemp003); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µarg_block, πTemp004); πE != nil {
								continue
							}
							µcontent = πTemp001
							// line 2193: content_offset = line_offset
							πF.SetLineno(2193)
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							µcontent_offset = µline_offset
							// line 2194: arg_block = []
							πF.SetLineno(2194)
							πTemp009 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp009...).ToObject()
							µarg_block = πTemp001
							goto Label24
						Label24:
							// line 2195: while content and not content[0].strip():
							πF.SetLineno(2195)
							πF.PushCheckpoint(26)
							πTemp002 = false
						Label25:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label27
							}
							if πE = πg.CheckLocal(πF, µcontent, "content"); πE != nil {
								continue
							}
							πTemp001 = µcontent
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp007 {
								goto Label28
							}
							πTemp004 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcontent, "content"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µcontent, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp008).ToObject()
							πTemp001 = πTemp003
						Label28:
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(25)
							// line 2196: content.trim_start()
							πF.SetLineno(2196)
							if πE = πg.CheckLocal(πF, µcontent, "content"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µcontent, ßtrim_start, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							// line 2197: content_offset += 1
							πF.SetLineno(2197)
							if πE = πg.CheckLocal(πF, µcontent_offset, "content_offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µcontent_offset, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µcontent_offset = πTemp001
							continue
						Label26:
							if πE != nil || πR != nil {
								continue
							}
						Label27:
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µdirective, ßrequired_arguments, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label29
							}
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µdirective, ßoptional_arguments, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
						Label29:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label30
							}
							goto Label31
							// line 2198: if directive.required_arguments or directive.optional_arguments:
							πF.SetLineno(2198)
						Label30:
							// line 2199: arguments = self.parse_directive_arguments(
							πF.SetLineno(2199)
							πTemp009 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							πTemp009[0] = µdirective
							if πE = πg.CheckLocal(πF, µarg_block, "arg_block"); πE != nil {
								continue
							}
							πTemp009[1] = µarg_block
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparse_directive_arguments, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							µarguments = πTemp003
							goto Label32
						Label31:
							// line 2202: arguments = []
							πF.SetLineno(2202)
							πTemp009 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp009...).ToObject()
							µarguments = πTemp001
							goto Label32
						Label32:
							if πE = πg.CheckLocal(πF, µcontent, "content"); πE != nil {
								continue
							}
							πTemp001 = µcontent
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label33
							}
							if πE = πg.CheckLocal(πF, µhas_content, "has_content"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µhas_content); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp006).ToObject()
							πTemp001 = πTemp003
						Label33:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label34
							}
							goto Label35
							// line 2203: if content and not has_content:
							πF.SetLineno(2203)
						Label34:
							πTemp009 = πF.MakeArgs(1)
							πTemp009[0] = πg.NewStr("no content permitted").ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							// line 2204: raise MarkupError('no content permitted')
							πF.SetLineno(2204)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label35
						Label35:
							// line 2205: return (arguments, options, content, content_offset)
							πF.SetLineno(2205)
							if πE = πg.CheckLocal(πF, µarguments, "arguments"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontent, "content"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontent_offset, "content_offset"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple4(µarguments, µoptions, µcontent, µcontent_offset).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_directive_block.ToObject(), πTemp051); πE != nil {
						continue
					}
					// line 2207: def parse_directive_options(self, option_presets, option_spec, arg_block):
					πF.SetLineno(2207)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "option_presets", Def: nil}
					πTemp016[2] = πg.Param{Name: "option_spec", Def: nil}
					πTemp016[3] = πg.Param{Name: "arg_block", Def: nil}
					πTemp052 = πg.NewFunction(πg.NewCode("parse_directive_options", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µoption_presets *πg.Object = πArgs[1]
						_ = µoption_presets
						var µoption_spec *πg.Object = πArgs[2]
						_ = µoption_spec
						var µarg_block *πg.Object = πArgs[3]
						_ = µarg_block
						var µoptions *πg.Object = πg.UnboundLocal
						_ = µoptions
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var µopt_block *πg.Object = πg.UnboundLocal
						_ = µopt_block
						var µsuccess *πg.Object = πg.UnboundLocal
						_ = µsuccess
						var µdata *πg.Object = πg.UnboundLocal
						_ = µdata
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2208: options = option_presets.copy()
							πF.SetLineno(2208)
							if πE = πg.CheckLocal(πF, µoption_presets, "option_presets"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µoption_presets, ßcopy, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µoptions = πTemp002
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_block, "arg_block"); πE != nil {
								continue
							}
							πTemp003[0] = µarg_block
							if πTemp002, πE = πg.ResolveGlobal(πF, ßenumerate); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp007}}}, πTemp002); πE != nil {
									continue
								}
								µi = πTemp004
								µline = πTemp007
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							πTemp003 = πF.MakeArgs(2)
							πTemp002 = ßfield_marker.ToObject()
							if πTemp007, πE = πg.ResolveGlobal(πF, ßBody); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp007, ßpatterns, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp008, πTemp002); πE != nil {
								continue
							}
							πTemp003[0] = πTemp004
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp003[1] = µline
							if πTemp002, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label4
							}
							goto Label5
							// line 2210: if re.match(Body.patterns['field_marker'], line):
							πF.SetLineno(2210)
						Label4:
							// line 2211: opt_block = arg_block[i:]
							πF.SetLineno(2211)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µi, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_block, "arg_block"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µarg_block, πTemp002); πE != nil {
								continue
							}
							µopt_block = πTemp004
							// line 2212: arg_block = arg_block[:i]
							πF.SetLineno(2212)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, µi, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_block, "arg_block"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µarg_block, πTemp002); πE != nil {
								continue
							}
							µarg_block = πTemp004
							// line 2213: break
							πF.SetLineno(2213)
							πTemp005 = true
							continue
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
							// line 2215: opt_block = []
							πF.SetLineno(2215)
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							µopt_block = πTemp002
						Label3:
							if πE = πg.CheckLocal(πF, µopt_block, "opt_block"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µopt_block); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label6
							}
							goto Label7
							// line 2216: if opt_block:
							πF.SetLineno(2216)
						Label6:
							// line 2217: success, data = self.parse_extension_options(option_spec,
							πF.SetLineno(2217)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µoption_spec, "option_spec"); πE != nil {
								continue
							}
							πTemp003[0] = µoption_spec
							if πE = πg.CheckLocal(πF, µopt_block, "opt_block"); πE != nil {
								continue
							}
							πTemp003[1] = µopt_block
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparse_extension_options, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µsuccess = πTemp001
							µdata = πTemp004
							if πE = πg.CheckLocal(πF, µsuccess, "success"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µsuccess); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label8
							}
							goto Label9
							// line 2219: if success:                 # data is a dict of options
							πF.SetLineno(2219)
						Label8:
							// line 2220: options.update(data)
							πF.SetLineno(2220)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp003[0] = µdata
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µoptions, ßupdate, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label10
						Label9:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp003[0] = µdata
							if πTemp001, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2222: raise MarkupError(data)
							πF.SetLineno(2222)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							goto Label10
						Label10:
							goto Label7
						Label7:
							// line 2223: return options, arg_block
							πF.SetLineno(2223)
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µarg_block, "arg_block"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µoptions, µarg_block).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_directive_options.ToObject(), πTemp052); πE != nil {
						continue
					}
					// line 2225: def parse_directive_arguments(self, directive, arg_block):
					πF.SetLineno(2225)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "directive", Def: nil}
					πTemp016[2] = πg.Param{Name: "arg_block", Def: nil}
					πTemp053 = πg.NewFunction(πg.NewCode("parse_directive_arguments", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µdirective *πg.Object = πArgs[1]
						_ = µdirective
						var µarg_block *πg.Object = πArgs[2]
						_ = µarg_block
						var µrequired *πg.Object = πg.UnboundLocal
						_ = µrequired
						var µoptional *πg.Object = πg.UnboundLocal
						_ = µoptional
						var µarg_text *πg.Object = πg.UnboundLocal
						_ = µarg_text
						var µarguments *πg.Object = πg.UnboundLocal
						_ = µarguments
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2226: required = directive.required_arguments
							πF.SetLineno(2226)
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µdirective, ßrequired_arguments, nil); πE != nil {
								continue
							}
							µrequired = πTemp001
							// line 2227: optional = directive.optional_arguments
							πF.SetLineno(2227)
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µdirective, ßoptional_arguments, nil); πE != nil {
								continue
							}
							µoptional = πTemp001
							// line 2228: arg_text = '\n'.join(arg_block)
							πF.SetLineno(2228)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarg_block, "arg_block"); πE != nil {
								continue
							}
							πTemp002[0] = µarg_block
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µarg_text = πTemp003
							// line 2229: arguments = arg_text.split()
							πF.SetLineno(2229)
							if πE = πg.CheckLocal(πF, µarg_text, "arg_text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µarg_text, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µarguments = πTemp003
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarguments, "arguments"); πE != nil {
								continue
							}
							πTemp002[0] = µarguments
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.LT(πF, πTemp004, µrequired); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarguments, "arguments"); πE != nil {
								continue
							}
							πTemp002[0] = µarguments
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoptional, "optional"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µrequired, µoptional); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GT(πF, πTemp004, πTemp003); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label2
							}
							goto Label3
							// line 2230: if len(arguments) < required:
							πF.SetLineno(2230)
						Label1:
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarguments, "arguments"); πE != nil {
								continue
							}
							πTemp006[0] = µarguments
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp007, πE = πTemp004.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp003 = πg.NewTuple2(µrequired, πTemp007).ToObject()
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("%s argument(s) required, %s supplied").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 2231: raise MarkupError('%s argument(s) required, %s supplied'
							πF.SetLineno(2231)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label3
							// line 2233: elif len(arguments) > required + optional:
							πF.SetLineno(2233)
						Label2:
							if πE = πg.CheckLocal(πF, µdirective, "directive"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µdirective, ßfinal_argument_whitespace, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label4
							}
							goto Label5
							// line 2234: if directive.final_argument_whitespace:
							πF.SetLineno(2234)
						Label4:
							// line 2235: arguments = arg_text.split(None, required + optional - 1)
							πF.SetLineno(2235)
							πTemp002 = πF.MakeArgs(2)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoptional, "optional"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µrequired, µoptional); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp002[1] = πTemp001
							if πE = πg.CheckLocal(πF, µarg_text, "arg_text"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µarg_text, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µarguments = πTemp003
							goto Label6
						Label5:
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µrequired, "required"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoptional, "optional"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.Add(πF, µrequired, µoptional); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µarguments, "arguments"); πE != nil {
								continue
							}
							πTemp006[0] = µarguments
							if πTemp007, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp007.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							πTemp003 = πg.NewTuple2(πTemp004, πTemp008).ToObject()
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("maximum %s argument(s) allowed, %s supplied").ToObject(), πTemp003); πE != nil {
								continue
							}
							πTemp002[0] = πTemp001
							if πTemp001, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 2237: raise MarkupError(
							πF.SetLineno(2237)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
							goto Label6
						Label6:
							goto Label3
						Label3:
							// line 2240: return arguments
							πF.SetLineno(2240)
							if πE = πg.CheckLocal(πF, µarguments, "arguments"); πE != nil {
								continue
							}
							πR = µarguments
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_directive_arguments.ToObject(), πTemp053); πE != nil {
						continue
					}
					// line 2242: def parse_extension_options(self, option_spec, datalines):
					πF.SetLineno(2242)
					πTemp016 = make([]πg.Param, 3)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "option_spec", Def: nil}
					πTemp016[2] = πg.Param{Name: "datalines", Def: nil}
					πTemp054 = πg.NewFunction(πg.NewCode("parse_extension_options", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µoption_spec *πg.Object = πArgs[1]
						_ = µoption_spec
						var µdatalines *πg.Object = πArgs[2]
						_ = µdatalines
						var µnode *πg.Object = πg.UnboundLocal
						_ = µnode
						var µnewline_offset *πg.Object = πg.UnboundLocal
						_ = µnewline_offset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µoptions *πg.Object = πg.UnboundLocal
						_ = µoptions
						var µdetail *πg.Object = πg.UnboundLocal
						_ = µdetail
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.BaseException
						_ = πTemp007
						var πTemp008 *πg.Traceback
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 4:
								goto Label4
							default:
								panic("unexpected function state")
							}
							// line 2243: """
							πF.SetLineno(2243)
							// line 2256: node = nodes.field_list()
							πF.SetLineno(2256)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßfield_list, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µnode = πTemp001
							// line 2257: newline_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(2257)
							πTemp003 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µdatalines, "datalines"); πE != nil {
								continue
							}
							πTemp003[0] = µdatalines
							πTemp003[1] = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp003[2] = µnode
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"initial_state", ßExtensionOptions.ToObject()},
								{"blank_finish", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp005}}}, πTemp002); πE != nil {
								continue
							}
							µnewline_offset = πTemp001
							µblank_finish = πTemp005
							if πE = πg.CheckLocal(πF, µnewline_offset, "newline_offset"); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdatalines, "datalines"); πE != nil {
								continue
							}
							πTemp003[0] = µdatalines
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.NE(πF, µnewline_offset, πTemp005); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 2260: if newline_offset != len(datalines): # incomplete parse of block
							πF.SetLineno(2260)
						Label1:
							// line 2261: return 0, 'invalid option block'
							πF.SetLineno(2261)
							πTemp001 = πg.NewTuple2(πg.NewInt(0).ToObject(), πg.NewStr("invalid option block").ToObject()).ToObject()
							πR = πTemp001
							continue
							goto Label2
						Label2:
							// line 2262: try:
							πF.SetLineno(2262)
							πF.PushCheckpoint(4)
							// line 2263: options = utils.extract_extension_options(node, option_spec)
							πF.SetLineno(2263)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp003[0] = µnode
							if πE = πg.CheckLocal(πF, µoption_spec, "option_spec"); πE != nil {
								continue
							}
							πTemp003[1] = µoption_spec
							if πTemp001, πE = πg.ResolveGlobal(πF, ßutils); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßextract_extension_options, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µoptions = πTemp001
							πF.PopCheckpoint()
							goto Label3
						Label4:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp007, πTemp008 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßKeyError); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsInstance(πF, πTemp007.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label5
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßValueError); πE != nil {
								continue
							}
							if πTemp005, πE = πg.ResolveGlobal(πF, ßTypeError); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, πTemp005).ToObject()
							if πTemp006, πE = πg.IsInstance(πF, πTemp007.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label6
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßutils); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßExtensionOptionError, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsInstance(πF, πTemp007.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label7
							}
							πE = πF.Raise(πTemp007.ToObject(), nil, πTemp008.ToObject())
							continue
							// line 2264: except KeyError as detail:
							πF.SetLineno(2264)
						Label5:
							µdetail = πTemp007.ToObject()
							// line 2265: return 0, ('unknown option: "%s"' % detail.args[0])
							πF.SetLineno(2265)
							πTemp005 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µdetail, "detail"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetAttr(πF, µdetail, ßargs, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.GetItem(πF, πTemp010, πTemp005); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("unknown option: \"%s\"").ToObject(), πTemp009); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πg.NewInt(0).ToObject(), πTemp002).ToObject()
							πR = πTemp001
							continue
							πF.RestoreExc(nil, nil)
							goto Label3
							// line 2266: except (ValueError, TypeError) as detail:
							πF.SetLineno(2266)
						Label6:
							µdetail = πTemp007.ToObject()
							// line 2267: return 0, ('invalid option value: %s' % ' '.join(detail.args))
							πF.SetLineno(2267)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdetail, "detail"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µdetail, ßargs, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp005
							if πTemp005, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("invalid option value: %s").ToObject(), πTemp009); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πg.NewInt(0).ToObject(), πTemp002).ToObject()
							πR = πTemp001
							continue
							πF.RestoreExc(nil, nil)
							goto Label3
							// line 2268: except utils.ExtensionOptionError as detail:
							πF.SetLineno(2268)
						Label7:
							µdetail = πTemp007.ToObject()
							// line 2269: return 0, ('invalid option data: %s' % ' '.join(detail.args))
							πF.SetLineno(2269)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µdetail, "detail"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µdetail, ßargs, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp005
							if πTemp005, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πTemp005.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.Mod(πF, πg.NewStr("invalid option data: %s").ToObject(), πTemp009); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πg.NewInt(0).ToObject(), πTemp002).ToObject()
							πR = πTemp001
							continue
							πF.RestoreExc(nil, nil)
							goto Label3
						Label3:
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label8
							}
							goto Label9
							// line 2270: if blank_finish:
							πF.SetLineno(2270)
						Label8:
							// line 2271: return 1, options
							πF.SetLineno(2271)
							if πE = πg.CheckLocal(πF, µoptions, "options"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πg.NewInt(1).ToObject(), µoptions).ToObject()
							πR = πTemp001
							continue
							goto Label10
						Label9:
							// line 2273: return 0, 'option data incompletely parsed'
							πF.SetLineno(2273)
							πTemp001 = πg.NewTuple2(πg.NewInt(0).ToObject(), πg.NewStr("option data incompletely parsed").ToObject()).ToObject()
							πR = πTemp001
							continue
							goto Label10
						Label10:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_extension_options.ToObject(), πTemp054); πE != nil {
						continue
					}
					// line 2243: """
					πF.SetLineno(2243)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp055}, πg.NewStr("\n        Parse `datalines` for a field list containing extension options\n        matching `option_spec`.\n\n        :Parameters:\n            - `option_spec`: a mapping of option name to conversion\n              function, which should raise an exception on bad input.\n            - `datalines`: a list of input strings.\n\n        :Return:\n            - Success value, 1 or 0.\n            - An option dictionary on success, an error string on failure.\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp056, πE = πg.ResolveClass(πF, πClass, nil, ßparse_extension_options); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp056, ß__doc__, πTemp055); πE != nil {
						continue
					}
					// line 2275: def unknown_directive(self, type_name):
					πF.SetLineno(2275)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "type_name", Def: nil}
					πTemp055 = πg.NewFunction(πg.NewCode("unknown_directive", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtype_name *πg.Object = πArgs[1]
						_ = µtype_name
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µerror *πg.Object = πg.UnboundLocal
						_ = µerror
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2276: lineno = self.state_machine.abs_line_number()
							πF.SetLineno(2276)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 2277: indented, indent, offset, blank_finish = \
							πF.SetLineno(2277)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewInt(0).ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"strip_indent", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µindent = πTemp005
							µoffset = πTemp006
							µblank_finish = πTemp007
							// line 2279: text = '\n'.join(indented)
							πF.SetLineno(2279)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp003[0] = µindented
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtext = πTemp002
							// line 2280: error = self.reporter.error(
							πF.SetLineno(2280)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtype_name, "type_name"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("Unknown directive type \"%s\".").ToObject(), µtype_name); πE != nil {
								continue
							}
							πTemp003[0] = πTemp001
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp008[0] = µtext
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp008[1] = µtext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µerror = πTemp001
							// line 2283: return [error], blank_finish
							πF.SetLineno(2283)
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µerror, "error"); πE != nil {
								continue
							}
							πTemp003[0] = µerror
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp002, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßunknown_directive.ToObject(), πTemp055); πE != nil {
						continue
					}
					// line 2285: def comment(self, match):
					πF.SetLineno(2285)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp056 = πg.NewFunction(πg.NewCode("comment", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 bool
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πTemp011 []*πg.Object
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 4:
								goto Label4
							case 5:
								goto Label5
							default:
								panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πTemp006, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp007).ToObject()
							πTemp001 = πTemp003
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp002 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßis_next_line_blank, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001 = πTemp003
						Label1:
							if πTemp002, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp002 {
								goto Label2
							}
							goto Label3
							// line 2286: if not match.string[match.end():].strip() \
							πF.SetLineno(2286)
						Label2:
							// line 2288: return [nodes.comment()], 1 # "A tiny but practical wart."
							πF.SetLineno(2288)
							πTemp008 = make([]*πg.Object, 1)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßcomment, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp003
							πTemp003 = πg.NewList(πTemp008...).ToObject()
							πTemp001 = πg.NewTuple2(πTemp003, πg.NewInt(1).ToObject()).ToObject()
							πR = πTemp001
							continue
							goto Label3
						Label3:
							// line 2289: indented, indent, offset, blank_finish = \
							πF.SetLineno(2289)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp008[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp003
							µindent = πTemp004
							µoffset = πTemp005
							µblank_finish = πTemp006
							// line 2291: while indented and not indented[-1].strip():
							πF.SetLineno(2291)
							πF.PushCheckpoint(5)
							πTemp002 = false
						Label4:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp002 {
								πF.PopCheckpoint()
								goto Label6
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001 = µindented
							if πTemp009, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp009 {
								goto Label7
							}
							if πTemp005, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp004 = πTemp005
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µindented, πTemp004); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp005, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp010).ToObject()
							πTemp001 = πTemp003
						Label7:
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(4)
							// line 2292: indented.trim_end()
							πF.SetLineno(2292)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µindented, ßtrim_end, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label5:
							if πE != nil || πR != nil {
								continue
							}
						Label6:
							// line 2293: text = '\n'.join(indented)
							πF.SetLineno(2293)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp008[0] = µindented
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							µtext = πTemp003
							// line 2294: return [nodes.comment(text, text)], blank_finish
							πF.SetLineno(2294)
							πTemp008 = make([]*πg.Object, 1)
							πTemp011 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp011[0] = µtext
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp011[1] = µtext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßcomment, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp008[0] = πTemp003
							πTemp003 = πg.NewList(πTemp008...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp003, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßcomment.ToObject(), πTemp056); πE != nil {
						continue
					}
					// line 2296: explicit.constructs = [
					πF.SetLineno(2296)
					πTemp006 = make([]*πg.Object, 5)
					if πTemp058, πE = πg.ResolveClass(πF, πClass, nil, ßfootnote); πE != nil {
						continue
					}
					πTemp041 = πF.MakeArgs(2)
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßInliner); πE != nil {
						continue
					}
					if πTemp061, πE = πg.GetAttr(πF, πTemp060, ßsimplename, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πg.Mod(πF, πg.NewStr("\n                      \\.\\.[ ]+          # explicit markup start\n                      \\[\n                      (                 # footnote label:\n                          [0-9]+          # manually numbered footnote\n                        |               # *OR*\n                          \\#              # anonymous auto-numbered footnote\n                        |               # *OR*\n                          \\#%s            # auto-number ed?) footnote label\n                        |               # *OR*\n                          \\*              # auto-symbol footnote\n                      )\n                      \\]\n                      ([ ]+|$)          # whitespace or end of line\n                      ").ToObject(), πTemp061); πE != nil {
						continue
					}
					πTemp041[0] = πTemp059
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp061, πE = πg.GetAttr(πF, πTemp060, ßVERBOSE, nil); πE != nil {
						continue
					}
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp062, πE = πg.GetAttr(πF, πTemp060, ßUNICODE, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πg.Or(πF, πTemp061, πTemp062); πE != nil {
						continue
					}
					πTemp041[1] = πTemp059
					if πTemp059, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp060, πE = πg.GetAttr(πF, πTemp059, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πTemp060.Call(πF, πTemp041, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp041)
					πTemp057 = πg.NewTuple2(πTemp058, πTemp059).ToObject()
					πTemp006[0] = πTemp057
					if πTemp058, πE = πg.ResolveClass(πF, πClass, nil, ßcitation); πE != nil {
						continue
					}
					πTemp041 = πF.MakeArgs(2)
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßInliner); πE != nil {
						continue
					}
					if πTemp061, πE = πg.GetAttr(πF, πTemp060, ßsimplename, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πg.Mod(πF, πg.NewStr("\n                      \\.\\.[ ]+          # explicit markup start\n                      \\[(%s)\\]          # citation label\n                      ([ ]+|$)          # whitespace or end of line\n                      ").ToObject(), πTemp061); πE != nil {
						continue
					}
					πTemp041[0] = πTemp059
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp061, πE = πg.GetAttr(πF, πTemp060, ßVERBOSE, nil); πE != nil {
						continue
					}
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp062, πE = πg.GetAttr(πF, πTemp060, ßUNICODE, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πg.Or(πF, πTemp061, πTemp062); πE != nil {
						continue
					}
					πTemp041[1] = πTemp059
					if πTemp059, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp060, πE = πg.GetAttr(πF, πTemp059, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πTemp060.Call(πF, πTemp041, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp041)
					πTemp057 = πg.NewTuple2(πTemp058, πTemp059).ToObject()
					πTemp006[1] = πTemp057
					if πTemp058, πE = πg.ResolveClass(πF, πClass, nil, ßhyperlink_target); πE != nil {
						continue
					}
					πTemp041 = πF.MakeArgs(2)
					πTemp041[0] = πg.NewStr("\n                      \\.\\.[ ]+          # explicit markup start\n                      _                 # target indicator\n                      (?![ ]|$)         # first char. not space or EOL\n                      ").ToObject()
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp061, πE = πg.GetAttr(πF, πTemp060, ßVERBOSE, nil); πE != nil {
						continue
					}
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp062, πE = πg.GetAttr(πF, πTemp060, ßUNICODE, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πg.Or(πF, πTemp061, πTemp062); πE != nil {
						continue
					}
					πTemp041[1] = πTemp059
					if πTemp059, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp060, πE = πg.GetAttr(πF, πTemp059, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πTemp060.Call(πF, πTemp041, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp041)
					πTemp057 = πg.NewTuple2(πTemp058, πTemp059).ToObject()
					πTemp006[2] = πTemp057
					if πTemp058, πE = πg.ResolveClass(πF, πClass, nil, ßsubstitution_def); πE != nil {
						continue
					}
					πTemp041 = πF.MakeArgs(2)
					πTemp041[0] = πg.NewStr("\n                      \\.\\.[ ]+          # explicit markup start\n                      \\|                # substitution indicator\n                      (?![ ]|$)         # first char. not space or EOL\n                      ").ToObject()
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp061, πE = πg.GetAttr(πF, πTemp060, ßVERBOSE, nil); πE != nil {
						continue
					}
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp062, πE = πg.GetAttr(πF, πTemp060, ßUNICODE, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πg.Or(πF, πTemp061, πTemp062); πE != nil {
						continue
					}
					πTemp041[1] = πTemp059
					if πTemp059, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp060, πE = πg.GetAttr(πF, πTemp059, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πTemp060.Call(πF, πTemp041, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp041)
					πTemp057 = πg.NewTuple2(πTemp058, πTemp059).ToObject()
					πTemp006[3] = πTemp057
					if πTemp058, πE = πg.ResolveClass(πF, πClass, nil, ßdirective); πE != nil {
						continue
					}
					πTemp041 = πF.MakeArgs(2)
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßInliner); πE != nil {
						continue
					}
					if πTemp061, πE = πg.GetAttr(πF, πTemp060, ßsimplename, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πg.Mod(πF, πg.NewStr("\n                      \\.\\.[ ]+          # explicit markup start\n                      (%s)              # directive name\n                      [ ]?              # optional space\n                      ::                # directive delimiter\n                      ([ ]+|$)          # whitespace or end of line\n                      ").ToObject(), πTemp061); πE != nil {
						continue
					}
					πTemp041[0] = πTemp059
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp061, πE = πg.GetAttr(πF, πTemp060, ßVERBOSE, nil); πE != nil {
						continue
					}
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp062, πE = πg.GetAttr(πF, πTemp060, ßUNICODE, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πg.Or(πF, πTemp061, πTemp062); πE != nil {
						continue
					}
					πTemp041[1] = πTemp059
					if πTemp059, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp060, πE = πg.GetAttr(πF, πTemp059, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp059, πE = πTemp060.Call(πF, πTemp041, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp041)
					πTemp057 = πg.NewTuple2(πTemp058, πTemp059).ToObject()
					πTemp006[4] = πTemp057
					πTemp057 = πg.NewList(πTemp006...).ToObject()
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp058}, πTemp057); πE != nil {
						continue
					}
					if πTemp059, πE = πg.ResolveClass(πF, πClass, nil, ßexplicit); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp059, ßconstructs, πTemp058); πE != nil {
						continue
					}
					// line 2340: def explicit_markup(self, match, context, next_state):
					πF.SetLineno(2340)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp057 = πg.NewFunction(πg.NewCode("explicit_markup", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2341: """Footnotes, hyperlink targets, directives, comments."""
							πF.SetLineno(2341)
							// line 2342: nodelist, blank_finish = self.explicit_construct(match)
							πF.SetLineno(2342)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßexplicit_construct, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µnodelist = πTemp002
							µblank_finish = πTemp004
							// line 2343: self.parent += nodelist
							πF.SetLineno(2343)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µnodelist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2344: self.explicit_list(blank_finish)
							πF.SetLineno(2344)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001[0] = µblank_finish
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßexplicit_list, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2345: return [], next_state, []
							πF.SetLineno(2345)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßexplicit_markup.ToObject(), πTemp057); πE != nil {
						continue
					}
					// line 2341: """Footnotes, hyperlink targets, directives, comments."""
					πF.SetLineno(2341)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp058}, πg.NewStr("Footnotes, hyperlink targets, directives, comments.").ToObject()); πE != nil {
						continue
					}
					if πTemp059, πE = πg.ResolveClass(πF, πClass, nil, ßexplicit_markup); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp059, ß__doc__, πTemp058); πE != nil {
						continue
					}
					// line 2347: def explicit_construct(self, match):
					πF.SetLineno(2347)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp058 = πg.NewFunction(πg.NewCode("explicit_construct", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µerrors *πg.Object = πg.UnboundLocal
						_ = µerrors
						var µmethod *πg.Object = πg.UnboundLocal
						_ = µmethod
						var µpattern *πg.Object = πg.UnboundLocal
						_ = µpattern
						var µexpmatch *πg.Object = πg.UnboundLocal
						_ = µexpmatch
						var µerror *πg.Object = πg.UnboundLocal
						_ = µerror
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µmessage *πg.Object = πg.UnboundLocal
						_ = µmessage
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 *πg.BaseException
						_ = πTemp008
						var πTemp009 *πg.Traceback
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πTemp011 πg.KWArgs
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 2348: """Determine which explicit construct this is, parse & return it."""
							πF.SetLineno(2348)
							// line 2349: errors = []
							πF.SetLineno(2349)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µerrors = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßexplicit, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßconstructs, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp005 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp005 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp006 = !isStop
							} else {
								πTemp006 = true
								if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp007}}}, πTemp003); πE != nil {
									continue
								}
								µmethod = πTemp004
								µpattern = πTemp007
							}
							if πE != nil || !πTemp006 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2351: expmatch = pattern.match(match.string)
							πF.SetLineno(2351)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µpattern, "pattern"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µpattern, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µexpmatch = πTemp004
							if πE = πg.CheckLocal(πF, µexpmatch, "expmatch"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µexpmatch); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label4
							}
							goto Label5
							// line 2352: if expmatch:
							πF.SetLineno(2352)
						Label4:
							// line 2353: try:
							πF.SetLineno(2353)
							πF.PushCheckpoint(7)
							// line 2354: return method(self, expmatch)
							πF.SetLineno(2354)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µexpmatch, "expmatch"); πE != nil {
								continue
							}
							πTemp001[1] = µexpmatch
							if πE = πg.CheckLocal(πF, µmethod, "method"); πE != nil {
								continue
							}
							if πTemp003, πE = µmethod.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πR = πTemp003
							continue
							πF.PopCheckpoint()
							goto Label6
						Label7:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp008, πTemp009 = πF.ExcInfo()
							if πTemp003, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsInstance(πF, πTemp008.ToObject(), πTemp003); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label8
							}
							πE = πF.Raise(πTemp008.ToObject(), nil, πTemp009.ToObject())
							continue
							// line 2355: except MarkupError as error:
							πF.SetLineno(2355)
						Label8:
							µerror = πTemp008.ToObject()
							// line 2356: lineno = self.state_machine.abs_line_number()
							πF.SetLineno(2356)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlineno = πTemp003
							// line 2357: message = ' '.join(error.args)
							πF.SetLineno(2357)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µerror, "error"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µerror, ßargs, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πTemp003, πE = πg.GetAttr(πF, πg.NewStr(" ").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmessage = πTemp004
							// line 2358: errors.append(self.reporter.warning(message, line=lineno))
							πF.SetLineno(2358)
							πTemp001 = πF.MakeArgs(1)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmessage, "message"); πE != nil {
								continue
							}
							πTemp010[0] = µmessage
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp011 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp010, πTemp011); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µerrors, "errors"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µerrors, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2359: break
							πF.SetLineno(2359)
							πTemp005 = true
							continue
							πF.RestoreExc(nil, nil)
							goto Label6
						Label6:
							goto Label5
						Label5:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2360: nodelist, blank_finish = self.comment(match)
							πF.SetLineno(2360)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßcomment, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µnodelist = πTemp002
							µblank_finish = πTemp004
							// line 2361: return nodelist + errors, blank_finish
							πF.SetLineno(2361)
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µerrors, "errors"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, µnodelist, µerrors); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple2(πTemp003, µblank_finish).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßexplicit_construct.ToObject(), πTemp058); πE != nil {
						continue
					}
					// line 2348: """Determine which explicit construct this is, parse & return it."""
					πF.SetLineno(2348)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp059}, πg.NewStr("Determine which explicit construct this is, parse & return it.").ToObject()); πE != nil {
						continue
					}
					if πTemp060, πE = πg.ResolveClass(πF, πClass, nil, ßexplicit_construct); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp060, ß__doc__, πTemp059); πE != nil {
						continue
					}
					// line 2363: def explicit_list(self, blank_finish):
					πF.SetLineno(2363)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "blank_finish", Def: nil}
					πTemp059 = πg.NewFunction(πg.NewCode("explicit_list", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µblank_finish *πg.Object = πArgs[1]
						_ = µblank_finish
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µnewline_offset *πg.Object = πg.UnboundLocal
						_ = µnewline_offset
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2364: """
							πF.SetLineno(2364)
							// line 2368: offset = self.state_machine.line_offset + 1   # next line
							πF.SetLineno(2368)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp001
							// line 2369: newline_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(2369)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp004[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp003, ßmatch_titles, nil); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"input_offset", πTemp001},
								{"node", πTemp002},
								{"initial_state", ßExplicit.ToObject()},
								{"blank_finish", µblank_finish},
								{"match_titles", πTemp005},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µnewline_offset = πTemp001
							µblank_finish = πTemp003
							// line 2375: self.goto_line(newline_offset)
							πF.SetLineno(2375)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnewline_offset, "newline_offset"); πE != nil {
								continue
							}
							πTemp004[0] = µnewline_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 2376: if not blank_finish:
							πF.SetLineno(2376)
						Label1:
							// line 2377: self.parent += self.unindent_warning('Explicit markup')
							πF.SetLineno(2377)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp004 = πF.MakeArgs(1)
							πTemp004[0] = πg.NewStr("Explicit markup").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßexplicit_list.ToObject(), πTemp059); πE != nil {
						continue
					}
					// line 2364: """
					πF.SetLineno(2364)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp060}, πg.NewStr("\n        Create a nested state machine for a series of explicit markup\n        constructs (including anonymous hyperlink targets).\n        ").ToObject()); πE != nil {
						continue
					}
					if πTemp061, πE = πg.ResolveClass(πF, πClass, nil, ßexplicit_list); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp061, ß__doc__, πTemp060); πE != nil {
						continue
					}
					// line 2379: def anonymous(self, match, context, next_state):
					πF.SetLineno(2379)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp060 = πg.NewFunction(πg.NewCode("anonymous", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2380: """Anonymous hyperlink targets."""
							πF.SetLineno(2380)
							// line 2381: nodelist, blank_finish = self.anonymous_target(match)
							πF.SetLineno(2381)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßanonymous_target, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µnodelist = πTemp002
							µblank_finish = πTemp004
							// line 2382: self.parent += nodelist
							πF.SetLineno(2382)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µnodelist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2383: self.explicit_list(blank_finish)
							πF.SetLineno(2383)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001[0] = µblank_finish
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßexplicit_list, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2384: return [], next_state, []
							πF.SetLineno(2384)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßanonymous.ToObject(), πTemp060); πE != nil {
						continue
					}
					// line 2380: """Anonymous hyperlink targets."""
					πF.SetLineno(2380)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp061}, πg.NewStr("Anonymous hyperlink targets.").ToObject()); πE != nil {
						continue
					}
					if πTemp062, πE = πg.ResolveClass(πF, πClass, nil, ßanonymous); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp062, ß__doc__, πTemp061); πE != nil {
						continue
					}
					// line 2386: def anonymous_target(self, match):
					πF.SetLineno(2386)
					πTemp016 = make([]πg.Param, 2)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp061 = πg.NewFunction(πg.NewCode("anonymous_target", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µblock *πg.Object = πg.UnboundLocal
						_ = µblock
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µblocktext *πg.Object = πg.UnboundLocal
						_ = µblocktext
						var µtarget *πg.Object = πg.UnboundLocal
						_ = µtarget
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []πg.Param
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2387: lineno = self.state_machine.abs_line_number()
							πF.SetLineno(2387)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 2388: block, indent, offset, blank_finish \
							πF.SetLineno(2388)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"until_blank", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp001); πE != nil {
								continue
							}
							µblock = πTemp002
							µindent = πTemp005
							µoffset = πTemp006
							µblank_finish = πTemp007
							// line 2391: blocktext = match.string[:match.end()] + '\n'.join(block)
							πF.SetLineno(2391)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp006, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003[0] = µblock
							if πTemp002, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.Add(πF, πTemp005, πTemp006); πE != nil {
								continue
							}
							µblocktext = πTemp001
							// line 2392: block = [escape2null(line) for line in block]
							πF.SetLineno(2392)
							πTemp008 = make([]πg.Param, 0)
							πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp008, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
								var µline *πg.Object = πg.UnboundLocal
								_ = µline
								var πTemp001 *πg.Object
								_ = πTemp001
								var πTemp002 bool
								_ = πTemp002
								var πTemp003 bool
								_ = πTemp003
								var πTemp004 *πg.Object
								_ = πTemp004
								var πTemp005 []*πg.Object
								_ = πTemp005
								var πTemp006 *πg.Object
								_ = πTemp006
								var πR *πg.Object
								_ = πR
								var πE *πg.BaseException
								_ = πE
								return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
									for ; πF.State() >= 0; πF.PopCheckpoint() {
										switch πF.State() {
										case 0:
										case 1:
											goto Label1
										case 2:
											goto Label2
										case 4:
											goto Label4
										default:
											panic("unexpected function state")
										}
										if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
											continue
										}
										if πTemp001, πE = πg.Iter(πF, µblock); πE != nil {
											continue
										}
										πF.PushCheckpoint(2)
										πTemp002 = false
									Label1:
										if πE != nil || πR != nil {
											continue
										}
										if πTemp002 {
											πF.PopCheckpoint()
											goto Label3
										}
										if πTemp004, πE = πg.Next(πF, πTemp001); πE != nil {
											isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
											if exc != nil {
												πE = exc
											} else if isStop {
												πE = nil
												πF.RestoreExc(nil, nil)
											}
											πTemp003 = !isStop
										} else {
											πTemp003 = true
											µline = πTemp004
										}
										if πE != nil || !πTemp003 {
											continue
										}
										πF.PushCheckpoint(1)
										// line 2392: block = [escape2null(line) for line in block]
										πF.SetLineno(2392)
										πTemp005 = πF.MakeArgs(1)
										if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
											continue
										}
										πTemp005[0] = µline
										if πTemp004, πE = πg.ResolveGlobal(πF, ßescape2null); πE != nil {
											continue
										}
										if πTemp006, πE = πTemp004.Call(πF, πTemp005, nil); πE != nil {
											continue
										}
										πF.FreeArgs(πTemp005)
										πF.PushCheckpoint(4)
										return πTemp006, nil
									Label4:
										πTemp004 = πSent
										continue
									Label2:
										if πE != nil || πR != nil {
											continue
										}
									Label3:
									}
									return nil, πE
								}).ToObject(), nil
							}), πF.Globals()).ToObject()
							if πTemp005, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp005}, nil); πE != nil {
								continue
							}
							µblock = πTemp001
							// line 2393: target = self.make_target(block, blocktext, lineno, '')
							πF.SetLineno(2393)
							πTemp003 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp003[0] = µblock
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp003[1] = µblocktext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[2] = µlineno
							πTemp003[3] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmake_target, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µtarget = πTemp005
							// line 2394: return [target], blank_finish
							πF.SetLineno(2394)
							πTemp003 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µtarget, "target"); πE != nil {
								continue
							}
							πTemp003[0] = µtarget
							πTemp005 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp005, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßanonymous_target.ToObject(), πTemp061); πE != nil {
						continue
					}
					// line 2396: def line(self, match, context, next_state):
					πF.SetLineno(2396)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp062 = πg.NewFunction(πg.NewCode("line", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var µblocktext *πg.Object = πg.UnboundLocal
						_ = µblocktext
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2397: """Section title overline or transition marker."""
							πF.SetLineno(2397)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßmatch_titles, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp002, πg.NewStr("::").ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label2
							}
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.LT(πF, πTemp004, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label3
							}
							goto Label4
							// line 2398: if self.state_machine.match_titles:
							πF.SetLineno(2398)
						Label1:
							// line 2399: return [match.string], 'Line', []
							πF.SetLineno(2399)
							πTemp005 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp002
							πTemp002 = πg.NewList(πTemp005...).ToObject()
							πTemp005 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp005...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, ßLine.ToObject(), πTemp004).ToObject()
							πR = πTemp001
							continue
							goto Label5
							// line 2400: elif match.string.strip() == '::':
							πF.SetLineno(2400)
						Label2:
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = ßtext.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstatemachine); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßTransitionCorrection, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 2401: raise statemachine.TransitionCorrection('text')
							πF.SetLineno(2401)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
							goto Label5
							// line 2402: elif len(match.string.strip()) < 4:
							πF.SetLineno(2402)
						Label3:
							// line 2403: msg = self.reporter.info(
							πF.SetLineno(2403)
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = πg.NewStr("Unexpected possible title overline or transition.\nTreating it as ordinary text because it's so short.").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"line", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinfo, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µmsg = πTemp001
							// line 2407: self.parent += msg
							πF.SetLineno(2407)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							πTemp005 = πF.MakeArgs(1)
							πTemp005[0] = ßtext.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstatemachine); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßTransitionCorrection, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							// line 2408: raise statemachine.TransitionCorrection('text')
							πF.SetLineno(2408)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
							goto Label5
						Label4:
							// line 2410: blocktext = self.state_machine.line
							πF.SetLineno(2410)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßline, nil); πE != nil {
								continue
							}
							µblocktext = πTemp002
							// line 2411: msg = self.reporter.severe(
							πF.SetLineno(2411)
							πTemp005 = πF.MakeArgs(2)
							πTemp005[0] = πg.NewStr("Unexpected section title or transition.").ToObject()
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp007[0] = µblocktext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp007[1] = µblocktext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"line", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsevere, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µmsg = πTemp001
							// line 2415: self.parent += msg
							πF.SetLineno(2415)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2416: return [], next_state, []
							πF.SetLineno(2416)
							πTemp005 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp005...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp005 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp005...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp004).ToObject()
							πR = πTemp001
							continue
							goto Label5
						Label5:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßline.ToObject(), πTemp062); πE != nil {
						continue
					}
					// line 2397: """Section title overline or transition marker."""
					πF.SetLineno(2397)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp063}, πg.NewStr("Section title overline or transition marker.").ToObject()); πE != nil {
						continue
					}
					if πTemp064, πE = πg.ResolveClass(πF, πClass, nil, ßline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp064, ß__doc__, πTemp063); πE != nil {
						continue
					}
					// line 2418: def text(self, match, context, next_state):
					πF.SetLineno(2418)
					πTemp016 = make([]πg.Param, 4)
					πTemp016[0] = πg.Param{Name: "self", Def: nil}
					πTemp016[1] = πg.Param{Name: "match", Def: nil}
					πTemp016[2] = πg.Param{Name: "context", Def: nil}
					πTemp016[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp063 = πg.NewFunction(πg.NewCode("text", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp016, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2419: """Titles, definition lists, paragraphs."""
							πF.SetLineno(2419)
							// line 2420: return [match.string], 'Text', []
							πF.SetLineno(2420)
							πTemp002 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							πTemp003 = πg.NewList(πTemp002...).ToObject()
							πTemp002 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp002...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp003, ßText.ToObject(), πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtext.ToObject(), πTemp063); πE != nil {
						continue
					}
					// line 2419: """Titles, definition lists, paragraphs."""
					πF.SetLineno(2419)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp064}, πg.NewStr("Titles, definition lists, paragraphs.").ToObject()); πE != nil {
						continue
					}
					if πTemp065, πE = πg.ResolveClass(πF, πClass, nil, ßtext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp065, ß__doc__, πTemp064); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("Body").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBody.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2423: class RFC2822Body(Body):
			πF.SetLineno(2423)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("RFC2822Body", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 []πg.Param
				_ = πTemp004
				var πTemp005 []*πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2425: """
					πF.SetLineno(2425)
					// line 2425: """
					πF.SetLineno(2425)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    RFC2822 headers are only valid as the first constructs in documents.  As\n    soon as anything else appears, the `Body` state should take over.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 2430: patterns = Body.patterns.copy()     # can't modify the original
					πF.SetLineno(2430)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßBody); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßpatterns, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßcopy, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßpatterns.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2431: patterns['rfc2822'] = r'[!-9;-~]+:( +|$)'
					πF.SetLineno(2431)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewStr("[!-9;-~]+:( +|$)").ToObject()); πE != nil {
						continue
					}
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßpatterns); πE != nil {
						continue
					}
					πTemp003 = ßrfc2822.ToObject()
					if πE = πg.SetItem(πF, πTemp002, πTemp003, πTemp001); πE != nil {
						continue
					}
					// line 2432: initial_transitions = [(name, 'Body')
					πF.SetLineno(2432)
					πTemp004 = make([]πg.Param, 0)
					πTemp002 = πg.NewFunction(πg.NewCode("<generator>", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						return πg.NewGenerator(πF, func(πSent *πg.Object) (*πg.Object, *πg.BaseException) {
							for ; πF.State() >= 0; πF.PopCheckpoint() {
								switch πF.State() {
								case 0:
								case 1:
									goto Label1
								case 2:
									goto Label2
								case 4:
									goto Label4
								default:
									panic("unexpected function state")
								}
								if πTemp002, πE = πg.ResolveGlobal(πF, ßBody); πE != nil {
									continue
								}
								if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßinitial_transitions, nil); πE != nil {
									continue
								}
								if πTemp001, πE = πg.Iter(πF, πTemp003); πE != nil {
									continue
								}
								πF.PushCheckpoint(2)
								πTemp004 = false
							Label1:
								if πE != nil || πR != nil {
									continue
								}
								if πTemp004 {
									πF.PopCheckpoint()
									goto Label3
								}
								if πTemp002, πE = πg.Next(πF, πTemp001); πE != nil {
									isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
									if exc != nil {
										πE = exc
									} else if isStop {
										πE = nil
										πF.RestoreExc(nil, nil)
									}
									πTemp005 = !isStop
								} else {
									πTemp005 = true
									µname = πTemp002
								}
								if πE != nil || !πTemp005 {
									continue
								}
								πF.PushCheckpoint(1)
								// line 2432: initial_transitions = [(name, 'Body')
								πF.SetLineno(2432)
								if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
									continue
								}
								πTemp002 = πg.NewTuple2(µname, ßBody.ToObject()).ToObject()
								πF.PushCheckpoint(4)
								return πTemp002, nil
							Label4:
								πTemp003 = πSent
								continue
							Label2:
								if πE != nil || πR != nil {
									continue
								}
							Label3:
							}
							return nil, πE
						}).ToObject(), nil
					}), πF.Globals()).ToObject()
					if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πg.ListType.Call(πF, πg.Args{πTemp003}, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßinitial_transitions.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2434: initial_transitions.insert(-1, ('rfc2822', 'Body')) # just before 'text'
					πF.SetLineno(2434)
					πTemp005 = πF.MakeArgs(2)
					if πTemp001, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					πTemp005[0] = πTemp001
					πTemp001 = πg.NewTuple2(ßrfc2822.ToObject(), ßBody.ToObject()).ToObject()
					πTemp005[1] = πTemp001
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßinitial_transitions); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßinsert, nil); πE != nil {
						continue
					}
					if πTemp001, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp005)
					// line 2436: def rfc2822(self, match, context, next_state):
					πF.SetLineno(2436)
					πTemp004 = make([]πg.Param, 4)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp004[1] = πg.Param{Name: "match", Def: nil}
					πTemp004[2] = πg.Param{Name: "context", Def: nil}
					πTemp004[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("rfc2822", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µfieldlist *πg.Object = πg.UnboundLocal
						_ = µfieldlist
						var µfield *πg.Object = πg.UnboundLocal
						_ = µfield
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µnewline_offset *πg.Object = πg.UnboundLocal
						_ = µnewline_offset
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 πg.KWArgs
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2437: """RFC2822-style field list item."""
							πF.SetLineno(2437)
							// line 2438: fieldlist = nodes.field_list(classes=['rfc2822'])
							πF.SetLineno(2438)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = ßrfc2822.ToObject()
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πTemp003 = πg.KWArgs{
								{"classes", πTemp002},
							}
							if πTemp002, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßfield_list, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, nil, πTemp003); πE != nil {
								continue
							}
							µfieldlist = πTemp002
							// line 2439: self.parent += fieldlist
							πF.SetLineno(2439)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfieldlist, "fieldlist"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IAdd(πF, πTemp002, µfieldlist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp004); πE != nil {
								continue
							}
							// line 2440: field, blank_finish = self.rfc2822_field(match)
							πF.SetLineno(2440)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßrfc2822_field, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}}}, πTemp004); πE != nil {
								continue
							}
							µfield = πTemp002
							µblank_finish = πTemp005
							// line 2441: fieldlist += field
							πF.SetLineno(2441)
							if πE = πg.CheckLocal(πF, µfieldlist, "fieldlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield, "field"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, µfieldlist, µfield); πE != nil {
								continue
							}
							µfieldlist = πTemp002
							// line 2442: offset = self.state_machine.line_offset + 1   # next line
							πF.SetLineno(2442)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp005, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp002
							// line 2443: newline_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(2443)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp005, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp006, πTemp002); πE != nil {
								continue
							}
							πTemp001[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfieldlist, "fieldlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp003 = πg.KWArgs{
								{"input_offset", πTemp002},
								{"node", µfieldlist},
								{"initial_state", ßRFC2822List.ToObject()},
								{"blank_finish", µblank_finish},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp005}}}, πTemp004); πE != nil {
								continue
							}
							µnewline_offset = πTemp002
							µblank_finish = πTemp005
							// line 2448: self.goto_line(newline_offset)
							πF.SetLineno(2448)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnewline_offset, "newline_offset"); πE != nil {
								continue
							}
							πTemp001[0] = µnewline_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 2449: if not blank_finish:
							πF.SetLineno(2449)
						Label1:
							// line 2450: self.parent += self.unindent_warning(
							πF.SetLineno(2450)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("RFC2822-style field list").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IAdd(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp004); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 2452: return [], next_state, []
							πF.SetLineno(2452)
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp005 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp004, µnext_state, πTemp005).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßrfc2822.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2437: """RFC2822-style field list item."""
					πF.SetLineno(2437)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("RFC2822-style field list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßrfc2822); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2454: def rfc2822_field(self, match):
					πF.SetLineno(2454)
					πTemp004 = make([]πg.Param, 2)
					πTemp004[0] = πg.Param{Name: "self", Def: nil}
					πTemp004[1] = πg.Param{Name: "match", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("rfc2822_field", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp004, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µname *πg.Object = πg.UnboundLocal
						_ = µname
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µline_offset *πg.Object = πg.UnboundLocal
						_ = µline_offset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µfieldnode *πg.Object = πg.UnboundLocal
						_ = µfieldnode
						var µfieldbody *πg.Object = πg.UnboundLocal
						_ = µfieldbody
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 πg.KWArgs
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 *πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2455: name = match.string[:match.string.find(':')]
							πF.SetLineno(2455)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr(":").ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßfind, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πTemp003, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp001); πE != nil {
								continue
							}
							µname = πTemp003
							// line 2456: indented, indent, line_offset, blank_finish = \
							πF.SetLineno(2456)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"until_blank", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßget_first_known_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp006}, πg.TieTarget{Target: &πTemp007}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp003
							µindent = πTemp004
							µline_offset = πTemp006
							µblank_finish = πTemp007
							// line 2459: fieldnode = nodes.field()
							πF.SetLineno(2459)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßfield, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µfieldnode = πTemp001
							// line 2460: fieldnode += nodes.field_name(name, name)
							πF.SetLineno(2460)
							if πE = πg.CheckLocal(πF, µfieldnode, "fieldnode"); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp002[0] = µname
							if πE = πg.CheckLocal(πF, µname, "name"); πE != nil {
								continue
							}
							πTemp002[1] = µname
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßfield_name, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.IAdd(πF, µfieldnode, πTemp001); πE != nil {
								continue
							}
							µfieldnode = πTemp003
							// line 2461: fieldbody = nodes.field_body('\n'.join(indented))
							πF.SetLineno(2461)
							πTemp002 = πF.MakeArgs(1)
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp008[0] = µindented
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp002[0] = πTemp003
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßfield_body, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µfieldbody = πTemp001
							// line 2462: fieldnode += fieldbody
							πF.SetLineno(2462)
							if πE = πg.CheckLocal(πF, µfieldnode, "fieldnode"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfieldbody, "fieldbody"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µfieldnode, µfieldbody); πE != nil {
								continue
							}
							µfieldnode = πTemp001
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, µindented); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label1
							}
							goto Label2
							// line 2463: if indented:
							πF.SetLineno(2463)
						Label1:
							// line 2464: self.nested_parse(indented, input_offset=line_offset,
							πF.SetLineno(2464)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp002[0] = µindented
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfieldbody, "fieldbody"); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"input_offset", µline_offset},
								{"node", µfieldbody},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label2
						Label2:
							// line 2466: return fieldnode, blank_finish
							πF.SetLineno(2466)
							if πE = πg.CheckLocal(πF, µfieldnode, "fieldnode"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µfieldnode, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßrfc2822_field.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("RFC2822Body").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßRFC2822Body.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2469: class SpecializedBody(Body):
			πF.SetLineno(2469)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("SpecializedBody", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2471: """
					πF.SetLineno(2471)
					// line 2471: """
					πF.SetLineno(2471)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    Superclass for second and subsequent compound element members.  Compound\n    elements are lists and list-like constructs.\n\n    All transition methods are disabled (redefined as `invalid_input`).\n    Override individual methods in subclasses to re-enable.\n\n    For example, once an initial bullet list item, say, is recognized, the\n    `BulletList` subclass takes over, with a \"bullet_list\" node as its\n    container.  Upon encountering the initial bullet list item, `Body.bullet`\n    calls its ``self.nested_list_parse`` (`RSTState.nested_list_parse`), which\n    starts up a nested parsing session with `BulletList` as the initial state.\n    Only the ``bullet`` transition method is enabled in `BulletList`; as long\n    as only bullet list items are encountered, they are parsed and inserted\n    into the container.  The first construct which is *not* a bullet list item\n    triggers the `invalid_input` method, which ends the nested parse and\n    closes the container.  `BulletList` needs to recognize input that is\n    invalid in the context of a bullet list, which means everything *other\n    than* bullet list items, so it inherits the transition list created in\n    `Body`.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 2493: def invalid_input(self, match=None, context=None, next_state=None):
					πF.SetLineno(2493)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "match", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "context", Def: πTemp003}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "next_state", Def: πTemp003}
					πTemp001 = πg.NewFunction(πg.NewCode("invalid_input", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2494: """Not a compound element member. Abort this state machine."""
							πF.SetLineno(2494)
							// line 2495: self.state_machine.previous_line() # back up so parent SM can reassess
							πF.SetLineno(2495)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							// line 2496: raise EOFError
							πF.SetLineno(2496)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinvalid_input.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2494: """Not a compound element member. Abort this state machine."""
					πF.SetLineno(2494)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Not a compound element member. Abort this state machine.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2498: indent = invalid_input
					πF.SetLineno(2498)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßindent.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2499: bullet = invalid_input
					πF.SetLineno(2499)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßbullet.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2500: enumerator = invalid_input
					πF.SetLineno(2500)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßenumerator.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2501: field_marker = invalid_input
					πF.SetLineno(2501)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßfield_marker.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2502: option_marker = invalid_input
					πF.SetLineno(2502)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßoption_marker.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2503: doctest = invalid_input
					πF.SetLineno(2503)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßdoctest.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2504: line_block = invalid_input
					πF.SetLineno(2504)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßline_block.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2505: grid_table_top = invalid_input
					πF.SetLineno(2505)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßgrid_table_top.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2506: simple_table_top = invalid_input
					πF.SetLineno(2506)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßsimple_table_top.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2507: explicit_markup = invalid_input
					πF.SetLineno(2507)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßexplicit_markup.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2508: anonymous = invalid_input
					πF.SetLineno(2508)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßanonymous.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2509: line = invalid_input
					πF.SetLineno(2509)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßline.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2510: text = invalid_input
					πF.SetLineno(2510)
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtext.ToObject(), πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("SpecializedBody").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßSpecializedBody.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2513: class BulletList(SpecializedBody):
			πF.SetLineno(2513)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("BulletList", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2515: """Second and subsequent bullet_list list_items."""
					πF.SetLineno(2515)
					// line 2515: """Second and subsequent bullet_list list_items."""
					πF.SetLineno(2515)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Second and subsequent bullet_list list_items.").ToObject()); πE != nil {
						continue
					}
					// line 2517: def bullet(self, match, context, next_state):
					πF.SetLineno(2517)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("bullet", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µlistitem *πg.Object = πg.UnboundLocal
						_ = µlistitem
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2518: """Bullet list item."""
							πF.SetLineno(2518)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							πTemp002 = ßbullet.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.NE(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 2519: if match.string[0] != self.parent['bullet']:
							πF.SetLineno(2519)
						Label1:
							// line 2521: self.invalid_input()
							πF.SetLineno(2521)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßinvalid_input, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 2522: listitem, blank_finish = self.list_item(match.end())
							πF.SetLineno(2522)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßlist_item, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µlistitem = πTemp001
							µblank_finish = πTemp003
							// line 2523: self.parent += listitem
							πF.SetLineno(2523)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlistitem, "listitem"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µlistitem); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2524: self.blank_finish = blank_finish
							πF.SetLineno(2524)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp001); πE != nil {
								continue
							}
							// line 2525: return [], next_state, []
							πF.SetLineno(2525)
							πTemp007 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp007...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp007 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp007...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp003).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßbullet.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2518: """Bullet list item."""
					πF.SetLineno(2518)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Bullet list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßbullet); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("BulletList").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßBulletList.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2528: class DefinitionList(SpecializedBody):
			πF.SetLineno(2528)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("DefinitionList", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2530: """Second and subsequent definition_list_items."""
					πF.SetLineno(2530)
					// line 2530: """Second and subsequent definition_list_items."""
					πF.SetLineno(2530)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Second and subsequent definition_list_items.").ToObject()); πE != nil {
						continue
					}
					// line 2532: def text(self, match, context, next_state):
					πF.SetLineno(2532)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("text", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2533: """Definition lists."""
							πF.SetLineno(2533)
							// line 2534: return [match.string], 'Definition', []
							πF.SetLineno(2534)
							πTemp002 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							πTemp003 = πg.NewList(πTemp002...).ToObject()
							πTemp002 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp002...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp003, ßDefinition.ToObject(), πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtext.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2533: """Definition lists."""
					πF.SetLineno(2533)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Definition lists.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßtext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("DefinitionList").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßDefinitionList.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2537: class EnumeratedList(SpecializedBody):
			πF.SetLineno(2537)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("EnumeratedList", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2539: """Second and subsequent enumerated_list list_items."""
					πF.SetLineno(2539)
					// line 2539: """Second and subsequent enumerated_list list_items."""
					πF.SetLineno(2539)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Second and subsequent enumerated_list list_items.").ToObject()); πE != nil {
						continue
					}
					// line 2541: def enumerator(self, match, context, next_state):
					πF.SetLineno(2541)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("enumerator", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µformat *πg.Object = πg.UnboundLocal
						_ = µformat
						var µsequence *πg.Object = πg.UnboundLocal
						_ = µsequence
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µordinal *πg.Object = πg.UnboundLocal
						_ = µordinal
						var µlistitem *πg.Object = πg.UnboundLocal
						_ = µlistitem
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 *πg.Object
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2542: """Enumerated list item."""
							πF.SetLineno(2542)
							// line 2543: format, sequence, text, ordinal = self.parse_enumerator(
							πF.SetLineno(2543)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							πTemp002 = ßenumtype.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparse_enumerator, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}, πg.TieTarget{Target: &πTemp006}}}, πTemp003); πE != nil {
								continue
							}
							µformat = πTemp002
							µsequence = πTemp004
							µtext = πTemp005
							µordinal = πTemp006
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßformat, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.NE(πF, µformat, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πTemp003
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.NE(πF, µsequence, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp004
							if πTemp008, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if !πTemp008 {
								goto Label2
							}
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							πTemp006 = ßenumtype.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetItem(πF, πTemp011, πTemp006); πE != nil {
								continue
							}
							if πTemp005, πE = πg.NE(πF, µsequence, πTemp010); πE != nil {
								continue
							}
							πTemp004 = πTemp005
							if πTemp009, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßauto, nil); πE != nil {
								continue
							}
							πTemp004 = πTemp005
							if πTemp009, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetAttr(πF, µself, ßlastordinal, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.Add(πF, πTemp010, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.NE(πF, µordinal, πTemp006); πE != nil {
								continue
							}
							πTemp004 = πTemp005
						Label3:
							πTemp003 = πTemp004
						Label2:
							πTemp002 = πTemp003
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							πTemp001[0] = µordinal
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							πTemp001[1] = µsequence
							if πE = πg.CheckLocal(πF, µformat, "format"); πE != nil {
								continue
							}
							πTemp001[2] = µformat
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßis_enumerated_list_item, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp008, πE = πg.IsTrue(πF, πTemp005); πE != nil {
								continue
							}
							πTemp003 = πg.GetBool(!πTemp008).ToObject()
							πTemp002 = πTemp003
						Label1:
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 2545: if ( format != self.format
							πF.SetLineno(2545)
						Label4:
							// line 2551: self.invalid_input()
							πF.SetLineno(2551)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinvalid_input, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label5
						Label5:
							if πE = πg.CheckLocal(πF, µsequence, "sequence"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Eq(πF, µsequence, πg.NewStr("#").ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label6
							}
							goto Label7
							// line 2552: if sequence == '#':
							πF.SetLineno(2552)
						Label6:
							// line 2553: self.auto = 1
							πF.SetLineno(2553)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßauto, πTemp002); πE != nil {
								continue
							}
							goto Label7
						Label7:
							// line 2554: listitem, blank_finish = self.list_item(match.end())
							πF.SetLineno(2554)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßlist_item, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µlistitem = πTemp002
							µblank_finish = πTemp004
							// line 2555: self.parent += listitem
							πF.SetLineno(2555)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µlistitem, "listitem"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µlistitem); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2556: self.blank_finish = blank_finish
							πF.SetLineno(2556)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp002); πE != nil {
								continue
							}
							// line 2557: self.lastordinal = ordinal
							πF.SetLineno(2557)
							if πE = πg.CheckLocal(πF, µordinal, "ordinal"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µordinal); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßlastordinal, πTemp002); πE != nil {
								continue
							}
							// line 2558: return [], next_state, []
							πF.SetLineno(2558)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßenumerator.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2542: """Enumerated list item."""
					πF.SetLineno(2542)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Enumerated list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßenumerator); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("EnumeratedList").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßEnumeratedList.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2561: class FieldList(SpecializedBody):
			πF.SetLineno(2561)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("FieldList", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2563: """Second and subsequent field_list fields."""
					πF.SetLineno(2563)
					// line 2563: """Second and subsequent field_list fields."""
					πF.SetLineno(2563)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Second and subsequent field_list fields.").ToObject()); πE != nil {
						continue
					}
					// line 2565: def field_marker(self, match, context, next_state):
					πF.SetLineno(2565)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("field_marker", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µfield *πg.Object = πg.UnboundLocal
						_ = µfield
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2566: """Field list field."""
							πF.SetLineno(2566)
							// line 2567: field, blank_finish = self.field(match)
							πF.SetLineno(2567)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßfield, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µfield = πTemp002
							µblank_finish = πTemp004
							// line 2568: self.parent += field
							πF.SetLineno(2568)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield, "field"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µfield); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2569: self.blank_finish = blank_finish
							πF.SetLineno(2569)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp002); πE != nil {
								continue
							}
							// line 2570: return [], next_state, []
							πF.SetLineno(2570)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßfield_marker.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2566: """Field list field."""
					πF.SetLineno(2566)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Field list field.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßfield_marker); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("FieldList").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßFieldList.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2573: class OptionList(SpecializedBody):
			πF.SetLineno(2573)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("OptionList", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2575: """Second and subsequent option_list option_list_items."""
					πF.SetLineno(2575)
					// line 2575: """Second and subsequent option_list option_list_items."""
					πF.SetLineno(2575)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Second and subsequent option_list option_list_items.").ToObject()); πE != nil {
						continue
					}
					// line 2577: def option_marker(self, match, context, next_state):
					πF.SetLineno(2577)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("option_marker", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µoption_list_item *πg.Object = πg.UnboundLocal
						_ = µoption_list_item
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2578: """Option list item."""
							πF.SetLineno(2578)
							// line 2579: try:
							πF.SetLineno(2579)
							πF.PushCheckpoint(2)
							// line 2580: option_list_item, blank_finish = self.option_list_item(match)
							πF.SetLineno(2580)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßoption_list_item, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µoption_list_item = πTemp002
							µblank_finish = πTemp004
							πF.PopCheckpoint()
							goto Label1
						Label2:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßMarkupError); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label3
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 2581: except MarkupError:
							πF.SetLineno(2581)
						Label3:
							// line 2582: self.invalid_input()
							πF.SetLineno(2582)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßinvalid_input, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πF.RestoreExc(nil, nil)
							goto Label1
						Label1:
							// line 2583: self.parent += option_list_item
							πF.SetLineno(2583)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µoption_list_item, "option_list_item"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µoption_list_item); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2584: self.blank_finish = blank_finish
							πF.SetLineno(2584)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp002); πE != nil {
								continue
							}
							// line 2585: return [], next_state, []
							πF.SetLineno(2585)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßoption_marker.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2578: """Option list item."""
					πF.SetLineno(2578)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Option list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßoption_marker); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("OptionList").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßOptionList.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2588: class RFC2822List(SpecializedBody, RFC2822Body):
			πF.SetLineno(2588)
			πTemp002 = make([]*πg.Object, 2)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			if πTemp010, πE = πg.ResolveGlobal(πF, ßRFC2822Body); πE != nil {
				continue
			}
			πTemp002[1] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("RFC2822List", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2590: """Second and subsequent RFC2822-style field_list fields."""
					πF.SetLineno(2590)
					// line 2590: """Second and subsequent RFC2822-style field_list fields."""
					πF.SetLineno(2590)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Second and subsequent RFC2822-style field_list fields.").ToObject()); πE != nil {
						continue
					}
					// line 2592: patterns = RFC2822Body.patterns
					πF.SetLineno(2592)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßRFC2822Body); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßpatterns, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßpatterns.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2593: initial_transitions = RFC2822Body.initial_transitions
					πF.SetLineno(2593)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßRFC2822Body); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinitial_transitions, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßinitial_transitions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2595: def rfc2822(self, match, context, next_state):
					πF.SetLineno(2595)
					πTemp003 = make([]πg.Param, 4)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "match", Def: nil}
					πTemp003[2] = πg.Param{Name: "context", Def: nil}
					πTemp003[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("rfc2822", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µfield *πg.Object = πg.UnboundLocal
						_ = µfield
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2596: """RFC2822-style field list item."""
							πF.SetLineno(2596)
							// line 2597: field, blank_finish = self.rfc2822_field(match)
							πF.SetLineno(2597)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßrfc2822_field, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µfield = πTemp002
							µblank_finish = πTemp004
							// line 2598: self.parent += field
							πF.SetLineno(2598)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µfield, "field"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µfield); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2599: self.blank_finish = blank_finish
							πF.SetLineno(2599)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp002); πE != nil {
								continue
							}
							// line 2600: return [], 'RFC2822List', []
							πF.SetLineno(2600)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, ßRFC2822List.ToObject(), πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßrfc2822.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2596: """RFC2822-style field list item."""
					πF.SetLineno(2596)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("RFC2822-style field list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßrfc2822); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
					// line 2602: blank = SpecializedBody.invalid_input
					πF.SetLineno(2602)
					if πTemp002, πE = πg.ResolveClass(πF, πClass, nil, ßSpecializedBody); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßinvalid_input, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßblank.ToObject(), πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("RFC2822List").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßRFC2822List.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2605: class ExtensionOptions(FieldList):
			πF.SetLineno(2605)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßFieldList); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("ExtensionOptions", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2607: """
					πF.SetLineno(2607)
					// line 2607: """
					πF.SetLineno(2607)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    Parse field_list fields for extension options.\n\n    No nested parsing is done (including inline markup parsing).\n    ").ToObject()); πE != nil {
						continue
					}
					// line 2613: def parse_field_body(self, indented, offset, node):
					πF.SetLineno(2613)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "indented", Def: nil}
					πTemp002[2] = πg.Param{Name: "offset", Def: nil}
					πTemp002[3] = πg.Param{Name: "node", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("parse_field_body", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindented *πg.Object = πArgs[1]
						_ = µindented
						var µoffset *πg.Object = πArgs[2]
						_ = µoffset
						var µnode *πg.Object = πArgs[3]
						_ = µnode
						var µlines *πg.Object = πg.UnboundLocal
						_ = µlines
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2614: """Override `Body.parse_field_body` for simpler parsing."""
							πF.SetLineno(2614)
							// line 2615: lines = []
							πF.SetLineno(2615)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							µlines = πTemp002
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001[0] = µindented
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							πTemp001 = make([]*πg.Object, 1)
							πTemp001[0] = ß.ToObject()
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							if πTemp003, πE = πg.Add(πF, πTemp005, πTemp004); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Iter(πF, πTemp003); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp002); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µline = πTemp003
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µline, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µlines); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label5
							}
							goto Label6
							// line 2617: if line.strip():
							πF.SetLineno(2617)
						Label4:
							// line 2618: lines.append(line)
							πF.SetLineno(2618)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							πTemp001[0] = µline
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µlines, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							goto Label6
							// line 2619: elif lines:
							πF.SetLineno(2619)
						Label5:
							// line 2620: text = '\n'.join(lines)
							πF.SetLineno(2620)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp001[0] = µlines
							if πTemp003, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µtext = πTemp004
							// line 2621: node += nodes.paragraph(text, text)
							πF.SetLineno(2621)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[0] = µtext
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp001[1] = µtext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßparagraph, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πTemp004, πE = πg.IAdd(πF, µnode, πTemp003); πE != nil {
								continue
							}
							µnode = πTemp004
							// line 2622: lines = []
							πF.SetLineno(2622)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							µlines = πTemp003
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßparse_field_body.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2614: """Override `Body.parse_field_body` for simpler parsing."""
					πF.SetLineno(2614)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Override `Body.parse_field_body` for simpler parsing.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßparse_field_body); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("ExtensionOptions").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßExtensionOptions.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2625: class LineBlock(SpecializedBody):
			πF.SetLineno(2625)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("LineBlock", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 []πg.Param
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2627: """Second and subsequent lines of a line_block."""
					πF.SetLineno(2627)
					// line 2627: """Second and subsequent lines of a line_block."""
					πF.SetLineno(2627)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Second and subsequent lines of a line_block.").ToObject()); πE != nil {
						continue
					}
					// line 2629: blank = SpecializedBody.invalid_input
					πF.SetLineno(2629)
					if πTemp001, πE = πg.ResolveClass(πF, πClass, nil, ßSpecializedBody); πE != nil {
						continue
					}
					if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinvalid_input, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßblank.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2631: def line_block(self, match, context, next_state):
					πF.SetLineno(2631)
					πTemp003 = make([]πg.Param, 4)
					πTemp003[0] = πg.Param{Name: "self", Def: nil}
					πTemp003[1] = πg.Param{Name: "match", Def: nil}
					πTemp003[2] = πg.Param{Name: "context", Def: nil}
					πTemp003[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("line_block", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp003, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µline *πg.Object = πg.UnboundLocal
						_ = µline
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2632: """New line of line block."""
							πF.SetLineno(2632)
							// line 2633: lineno = self.state_machine.abs_line_number()
							πF.SetLineno(2633)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 2634: line, messages, blank_finish = self.line_block_line(match, lineno)
							πF.SetLineno(2634)
							πTemp003 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp003[0] = µmatch
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp003[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßline_block_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp002); πE != nil {
								continue
							}
							µline = πTemp001
							µmessages = πTemp004
							µblank_finish = πTemp005
							// line 2635: self.parent += line
							πF.SetLineno(2635)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µline, "line"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µline); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2636: self.parent.parent += messages
							πF.SetLineno(2636)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, πTemp002, µmessages); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp004, ßparent, πTemp001); πE != nil {
								continue
							}
							// line 2637: self.blank_finish = blank_finish
							πF.SetLineno(2637)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp001); πE != nil {
								continue
							}
							// line 2638: return [], next_state, []
							πF.SetLineno(2638)
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßline_block.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2632: """New line of line block."""
					πF.SetLineno(2632)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πg.NewStr("New line of line block.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßline_block); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp002); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("LineBlock").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLineBlock.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2641: class Explicit(SpecializedBody):
			πF.SetLineno(2641)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Explicit", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2643: """Second and subsequent explicit markup construct."""
					πF.SetLineno(2643)
					// line 2643: """Second and subsequent explicit markup construct."""
					πF.SetLineno(2643)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Second and subsequent explicit markup construct.").ToObject()); πE != nil {
						continue
					}
					// line 2645: def explicit_markup(self, match, context, next_state):
					πF.SetLineno(2645)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("explicit_markup", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2646: """Footnotes, hyperlink targets, directives, comments."""
							πF.SetLineno(2646)
							// line 2647: nodelist, blank_finish = self.explicit_construct(match)
							πF.SetLineno(2647)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßexplicit_construct, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µnodelist = πTemp002
							µblank_finish = πTemp004
							// line 2648: self.parent += nodelist
							πF.SetLineno(2648)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µnodelist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2649: self.blank_finish = blank_finish
							πF.SetLineno(2649)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp002); πE != nil {
								continue
							}
							// line 2650: return [], next_state, []
							πF.SetLineno(2650)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßexplicit_markup.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2646: """Footnotes, hyperlink targets, directives, comments."""
					πF.SetLineno(2646)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Footnotes, hyperlink targets, directives, comments.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßexplicit_markup); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2652: def anonymous(self, match, context, next_state):
					πF.SetLineno(2652)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("anonymous", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2653: """Anonymous hyperlink targets."""
							πF.SetLineno(2653)
							// line 2654: nodelist, blank_finish = self.anonymous_target(match)
							πF.SetLineno(2654)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßanonymous_target, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µnodelist = πTemp002
							µblank_finish = πTemp004
							// line 2655: self.parent += nodelist
							πF.SetLineno(2655)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µnodelist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2656: self.blank_finish = blank_finish
							πF.SetLineno(2656)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp002); πE != nil {
								continue
							}
							// line 2657: return [], next_state, []
							πF.SetLineno(2657)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßanonymous.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2653: """Anonymous hyperlink targets."""
					πF.SetLineno(2653)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Anonymous hyperlink targets.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßanonymous); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2659: blank = SpecializedBody.invalid_input
					πF.SetLineno(2659)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßSpecializedBody); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßinvalid_input, nil); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßblank.ToObject(), πTemp005); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("Explicit").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßExplicit.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2662: class SubstitutionDef(Body):
			πF.SetLineno(2662)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("SubstitutionDef", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 []*πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 []πg.Param
				_ = πTemp006
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2664: """
					πF.SetLineno(2664)
					// line 2664: """
					πF.SetLineno(2664)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    Parser for the contents of a substitution_definition element.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 2668: patterns = {
					πF.SetLineno(2668)
					πTemp001 = πg.NewDict()
					πTemp002 = πF.MakeArgs(2)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßInliner); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßsimplename, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πg.Mod(πF, πg.NewStr("(%s)::( +|$)").ToObject(), πTemp005); πE != nil {
						continue
					}
					πTemp002[0] = πTemp003
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßUNICODE, nil); πE != nil {
						continue
					}
					πTemp002[1] = πTemp004
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp002)
					if πE = πTemp001.SetItem(πF, ßembedded_directive.ToObject(), πTemp003); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, ßtext.ToObject(), ß.ToObject()); πE != nil {
						continue
					}
					πTemp003 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßpatterns.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2672: initial_transitions = ['embedded_directive', 'text']
					πF.SetLineno(2672)
					πTemp002 = make([]*πg.Object, 2)
					πTemp002[0] = ßembedded_directive.ToObject()
					πTemp002[1] = ßtext.ToObject()
					πTemp003 = πg.NewList(πTemp002...).ToObject()
					if πE = πClass.SetItem(πF, ßinitial_transitions.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2674: def embedded_directive(self, match, context, next_state):
					πF.SetLineno(2674)
					πTemp006 = make([]πg.Param, 4)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "match", Def: nil}
					πTemp006[2] = πg.Param{Name: "context", Def: nil}
					πTemp006[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("embedded_directive", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πTemp007 πg.KWArgs
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2675: nodelist, blank_finish = self.directive(match,
							πF.SetLineno(2675)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							πTemp001[0] = µmatch
							πTemp002 = πg.NewInt(0).ToObject()
							πTemp004 = ßnames.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, πTemp006, πTemp004); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"alt", πTemp003},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdirective, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µnodelist = πTemp002
							µblank_finish = πTemp004
							// line 2677: self.parent += nodelist
							πF.SetLineno(2677)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µnodelist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßat_eof, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp008).ToObject()
							if πTemp008, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp008 {
								goto Label1
							}
							goto Label2
							// line 2678: if not self.state_machine.at_eof():
							πF.SetLineno(2678)
						Label1:
							// line 2679: self.blank_finish = blank_finish
							πF.SetLineno(2679)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							// line 2680: raise EOFError
							πF.SetLineno(2680)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßembedded_directive.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2682: def text(self, match, context, next_state):
					πF.SetLineno(2682)
					πTemp006 = make([]πg.Param, 4)
					πTemp006[0] = πg.Param{Name: "self", Def: nil}
					πTemp006[1] = πg.Param{Name: "match", Def: nil}
					πTemp006[2] = πg.Param{Name: "context", Def: nil}
					πTemp006[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("text", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp006, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 bool
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßat_eof, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp004).ToObject()
							if πTemp004, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp004 {
								goto Label1
							}
							goto Label2
							// line 2683: if not self.state_machine.at_eof():
							πF.SetLineno(2683)
						Label1:
							// line 2684: self.blank_finish = self.state_machine.is_next_line_blank()
							πF.SetLineno(2684)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßis_next_line_blank, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							// line 2685: raise EOFError
							πF.SetLineno(2685)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtext.ToObject(), πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("SubstitutionDef").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßSubstitutionDef.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2688: class Text(RSTState):
			πF.SetLineno(2688)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßRSTState); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Text", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 []*πg.Object
				_ = πTemp006
				var πTemp007 []πg.Param
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				var πTemp011 *πg.Object
				_ = πTemp011
				var πTemp012 *πg.Object
				_ = πTemp012
				var πTemp013 *πg.Object
				_ = πTemp013
				var πTemp014 *πg.Object
				_ = πTemp014
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2690: """
					πF.SetLineno(2690)
					// line 2690: """
					πF.SetLineno(2690)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    Classifier of second line of a text block.\n\n    Could be a paragraph, a definition list item, or a title.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 2696: patterns = {'underline': Body.patterns['line'],
					πF.SetLineno(2696)
					πTemp001 = πg.NewDict()
					πTemp002 = ßline.ToObject()
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßBody); πE != nil {
						continue
					}
					if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßpatterns, nil); πE != nil {
						continue
					}
					if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, ßunderline.ToObject(), πTemp003); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, ßtext.ToObject(), ß.ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßpatterns.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2698: initial_transitions = [('underline', 'Body'), ('text', 'Body')]
					πF.SetLineno(2698)
					πTemp006 = make([]*πg.Object, 2)
					πTemp002 = πg.NewTuple2(ßunderline.ToObject(), ßBody.ToObject()).ToObject()
					πTemp006[0] = πTemp002
					πTemp002 = πg.NewTuple2(ßtext.ToObject(), ßBody.ToObject()).ToObject()
					πTemp006[1] = πTemp002
					πTemp002 = πg.NewList(πTemp006...).ToObject()
					if πE = πClass.SetItem(πF, ßinitial_transitions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2700: def blank(self, match, context, next_state):
					πF.SetLineno(2700)
					πTemp007 = make([]πg.Param, 4)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp007[1] = πg.Param{Name: "match", Def: nil}
					πTemp007[2] = πg.Param{Name: "context", Def: nil}
					πTemp007[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp002 = πg.NewFunction(πg.NewCode("blank", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µparagraph *πg.Object = πg.UnboundLocal
						_ = µparagraph
						var µliteralnext *πg.Object = πg.UnboundLocal
						_ = µliteralnext
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2701: """End of paragraph."""
							πF.SetLineno(2701)
							// line 2703: paragraph, literalnext = self.paragraph(
							πF.SetLineno(2703)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp001[0] = µcontext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Sub(πF, πTemp003, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparagraph, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µparagraph = πTemp002
							µliteralnext = πTemp004
							// line 2705: self.parent += paragraph
							πF.SetLineno(2705)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparagraph, "paragraph"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µparagraph); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µliteralnext, "literalnext"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, µliteralnext); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2706: if literalnext:
							πF.SetLineno(2706)
						Label1:
							// line 2707: self.parent += self.literal_block()
							πF.SetLineno(2707)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 2708: return [], 'Body', []
							πF.SetLineno(2708)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, ßBody.ToObject(), πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßblank.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 2701: """End of paragraph."""
					πF.SetLineno(2701)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("End of paragraph.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßblank); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2710: def eof(self, context):
					πF.SetLineno(2710)
					πTemp007 = make([]πg.Param, 2)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp007[1] = πg.Param{Name: "context", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("eof", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontext *πg.Object = πArgs[1]
						_ = µcontext
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IsTrue(πF, µcontext); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label1
							}
							goto Label2
							// line 2711: if context:
							πF.SetLineno(2711)
						Label1:
							// line 2712: self.blank(None, context, None)
							πF.SetLineno(2712)
							πTemp002 = πF.MakeArgs(3)
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp002[1] = µcontext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							πTemp002[2] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßblank, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							goto Label2
						Label2:
							// line 2713: return []
							πF.SetLineno(2713)
							πTemp002 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp002...).ToObject()
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßeof.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2715: def indent(self, match, context, next_state):
					πF.SetLineno(2715)
					πTemp007 = make([]πg.Param, 4)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp007[1] = πg.Param{Name: "match", Def: nil}
					πTemp007[2] = πg.Param{Name: "context", Def: nil}
					πTemp007[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("indent", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µdefinitionlist *πg.Object = πg.UnboundLocal
						_ = µdefinitionlist
						var µdefinitionlistitem *πg.Object = πg.UnboundLocal
						_ = µdefinitionlistitem
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µnewline_offset *πg.Object = πg.UnboundLocal
						_ = µnewline_offset
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2716: """Definition list item."""
							πF.SetLineno(2716)
							// line 2717: definitionlist = nodes.definition_list()
							πF.SetLineno(2717)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßdefinition_list, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µdefinitionlist = πTemp001
							// line 2718: definitionlistitem, blank_finish = self.definition_list_item(context)
							πF.SetLineno(2718)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp003[0] = µcontext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßdefinition_list_item, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µdefinitionlistitem = πTemp001
							µblank_finish = πTemp004
							// line 2719: definitionlist += definitionlistitem
							πF.SetLineno(2719)
							if πE = πg.CheckLocal(πF, µdefinitionlist, "definitionlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefinitionlistitem, "definitionlistitem"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µdefinitionlist, µdefinitionlistitem); πE != nil {
								continue
							}
							µdefinitionlist = πTemp001
							// line 2720: self.parent += definitionlist
							πF.SetLineno(2720)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefinitionlist, "definitionlist"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µdefinitionlist); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2721: offset = self.state_machine.line_offset + 1   # next line
							πF.SetLineno(2721)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßline_offset, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µoffset = πTemp001
							// line 2722: newline_offset, blank_finish = self.nested_list_parse(
							πF.SetLineno(2722)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefinitionlist, "definitionlist"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"input_offset", πTemp001},
								{"node", µdefinitionlist},
								{"initial_state", ßDefinitionList.ToObject()},
								{"blank_finish", µblank_finish},
								{"blank_finish_state", ßDefinition.ToObject()},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_list_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp002); πE != nil {
								continue
							}
							µnewline_offset = πTemp001
							µblank_finish = πTemp004
							// line 2727: self.goto_line(newline_offset)
							πF.SetLineno(2727)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnewline_offset, "newline_offset"); πE != nil {
								continue
							}
							πTemp003[0] = µnewline_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp007).ToObject()
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label1
							}
							goto Label2
							// line 2728: if not blank_finish:
							πF.SetLineno(2728)
						Label1:
							// line 2729: self.parent += self.unindent_warning('Definition list')
							πF.SetLineno(2729)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("Definition list").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label2
						Label2:
							// line 2730: return [], 'Body', []
							πF.SetLineno(2730)
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							πTemp003 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, ßBody.ToObject(), πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßindent.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2716: """Definition list item."""
					πF.SetLineno(2716)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Definition list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp008, πE = πg.ResolveClass(πF, πClass, nil, ßindent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp008, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 2732: def underline(self, match, context, next_state):
					πF.SetLineno(2732)
					πTemp007 = make([]πg.Param, 4)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp007[1] = πg.Param{Name: "match", Def: nil}
					πTemp007[2] = πg.Param{Name: "context", Def: nil}
					πTemp007[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("underline", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µtitle *πg.Object = πg.UnboundLocal
						_ = µtitle
						var µunderline *πg.Object = πg.UnboundLocal
						_ = µunderline
						var µsource *πg.Object = πg.UnboundLocal
						_ = µsource
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var µblocktext *πg.Object = πg.UnboundLocal
						_ = µblocktext
						var µsrc *πg.Object = πg.UnboundLocal
						_ = µsrc
						var µsrcline *πg.Object = πg.UnboundLocal
						_ = µsrcline
						var µstyle *πg.Object = πg.UnboundLocal
						_ = µstyle
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 πg.KWArgs
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2733: """Section title."""
							πF.SetLineno(2733)
							// line 2734: lineno = self.state_machine.abs_line_number()
							πF.SetLineno(2734)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 2735: title = context[0].rstrip()
							πF.SetLineno(2735)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcontext, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtitle = πTemp002
							// line 2736: underline = match.string.rstrip()
							πF.SetLineno(2736)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µunderline = πTemp001
							// line 2737: source = title + '\n' + underline
							πF.SetLineno(2737)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µtitle, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µunderline); πE != nil {
								continue
							}
							µsource = πTemp001
							// line 2738: messages = []
							πF.SetLineno(2738)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							µmessages = πTemp001
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							πTemp003[0] = µtitle
							if πTemp002, πE = πg.ResolveGlobal(πF, ßcolumn_width); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							πTemp003[0] = µunderline
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.GT(πF, πTemp004, πTemp005); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 2739: if column_width(title) > len(underline):
							πF.SetLineno(2739)
						Label1:
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							πTemp003[0] = µunderline
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							if πTemp001, πE = πg.LT(πF, πTemp004, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label3
							}
							goto Label4
							// line 2740: if len(underline) < 4:
							πF.SetLineno(2740)
						Label3:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßmatch_titles, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label6
							}
							goto Label7
							// line 2741: if self.state_machine.match_titles:
							πF.SetLineno(2741)
						Label6:
							// line 2742: msg = self.reporter.info(
							πF.SetLineno(2742)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("Possible title underline, too short for the title.\nTreating it as ordinary text because it's so short.").ToObject()
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinfo, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmsg = πTemp001
							// line 2746: self.parent += msg
							πF.SetLineno(2746)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label7
						Label7:
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = ßtext.ToObject()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstatemachine); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßTransitionCorrection, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2747: raise statemachine.TransitionCorrection('text')
							πF.SetLineno(2747)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
							goto Label5
						Label4:
							// line 2749: blocktext = context[0] + '\n' + self.state_machine.line
							πF.SetLineno(2749)
							πTemp004 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µcontext, πTemp004); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp005, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßline, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							µblocktext = πTemp001
							// line 2750: msg = self.reporter.warning('Title underline too short.',
							πF.SetLineno(2750)
							πTemp003 = πF.MakeArgs(2)
							πTemp003[0] = πg.NewStr("Title underline too short.").ToObject()
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp008[0] = µblocktext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp008[1] = µblocktext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmsg = πTemp001
							// line 2752: messages.append(msg)
							πF.SetLineno(2752)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp003[0] = µmsg
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmessages, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							goto Label5
						Label5:
							goto Label2
						Label2:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp002, ßmatch_titles, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label8
							}
							goto Label9
							// line 2753: if not self.state_machine.match_titles:
							πF.SetLineno(2753)
						Label8:
							// line 2754: blocktext = context[0] + '\n' + self.state_machine.line
							πF.SetLineno(2754)
							πTemp004 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µcontext, πTemp004); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp005, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßline, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							µblocktext = πTemp001
							// line 2756: src, srcline = self.state_machine.get_source_and_line()
							πF.SetLineno(2756)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp001); πE != nil {
								continue
							}
							µsrc = πTemp002
							µsrcline = πTemp004
							// line 2761: msg = self.reporter.severe('Unexpected section title.',
							πF.SetLineno(2761)
							πTemp003 = πF.MakeArgs(2)
							πTemp003[0] = πg.NewStr("Unexpected section title.").ToObject()
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp008[0] = µblocktext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp008[1] = µblocktext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp003[1] = πTemp001
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							πTemp007 = πg.KWArgs{
								{"source", µsrc},
								{"line", µsrcline},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsevere, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µmsg = πTemp001
							// line 2764: self.parent += messages
							πF.SetLineno(2764)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmessages); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2765: self.parent += msg
							πF.SetLineno(2765)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2766: return [], next_state, []
							πF.SetLineno(2766)
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp004).ToObject()
							πR = πTemp001
							continue
							goto Label9
						Label9:
							// line 2767: style = underline[0]
							πF.SetLineno(2767)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µunderline, πTemp001); πE != nil {
								continue
							}
							µstyle = πTemp002
							// line 2768: context[:] = []
							πF.SetLineno(2768)
							πTemp003 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.SetItem(πF, µcontext, πTemp004, πTemp002); πE != nil {
								continue
							}
							// line 2769: self.section(title, source, style, lineno - 1, messages)
							πF.SetLineno(2769)
							πTemp003 = πF.MakeArgs(5)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							πTemp003[0] = µtitle
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp003[1] = µsource
							if πE = πg.CheckLocal(πF, µstyle, "style"); πE != nil {
								continue
							}
							πTemp003[2] = µstyle
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, µlineno, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003[3] = πTemp001
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							πTemp003[4] = µmessages
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsection, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2770: return [], next_state, []
							πF.SetLineno(2770)
							πTemp003 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp003...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp003...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp004).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßunderline.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 2733: """Section title."""
					πF.SetLineno(2733)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Section title.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßunderline); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 2772: def text(self, match, context, next_state):
					πF.SetLineno(2772)
					πTemp007 = make([]πg.Param, 4)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp007[1] = πg.Param{Name: "match", Def: nil}
					πTemp007[2] = πg.Param{Name: "context", Def: nil}
					πTemp007[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("text", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µstartline *πg.Object = πg.UnboundLocal
						_ = µstartline
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var µblock *πg.Object = πg.UnboundLocal
						_ = µblock
						var µerr *πg.Object = πg.UnboundLocal
						_ = µerr
						var µsrc *πg.Object = πg.UnboundLocal
						_ = µsrc
						var µsrcline *πg.Object = πg.UnboundLocal
						_ = µsrcline
						var µlines *πg.Object = πg.UnboundLocal
						_ = µlines
						var µparagraph *πg.Object = πg.UnboundLocal
						_ = µparagraph
						var µliteralnext *πg.Object = πg.UnboundLocal
						_ = µliteralnext
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 πg.KWArgs
						_ = πTemp004
						var πTemp005 *πg.BaseException
						_ = πTemp005
						var πTemp006 *πg.Traceback
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 []*πg.Object
						_ = πTemp009
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 2:
								goto Label2
							case 7:
								goto Label7
							default:
								panic("unexpected function state")
							}
							// line 2773: """Paragraph."""
							πF.SetLineno(2773)
							// line 2774: startline = self.state_machine.abs_line_number() - 1
							πF.SetLineno(2774)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µstartline = πTemp001
							// line 2775: msg = None
							πF.SetLineno(2775)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							µmsg = πTemp001
							// line 2776: try:
							πF.SetLineno(2776)
							πF.PushCheckpoint(2)
							// line 2777: block = self.state_machine.get_text_block(flush_left=True)
							πF.SetLineno(2777)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"flush_left", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_text_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, πTemp004); πE != nil {
								continue
							}
							µblock = πTemp001
							πF.PopCheckpoint()
							goto Label1
						Label2:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßstatemachine); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßUnexpectedIndentationError, nil); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label3
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 2778: except statemachine.UnexpectedIndentationError as err:
							πF.SetLineno(2778)
						Label3:
							µerr = πTemp005.ToObject()
							// line 2779: block, src, srcline = err.args
							πF.SetLineno(2779)
							if πE = πg.CheckLocal(πF, µerr, "err"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µerr, ßargs, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp008}}}, πTemp001); πE != nil {
								continue
							}
							µblock = πTemp002
							µsrc = πTemp003
							µsrcline = πTemp008
							// line 2780: msg = self.reporter.error('Unexpected indentation.',
							πF.SetLineno(2780)
							πTemp009 = πF.MakeArgs(1)
							πTemp009[0] = πg.NewStr("Unexpected indentation.").ToObject()
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							πTemp004 = πg.KWArgs{
								{"source", µsrc},
								{"line", µsrcline},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp009, πTemp004); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							µmsg = πTemp001
							πF.RestoreExc(nil, nil)
							goto Label1
						Label1:
							// line 2782: lines = context + list(block)
							πF.SetLineno(2782)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp009 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µblock, "block"); πE != nil {
								continue
							}
							πTemp009[0] = µblock
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							if πTemp001, πE = πg.Add(πF, µcontext, πTemp003); πE != nil {
								continue
							}
							µlines = πTemp001
							// line 2783: paragraph, literalnext = self.paragraph(lines, startline)
							πF.SetLineno(2783)
							πTemp009 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp009[0] = µlines
							if πE = πg.CheckLocal(πF, µstartline, "startline"); πE != nil {
								continue
							}
							πTemp009[1] = µstartline
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparagraph, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp009, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp009)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µparagraph = πTemp001
							µliteralnext = πTemp003
							// line 2784: self.parent += paragraph
							πF.SetLineno(2784)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparagraph, "paragraph"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µparagraph); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2785: self.parent += msg
							πF.SetLineno(2785)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µliteralnext, "literalnext"); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, µliteralnext); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 2786: if literalnext:
							πF.SetLineno(2786)
						Label4:
							// line 2787: try:
							πF.SetLineno(2787)
							πF.PushCheckpoint(7)
							// line 2788: self.state_machine.next_line()
							πF.SetLineno(2788)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnext_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πF.PopCheckpoint()
							goto Label6
						Label7:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp005, πTemp006 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsInstance(πF, πTemp005.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label8
							}
							πE = πF.Raise(πTemp005.ToObject(), nil, πTemp006.ToObject())
							continue
							// line 2789: except EOFError:
							πF.SetLineno(2789)
						Label8:
							// line 2790: pass
							πF.SetLineno(2790)
							πF.RestoreExc(nil, nil)
							goto Label6
						Label6:
							// line 2791: self.parent += self.literal_block()
							πF.SetLineno(2791)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label5
						Label5:
							// line 2792: return [], next_state, []
							πF.SetLineno(2792)
							πTemp009 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp009...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp009 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp009...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, µnext_state, πTemp003).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtext.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 2773: """Paragraph."""
					πF.SetLineno(2773)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Paragraph.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßtext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 2794: def literal_block(self):
					πF.SetLineno(2794)
					πTemp007 = make([]πg.Param, 1)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("literal_block", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µdata *πg.Object = πg.UnboundLocal
						_ = µdata
						var µliteral_block *πg.Object = πg.UnboundLocal
						_ = µliteral_block
						var µnodelist *πg.Object = πg.UnboundLocal
						_ = µnodelist
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 bool
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 []*πg.Object
						_ = πTemp010
						var πTemp011 []*πg.Object
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2795: """Return a list of nodes."""
							πF.SetLineno(2795)
							// line 2796: indented, indent, offset, blank_finish = \
							πF.SetLineno(2796)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µindent = πTemp003
							µoffset = πTemp004
							µblank_finish = πTemp005
							// line 2798: while indented and not indented[-1].strip():
							πF.SetLineno(2798)
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp001 = µindented
							if πTemp008, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if !πTemp008 {
								goto Label4
							}
							if πTemp004, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp004
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µindented, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							πTemp002 = πg.GetBool(!πTemp009).ToObject()
							πTemp001 = πTemp002
						Label4:
							if πTemp007, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2799: indented.trim_end()
							πF.SetLineno(2799)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µindented, ßtrim_end, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µindented); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label5
							}
							goto Label6
							// line 2800: if not indented:
							πF.SetLineno(2800)
						Label5:
							// line 2801: return self.quoted_literal_block()
							πF.SetLineno(2801)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßquoted_literal_block, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πR = πTemp002
							continue
							goto Label6
						Label6:
							// line 2802: data = '\n'.join(indented)
							πF.SetLineno(2802)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp010[0] = µindented
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							µdata = πTemp002
							// line 2803: literal_block = nodes.literal_block(data, data)
							πF.SetLineno(2803)
							πTemp010 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp010[0] = µdata
							if πE = πg.CheckLocal(πF, µdata, "data"); πE != nil {
								continue
							}
							πTemp010[1] = µdata
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							µliteral_block = πTemp001
							// line 2804: (literal_block.source,
							πF.SetLineno(2804)
							πTemp010 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µoffset, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp010[0] = πTemp001
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µliteral_block, "literal_block"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µliteral_block, ßsource, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µliteral_block, "literal_block"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µliteral_block, ßline, πTemp003); πE != nil {
								continue
							}
							// line 2806: nodelist = [literal_block]
							πF.SetLineno(2806)
							πTemp010 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µliteral_block, "literal_block"); πE != nil {
								continue
							}
							πTemp010[0] = µliteral_block
							πTemp001 = πg.NewList(πTemp010...).ToObject()
							µnodelist = πTemp001
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, µblank_finish); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label7
							}
							goto Label8
							// line 2807: if not blank_finish:
							πF.SetLineno(2807)
						Label7:
							// line 2808: nodelist.append(self.unindent_warning('Literal block'))
							πF.SetLineno(2808)
							πTemp010 = πF.MakeArgs(1)
							πTemp011 = πF.MakeArgs(1)
							πTemp011[0] = πg.NewStr("Literal block").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßunindent_warning, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp010[0] = πTemp002
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µnodelist, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp010, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp010)
							goto Label8
						Label8:
							// line 2809: return nodelist
							πF.SetLineno(2809)
							if πE = πg.CheckLocal(πF, µnodelist, "nodelist"); πE != nil {
								continue
							}
							πR = µnodelist
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßliteral_block.ToObject(), πTemp009); πE != nil {
						continue
					}
					// line 2795: """Return a list of nodes."""
					πF.SetLineno(2795)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp010}, πg.NewStr("Return a list of nodes.").ToObject()); πE != nil {
						continue
					}
					if πTemp011, πE = πg.ResolveClass(πF, πClass, nil, ßliteral_block); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp011, ß__doc__, πTemp010); πE != nil {
						continue
					}
					// line 2811: def quoted_literal_block(self):
					πF.SetLineno(2811)
					πTemp007 = make([]πg.Param, 1)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp010 = πg.NewFunction(πg.NewCode("quoted_literal_block", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µabs_line_offset *πg.Object = πg.UnboundLocal
						_ = µabs_line_offset
						var µoffset *πg.Object = πg.UnboundLocal
						_ = µoffset
						var µparent_node *πg.Object = πg.UnboundLocal
						_ = µparent_node
						var µnew_abs_offset *πg.Object = πg.UnboundLocal
						_ = µnew_abs_offset
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 *πg.Dict
						_ = πTemp006
						var πTemp007 πg.KWArgs
						_ = πTemp007
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2812: abs_line_offset = self.state_machine.abs_line_offset()
							πF.SetLineno(2812)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßabs_line_offset, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µabs_line_offset = πTemp001
							// line 2813: offset = self.state_machine.line_offset
							πF.SetLineno(2813)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßline_offset, nil); πE != nil {
								continue
							}
							µoffset = πTemp002
							// line 2814: parent_node = nodes.Element()
							πF.SetLineno(2814)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßElement, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µparent_node = πTemp001
							// line 2815: new_abs_offset = self.nested_parse(
							πF.SetLineno(2815)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoffset, "offset"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.SliceType.Call(πF, πg.Args{µoffset, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßinput_lines, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, πTemp005, πTemp001); πE != nil {
								continue
							}
							πTemp003[0] = πTemp002
							if πE = πg.CheckLocal(πF, µabs_line_offset, "abs_line_offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparent_node, "parent_node"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							πTemp006 = πg.NewDict()
							if πTemp004, πE = πg.ResolveGlobal(πF, ßQuotedLiteralBlock); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple1(πTemp004).ToObject()
							if πE = πTemp006.SetItem(πF, ßstate_classes.ToObject(), πTemp002); πE != nil {
								continue
							}
							if πE = πTemp006.SetItem(πF, ßinitial_state.ToObject(), ßQuotedLiteralBlock.ToObject()); πE != nil {
								continue
							}
							πTemp002 = πTemp006.ToObject()
							πTemp007 = πg.KWArgs{
								{"input_offset", µabs_line_offset},
								{"node", µparent_node},
								{"match_titles", πTemp001},
								{"state_machine_kwargs", πTemp002},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, πTemp007); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							µnew_abs_offset = πTemp002
							// line 2820: self.goto_line(new_abs_offset)
							πF.SetLineno(2820)
							πTemp003 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnew_abs_offset, "new_abs_offset"); πE != nil {
								continue
							}
							πTemp003[0] = µnew_abs_offset
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßgoto_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp003, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							// line 2821: return parent_node.children
							πF.SetLineno(2821)
							if πE = πg.CheckLocal(πF, µparent_node, "parent_node"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µparent_node, ßchildren, nil); πE != nil {
								continue
							}
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßquoted_literal_block.ToObject(), πTemp010); πE != nil {
						continue
					}
					// line 2823: def definition_list_item(self, termline):
					πF.SetLineno(2823)
					πTemp007 = make([]πg.Param, 2)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp007[1] = πg.Param{Name: "termline", Def: nil}
					πTemp011 = πg.NewFunction(πg.NewCode("definition_list_item", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µtermline *πg.Object = πArgs[1]
						_ = µtermline
						var µindented *πg.Object = πg.UnboundLocal
						_ = µindented
						var µindent *πg.Object = πg.UnboundLocal
						_ = µindent
						var µline_offset *πg.Object = πg.UnboundLocal
						_ = µline_offset
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var µitemnode *πg.Object = πg.UnboundLocal
						_ = µitemnode
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µtermlist *πg.Object = πg.UnboundLocal
						_ = µtermlist
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µdefinition *πg.Object = πg.UnboundLocal
						_ = µdefinition
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 []*πg.Object
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 bool
						_ = πTemp009
						var πTemp010 πg.KWArgs
						_ = πTemp010
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2824: indented, indent, line_offset, blank_finish = \
							πF.SetLineno(2824)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_indented, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp001); πE != nil {
								continue
							}
							µindented = πTemp002
							µindent = πTemp003
							µline_offset = πTemp004
							µblank_finish = πTemp005
							// line 2826: itemnode = nodes.definition_list_item(
							πF.SetLineno(2826)
							πTemp006 = πF.MakeArgs(1)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtermline, "termline"); πE != nil {
								continue
							}
							πTemp008 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp008[0] = µindented
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlist); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							if πTemp001, πE = πg.Add(πF, µtermline, πTemp003); πE != nil {
								continue
							}
							πTemp007[0] = πTemp001
							if πTemp001, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp006[0] = πTemp002
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßdefinition_list_item, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µitemnode = πTemp001
							// line 2828: lineno = self.state_machine.abs_line_number() - 1
							πF.SetLineno(2828)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 2829: (itemnode.source,
							πF.SetLineno(2829)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp006[0] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µitemnode, "itemnode"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µitemnode, ßsource, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µitemnode, "itemnode"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µitemnode, ßline, πTemp003); πE != nil {
								continue
							}
							// line 2831: termlist, messages = self.term(termline, lineno)
							πF.SetLineno(2831)
							πTemp006 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtermline, "termline"); πE != nil {
								continue
							}
							πTemp006[0] = µtermline
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp006[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßterm, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp003}}}, πTemp002); πE != nil {
								continue
							}
							µtermlist = πTemp001
							µmessages = πTemp003
							// line 2832: itemnode += termlist
							πF.SetLineno(2832)
							if πE = πg.CheckLocal(πF, µitemnode, "itemnode"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtermlist, "termlist"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µitemnode, µtermlist); πE != nil {
								continue
							}
							µitemnode = πTemp001
							// line 2833: definition = nodes.definition('', *messages)
							πF.SetLineno(2833)
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = ß.ToObject()
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßdefinition, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Invoke(πF, πTemp002, πTemp006, µmessages, nil, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							µdefinition = πTemp001
							// line 2834: itemnode += definition
							πF.SetLineno(2834)
							if πE = πg.CheckLocal(πF, µitemnode, "itemnode"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefinition, "definition"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IAdd(πF, µitemnode, µdefinition); πE != nil {
								continue
							}
							µitemnode = πTemp001
							if πTemp003, πE = πg.Neg(πF, πg.NewInt(2).ToObject()); πE != nil {
								continue
							}
							if πTemp002, πE = πg.SliceType.Call(πF, πg.Args{πTemp003, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							πTemp004 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µtermline, "termline"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetItem(πF, µtermline, πTemp004); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp005, πTemp002); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Eq(πF, πTemp003, πg.NewStr("::").ToObject()); πE != nil {
								continue
							}
							if πTemp009, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp009 {
								goto Label1
							}
							goto Label2
							// line 2835: if termline[0][-2:] == '::':
							πF.SetLineno(2835)
						Label1:
							// line 2836: definition += self.reporter.info(
							πF.SetLineno(2836)
							if πE = πg.CheckLocal(πF, µdefinition, "definition"); πE != nil {
								continue
							}
							πTemp006 = πF.MakeArgs(1)
							πTemp006[0] = πg.NewStr("Blank line missing before literal block (after the \"::\")? Interpreted as a definition list item.").ToObject()
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µlineno, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp010 = πg.KWArgs{
								{"line", πTemp001},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßinfo, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp006, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							if πTemp002, πE = πg.IAdd(πF, µdefinition, πTemp001); πE != nil {
								continue
							}
							µdefinition = πTemp002
							goto Label2
						Label2:
							// line 2840: self.nested_parse(indented, input_offset=line_offset, node=definition)
							πF.SetLineno(2840)
							πTemp006 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µindented, "indented"); πE != nil {
								continue
							}
							πTemp006[0] = µindented
							if πE = πg.CheckLocal(πF, µline_offset, "line_offset"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µdefinition, "definition"); πE != nil {
								continue
							}
							πTemp010 = πg.KWArgs{
								{"input_offset", µline_offset},
								{"node", µdefinition},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßnested_parse, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp006, πTemp010); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp006)
							// line 2841: return itemnode, blank_finish
							πF.SetLineno(2841)
							if πE = πg.CheckLocal(πF, µitemnode, "itemnode"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µitemnode, µblank_finish).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßdefinition_list_item.ToObject(), πTemp011); πE != nil {
						continue
					}
					// line 2843: classifier_delimiter = re.compile(' +: +')
					πF.SetLineno(2843)
					πTemp006 = πF.MakeArgs(1)
					πTemp006[0] = πg.NewStr(" +: +").ToObject()
					if πTemp012, πE = πg.ResolveClass(πF, πClass, nil, ßre); πE != nil {
						continue
					}
					if πTemp013, πE = πg.GetAttr(πF, πTemp012, ßcompile, nil); πE != nil {
						continue
					}
					if πTemp012, πE = πTemp013.Call(πF, πTemp006, nil); πE != nil {
						continue
					}
					πF.FreeArgs(πTemp006)
					if πE = πClass.SetItem(πF, ßclassifier_delimiter.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 2845: def term(self, lines, lineno):
					πF.SetLineno(2845)
					πTemp007 = make([]πg.Param, 3)
					πTemp007[0] = πg.Param{Name: "self", Def: nil}
					πTemp007[1] = πg.Param{Name: "lines", Def: nil}
					πTemp007[2] = πg.Param{Name: "lineno", Def: nil}
					πTemp012 = πg.NewFunction(πg.NewCode("term", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp007, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µlines *πg.Object = πArgs[1]
						_ = µlines
						var µlineno *πg.Object = πArgs[2]
						_ = µlineno
						var µtext_nodes *πg.Object = πg.UnboundLocal
						_ = µtext_nodes
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µterm_node *πg.Object = πg.UnboundLocal
						_ = µterm_node
						var µnode_list *πg.Object = πg.UnboundLocal
						_ = µnode_list
						var µi *πg.Object = πg.UnboundLocal
						_ = µi
						var µnode *πg.Object = πg.UnboundLocal
						_ = µnode
						var µparts *πg.Object = πg.UnboundLocal
						_ = µparts
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µtextnode *πg.Object = πg.UnboundLocal
						_ = µtextnode
						var µpart *πg.Object = πg.UnboundLocal
						_ = µpart
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 bool
						_ = πTemp007
						var πTemp008 *πg.Object
						_ = πTemp008
						var πTemp009 *πg.Object
						_ = πTemp009
						var πTemp010 bool
						_ = πTemp010
						var πTemp011 []*πg.Object
						_ = πTemp011
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 1:
								goto Label1
							case 2:
								goto Label2
							case 11:
								goto Label11
							case 10:
								goto Label10
							default:
								panic("unexpected function state")
							}
							// line 2846: """Return a definition_list's term and optional classifiers."""
							πF.SetLineno(2846)
							// line 2847: assert len(lines) == 1
							πF.SetLineno(2847)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp002[0] = µlines
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Eq(πF, πTemp004, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.Assert(πF, πTemp001, nil); πE != nil {
								continue
							}
							// line 2848: text_nodes, messages = self.inline_text(lines[0], lineno)
							πF.SetLineno(2848)
							πTemp002 = πF.MakeArgs(2)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µlines, πTemp001); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp002[1] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßinline_text, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp001.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp001}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µtext_nodes = πTemp001
							µmessages = πTemp004
							// line 2849: term_node = nodes.term(lines[0])
							πF.SetLineno(2849)
							πTemp002 = πF.MakeArgs(1)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µlines, πTemp001); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßterm, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µterm_node = πTemp001
							// line 2850: (term_node.source,
							πF.SetLineno(2850)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp002[0] = µlineno
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp003}, πg.TieTarget{Target: &πTemp004}}}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µterm_node, "term_node"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µterm_node, ßsource, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µterm_node, "term_node"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µterm_node, ßline, πTemp004); πE != nil {
								continue
							}
							// line 2852: node_list = [term_node]
							πF.SetLineno(2852)
							πTemp002 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µterm_node, "term_node"); πE != nil {
								continue
							}
							πTemp002[0] = µterm_node
							πTemp001 = πg.NewList(πTemp002...).ToObject()
							µnode_list = πTemp001
							πTemp002 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext_nodes, "text_nodes"); πE != nil {
								continue
							}
							πTemp005[0] = µtext_nodes
							if πTemp003, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp002[0] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßrange); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp001, πE = πg.Iter(πF, πTemp004); πE != nil {
								continue
							}
							πF.PushCheckpoint(2)
							πTemp006 = false
						Label1:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp006 {
								πF.PopCheckpoint()
								goto Label3
							}
							if πTemp003, πE = πg.Next(πF, πTemp001); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp007 = !isStop
							} else {
								πTemp007 = true
								µi = πTemp003
							}
							if πE != nil || !πTemp007 {
								continue
							}
							πF.PushCheckpoint(1)
							// line 2854: node = text_nodes[i]
							πF.SetLineno(2854)
							if πE = πg.CheckLocal(πF, µi, "i"); πE != nil {
								continue
							}
							πTemp003 = µi
							if πE = πg.CheckLocal(πF, µtext_nodes, "text_nodes"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µtext_nodes, πTemp003); πE != nil {
								continue
							}
							µnode = πTemp004
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp002[0] = µnode
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßText, nil); πE != nil {
								continue
							}
							πTemp002[1] = πTemp004
							if πTemp003, πE = πg.ResolveGlobal(πF, ßisinstance); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp007, πE = πg.IsTrue(πF, πTemp004); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label4
							}
							goto Label5
							// line 2855: if isinstance(node, nodes.Text):
							πF.SetLineno(2855)
						Label4:
							// line 2856: parts = self.classifier_delimiter.split(node)
							πF.SetLineno(2856)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							πTemp002[0] = µnode
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßclassifier_delimiter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßsplit, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µparts = πTemp003
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							πTemp002[0] = µparts
							if πTemp004, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp003, πE = πg.Eq(πF, πTemp008, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πTemp007, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							if πTemp007 {
								goto Label7
							}
							goto Label8
							// line 2857: if len(parts) == 1:
							πF.SetLineno(2857)
						Label7:
							// line 2858: node_list[-1] += node
							πF.SetLineno(2858)
							if πTemp004, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp004
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µnode_list, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp004, µnode); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp008 = πTemp009
							if πE = πg.SetItem(πF, µnode_list, πTemp008, πTemp003); πE != nil {
								continue
							}
							goto Label9
						Label8:
							// line 2860: text = parts[0].rstrip()
							πF.SetLineno(2860)
							πTemp003 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µparts, πTemp003); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp004, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtext = πTemp004
							// line 2861: textnode = nodes.Text(text)
							πF.SetLineno(2861)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp002[0] = µtext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßText, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µtextnode = πTemp003
							// line 2862: node_list[-1] += textnode
							πF.SetLineno(2862)
							if πTemp004, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp004
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µnode_list, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtextnode, "textnode"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp004, µtextnode); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp008 = πTemp009
							if πE = πg.SetItem(πF, µnode_list, πTemp008, πTemp003); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πg.NewInt(1).ToObject(), πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µparts, "parts"); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetItem(πF, µparts, πTemp004); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Iter(πF, πTemp008); πE != nil {
								continue
							}
							πF.PushCheckpoint(11)
							πTemp007 = false
						Label10:
							if πE != nil || πR != nil {
								continue
							}
							if πTemp007 {
								πF.PopCheckpoint()
								goto Label12
							}
							if πTemp004, πE = πg.Next(πF, πTemp003); πE != nil {
								isStop, exc := πg.IsInstance(πF, πE.ToObject(), πg.StopIterationType.ToObject())
								if exc != nil {
									πE = exc
								} else if isStop {
									πE = nil
									πF.RestoreExc(nil, nil)
								}
								πTemp010 = !isStop
							} else {
								πTemp010 = true
								µpart = πTemp004
							}
							if πE != nil || !πTemp010 {
								continue
							}
							πF.PushCheckpoint(10)
							// line 2864: node_list.append(
							πF.SetLineno(2864)
							πTemp002 = πF.MakeArgs(1)
							πTemp005 = πF.MakeArgs(2)
							πTemp011 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
								continue
							}
							πTemp011[0] = µpart
							if πTemp004, πE = πg.ResolveGlobal(πF, ßTrue); πE != nil {
								continue
							}
							πTemp011[1] = πTemp004
							if πTemp004, πE = πg.ResolveGlobal(πF, ßunescape); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp011, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp011)
							πTemp005[0] = πTemp008
							if πE = πg.CheckLocal(πF, µpart, "part"); πE != nil {
								continue
							}
							πTemp005[1] = µpart
							if πTemp004, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp008, πE = πg.GetAttr(πF, πTemp004, ßclassifier, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp008.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µnode_list, ßappend, nil); πE != nil {
								continue
							}
							if πTemp008, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							continue
						Label11:
							if πE != nil || πR != nil {
								continue
							}
						Label12:
							goto Label9
						Label9:
							goto Label6
						Label5:
							// line 2867: node_list[-1] += node
							πF.SetLineno(2867)
							if πTemp004, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp003 = πTemp004
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetItem(πF, µnode_list, πTemp003); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode, "node"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp004, µnode); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πTemp009, πE = πg.Neg(πF, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp008 = πTemp009
							if πE = πg.SetItem(πF, µnode_list, πTemp008, πTemp003); πE != nil {
								continue
							}
							goto Label6
						Label6:
							continue
						Label2:
							if πE != nil || πR != nil {
								continue
							}
						Label3:
							// line 2868: return node_list, messages
							πF.SetLineno(2868)
							if πE = πg.CheckLocal(πF, µnode_list, "node_list"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(µnode_list, µmessages).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßterm.ToObject(), πTemp012); πE != nil {
						continue
					}
					// line 2846: """Return a definition_list's term and optional classifiers."""
					πF.SetLineno(2846)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp013}, πg.NewStr("Return a definition_list's term and optional classifiers.").ToObject()); πE != nil {
						continue
					}
					if πTemp014, πE = πg.ResolveClass(πF, πClass, nil, ßterm); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp014, ß__doc__, πTemp013); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("Text").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßText.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2871: class SpecializedText(Text):
			πF.SetLineno(2871)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("SpecializedText", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2873: """
					πF.SetLineno(2873)
					// line 2873: """
					πF.SetLineno(2873)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    Superclass for second and subsequent lines of Text-variants.\n\n    All transition methods are disabled. Override individual methods in\n    subclasses to re-enable.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 2880: def eof(self, context):
					πF.SetLineno(2880)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "context", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("eof", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontext *πg.Object = πArgs[1]
						_ = µcontext
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2881: """Incomplete construct."""
							πF.SetLineno(2881)
							// line 2882: return []
							πF.SetLineno(2882)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßeof.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2881: """Incomplete construct."""
					πF.SetLineno(2881)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Incomplete construct.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßeof); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2884: def invalid_input(self, match=None, context=None, next_state=None):
					πF.SetLineno(2884)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[1] = πg.Param{Name: "match", Def: πTemp004}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[2] = πg.Param{Name: "context", Def: πTemp004}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßNone); πE != nil {
						continue
					}
					πTemp002[3] = πg.Param{Name: "next_state", Def: πTemp004}
					πTemp003 = πg.NewFunction(πg.NewCode("invalid_input", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 *πg.Object
						_ = πTemp001
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2885: """Not a compound element member. Abort this state machine."""
							πF.SetLineno(2885)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							// line 2886: raise EOFError
							πF.SetLineno(2886)
							πE = πF.Raise(πTemp001, nil, nil)
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinvalid_input.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2885: """Not a compound element member. Abort this state machine."""
					πF.SetLineno(2885)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Not a compound element member. Abort this state machine.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2888: blank = invalid_input
					πF.SetLineno(2888)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßblank.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2889: indent = invalid_input
					πF.SetLineno(2889)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßindent.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2890: underline = invalid_input
					πF.SetLineno(2890)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßunderline.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2891: text = invalid_input
					πF.SetLineno(2891)
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßinvalid_input); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßtext.ToObject(), πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("SpecializedText").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßSpecializedText.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2894: class Definition(SpecializedText):
			πF.SetLineno(2894)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Definition", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2896: """Second line of potential definition_list_item."""
					πF.SetLineno(2896)
					// line 2896: """Second line of potential definition_list_item."""
					πF.SetLineno(2896)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("Second line of potential definition_list_item.").ToObject()); πE != nil {
						continue
					}
					// line 2898: def eof(self, context):
					πF.SetLineno(2898)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "context", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("eof", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontext *πg.Object = πArgs[1]
						_ = µcontext
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2899: """Not a definition."""
							πF.SetLineno(2899)
							// line 2900: self.state_machine.previous_line(2) # so parent SM can reassess
							πF.SetLineno(2900)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 2901: return []
							πF.SetLineno(2901)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßeof.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2899: """Not a definition."""
					πF.SetLineno(2899)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Not a definition.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßeof); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2903: def indent(self, match, context, next_state):
					πF.SetLineno(2903)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("indent", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µitemnode *πg.Object = πg.UnboundLocal
						_ = µitemnode
						var µblank_finish *πg.Object = πg.UnboundLocal
						_ = µblank_finish
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2904: """Definition list item."""
							πF.SetLineno(2904)
							// line 2905: itemnode, blank_finish = self.definition_list_item(context)
							πF.SetLineno(2905)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp001[0] = µcontext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßdefinition_list_item, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp004}}}, πTemp003); πE != nil {
								continue
							}
							µitemnode = πTemp002
							µblank_finish = πTemp004
							// line 2906: self.parent += itemnode
							πF.SetLineno(2906)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µitemnode, "itemnode"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IAdd(πF, πTemp002, µitemnode); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp003); πE != nil {
								continue
							}
							// line 2907: self.blank_finish = blank_finish
							πF.SetLineno(2907)
							if πE = πg.CheckLocal(πF, µblank_finish, "blank_finish"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, µblank_finish); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßblank_finish, πTemp002); πE != nil {
								continue
							}
							// line 2908: return [], 'DefinitionList', []
							πF.SetLineno(2908)
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, ßDefinitionList.ToObject(), πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßindent.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2904: """Definition list item."""
					πF.SetLineno(2904)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Definition list item.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßindent); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("Definition").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßDefinition.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 2911: class Line(SpecializedText):
			πF.SetLineno(2911)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßSpecializedText); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("Line", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Object
				_ = πTemp001
				var πTemp002 []πg.Param
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 *πg.Object
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 2913: """
					πF.SetLineno(2913)
					// line 2913: """
					πF.SetLineno(2913)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    Second line of over- & underlined section title or transition marker.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 2917: eofcheck = 1                        # @@@ ???
					πF.SetLineno(2917)
					if πE = πClass.SetItem(πF, ßeofcheck.ToObject(), πg.NewInt(1).ToObject()); πE != nil {
						continue
					}
					// line 2918: """Set to 0 while parsing sections, so that we don't catch the EOF."""
					πF.SetLineno(2918)
					// line 2920: def eof(self, context):
					πF.SetLineno(2920)
					πTemp002 = make([]πg.Param, 2)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "context", Def: nil}
					πTemp001 = πg.NewFunction(πg.NewCode("eof", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontext *πg.Object = πArgs[1]
						_ = µcontext
						var µmarker *πg.Object = πg.UnboundLocal
						_ = µmarker
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µtransition *πg.Object = πg.UnboundLocal
						_ = µtransition
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 bool
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2921: """Transition marker at end of section or document."""
							πF.SetLineno(2921)
							// line 2922: marker = context[0].strip()
							πF.SetLineno(2922)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcontext, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µmarker = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßmemo, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsection_bubble_up_kludge, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp002); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label1
							}
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmarker, "marker"); πE != nil {
								continue
							}
							πTemp004[0] = µmarker
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp005, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.LT(πF, πTemp005, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label2
							}
							goto Label3
							// line 2923: if self.memo.section_bubble_up_kludge:
							πF.SetLineno(2923)
						Label1:
							// line 2924: self.memo.section_bubble_up_kludge = False
							πF.SetLineno(2924)
							if πTemp001, πE = πg.ResolveGlobal(πF, ßFalse); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, µself, ßmemo, nil); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, πTemp005, ßsection_bubble_up_kludge, πTemp002); πE != nil {
								continue
							}
							goto Label3
							// line 2925: elif len(marker) < 4:
							πF.SetLineno(2925)
						Label2:
							// line 2926: self.state_correction(context)
							πF.SetLineno(2926)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp004[0] = µcontext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_correction, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label3
						Label3:
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßeofcheck, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp003 {
								goto Label4
							}
							goto Label5
							// line 2927: if self.eofcheck:               # ignore EOFError with sections
							πF.SetLineno(2927)
						Label4:
							// line 2928: lineno = self.state_machine.abs_line_number() - 1
							πF.SetLineno(2928)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp002, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 2929: transition = nodes.transition(rawsource=context[0])
							πF.SetLineno(2929)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcontext, πTemp001); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"rawsource", πTemp002},
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtransition, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, πTemp006); πE != nil {
								continue
							}
							µtransition = πTemp001
							// line 2930: transition.line = lineno
							πF.SetLineno(2930)
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µlineno); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtransition, "transition"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µtransition, ßline, πTemp001); πE != nil {
								continue
							}
							// line 2931: self.parent += transition
							πF.SetLineno(2931)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtransition, "transition"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µtransition); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							goto Label5
						Label5:
							// line 2932: self.eofcheck = 1
							πF.SetLineno(2932)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßeofcheck, πTemp001); πE != nil {
								continue
							}
							// line 2933: return []
							πF.SetLineno(2933)
							πTemp004 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp004...).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßeof.ToObject(), πTemp001); πE != nil {
						continue
					}
					// line 2921: """Transition marker at end of section or document."""
					πF.SetLineno(2921)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πg.NewStr("Transition marker at end of section or document.").ToObject()); πE != nil {
						continue
					}
					if πTemp004, πE = πg.ResolveClass(πF, πClass, nil, ßeof); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp004, ß__doc__, πTemp003); πE != nil {
						continue
					}
					// line 2935: def blank(self, match, context, next_state):
					πF.SetLineno(2935)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("blank", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µsrc *πg.Object = πg.UnboundLocal
						_ = µsrc
						var µsrcline *πg.Object = πg.UnboundLocal
						_ = µsrcline
						var µmarker *πg.Object = πg.UnboundLocal
						_ = µmarker
						var µtransition *πg.Object = πg.UnboundLocal
						_ = µtransition
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 []*πg.Object
						_ = πTemp004
						var πTemp005 bool
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 2936: """Transition marker."""
							πF.SetLineno(2936)
							// line 2937: src, srcline = self.state_machine.get_source_and_line()
							πF.SetLineno(2937)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp002}, πg.TieTarget{Target: &πTemp003}}}, πTemp001); πE != nil {
								continue
							}
							µsrc = πTemp002
							µsrcline = πTemp003
							// line 2938: marker = context[0].strip()
							πF.SetLineno(2938)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcontext, πTemp001); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, πTemp002, ßstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µmarker = πTemp002
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmarker, "marker"); πE != nil {
								continue
							}
							πTemp004[0] = µmarker
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							if πTemp001, πE = πg.LT(πF, πTemp003, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp005 {
								goto Label1
							}
							goto Label2
							// line 2939: if len(marker) < 4:
							πF.SetLineno(2939)
						Label1:
							// line 2940: self.state_correction(context)
							πF.SetLineno(2940)
							πTemp004 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp004[0] = µcontext
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_correction, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp004, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp004)
							goto Label2
						Label2:
							// line 2941: transition = nodes.transition(rawsource=marker)
							πF.SetLineno(2941)
							if πE = πg.CheckLocal(πF, µmarker, "marker"); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"rawsource", µmarker},
							}
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßtransition, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, πTemp006); πE != nil {
								continue
							}
							µtransition = πTemp001
							// line 2942: transition.source = src
							πF.SetLineno(2942)
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, µsrc); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtransition, "transition"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µtransition, ßsource, πTemp001); πE != nil {
								continue
							}
							// line 2943: transition.line = srcline - 1
							πF.SetLineno(2943)
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, µsrcline, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp002}, πTemp001); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtransition, "transition"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µtransition, ßline, πTemp002); πE != nil {
								continue
							}
							// line 2944: self.parent += transition
							πF.SetLineno(2944)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtransition, "transition"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µtransition); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2945: return [], 'Body', []
							πF.SetLineno(2945)
							πTemp004 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp004...).ToObject()
							πTemp004 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp004...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, ßBody.ToObject(), πTemp003).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßblank.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 2936: """Transition marker."""
					πF.SetLineno(2936)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp004}, πg.NewStr("Transition marker.").ToObject()); πE != nil {
						continue
					}
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßblank); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp005, ß__doc__, πTemp004); πE != nil {
						continue
					}
					// line 2947: def text(self, match, context, next_state):
					πF.SetLineno(2947)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("text", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µoverline *πg.Object = πg.UnboundLocal
						_ = µoverline
						var µtitle *πg.Object = πg.UnboundLocal
						_ = µtitle
						var µunderline *πg.Object = πg.UnboundLocal
						_ = µunderline
						var µblocktext *πg.Object = πg.UnboundLocal
						_ = µblocktext
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var µsource *πg.Object = πg.UnboundLocal
						_ = µsource
						var µmessages *πg.Object = πg.UnboundLocal
						_ = µmessages
						var µstyle *πg.Object = πg.UnboundLocal
						_ = µstyle
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.BaseException
						_ = πTemp004
						var πTemp005 *πg.Traceback
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 []*πg.Object
						_ = πTemp008
						var πTemp009 πg.KWArgs
						_ = πTemp009
						var πTemp010 *πg.Object
						_ = πTemp010
						var πTemp011 *πg.Object
						_ = πTemp011
						var πTemp012 *πg.Object
						_ = πTemp012
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							case 2:
								goto Label2
							default:
								panic("unexpected function state")
							}
							// line 2948: """Potential over- & underlined title."""
							πF.SetLineno(2948)
							// line 2949: lineno = self.state_machine.abs_line_number() - 1
							πF.SetLineno(2949)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µlineno = πTemp001
							// line 2950: overline = context[0]
							πF.SetLineno(2950)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcontext, πTemp001); πE != nil {
								continue
							}
							µoverline = πTemp002
							// line 2951: title = match.string
							πF.SetLineno(2951)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							µtitle = πTemp001
							// line 2952: underline = ''
							πF.SetLineno(2952)
							µunderline = ß.ToObject()
							// line 2953: try:
							πF.SetLineno(2953)
							πF.PushCheckpoint(2)
							// line 2954: underline = self.state_machine.next_line()
							πF.SetLineno(2954)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßnext_line, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							µunderline = πTemp001
							πF.PopCheckpoint()
							goto Label1
						Label2:
							if πE == nil {
								continue
							}
							πE = nil
							πTemp004, πTemp005 = πF.ExcInfo()
							if πTemp001, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsInstance(πF, πTemp004.ToObject(), πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label3
							}
							πE = πF.Raise(πTemp004.ToObject(), nil, πTemp005.ToObject())
							continue
							// line 2955: except EOFError:
							πF.SetLineno(2955)
						Label3:
							// line 2956: blocktext = overline + '\n' + title
							πF.SetLineno(2956)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µoverline, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µtitle); πE != nil {
								continue
							}
							µblocktext = πTemp001
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoverline, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp001, πE = πg.LT(πF, πTemp003, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label4
							}
							goto Label5
							// line 2957: if len(overline.rstrip()) < 4:
							πF.SetLineno(2957)
						Label4:
							// line 2958: self.short_overline(context, blocktext, lineno, 2)
							πF.SetLineno(2958)
							πTemp007 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp007[0] = µcontext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp007[1] = µblocktext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp007[2] = µlineno
							πTemp007[3] = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßshort_overline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							goto Label6
						Label5:
							// line 2960: msg = self.reporter.severe(
							πF.SetLineno(2960)
							πTemp007 = πF.MakeArgs(2)
							πTemp007[0] = πg.NewStr("Incomplete section title.").ToObject()
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp008[0] = µblocktext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp008[1] = µblocktext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp007[1] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsevere, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							µmsg = πTemp001
							// line 2964: self.parent += msg
							πF.SetLineno(2964)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2965: return [], 'Body', []
							πF.SetLineno(2965)
							πTemp007 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp007...).ToObject()
							πTemp007 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp007...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, ßBody.ToObject(), πTemp003).ToObject()
							πR = πTemp001
							continue
							goto Label6
						Label6:
							πF.RestoreExc(nil, nil)
							goto Label1
						Label1:
							// line 2966: source = '%s\n%s\n%s' % (overline, title, underline)
							πF.SetLineno(2966)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple3(µoverline, µtitle, µunderline).ToObject()
							if πTemp001, πE = πg.Mod(πF, πg.NewStr("%s\n%s\n%s").ToObject(), πTemp002); πE != nil {
								continue
							}
							µsource = πTemp001
							// line 2967: overline = overline.rstrip()
							πF.SetLineno(2967)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µoverline, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µoverline = πTemp002
							// line 2968: underline = underline.rstrip()
							πF.SetLineno(2968)
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µunderline, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µunderline = πTemp002
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							πTemp007[0] = µunderline
							πTemp002 = πg.NewInt(0).ToObject()
							πTemp010 = ßunderline.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp012, πE = πg.GetAttr(πF, µself, ßtransitions, nil); πE != nil {
								continue
							}
							if πTemp011, πE = πg.GetItem(πF, πTemp012, πTemp010); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp011, πTemp002); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp003, ßmatch, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp006, πE = πg.IsTrue(πF, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πg.GetBool(!πTemp006).ToObject()
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label7
							}
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.NE(πF, µoverline, µunderline); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label8
							}
							goto Label9
							// line 2969: if not self.transitions['underline'][0].match(underline):
							πF.SetLineno(2969)
						Label7:
							// line 2970: blocktext = overline + '\n' + title + '\n' + underline
							πF.SetLineno(2970)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.Add(πF, µoverline, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp010, µtitle); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µunderline); πE != nil {
								continue
							}
							µblocktext = πTemp001
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoverline, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp001, πE = πg.LT(πF, πTemp003, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label10
							}
							goto Label11
							// line 2971: if len(overline.rstrip()) < 4:
							πF.SetLineno(2971)
						Label10:
							// line 2972: self.short_overline(context, blocktext, lineno, 2)
							πF.SetLineno(2972)
							πTemp007 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp007[0] = µcontext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp007[1] = µblocktext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp007[2] = µlineno
							πTemp007[3] = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßshort_overline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							goto Label12
						Label11:
							// line 2974: msg = self.reporter.severe(
							πF.SetLineno(2974)
							πTemp007 = πF.MakeArgs(2)
							πTemp007[0] = πg.NewStr("Missing matching underline for section title overline.").ToObject()
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp008[0] = µsource
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp008[1] = µsource
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp007[1] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsevere, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							µmsg = πTemp001
							// line 2978: self.parent += msg
							πF.SetLineno(2978)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2979: return [], 'Body', []
							πF.SetLineno(2979)
							πTemp007 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp007...).ToObject()
							πTemp007 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp007...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, ßBody.ToObject(), πTemp003).ToObject()
							πR = πTemp001
							continue
							goto Label12
						Label12:
							goto Label9
							// line 2980: elif overline != underline:
							πF.SetLineno(2980)
						Label8:
							// line 2981: blocktext = overline + '\n' + title + '\n' + underline
							πF.SetLineno(2981)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.Add(πF, µoverline, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp010, µtitle); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µunderline); πE != nil {
								continue
							}
							µblocktext = πTemp001
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoverline, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp001, πE = πg.LT(πF, πTemp003, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label13
							}
							goto Label14
							// line 2982: if len(overline.rstrip()) < 4:
							πF.SetLineno(2982)
						Label13:
							// line 2983: self.short_overline(context, blocktext, lineno, 2)
							πF.SetLineno(2983)
							πTemp007 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp007[0] = µcontext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp007[1] = µblocktext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp007[2] = µlineno
							πTemp007[3] = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßshort_overline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							goto Label15
						Label14:
							// line 2985: msg = self.reporter.severe(
							πF.SetLineno(2985)
							πTemp007 = πF.MakeArgs(2)
							πTemp007[0] = πg.NewStr("Title overline & underline mismatch.").ToObject()
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp008[0] = µsource
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp008[1] = µsource
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp007[1] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßsevere, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							µmsg = πTemp001
							// line 2989: self.parent += msg
							πF.SetLineno(2989)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 2990: return [], 'Body', []
							πF.SetLineno(2990)
							πTemp007 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp007...).ToObject()
							πTemp007 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp007...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, ßBody.ToObject(), πTemp003).ToObject()
							πR = πTemp001
							continue
							goto Label15
						Label15:
							goto Label9
						Label9:
							// line 2991: title = title.rstrip()
							πF.SetLineno(2991)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtitle, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							µtitle = πTemp002
							// line 2992: messages = []
							πF.SetLineno(2992)
							πTemp007 = make([]*πg.Object, 0)
							πTemp001 = πg.NewList(πTemp007...).ToObject()
							µmessages = πTemp001
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							πTemp007[0] = µtitle
							if πTemp002, πE = πg.ResolveGlobal(πF, ßcolumn_width); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							πTemp007[0] = µoverline
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp010, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp001, πE = πg.GT(πF, πTemp003, πTemp010); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label16
							}
							goto Label17
							// line 2993: if column_width(title) > len(overline):
							πF.SetLineno(2993)
						Label16:
							// line 2994: blocktext = overline + '\n' + title + '\n' + underline
							πF.SetLineno(2994)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.Add(πF, µoverline, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.Add(πF, πTemp010, µtitle); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, πTemp003, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, µunderline); πE != nil {
								continue
							}
							µblocktext = πTemp001
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoverline, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							if πTemp001, πE = πg.LT(πF, πTemp003, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label18
							}
							goto Label19
							// line 2995: if len(overline.rstrip()) < 4:
							πF.SetLineno(2995)
						Label18:
							// line 2996: self.short_overline(context, blocktext, lineno, 2)
							πF.SetLineno(2996)
							πTemp007 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp007[0] = µcontext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp007[1] = µblocktext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp007[2] = µlineno
							πTemp007[3] = πg.NewInt(2).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßshort_overline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							goto Label20
						Label19:
							// line 2998: msg = self.reporter.warning(
							πF.SetLineno(2998)
							πTemp007 = πF.MakeArgs(2)
							πTemp007[0] = πg.NewStr("Title overline too short.").ToObject()
							πTemp008 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp008[0] = µsource
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp008[1] = µsource
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp008, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp008)
							πTemp007[1] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp009 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, πTemp009); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							µmsg = πTemp001
							// line 3002: messages.append(msg)
							πF.SetLineno(3002)
							πTemp007 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							πTemp007[0] = µmsg
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µmessages, ßappend, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							goto Label20
						Label20:
							goto Label17
						Label17:
							// line 3003: style = (overline[0], underline[0])
							πF.SetLineno(3003)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, µoverline, πTemp002); πE != nil {
								continue
							}
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µunderline, "underline"); πE != nil {
								continue
							}
							if πTemp010, πE = πg.GetItem(πF, µunderline, πTemp002); πE != nil {
								continue
							}
							πTemp001 = πg.NewTuple2(πTemp003, πTemp010).ToObject()
							µstyle = πTemp001
							// line 3004: self.eofcheck = 0               # @@@ not sure this is correct
							πF.SetLineno(3004)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(0).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßeofcheck, πTemp001); πE != nil {
								continue
							}
							// line 3005: self.section(title.lstrip(), source, style, lineno + 1, messages)
							πF.SetLineno(3005)
							πTemp007 = πF.MakeArgs(5)
							if πE = πg.CheckLocal(πF, µtitle, "title"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µtitle, ßlstrip, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp007[0] = πTemp002
							if πE = πg.CheckLocal(πF, µsource, "source"); πE != nil {
								continue
							}
							πTemp007[1] = µsource
							if πE = πg.CheckLocal(πF, µstyle, "style"); πE != nil {
								continue
							}
							πTemp007[2] = µstyle
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, µlineno, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							πTemp007[3] = πTemp001
							if πE = πg.CheckLocal(πF, µmessages, "messages"); πE != nil {
								continue
							}
							πTemp007[4] = µmessages
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßsection, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							// line 3006: self.eofcheck = 1
							πF.SetLineno(3006)
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp001}, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßeofcheck, πTemp001); πE != nil {
								continue
							}
							// line 3007: return [], 'Body', []
							πF.SetLineno(3007)
							πTemp007 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp007...).ToObject()
							πTemp007 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp007...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, ßBody.ToObject(), πTemp003).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtext.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 2948: """Potential over- & underlined title."""
					πF.SetLineno(2948)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp005}, πg.NewStr("Potential over- & underlined title.").ToObject()); πE != nil {
						continue
					}
					if πTemp006, πE = πg.ResolveClass(πF, πClass, nil, ßtext); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp006, ß__doc__, πTemp005); πE != nil {
						continue
					}
					// line 3009: indent = text                       # indented title
					πF.SetLineno(3009)
					if πTemp005, πE = πg.ResolveClass(πF, πClass, nil, ßtext); πE != nil {
						continue
					}
					if πE = πClass.SetItem(πF, ßindent.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 3011: def underline(self, match, context, next_state):
					πF.SetLineno(3011)
					πTemp002 = make([]πg.Param, 4)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "match", Def: nil}
					πTemp002[2] = πg.Param{Name: "context", Def: nil}
					πTemp002[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp005 = πg.NewFunction(πg.NewCode("underline", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µoverline *πg.Object = πg.UnboundLocal
						_ = µoverline
						var µblocktext *πg.Object = πg.UnboundLocal
						_ = µblocktext
						var µlineno *πg.Object = πg.UnboundLocal
						_ = µlineno
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var πTemp001 *πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 bool
						_ = πTemp006
						var πTemp007 []*πg.Object
						_ = πTemp007
						var πTemp008 πg.KWArgs
						_ = πTemp008
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3012: overline = context[0]
							πF.SetLineno(3012)
							πTemp001 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetItem(πF, µcontext, πTemp001); πE != nil {
								continue
							}
							µoverline = πTemp002
							// line 3013: blocktext = overline + '\n' + self.state_machine.line
							πF.SetLineno(3013)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.Add(πF, µoverline, πg.NewStr("\n").ToObject()); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßline, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Add(πF, πTemp002, πTemp004); πE != nil {
								continue
							}
							µblocktext = πTemp001
							// line 3014: lineno = self.state_machine.abs_line_number() - 1
							πF.SetLineno(3014)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πg.Sub(πF, πTemp002, πg.NewInt(1).ToObject()); πE != nil {
								continue
							}
							µlineno = πTemp001
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µoverline, "overline"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µoverline, ßrstrip, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp005[0] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßlen); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							if πTemp001, πE = πg.LT(πF, πTemp003, πg.NewInt(4).ToObject()); πE != nil {
								continue
							}
							if πTemp006, πE = πg.IsTrue(πF, πTemp001); πE != nil {
								continue
							}
							if πTemp006 {
								goto Label1
							}
							goto Label2
							// line 3015: if len(overline.rstrip()) < 4:
							πF.SetLineno(3015)
						Label1:
							// line 3016: self.short_overline(context, blocktext, lineno, 1)
							πF.SetLineno(3016)
							πTemp005 = πF.MakeArgs(4)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp005[0] = µcontext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp005[1] = µblocktext
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp005[2] = µlineno
							πTemp005[3] = πg.NewInt(1).ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßshort_overline, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp001.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							goto Label2
						Label2:
							// line 3017: msg = self.reporter.error(
							πF.SetLineno(3017)
							πTemp005 = πF.MakeArgs(2)
							πTemp005[0] = πg.NewStr("Invalid section title or transition marker.").ToObject()
							πTemp007 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp007[0] = µblocktext
							if πE = πg.CheckLocal(πF, µblocktext, "blocktext"); πE != nil {
								continue
							}
							πTemp007[1] = µblocktext
							if πTemp001, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp007, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp007)
							πTemp005[1] = πTemp001
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp008 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, πTemp001, ßerror, nil); πE != nil {
								continue
							}
							if πTemp001, πE = πTemp002.Call(πF, πTemp005, πTemp008); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							µmsg = πTemp001
							// line 3021: self.parent += msg
							πF.SetLineno(3021)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.IAdd(πF, πTemp001, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp002); πE != nil {
								continue
							}
							// line 3022: return [], 'Body', []
							πF.SetLineno(3022)
							πTemp005 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp005...).ToObject()
							πTemp005 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp005...).ToObject()
							πTemp001 = πg.NewTuple3(πTemp002, ßBody.ToObject(), πTemp003).ToObject()
							πR = πTemp001
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßunderline.ToObject(), πTemp005); πE != nil {
						continue
					}
					// line 3024: def short_overline(self, context, blocktext, lineno, lines=1):
					πF.SetLineno(3024)
					πTemp002 = make([]πg.Param, 5)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "context", Def: nil}
					πTemp002[2] = πg.Param{Name: "blocktext", Def: nil}
					πTemp002[3] = πg.Param{Name: "lineno", Def: nil}
					πTemp002[4] = πg.Param{Name: "lines", Def: πg.NewInt(1).ToObject()}
					πTemp006 = πg.NewFunction(πg.NewCode("short_overline", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontext *πg.Object = πArgs[1]
						_ = µcontext
						var µblocktext *πg.Object = πArgs[2]
						_ = µblocktext
						var µlineno *πg.Object = πArgs[3]
						_ = µlineno
						var µlines *πg.Object = πArgs[4]
						_ = µlines
						var µmsg *πg.Object = πg.UnboundLocal
						_ = µmsg
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 πg.KWArgs
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3025: msg = self.reporter.info(
							πF.SetLineno(3025)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = πg.NewStr("Possible incomplete section title.\nTreating the overline as ordinary text because it's so short.").ToObject()
							if πE = πg.CheckLocal(πF, µlineno, "lineno"); πE != nil {
								continue
							}
							πTemp002 = πg.KWArgs{
								{"line", µlineno},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßinfo, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, πTemp002); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µmsg = πTemp003
							// line 3029: self.parent += msg
							πF.SetLineno(3029)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µmsg, "msg"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IAdd(πF, πTemp003, µmsg); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp004); πE != nil {
								continue
							}
							// line 3030: self.state_correction(context, lines)
							πF.SetLineno(3030)
							πTemp001 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp001[0] = µcontext
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp001[1] = µlines
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_correction, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßshort_overline.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 3032: def state_correction(self, context, lines=1):
					πF.SetLineno(3032)
					πTemp002 = make([]πg.Param, 3)
					πTemp002[0] = πg.Param{Name: "self", Def: nil}
					πTemp002[1] = πg.Param{Name: "context", Def: nil}
					πTemp002[2] = πg.Param{Name: "lines", Def: πg.NewInt(1).ToObject()}
					πTemp007 = πg.NewFunction(πg.NewCode("state_correction", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp002, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontext *πg.Object = πArgs[1]
						_ = µcontext
						var µlines *πg.Object = πArgs[2]
						_ = µlines
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3033: self.state_machine.previous_line(lines)
							πF.SetLineno(3033)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µlines, "lines"); πE != nil {
								continue
							}
							πTemp001[0] = µlines
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3034: context[:] = []
							πF.SetLineno(3034)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.SliceType.Call(πF, πg.Args{πg.None, πg.None, πg.None}, nil); πE != nil {
								continue
							}
							if πE = πg.SetItem(πF, µcontext, πTemp004, πTemp003); πE != nil {
								continue
							}
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = ßBody.ToObject()
							πTemp001[1] = ßtext.ToObject()
							if πTemp002, πE = πg.ResolveGlobal(πF, ßstatemachine); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßStateCorrection, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3035: raise statemachine.StateCorrection('Body', 'text')
							πF.SetLineno(3035)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßstate_correction.ToObject(), πTemp007); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("Line").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßLine.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 3038: class QuotedLiteralBlock(RSTState):
			πF.SetLineno(3038)
			πTemp002 = make([]*πg.Object, 1)
			if πTemp010, πE = πg.ResolveGlobal(πF, ßRSTState); πE != nil {
				continue
			}
			πTemp002[0] = πTemp010
			πTemp004 = πg.NewDict()
			if πTemp008, πE = πF.Globals().GetItem(πF, ß__name__.ToObject()); πE != nil {
				continue
			}
			if πE = πTemp004.SetItem(πF, ß__module__.ToObject(), πTemp008); πE != nil {
				continue
			}
			_, πE = πg.NewCode("QuotedLiteralBlock", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", nil, 0, func(πF *πg.Frame, _ []*πg.Object) (*πg.Object, *πg.BaseException) {
				πClass := πTemp004
				_ = πClass
				var πTemp001 *πg.Dict
				_ = πTemp001
				var πTemp002 *πg.Object
				_ = πTemp002
				var πTemp003 *πg.Object
				_ = πTemp003
				var πTemp004 *πg.Object
				_ = πTemp004
				var πTemp005 []πg.Param
				_ = πTemp005
				var πTemp006 *πg.Object
				_ = πTemp006
				var πTemp007 *πg.Object
				_ = πTemp007
				var πTemp008 *πg.Object
				_ = πTemp008
				var πTemp009 *πg.Object
				_ = πTemp009
				var πTemp010 *πg.Object
				_ = πTemp010
				for ; πF.State() >= 0; πF.PopCheckpoint() {
					switch πF.State() {
					case 0:
					default:
						panic("unexpected function state")
					}
					// line 3040: """
					πF.SetLineno(3040)
					// line 3040: """
					πF.SetLineno(3040)
					if πE = πClass.SetItem(πF, ß__doc__.ToObject(), πg.NewStr("\n    Nested parse handler for quoted (unindented) literal blocks.\n\n    Special-purpose.  Not for inclusion in `state_classes`.\n    ").ToObject()); πE != nil {
						continue
					}
					// line 3046: patterns = {'initial_quoted': r'(%(nonalphanum7bit)s)' % Body.pats,
					πF.SetLineno(3046)
					πTemp001 = πg.NewDict()
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßBody); πE != nil {
						continue
					}
					if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßpats, nil); πE != nil {
						continue
					}
					if πTemp002, πE = πg.Mod(πF, πg.NewStr("(%(nonalphanum7bit)s)").ToObject(), πTemp004); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, ßinitial_quoted.ToObject(), πTemp002); πE != nil {
						continue
					}
					if πE = πTemp001.SetItem(πF, ßtext.ToObject(), ß.ToObject()); πE != nil {
						continue
					}
					πTemp002 = πTemp001.ToObject()
					if πE = πClass.SetItem(πF, ßpatterns.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3048: initial_transitions = ('initial_quoted', 'text')
					πF.SetLineno(3048)
					πTemp002 = πg.NewTuple2(ßinitial_quoted.ToObject(), ßtext.ToObject()).ToObject()
					if πE = πClass.SetItem(πF, ßinitial_transitions.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3050: def __init__(self, state_machine, debug=False):
					πF.SetLineno(3050)
					πTemp005 = make([]πg.Param, 3)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "state_machine", Def: nil}
					if πTemp003, πE = πg.ResolveClass(πF, πClass, nil, ßFalse); πE != nil {
						continue
					}
					πTemp005[2] = πg.Param{Name: "debug", Def: πTemp003}
					πTemp002 = πg.NewFunction(πg.NewCode("__init__", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µstate_machine *πg.Object = πArgs[1]
						_ = µstate_machine
						var µdebug *πg.Object = πArgs[2]
						_ = µdebug
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3051: RSTState.__init__(self, state_machine, debug)
							πF.SetLineno(3051)
							πTemp001 = πF.MakeArgs(3)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							πTemp001[0] = µself
							if πE = πg.CheckLocal(πF, µstate_machine, "state_machine"); πE != nil {
								continue
							}
							πTemp001[1] = µstate_machine
							if πE = πg.CheckLocal(πF, µdebug, "debug"); πE != nil {
								continue
							}
							πTemp001[2] = µdebug
							if πTemp002, πE = πg.ResolveGlobal(πF, ßRSTState); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ß__init__, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3052: self.messages = []
							πF.SetLineno(3052)
							πTemp001 = make([]*πg.Object, 0)
							πTemp002 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßmessages, πTemp003); πE != nil {
								continue
							}
							// line 3053: self.initial_lineno = None
							πF.SetLineno(3053)
							if πTemp002, πE = πg.ResolveGlobal(πF, ßNone); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßinitial_lineno, πTemp003); πE != nil {
								continue
							}
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ß__init__.ToObject(), πTemp002); πE != nil {
						continue
					}
					// line 3055: def blank(self, match, context, next_state):
					πF.SetLineno(3055)
					πTemp005 = make([]πg.Param, 4)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "match", Def: nil}
					πTemp005[2] = πg.Param{Name: "context", Def: nil}
					πTemp005[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp003 = πg.NewFunction(πg.NewCode("blank", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IsTrue(πF, µcontext); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label1
							}
							goto Label2
							// line 3056: if context:
							πF.SetLineno(3056)
						Label1:
							if πTemp002, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							// line 3057: raise EOFError
							πF.SetLineno(3057)
							πE = πF.Raise(πTemp002, nil, nil)
							continue
							goto Label3
						Label2:
							// line 3059: return context, next_state, []
							πF.SetLineno(3059)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp003 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp003...).ToObject()
							πTemp002 = πg.NewTuple3(µcontext, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
							goto Label3
						Label3:
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßblank.ToObject(), πTemp003); πE != nil {
						continue
					}
					// line 3061: def eof(self, context):
					πF.SetLineno(3061)
					πTemp005 = make([]πg.Param, 2)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "context", Def: nil}
					πTemp004 = πg.NewFunction(πg.NewCode("eof", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µcontext *πg.Object = πArgs[1]
						_ = µcontext
						var µsrc *πg.Object = πg.UnboundLocal
						_ = µsrc
						var µsrcline *πg.Object = πg.UnboundLocal
						_ = µsrcline
						var µtext *πg.Object = πg.UnboundLocal
						_ = µtext
						var µliteral_block *πg.Object = πg.UnboundLocal
						_ = µliteral_block
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IsTrue(πF, µcontext); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label1
							}
							goto Label2
							// line 3062: if context:
							πF.SetLineno(3062)
						Label1:
							// line 3063: src, srcline = self.state_machine.get_source_and_line(
							πF.SetLineno(3063)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßinitial_lineno, nil); πE != nil {
								continue
							}
							πTemp002[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßget_source_and_line, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πE = πg.Tie(πF, πg.TieTarget{Children: []πg.TieTarget{πg.TieTarget{Target: &πTemp004}, πg.TieTarget{Target: &πTemp005}}}, πTemp003); πE != nil {
								continue
							}
							µsrc = πTemp004
							µsrcline = πTemp005
							// line 3065: text = '\n'.join(context)
							πF.SetLineno(3065)
							πTemp002 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							πTemp002[0] = µcontext
							if πTemp003, πE = πg.GetAttr(πF, πg.NewStr("\n").ToObject(), ßjoin, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp003.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µtext = πTemp004
							// line 3066: literal_block = nodes.literal_block(text, text)
							πF.SetLineno(3066)
							πTemp002 = πF.MakeArgs(2)
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp002[0] = µtext
							if πE = πg.CheckLocal(πF, µtext, "text"); πE != nil {
								continue
							}
							πTemp002[1] = µtext
							if πTemp003, πE = πg.ResolveGlobal(πF, ßnodes); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßliteral_block, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							µliteral_block = πTemp003
							// line 3067: literal_block.source = src
							πF.SetLineno(3067)
							if πE = πg.CheckLocal(πF, µsrc, "src"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µsrc); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µliteral_block, "literal_block"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µliteral_block, ßsource, πTemp003); πE != nil {
								continue
							}
							// line 3068: literal_block.line = srcline
							πF.SetLineno(3068)
							if πE = πg.CheckLocal(πF, µsrcline, "srcline"); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, µsrcline); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µliteral_block, "literal_block"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µliteral_block, ßline, πTemp003); πE != nil {
								continue
							}
							// line 3069: self.parent += literal_block
							πF.SetLineno(3069)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µliteral_block, "literal_block"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.IAdd(πF, πTemp003, µliteral_block); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp004); πE != nil {
								continue
							}
							goto Label3
						Label2:
							// line 3071: self.parent += self.reporter.warning(
							πF.SetLineno(3071)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("Literal block expected; none found.").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"line", πTemp004},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßwarning, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, πTemp002, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							if πTemp005, πE = πg.IAdd(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp005); πE != nil {
								continue
							}
							// line 3075: self.state_machine.previous_line()
							πF.SetLineno(3075)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label3
						Label3:
							// line 3076: self.parent += self.messages
							πF.SetLineno(3076)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßparent, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßmessages, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.IAdd(πF, πTemp003, πTemp004); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßparent, πTemp005); πE != nil {
								continue
							}
							// line 3077: return []
							πF.SetLineno(3077)
							πTemp002 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp002...).ToObject()
							πR = πTemp003
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßeof.ToObject(), πTemp004); πE != nil {
						continue
					}
					// line 3079: def indent(self, match, context, next_state):
					πF.SetLineno(3079)
					πTemp005 = make([]πg.Param, 4)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "match", Def: nil}
					πTemp005[2] = πg.Param{Name: "context", Def: nil}
					πTemp005[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp006 = πg.NewFunction(πg.NewCode("indent", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 πg.KWArgs
						_ = πTemp005
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3080: assert context, ('QuotedLiteralBlock.indent: context should not '
							πF.SetLineno(3080)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πE = πg.Assert(πF, µcontext, πg.NewStr("QuotedLiteralBlock.indent: context should not be empty!").ToObject()); πE != nil {
								continue
							}
							// line 3082: self.messages.append(
							πF.SetLineno(3082)
							πTemp001 = πF.MakeArgs(1)
							πTemp002 = πF.MakeArgs(1)
							πTemp002[0] = πg.NewStr("Unexpected indentation.").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp005 = πg.KWArgs{
								{"line", πTemp003},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßerror, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp002, πTemp005); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							πTemp001[0] = πTemp003
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßmessages, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3085: self.state_machine.previous_line()
							πF.SetLineno(3085)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, πTemp003, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp004.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							// line 3086: raise EOFError
							πF.SetLineno(3086)
							πE = πF.Raise(πTemp003, nil, nil)
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßindent.ToObject(), πTemp006); πE != nil {
						continue
					}
					// line 3088: def initial_quoted(self, match, context, next_state):
					πF.SetLineno(3088)
					πTemp005 = make([]πg.Param, 4)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "match", Def: nil}
					πTemp005[2] = πg.Param{Name: "context", Def: nil}
					πTemp005[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp007 = πg.NewFunction(πg.NewCode("initial_quoted", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var µquote *πg.Object = πg.UnboundLocal
						_ = µquote
						var µpattern *πg.Object = πg.UnboundLocal
						_ = µpattern
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 []*πg.Object
						_ = πTemp005
						var πTemp006 *πg.Object
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3089: """Match arbitrary quote character on the first line only."""
							πF.SetLineno(3089)
							// line 3090: self.remove_transition('initial_quoted')
							πF.SetLineno(3090)
							πTemp001 = πF.MakeArgs(1)
							πTemp001[0] = ßinitial_quoted.ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßremove_transition, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3091: quote = match.string[0]
							πF.SetLineno(3091)
							πTemp002 = πg.NewInt(0).ToObject()
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetItem(πF, πTemp004, πTemp002); πE != nil {
								continue
							}
							µquote = πTemp003
							// line 3092: pattern = re.compile(re.escape(quote), re.UNICODE)
							πF.SetLineno(3092)
							πTemp001 = πF.MakeArgs(2)
							πTemp005 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µquote, "quote"); πE != nil {
								continue
							}
							πTemp005[0] = µquote
							if πTemp002, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßescape, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp005, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp005)
							πTemp001[0] = πTemp002
							if πTemp002, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßUNICODE, nil); πE != nil {
								continue
							}
							πTemp001[1] = πTemp003
							if πTemp002, πE = πg.ResolveGlobal(πF, ßre); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßcompile, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							µpattern = πTemp002
							// line 3094: self.add_transition('quoted',
							πF.SetLineno(3094)
							πTemp001 = πF.MakeArgs(2)
							πTemp001[0] = ßquoted.ToObject()
							if πE = πg.CheckLocal(πF, µpattern, "pattern"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µself, ßquoted, nil); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ß__class__, nil); πE != nil {
								continue
							}
							if πTemp006, πE = πg.GetAttr(πF, πTemp004, ß__name__, nil); πE != nil {
								continue
							}
							πTemp002 = πg.NewTuple3(µpattern, πTemp003, πTemp006).ToObject()
							πTemp001[1] = πTemp002
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßadd_transition, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3096: self.initial_lineno = self.state_machine.abs_line_number()
							πF.SetLineno(3096)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, πTemp002, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp002, πE = πTemp003.Call(πF, nil, nil); πE != nil {
								continue
							}
							if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp003}, πTemp002); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πE = πg.SetAttr(πF, µself, ßinitial_lineno, πTemp003); πE != nil {
								continue
							}
							// line 3097: return [match.string], next_state, []
							πF.SetLineno(3097)
							πTemp001 = make([]*πg.Object, 1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp003, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp003
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp004 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(πTemp003, µnext_state, πTemp004).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßinitial_quoted.ToObject(), πTemp007); πE != nil {
						continue
					}
					// line 3089: """Match arbitrary quote character on the first line only."""
					πF.SetLineno(3089)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp008}, πg.NewStr("Match arbitrary quote character on the first line only.").ToObject()); πE != nil {
						continue
					}
					if πTemp009, πE = πg.ResolveClass(πF, πClass, nil, ßinitial_quoted); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp009, ß__doc__, πTemp008); πE != nil {
						continue
					}
					// line 3099: def quoted(self, match, context, next_state):
					πF.SetLineno(3099)
					πTemp005 = make([]πg.Param, 4)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "match", Def: nil}
					πTemp005[2] = πg.Param{Name: "context", Def: nil}
					πTemp005[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp008 = πg.NewFunction(πg.NewCode("quoted", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 []*πg.Object
						_ = πTemp001
						var πTemp002 *πg.Object
						_ = πTemp002
						var πTemp003 *πg.Object
						_ = πTemp003
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							// line 3100: """Match consistent quotes on subsequent lines."""
							πF.SetLineno(3100)
							// line 3101: context.append(match.string)
							πF.SetLineno(3101)
							πTemp001 = πF.MakeArgs(1)
							if πE = πg.CheckLocal(πF, µmatch, "match"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µmatch, ßstring, nil); πE != nil {
								continue
							}
							πTemp001[0] = πTemp002
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp002, πE = πg.GetAttr(πF, µcontext, ßappend, nil); πE != nil {
								continue
							}
							if πTemp003, πE = πTemp002.Call(πF, πTemp001, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp001)
							// line 3102: return context, next_state, []
							πF.SetLineno(3102)
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πE = πg.CheckLocal(πF, µnext_state, "next_state"); πE != nil {
								continue
							}
							πTemp001 = make([]*πg.Object, 0)
							πTemp003 = πg.NewList(πTemp001...).ToObject()
							πTemp002 = πg.NewTuple3(µcontext, µnext_state, πTemp003).ToObject()
							πR = πTemp002
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßquoted.ToObject(), πTemp008); πE != nil {
						continue
					}
					// line 3100: """Match consistent quotes on subsequent lines."""
					πF.SetLineno(3100)
					if πE = πg.Tie(πF, πg.TieTarget{Target: &πTemp009}, πg.NewStr("Match consistent quotes on subsequent lines.").ToObject()); πE != nil {
						continue
					}
					if πTemp010, πE = πg.ResolveClass(πF, πClass, nil, ßquoted); πE != nil {
						continue
					}
					if πE = πg.SetAttr(πF, πTemp010, ß__doc__, πTemp009); πE != nil {
						continue
					}
					// line 3104: def text(self, match, context, next_state):
					πF.SetLineno(3104)
					πTemp005 = make([]πg.Param, 4)
					πTemp005[0] = πg.Param{Name: "self", Def: nil}
					πTemp005[1] = πg.Param{Name: "match", Def: nil}
					πTemp005[2] = πg.Param{Name: "context", Def: nil}
					πTemp005[3] = πg.Param{Name: "next_state", Def: nil}
					πTemp009 = πg.NewFunction(πg.NewCode("text", "/usr/lib/python2.7/site-packages/docutils/parsers/rst/states.py", πTemp005, 0, func(πF *πg.Frame, πArgs []*πg.Object) (*πg.Object, *πg.BaseException) {
						var µself *πg.Object = πArgs[0]
						_ = µself
						var µmatch *πg.Object = πArgs[1]
						_ = µmatch
						var µcontext *πg.Object = πArgs[2]
						_ = µcontext
						var µnext_state *πg.Object = πArgs[3]
						_ = µnext_state
						var πTemp001 bool
						_ = πTemp001
						var πTemp002 []*πg.Object
						_ = πTemp002
						var πTemp003 []*πg.Object
						_ = πTemp003
						var πTemp004 *πg.Object
						_ = πTemp004
						var πTemp005 *πg.Object
						_ = πTemp005
						var πTemp006 πg.KWArgs
						_ = πTemp006
						var πR *πg.Object
						_ = πR
						var πE *πg.BaseException
						_ = πE
						for ; πF.State() >= 0; πF.PopCheckpoint() {
							switch πF.State() {
							case 0:
							default:
								panic("unexpected function state")
							}
							if πE = πg.CheckLocal(πF, µcontext, "context"); πE != nil {
								continue
							}
							if πTemp001, πE = πg.IsTrue(πF, µcontext); πE != nil {
								continue
							}
							if πTemp001 {
								goto Label1
							}
							goto Label2
							// line 3105: if context:
							πF.SetLineno(3105)
						Label1:
							// line 3106: self.messages.append(
							πF.SetLineno(3106)
							πTemp002 = πF.MakeArgs(1)
							πTemp003 = πF.MakeArgs(1)
							πTemp003[0] = πg.NewStr("Inconsistent literal block quoting.").ToObject()
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßabs_line_number, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							πTemp006 = πg.KWArgs{
								{"line", πTemp004},
							}
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßreporter, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßerror, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, πTemp003, πTemp006); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp003)
							πTemp002[0] = πTemp004
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßmessages, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßappend, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, πTemp002, nil); πE != nil {
								continue
							}
							πF.FreeArgs(πTemp002)
							// line 3109: self.state_machine.previous_line()
							πF.SetLineno(3109)
							if πE = πg.CheckLocal(πF, µself, "self"); πE != nil {
								continue
							}
							if πTemp004, πE = πg.GetAttr(πF, µself, ßstate_machine, nil); πE != nil {
								continue
							}
							if πTemp005, πE = πg.GetAttr(πF, πTemp004, ßprevious_line, nil); πE != nil {
								continue
							}
							if πTemp004, πE = πTemp005.Call(πF, nil, nil); πE != nil {
								continue
							}
							goto Label2
						Label2:
							if πTemp004, πE = πg.ResolveGlobal(πF, ßEOFError); πE != nil {
								continue
							}
							// line 3110: raise EOFError
							πF.SetLineno(3110)
							πE = πF.Raise(πTemp004, nil, nil)
							continue
						}
						if πE != nil {
							πR = nil
						} else if πR == nil {
							πR = πg.None
						}
						return πR, πE
					}), πF.Globals()).ToObject()
					if πE = πClass.SetItem(πF, ßtext.ToObject(), πTemp009); πE != nil {
						continue
					}
				}
				return nil, nil
			}).Eval(πF, πF.Globals(), nil, nil)
			if πE != nil {
				continue
			}
			if πTemp009, πE = πTemp004.GetItem(πF, ß__metaclass__.ToObject()); πE != nil {
				continue
			}
			if πTemp009 == nil {
				πTemp009 = πg.TypeType.ToObject()
			}
			if πTemp010, πE = πTemp009.Call(πF, []*πg.Object{πg.NewStr("QuotedLiteralBlock").ToObject(), πg.NewTuple(πTemp002...).ToObject(), πTemp004.ToObject()}, nil); πE != nil {
				continue
			}
			if πE = πF.Globals().SetItem(πF, ßQuotedLiteralBlock.ToObject(), πTemp010); πE != nil {
				continue
			}
			// line 3113: state_classes = (Body, BulletList, DefinitionList, EnumeratedList, FieldList,
			πF.SetLineno(3113)
			πTemp002 = make([]*πg.Object, 15)
			if πTemp009, πE = πg.ResolveGlobal(πF, ßBody); πE != nil {
				continue
			}
			πTemp002[0] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßBulletList); πE != nil {
				continue
			}
			πTemp002[1] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßDefinitionList); πE != nil {
				continue
			}
			πTemp002[2] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßEnumeratedList); πE != nil {
				continue
			}
			πTemp002[3] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßFieldList); πE != nil {
				continue
			}
			πTemp002[4] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßOptionList); πE != nil {
				continue
			}
			πTemp002[5] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßLineBlock); πE != nil {
				continue
			}
			πTemp002[6] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßExtensionOptions); πE != nil {
				continue
			}
			πTemp002[7] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßExplicit); πE != nil {
				continue
			}
			πTemp002[8] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßText); πE != nil {
				continue
			}
			πTemp002[9] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßDefinition); πE != nil {
				continue
			}
			πTemp002[10] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßLine); πE != nil {
				continue
			}
			πTemp002[11] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßSubstitutionDef); πE != nil {
				continue
			}
			πTemp002[12] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßRFC2822Body); πE != nil {
				continue
			}
			πTemp002[13] = πTemp009
			if πTemp009, πE = πg.ResolveGlobal(πF, ßRFC2822List); πE != nil {
				continue
			}
			πTemp002[14] = πTemp009
			πTemp008 = πg.NewTuple(πTemp002...).ToObject()
			if πE = πF.Globals().SetItem(πF, ßstate_classes.ToObject(), πTemp008); πE != nil {
				continue
			}
			// line 3116: """Standard set of State classes used to start `RSTStateMachine`."""
			πF.SetLineno(3116)
		}
		return nil, πE
	})
	πg.RegisterModule("states", Code)
}
